(function(){ 

  var path = require("path");
  
  if (typeof window === "undefined") 
    window = this;
  window.dispatchEvent = function() {};

  if (!window.navigator) window.navigator = {};
  if (!window.navigator.userAgent) {
    window.navigator.userAgent = "Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_4; de-de) AppleWebKit/533.17.8 (KHTML, like Gecko) Version/5.0.1 Safari/533.17.8";
  }
  if (!window.navigator.product) window.navigator.product = "";
  if (!window.navigator.cpuClass) window.navigator.cpuClass = "";

  // Node suppresses output to the "real" console when calling console.debug, it's only shown
  //  in the debugger 
  console.debug = function() {
    var args = [].slice.apply(arguments);
    console.log.apply(this, args);
  };
  
  var JSDOM = null;
  try {
    JSDOM = require("jsdom").JSDOM;
  } catch(ex) {
    // Nothing
  }
  if (JSDOM) {
    var dom = new JSDOM(`<!DOCTYPE html><html><head></head><body></body></html>`);
    if (!window)
      window = dom.window;
    else {
      window.document = dom.window.document;
    }
  } else {
    window.document = document = {
        readyState: "ready",
        createEvent: function() {
          return {
            initCustomEvent: function() {}
          };
        },
        createElement: function () {
          return {}
        },
        addListener: function() {},
        removeListener: function() {},
        documentElement: {
          style: {}
        }
    };
  }

  if (!this.qxloadPrefixUrl)
    qxloadPrefixUrl = "";

  if (!window.qx) 
    window.qx = {};
  
  if (!qx.$$appRoot) {
    qx.$$appRoot = __dirname + path.sep;
  }

  if (!window.qxvariants) 
    qxvariants = {};

  qx.$$start = new Date();

  if (!qx.$$environment) {
    qx.$$environment = {};
  }
  var envinfo = {
  "qx.application": "qx.tool.cli.Application",
  "qx.revision": "",
  "qx.theme": "qx.theme.Simple",
  "qx.version": "6.0.0-beta",
  "true": true,
  "qx.allowUrlSettings": false,
  "qx.allowUrlVariants": false,
  "qx.debug.property.level": 0,
  "qx.debug": false,
  "qx.debug.ui.queue": true,
  "qx.debug.touchpad.detection": false,
  "qx.aspects": false,
  "qx.dynlocale": true,
  "qx.dyntheme": true,
  "qx.blankpage": "qx/static/blank.html",
  "qx.debug.databinding": false,
  "qx.debug.dispose": false,
  "qx.nativeScrollBars": false,
  "qx.optimization.basecalls": false,
  "qx.optimization.comments": false,
  "qx.optimization.privates": false,
  "qx.optimization.strings": false,
  "qx.optimization.variables": false,
  "qx.optimization.variants": false,
  "module.databinding": true,
  "module.logger": true,
  "module.property": true,
  "module.events": true,
  "qx.automaticMemoryManagement": true,
  "qx.promise": true,
  "qx.promise.warnings": true,
  "qx.promise.longStackTraces": true,
  "qx.compiler": true,
  "qx.compiler.version": "1.0.0-beta-20210111-1639",
  "qx.headless": true
};
  for (var k in envinfo) {
    if (qx.$$environment[k] === undefined) {
       qx.$$environment[k] = envinfo[k];
    }
  }

  if (!qx.$$libraries) {
    qx.$$libraries = {};
  }
  [
  "qx",
  "qxcompiler"
].forEach(ns => qx.$$libraries[ns] = {
      sourceUri: qx.$$appRoot + ".",
      resourceUri: qx.$$appRoot + "../resource"
   });

  var isDebug = qx.$$environment["qx.debugLoader"];
  var log = isDebug ? console.log : function() { };
  var loaderMethod = qx.$$environment["qx.ooLoader"] ? this[qx.$$environment["qx.ooLoader"]] : require;
  if (typeof loaderMethod !== "function")
    throw new Error("Cannot initialise Qooxdoo application - no URI loader method detected");

  qx.$$resources = {};
  qx.$$translations = {
  "C": null,
  "en": null
};
  qx.$$locales = {
  "C": null,
  "en": null
};
  qx.$$packageData = {};
  qx.$$g = {}
  qx.$$createdAt = function(obj, filename, lineNumber, column) {
    if (obj !== undefined && obj !== null && typeof Object.$$createdAt === undefined) {
      Object.defineProperty(obj, "$$createdAt", {
        value: {
          filename: filename,
          lineNumber: lineNumber,
          column: column
        },
        enumerable: false,
        configurable: false,
        writable: false
      });
    }
    return obj;
  };

  qx.$$loader = {
      parts : {
  "boot": [
    "0"
  ]
},
      packages : {
  "0": {
    "uris": []
  }
},
      urisBefore : [],
      boot : "boot",
      closureParts : {},
      delayDefer: true,
      transpiledPath: qx.$$appRoot + "../transpiled",

      decodeUris : function(compressedUris, pathName) {
        if (!pathName)
          pathName = this.transpiledPath;
        var libs = qx.$$libraries;
        var uris = [];
        for (var i = 0; i < compressedUris.length; i++) {
          var uri = compressedUris[i].split(":");
          var euri;
          if (uri[0] == "__external__") {
            continue;
          } else {
            euri = qx.$$appRoot + compressedUris[i];
          }
          
          uris.push(qxloadPrefixUrl + euri);
        }
        return uris;
      },

      init : function() {
        var l = qx.$$loader;
        var t = this;

        var allScripts = l.decodeUris(l.urisBefore, "resourceUri");
        t.loadScriptList(allScripts);
    
        l.parts[l.boot].forEach(function(pkg) {
          t.loadScriptList(l.decodeUris(l.packages[pkg].uris));
        });

        l.parts[l.boot].forEach(function(pkg) {
          l.importPackageData(qx.$$packageData[pkg] || {});
        });
        qx.$$domReady = true;
        l.signalStartup();
      },

      loadScriptList: function(list) {
        list.forEach(function(uri) {
          var f = loaderMethod(uri);
          if (typeof f === "function") {
            var s = f.name === ""?path.basename(uri, ".js"):f.name;
            window[s] = f;
          }
        });
      },

      signalStartup : function() {
        qx.Bootstrap.executePendingDefers();
        qx.$$loader.delayDefer = false;
        qx.$$loader.scriptLoaded = true;
        qx.core.BaseInit.ready();
        qx.$$loader.applicationHandlerReady = true;
      },

      importPackageData : function(dataMap, callback) {
        if (dataMap["resources"]) {
          var resMap = dataMap["resources"];
          for ( var k in resMap)
            qx.$$resources[k] = resMap[k];
        }
        if (dataMap["locales"]) {
          var locMap = dataMap["locales"];
          var qxlocs = qx.$$locales;
          for ( var lang in locMap) {
            if (!qxlocs[lang])
              qxlocs[lang] = locMap[lang];
            else
              for (var k in locMap[lang])
                qxlocs[lang][k] = locMap[lang][k];
          }
        }
        if (dataMap["translations"]) {
          var trMap = dataMap["translations"];
          var qxtrans = qx.$$translations;
          for ( var lang in trMap) {
            if (!qxtrans[lang])
              qxtrans[lang] = trMap[lang];
            else
              for ( var k in trMap[lang])
                qxtrans[lang][k] = trMap[lang][k];
          }
        }
        if (callback) {
          callback(dataMap);
        }
      }
  };

})();


(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(_dereq_,module,exports){
_dereq_(276);
_dereq_(212);
_dereq_(214);
_dereq_(213);
_dereq_(216);
_dereq_(218);
_dereq_(223);
_dereq_(217);
_dereq_(215);
_dereq_(225);
_dereq_(224);
_dereq_(220);
_dereq_(221);
_dereq_(219);
_dereq_(211);
_dereq_(222);
_dereq_(226);
_dereq_(227);
_dereq_(178);
_dereq_(180);
_dereq_(179);
_dereq_(229);
_dereq_(228);
_dereq_(199);
_dereq_(209);
_dereq_(210);
_dereq_(200);
_dereq_(201);
_dereq_(202);
_dereq_(203);
_dereq_(204);
_dereq_(205);
_dereq_(206);
_dereq_(207);
_dereq_(208);
_dereq_(182);
_dereq_(183);
_dereq_(184);
_dereq_(185);
_dereq_(186);
_dereq_(187);
_dereq_(188);
_dereq_(189);
_dereq_(190);
_dereq_(191);
_dereq_(192);
_dereq_(193);
_dereq_(194);
_dereq_(195);
_dereq_(196);
_dereq_(197);
_dereq_(198);
_dereq_(263);
_dereq_(268);
_dereq_(275);
_dereq_(266);
_dereq_(258);
_dereq_(259);
_dereq_(264);
_dereq_(269);
_dereq_(271);
_dereq_(254);
_dereq_(255);
_dereq_(256);
_dereq_(257);
_dereq_(260);
_dereq_(261);
_dereq_(262);
_dereq_(265);
_dereq_(267);
_dereq_(270);
_dereq_(272);
_dereq_(273);
_dereq_(274);
_dereq_(173);
_dereq_(175);
_dereq_(174);
_dereq_(177);
_dereq_(176);
_dereq_(161);
_dereq_(159);
_dereq_(166);
_dereq_(163);
_dereq_(169);
_dereq_(171);
_dereq_(158);
_dereq_(165);
_dereq_(155);
_dereq_(170);
_dereq_(153);
_dereq_(168);
_dereq_(167);
_dereq_(160);
_dereq_(164);
_dereq_(152);
_dereq_(154);
_dereq_(157);
_dereq_(156);
_dereq_(172);
_dereq_(162);
_dereq_(245);
_dereq_(246);
_dereq_(252);
_dereq_(247);
_dereq_(248);
_dereq_(249);
_dereq_(250);
_dereq_(251);
_dereq_(230);
_dereq_(181);
_dereq_(253);
_dereq_(288);
_dereq_(289);
_dereq_(277);
_dereq_(278);
_dereq_(283);
_dereq_(286);
_dereq_(287);
_dereq_(281);
_dereq_(284);
_dereq_(282);
_dereq_(285);
_dereq_(279);
_dereq_(280);
_dereq_(231);
_dereq_(232);
_dereq_(233);
_dereq_(234);
_dereq_(235);
_dereq_(238);
_dereq_(236);
_dereq_(237);
_dereq_(239);
_dereq_(240);
_dereq_(241);
_dereq_(242);
_dereq_(244);
_dereq_(243);
module.exports = _dereq_(50);

},{"152":152,"153":153,"154":154,"155":155,"156":156,"157":157,"158":158,"159":159,"160":160,"161":161,"162":162,"163":163,"164":164,"165":165,"166":166,"167":167,"168":168,"169":169,"170":170,"171":171,"172":172,"173":173,"174":174,"175":175,"176":176,"177":177,"178":178,"179":179,"180":180,"181":181,"182":182,"183":183,"184":184,"185":185,"186":186,"187":187,"188":188,"189":189,"190":190,"191":191,"192":192,"193":193,"194":194,"195":195,"196":196,"197":197,"198":198,"199":199,"200":200,"201":201,"202":202,"203":203,"204":204,"205":205,"206":206,"207":207,"208":208,"209":209,"210":210,"211":211,"212":212,"213":213,"214":214,"215":215,"216":216,"217":217,"218":218,"219":219,"220":220,"221":221,"222":222,"223":223,"224":224,"225":225,"226":226,"227":227,"228":228,"229":229,"230":230,"231":231,"232":232,"233":233,"234":234,"235":235,"236":236,"237":237,"238":238,"239":239,"240":240,"241":241,"242":242,"243":243,"244":244,"245":245,"246":246,"247":247,"248":248,"249":249,"250":250,"251":251,"252":252,"253":253,"254":254,"255":255,"256":256,"257":257,"258":258,"259":259,"260":260,"261":261,"262":262,"263":263,"264":264,"265":265,"266":266,"267":267,"268":268,"269":269,"270":270,"271":271,"272":272,"273":273,"274":274,"275":275,"276":276,"277":277,"278":278,"279":279,"280":280,"281":281,"282":282,"283":283,"284":284,"285":285,"286":286,"287":287,"288":288,"289":289,"50":50}],2:[function(_dereq_,module,exports){
_dereq_(290);
module.exports = _dereq_(50).Array.flatMap;

},{"290":290,"50":50}],3:[function(_dereq_,module,exports){
_dereq_(291);
module.exports = _dereq_(50).Array.includes;

},{"291":291,"50":50}],4:[function(_dereq_,module,exports){
_dereq_(292);
module.exports = _dereq_(50).Object.entries;

},{"292":292,"50":50}],5:[function(_dereq_,module,exports){
_dereq_(293);
module.exports = _dereq_(50).Object.getOwnPropertyDescriptors;

},{"293":293,"50":50}],6:[function(_dereq_,module,exports){
_dereq_(294);
module.exports = _dereq_(50).Object.values;

},{"294":294,"50":50}],7:[function(_dereq_,module,exports){
'use strict';
_dereq_(230);
_dereq_(295);
module.exports = _dereq_(50).Promise['finally'];

},{"230":230,"295":295,"50":50}],8:[function(_dereq_,module,exports){
_dereq_(296);
module.exports = _dereq_(50).String.padEnd;

},{"296":296,"50":50}],9:[function(_dereq_,module,exports){
_dereq_(297);
module.exports = _dereq_(50).String.padStart;

},{"297":297,"50":50}],10:[function(_dereq_,module,exports){
_dereq_(299);
module.exports = _dereq_(50).String.trimRight;

},{"299":299,"50":50}],11:[function(_dereq_,module,exports){
_dereq_(298);
module.exports = _dereq_(50).String.trimLeft;

},{"298":298,"50":50}],12:[function(_dereq_,module,exports){
_dereq_(300);
module.exports = _dereq_(149).f('asyncIterator');

},{"149":149,"300":300}],13:[function(_dereq_,module,exports){
_dereq_(30);
module.exports = _dereq_(16).global;

},{"16":16,"30":30}],14:[function(_dereq_,module,exports){
module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};

},{}],15:[function(_dereq_,module,exports){
var isObject = _dereq_(26);
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};

},{"26":26}],16:[function(_dereq_,module,exports){
var core = module.exports = { version: '2.6.11' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef

},{}],17:[function(_dereq_,module,exports){
// optional / simple context binding
var aFunction = _dereq_(14);
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};

},{"14":14}],18:[function(_dereq_,module,exports){
// Thank's IE8 for his funny defineProperty
module.exports = !_dereq_(21)(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});

},{"21":21}],19:[function(_dereq_,module,exports){
var isObject = _dereq_(26);
var document = _dereq_(22).document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};

},{"22":22,"26":26}],20:[function(_dereq_,module,exports){
var global = _dereq_(22);
var core = _dereq_(16);
var ctx = _dereq_(17);
var hide = _dereq_(24);
var has = _dereq_(23);
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var IS_WRAP = type & $export.W;
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE];
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
  var key, own, out;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if (own && has(exports, key)) continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function (C) {
      var F = function (a, b, c) {
        if (this instanceof C) {
          switch (arguments.length) {
            case 0: return new C();
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if (IS_PROTO) {
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;

},{"16":16,"17":17,"22":22,"23":23,"24":24}],21:[function(_dereq_,module,exports){
module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};

},{}],22:[function(_dereq_,module,exports){
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef

},{}],23:[function(_dereq_,module,exports){
var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};

},{}],24:[function(_dereq_,module,exports){
var dP = _dereq_(27);
var createDesc = _dereq_(28);
module.exports = _dereq_(18) ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

},{"18":18,"27":27,"28":28}],25:[function(_dereq_,module,exports){
module.exports = !_dereq_(18) && !_dereq_(21)(function () {
  return Object.defineProperty(_dereq_(19)('div'), 'a', { get: function () { return 7; } }).a != 7;
});

},{"18":18,"19":19,"21":21}],26:[function(_dereq_,module,exports){
module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

},{}],27:[function(_dereq_,module,exports){
var anObject = _dereq_(15);
var IE8_DOM_DEFINE = _dereq_(25);
var toPrimitive = _dereq_(29);
var dP = Object.defineProperty;

exports.f = _dereq_(18) ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

},{"15":15,"18":18,"25":25,"29":29}],28:[function(_dereq_,module,exports){
module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

},{}],29:[function(_dereq_,module,exports){
// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = _dereq_(26);
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};

},{"26":26}],30:[function(_dereq_,module,exports){
// https://github.com/tc39/proposal-global
var $export = _dereq_(20);

$export($export.G, { global: _dereq_(22) });

},{"20":20,"22":22}],31:[function(_dereq_,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"14":14}],32:[function(_dereq_,module,exports){
var cof = _dereq_(46);
module.exports = function (it, msg) {
  if (typeof it != 'number' && cof(it) != 'Number') throw TypeError(msg);
  return +it;
};

},{"46":46}],33:[function(_dereq_,module,exports){
// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = _dereq_(150)('unscopables');
var ArrayProto = Array.prototype;
if (ArrayProto[UNSCOPABLES] == undefined) _dereq_(70)(ArrayProto, UNSCOPABLES, {});
module.exports = function (key) {
  ArrayProto[UNSCOPABLES][key] = true;
};

},{"150":150,"70":70}],34:[function(_dereq_,module,exports){
'use strict';
var at = _dereq_(127)(true);

 // `AdvanceStringIndex` abstract operation
// https://tc39.github.io/ecma262/#sec-advancestringindex
module.exports = function (S, index, unicode) {
  return index + (unicode ? at(S, index).length : 1);
};

},{"127":127}],35:[function(_dereq_,module,exports){
module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};

},{}],36:[function(_dereq_,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"15":15,"79":79}],37:[function(_dereq_,module,exports){
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
'use strict';
var toObject = _dereq_(140);
var toAbsoluteIndex = _dereq_(135);
var toLength = _dereq_(139);

module.exports = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {
  var O = toObject(this);
  var len = toLength(O.length);
  var to = toAbsoluteIndex(target, len);
  var from = toAbsoluteIndex(start, len);
  var end = arguments.length > 2 ? arguments[2] : undefined;
  var count = Math.min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
  var inc = 1;
  if (from < to && to < from + count) {
    inc = -1;
    from += count - 1;
    to += count - 1;
  }
  while (count-- > 0) {
    if (from in O) O[to] = O[from];
    else delete O[to];
    to += inc;
    from += inc;
  } return O;
};

},{"135":135,"139":139,"140":140}],38:[function(_dereq_,module,exports){
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
'use strict';
var toObject = _dereq_(140);
var toAbsoluteIndex = _dereq_(135);
var toLength = _dereq_(139);
module.exports = function fill(value /* , start = 0, end = @length */) {
  var O = toObject(this);
  var length = toLength(O.length);
  var aLen = arguments.length;
  var index = toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length);
  var end = aLen > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
  while (endPos > index) O[index++] = value;
  return O;
};

},{"135":135,"139":139,"140":140}],39:[function(_dereq_,module,exports){
// false -> Array#indexOf
// true  -> Array#includes
var toIObject = _dereq_(138);
var toLength = _dereq_(139);
var toAbsoluteIndex = _dereq_(135);
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

},{"135":135,"138":138,"139":139}],40:[function(_dereq_,module,exports){
// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx = _dereq_(52);
var IObject = _dereq_(75);
var toObject = _dereq_(140);
var toLength = _dereq_(139);
var asc = _dereq_(43);
module.exports = function (TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || asc;
  return function ($this, callbackfn, that) {
    var O = toObject($this);
    var self = IObject(O);
    var f = ctx(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var val, res;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      val = self[index];
      res = f(val, index, O);
      if (TYPE) {
        if (IS_MAP) result[index] = res;   // map
        else if (res) switch (TYPE) {
          case 3: return true;             // some
          case 5: return val;              // find
          case 6: return index;            // findIndex
          case 2: result.push(val);        // filter
        } else if (IS_EVERY) return false; // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};

},{"139":139,"140":140,"43":43,"52":52,"75":75}],41:[function(_dereq_,module,exports){
var aFunction = _dereq_(31);
var toObject = _dereq_(140);
var IObject = _dereq_(75);
var toLength = _dereq_(139);

module.exports = function (that, callbackfn, aLen, memo, isRight) {
  aFunction(callbackfn);
  var O = toObject(that);
  var self = IObject(O);
  var length = toLength(O.length);
  var index = isRight ? length - 1 : 0;
  var i = isRight ? -1 : 1;
  if (aLen < 2) for (;;) {
    if (index in self) {
      memo = self[index];
      index += i;
      break;
    }
    index += i;
    if (isRight ? index < 0 : length <= index) {
      throw TypeError('Reduce of empty array with no initial value');
    }
  }
  for (;isRight ? index >= 0 : length > index; index += i) if (index in self) {
    memo = callbackfn(memo, self[index], index, O);
  }
  return memo;
};

},{"139":139,"140":140,"31":31,"75":75}],42:[function(_dereq_,module,exports){
var isObject = _dereq_(79);
var isArray = _dereq_(77);
var SPECIES = _dereq_(150)('species');

module.exports = function (original) {
  var C;
  if (isArray(original)) {
    C = original.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
    if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return C === undefined ? Array : C;
};

},{"150":150,"77":77,"79":79}],43:[function(_dereq_,module,exports){
// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = _dereq_(42);

module.exports = function (original, length) {
  return new (speciesConstructor(original))(length);
};

},{"42":42}],44:[function(_dereq_,module,exports){
'use strict';
var aFunction = _dereq_(31);
var isObject = _dereq_(79);
var invoke = _dereq_(74);
var arraySlice = [].slice;
var factories = {};

var construct = function (F, len, args) {
  if (!(len in factories)) {
    for (var n = [], i = 0; i < len; i++) n[i] = 'a[' + i + ']';
    // eslint-disable-next-line no-new-func
    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
  } return factories[len](F, args);
};

module.exports = Function.bind || function bind(that /* , ...args */) {
  var fn = aFunction(this);
  var partArgs = arraySlice.call(arguments, 1);
  var bound = function (/* args... */) {
    var args = partArgs.concat(arraySlice.call(arguments));
    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
  };
  if (isObject(fn.prototype)) bound.prototype = fn.prototype;
  return bound;
};

},{"31":31,"74":74,"79":79}],45:[function(_dereq_,module,exports){
// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = _dereq_(46);
var TAG = _dereq_(150)('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};

},{"150":150,"46":46}],46:[function(_dereq_,module,exports){
var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};

},{}],47:[function(_dereq_,module,exports){
'use strict';
var dP = _dereq_(97).f;
var create = _dereq_(96);
var redefineAll = _dereq_(115);
var ctx = _dereq_(52);
var anInstance = _dereq_(35);
var forOf = _dereq_(66);
var $iterDefine = _dereq_(83);
var step = _dereq_(85);
var setSpecies = _dereq_(121);
var DESCRIPTORS = _dereq_(56);
var fastKey = _dereq_(92).fastKey;
var validate = _dereq_(147);
var SIZE = DESCRIPTORS ? '_s' : 'size';

var getEntry = function (that, key) {
  // fast case
  var index = fastKey(key);
  var entry;
  if (index !== 'F') return that._i[index];
  // frozen object case
  for (entry = that._f; entry; entry = entry.n) {
    if (entry.k == key) return entry;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;         // collection type
      that._i = create(null); // index
      that._f = undefined;    // first entry
      that._l = undefined;    // last entry
      that[SIZE] = 0;         // size
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
          entry.r = true;
          if (entry.p) entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function (key) {
        var that = validate(this, NAME);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.n;
          var prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if (prev) prev.n = next;
          if (next) next.p = prev;
          if (that._f == entry) that._f = next;
          if (that._l == entry) that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /* , that = undefined */) {
        validate(this, NAME);
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;
        while (entry = entry ? entry.n : this._f) {
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while (entry && entry.r) entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(validate(this, NAME), key);
      }
    });
    if (DESCRIPTORS) dP(C.prototype, 'size', {
      get: function () {
        return validate(this, NAME)[SIZE];
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var entry = getEntry(that, key);
    var prev, index;
    // change existing entry
    if (entry) {
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if (!that._f) that._f = entry;
      if (prev) prev.n = entry;
      that[SIZE]++;
      // add to index
      if (index !== 'F') that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function (C, NAME, IS_MAP) {
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function (iterated, kind) {
      this._t = validate(iterated, NAME); // target
      this._k = kind;                     // kind
      this._l = undefined;                // previous
    }, function () {
      var that = this;
      var kind = that._k;
      var entry = that._l;
      // revert to the last existing entry
      while (entry && entry.r) entry = entry.p;
      // get next entry
      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
        // or finish the iteration
        that._t = undefined;
        return step(1);
      }
      // return step by kind
      if (kind == 'keys') return step(0, entry.k);
      if (kind == 'values') return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(NAME);
  }
};

},{"115":115,"121":121,"147":147,"35":35,"52":52,"56":56,"66":66,"83":83,"85":85,"92":92,"96":96,"97":97}],48:[function(_dereq_,module,exports){
'use strict';
var redefineAll = _dereq_(115);
var getWeak = _dereq_(92).getWeak;
var anObject = _dereq_(36);
var isObject = _dereq_(79);
var anInstance = _dereq_(35);
var forOf = _dereq_(66);
var createArrayMethod = _dereq_(40);
var $has = _dereq_(69);
var validate = _dereq_(147);
var arrayFind = createArrayMethod(5);
var arrayFindIndex = createArrayMethod(6);
var id = 0;

// fallback for uncaught frozen keys
var uncaughtFrozenStore = function (that) {
  return that._l || (that._l = new UncaughtFrozenStore());
};
var UncaughtFrozenStore = function () {
  this.a = [];
};
var findUncaughtFrozen = function (store, key) {
  return arrayFind(store.a, function (it) {
    return it[0] === key;
  });
};
UncaughtFrozenStore.prototype = {
  get: function (key) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) return entry[1];
  },
  has: function (key) {
    return !!findUncaughtFrozen(this, key);
  },
  set: function (key, value) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) entry[1] = value;
    else this.a.push([key, value]);
  },
  'delete': function (key) {
    var index = arrayFindIndex(this.a, function (it) {
      return it[0] === key;
    });
    if (~index) this.a.splice(index, 1);
    return !!~index;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;      // collection type
      that._i = id++;      // collection id
      that._l = undefined; // leak store for uncaught frozen objects
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.3.3.2 WeakMap.prototype.delete(key)
      // 23.4.3.3 WeakSet.prototype.delete(value)
      'delete': function (key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME))['delete'](key);
        return data && $has(data, this._i) && delete data[this._i];
      },
      // 23.3.3.4 WeakMap.prototype.has(key)
      // 23.4.3.4 WeakSet.prototype.has(value)
      has: function has(key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);
        return data && $has(data, this._i);
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var data = getWeak(anObject(key), true);
    if (data === true) uncaughtFrozenStore(that).set(key, value);
    else data[that._i] = value;
    return that;
  },
  ufstore: uncaughtFrozenStore
};

},{"115":115,"147":147,"35":35,"36":36,"40":40,"66":66,"69":69,"79":79,"92":92}],49:[function(_dereq_,module,exports){
'use strict';
var global = _dereq_(68);
var $export = _dereq_(60);
var redefine = _dereq_(116);
var redefineAll = _dereq_(115);
var meta = _dereq_(92);
var forOf = _dereq_(66);
var anInstance = _dereq_(35);
var isObject = _dereq_(79);
var fails = _dereq_(62);
var $iterDetect = _dereq_(84);
var setToStringTag = _dereq_(122);
var inheritIfRequired = _dereq_(73);

module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
  var Base = global[NAME];
  var C = Base;
  var ADDER = IS_MAP ? 'set' : 'add';
  var proto = C && C.prototype;
  var O = {};
  var fixMethod = function (KEY) {
    var fn = proto[KEY];
    redefine(proto, KEY,
      KEY == 'delete' ? function (a) {
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'has' ? function has(a) {
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'get' ? function get(a) {
        return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'add' ? function add(a) { fn.call(this, a === 0 ? 0 : a); return this; }
        : function set(a, b) { fn.call(this, a === 0 ? 0 : a, b); return this; }
    );
  };
  if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
    new C().entries().next();
  }))) {
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    var instance = new C();
    // early implementations not supports chaining
    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
    // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
    var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });
    // most early implementations doesn't supports iterables, most modern - not close it correctly
    var ACCEPT_ITERABLES = $iterDetect(function (iter) { new C(iter); }); // eslint-disable-line no-new
    // for early implementations -0 and +0 not the same
    var BUGGY_ZERO = !IS_WEAK && fails(function () {
      // V8 ~ Chromium 42- fails only with 5+ elements
      var $instance = new C();
      var index = 5;
      while (index--) $instance[ADDER](index, index);
      return !$instance.has(-0);
    });
    if (!ACCEPT_ITERABLES) {
      C = wrapper(function (target, iterable) {
        anInstance(target, C, NAME);
        var that = inheritIfRequired(new Base(), target, C);
        if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
        return that;
      });
      C.prototype = proto;
      proto.constructor = C;
    }
    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }
    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
    // weak collections should not contains .clear method
    if (IS_WEAK && proto.clear) delete proto.clear;
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F * (C != Base), O);

  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);

  return C;
};

},{"115":115,"116":116,"122":122,"35":35,"60":60,"62":62,"66":66,"68":68,"73":73,"79":79,"84":84,"92":92}],50:[function(_dereq_,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"16":16}],51:[function(_dereq_,module,exports){
'use strict';
var $defineProperty = _dereq_(97);
var createDesc = _dereq_(114);

module.exports = function (object, index, value) {
  if (index in object) $defineProperty.f(object, index, createDesc(0, value));
  else object[index] = value;
};

},{"114":114,"97":97}],52:[function(_dereq_,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"17":17,"31":31}],53:[function(_dereq_,module,exports){
'use strict';
// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
var fails = _dereq_(62);
var getTime = Date.prototype.getTime;
var $toISOString = Date.prototype.toISOString;

var lz = function (num) {
  return num > 9 ? num : '0' + num;
};

// PhantomJS / old WebKit has a broken implementations
module.exports = (fails(function () {
  return $toISOString.call(new Date(-5e13 - 1)) != '0385-07-25T07:06:39.999Z';
}) || !fails(function () {
  $toISOString.call(new Date(NaN));
})) ? function toISOString() {
  if (!isFinite(getTime.call(this))) throw RangeError('Invalid time value');
  var d = this;
  var y = d.getUTCFullYear();
  var m = d.getUTCMilliseconds();
  var s = y < 0 ? '-' : y > 9999 ? '+' : '';
  return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) +
    '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) +
    'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) +
    ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
} : $toISOString;

},{"62":62}],54:[function(_dereq_,module,exports){
'use strict';
var anObject = _dereq_(36);
var toPrimitive = _dereq_(141);
var NUMBER = 'number';

module.exports = function (hint) {
  if (hint !== 'string' && hint !== NUMBER && hint !== 'default') throw TypeError('Incorrect hint');
  return toPrimitive(anObject(this), hint != NUMBER);
};

},{"141":141,"36":36}],55:[function(_dereq_,module,exports){
// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};

},{}],56:[function(_dereq_,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"18":18,"62":62}],57:[function(_dereq_,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"19":19,"68":68,"79":79}],58:[function(_dereq_,module,exports){
// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');

},{}],59:[function(_dereq_,module,exports){
// all enumerable object keys, includes symbols
var getKeys = _dereq_(105);
var gOPS = _dereq_(102);
var pIE = _dereq_(106);
module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;
  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;
    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  } return result;
};

},{"102":102,"105":105,"106":106}],60:[function(_dereq_,module,exports){
var global = _dereq_(68);
var core = _dereq_(50);
var hide = _dereq_(70);
var redefine = _dereq_(116);
var ctx = _dereq_(52);
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
  var key, own, out, exp;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // extend global
    if (target) redefine(target, key, out, type & $export.U);
    // export
    if (exports[key] != out) hide(exports, key, exp);
    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
  }
};
global.core = core;
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;

},{"116":116,"50":50,"52":52,"68":68,"70":70}],61:[function(_dereq_,module,exports){
var MATCH = _dereq_(150)('match');
module.exports = function (KEY) {
  var re = /./;
  try {
    '/./'[KEY](re);
  } catch (e) {
    try {
      re[MATCH] = false;
      return !'/./'[KEY](re);
    } catch (f) { /* empty */ }
  } return true;
};

},{"150":150}],62:[function(_dereq_,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"21":21}],63:[function(_dereq_,module,exports){
'use strict';
_dereq_(246);
var redefine = _dereq_(116);
var hide = _dereq_(70);
var fails = _dereq_(62);
var defined = _dereq_(55);
var wks = _dereq_(150);
var regexpExec = _dereq_(118);

var SPECIES = wks('species');

var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
  // #replace needs built-in support for named groups.
  // #match works fine because it just return the exec results, even if it has
  // a "grops" property.
  var re = /./;
  re.exec = function () {
    var result = [];
    result.groups = { a: '7' };
    return result;
  };
  return ''.replace(re, '$<a>') !== '7';
});

var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = (function () {
  // Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
  var re = /(?:)/;
  var originalExec = re.exec;
  re.exec = function () { return originalExec.apply(this, arguments); };
  var result = 'ab'.split(re);
  return result.length === 2 && result[0] === 'a' && result[1] === 'b';
})();

module.exports = function (KEY, length, exec) {
  var SYMBOL = wks(KEY);

  var DELEGATES_TO_SYMBOL = !fails(function () {
    // String methods call symbol-named RegEp methods
    var O = {};
    O[SYMBOL] = function () { return 7; };
    return ''[KEY](O) != 7;
  });

  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL ? !fails(function () {
    // Symbol-named RegExp methods call .exec
    var execCalled = false;
    var re = /a/;
    re.exec = function () { execCalled = true; return null; };
    if (KEY === 'split') {
      // RegExp[@@split] doesn't call the regex's exec method, but first creates
      // a new one. We need to return the patched regex when creating the new one.
      re.constructor = {};
      re.constructor[SPECIES] = function () { return re; };
    }
    re[SYMBOL]('');
    return !execCalled;
  }) : undefined;

  if (
    !DELEGATES_TO_SYMBOL ||
    !DELEGATES_TO_EXEC ||
    (KEY === 'replace' && !REPLACE_SUPPORTS_NAMED_GROUPS) ||
    (KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC)
  ) {
    var nativeRegExpMethod = /./[SYMBOL];
    var fns = exec(
      defined,
      SYMBOL,
      ''[KEY],
      function maybeCallNative(nativeMethod, regexp, str, arg2, forceStringMethod) {
        if (regexp.exec === regexpExec) {
          if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
            // The native String method already delegates to @@method (this
            // polyfilled function), leasing to infinite recursion.
            // We avoid it by directly calling the native @@method method.
            return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };
          }
          return { done: true, value: nativeMethod.call(str, regexp, arg2) };
        }
        return { done: false };
      }
    );
    var strfn = fns[0];
    var rxfn = fns[1];

    redefine(String.prototype, KEY, strfn);
    hide(RegExp.prototype, SYMBOL, length == 2
      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
      ? function (string, arg) { return rxfn.call(string, this, arg); }
      // 21.2.5.6 RegExp.prototype[@@match](string)
      // 21.2.5.9 RegExp.prototype[@@search](string)
      : function (string) { return rxfn.call(string, this); }
    );
  }
};

},{"116":116,"118":118,"150":150,"246":246,"55":55,"62":62,"70":70}],64:[function(_dereq_,module,exports){
'use strict';
// 21.2.5.3 get RegExp.prototype.flags
var anObject = _dereq_(36);
module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};

},{"36":36}],65:[function(_dereq_,module,exports){
'use strict';
// https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray
var isArray = _dereq_(77);
var isObject = _dereq_(79);
var toLength = _dereq_(139);
var ctx = _dereq_(52);
var IS_CONCAT_SPREADABLE = _dereq_(150)('isConcatSpreadable');

function flattenIntoArray(target, original, source, sourceLen, start, depth, mapper, thisArg) {
  var targetIndex = start;
  var sourceIndex = 0;
  var mapFn = mapper ? ctx(mapper, thisArg, 3) : false;
  var element, spreadable;

  while (sourceIndex < sourceLen) {
    if (sourceIndex in source) {
      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];

      spreadable = false;
      if (isObject(element)) {
        spreadable = element[IS_CONCAT_SPREADABLE];
        spreadable = spreadable !== undefined ? !!spreadable : isArray(element);
      }

      if (spreadable && depth > 0) {
        targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1;
      } else {
        if (targetIndex >= 0x1fffffffffffff) throw TypeError();
        target[targetIndex] = element;
      }

      targetIndex++;
    }
    sourceIndex++;
  }
  return targetIndex;
}

module.exports = flattenIntoArray;

},{"139":139,"150":150,"52":52,"77":77,"79":79}],66:[function(_dereq_,module,exports){
var ctx = _dereq_(52);
var call = _dereq_(81);
var isArrayIter = _dereq_(76);
var anObject = _dereq_(36);
var toLength = _dereq_(139);
var getIterFn = _dereq_(151);
var BREAK = {};
var RETURN = {};
var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};
exports.BREAK = BREAK;
exports.RETURN = RETURN;

},{"139":139,"151":151,"36":36,"52":52,"76":76,"81":81}],67:[function(_dereq_,module,exports){
module.exports = _dereq_(124)('native-function-to-string', Function.toString);

},{"124":124}],68:[function(_dereq_,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"22":22}],69:[function(_dereq_,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"23":23}],70:[function(_dereq_,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"114":114,"24":24,"56":56,"97":97}],71:[function(_dereq_,module,exports){
var document = _dereq_(68).document;
module.exports = document && document.documentElement;

},{"68":68}],72:[function(_dereq_,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"25":25,"56":56,"57":57,"62":62}],73:[function(_dereq_,module,exports){
var isObject = _dereq_(79);
var setPrototypeOf = _dereq_(120).set;
module.exports = function (that, target, C) {
  var S = target.constructor;
  var P;
  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {
    setPrototypeOf(that, P);
  } return that;
};

},{"120":120,"79":79}],74:[function(_dereq_,module,exports){
// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function (fn, args, that) {
  var un = that === undefined;
  switch (args.length) {
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return fn.apply(that, args);
};

},{}],75:[function(_dereq_,module,exports){
// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = _dereq_(46);
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};

},{"46":46}],76:[function(_dereq_,module,exports){
// check on default Array iterator
var Iterators = _dereq_(86);
var ITERATOR = _dereq_(150)('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};

},{"150":150,"86":86}],77:[function(_dereq_,module,exports){
// 7.2.2 IsArray(argument)
var cof = _dereq_(46);
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};

},{"46":46}],78:[function(_dereq_,module,exports){
// 20.1.2.3 Number.isInteger(number)
var isObject = _dereq_(79);
var floor = Math.floor;
module.exports = function isInteger(it) {
  return !isObject(it) && isFinite(it) && floor(it) === it;
};

},{"79":79}],79:[function(_dereq_,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"26":26}],80:[function(_dereq_,module,exports){
// 7.2.8 IsRegExp(argument)
var isObject = _dereq_(79);
var cof = _dereq_(46);
var MATCH = _dereq_(150)('match');
module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
};

},{"150":150,"46":46,"79":79}],81:[function(_dereq_,module,exports){
// call something on iterator step with safe closing on error
var anObject = _dereq_(36);
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};

},{"36":36}],82:[function(_dereq_,module,exports){
'use strict';
var create = _dereq_(96);
var descriptor = _dereq_(114);
var setToStringTag = _dereq_(122);
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
_dereq_(70)(IteratorPrototype, _dereq_(150)('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};

},{"114":114,"122":122,"150":150,"70":70,"96":96}],83:[function(_dereq_,module,exports){
'use strict';
var LIBRARY = _dereq_(87);
var $export = _dereq_(60);
var redefine = _dereq_(116);
var hide = _dereq_(70);
var Iterators = _dereq_(86);
var $iterCreate = _dereq_(82);
var setToStringTag = _dereq_(122);
var getPrototypeOf = _dereq_(103);
var ITERATOR = _dereq_(150)('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};

},{"103":103,"116":116,"122":122,"150":150,"60":60,"70":70,"82":82,"86":86,"87":87}],84:[function(_dereq_,module,exports){
var ITERATOR = _dereq_(150)('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () { SAFE_CLOSING = true; };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () { throw 2; });
} catch (e) { /* empty */ }

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};

},{"150":150}],85:[function(_dereq_,module,exports){
module.exports = function (done, value) {
  return { value: value, done: !!done };
};

},{}],86:[function(_dereq_,module,exports){
module.exports = {};

},{}],87:[function(_dereq_,module,exports){
module.exports = false;

},{}],88:[function(_dereq_,module,exports){
// 20.2.2.14 Math.expm1(x)
var $expm1 = Math.expm1;
module.exports = (!$expm1
  // Old FF bug
  || $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168
  // Tor Browser bug
  || $expm1(-2e-17) != -2e-17
) ? function expm1(x) {
  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
} : $expm1;

},{}],89:[function(_dereq_,module,exports){
// 20.2.2.16 Math.fround(x)
var sign = _dereq_(91);
var pow = Math.pow;
var EPSILON = pow(2, -52);
var EPSILON32 = pow(2, -23);
var MAX32 = pow(2, 127) * (2 - EPSILON32);
var MIN32 = pow(2, -126);

var roundTiesToEven = function (n) {
  return n + 1 / EPSILON - 1 / EPSILON;
};

module.exports = Math.fround || function fround(x) {
  var $abs = Math.abs(x);
  var $sign = sign(x);
  var a, result;
  if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
  a = (1 + EPSILON32 / EPSILON) * $abs;
  result = a - (a - $abs);
  // eslint-disable-next-line no-self-compare
  if (result > MAX32 || result != result) return $sign * Infinity;
  return $sign * result;
};

},{"91":91}],90:[function(_dereq_,module,exports){
// 20.2.2.20 Math.log1p(x)
module.exports = Math.log1p || function log1p(x) {
  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
};

},{}],91:[function(_dereq_,module,exports){
// 20.2.2.28 Math.sign(x)
module.exports = Math.sign || function sign(x) {
  // eslint-disable-next-line no-self-compare
  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
};

},{}],92:[function(_dereq_,module,exports){
var META = _dereq_(145)('meta');
var isObject = _dereq_(79);
var has = _dereq_(69);
var setDesc = _dereq_(97).f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !_dereq_(62)(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};

},{"145":145,"62":62,"69":69,"79":79,"97":97}],93:[function(_dereq_,module,exports){
var global = _dereq_(68);
var macrotask = _dereq_(134).set;
var Observer = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var isNode = _dereq_(46)(process) == 'process';

module.exports = function () {
  var head, last, notify;

  var flush = function () {
    var parent, fn;
    if (isNode && (parent = process.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (e) {
        if (head) notify();
        else last = undefined;
        throw e;
      }
    } last = undefined;
    if (parent) parent.enter();
  };

  // Node.js
  if (isNode) {
    notify = function () {
      process.nextTick(flush);
    };
  // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339
  } else if (Observer && !(global.navigator && global.navigator.standalone)) {
    var toggle = true;
    var node = document.createTextNode('');
    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (Promise && Promise.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    var promise = Promise.resolve(undefined);
    notify = function () {
      promise.then(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function (fn) {
    var task = { fn: fn, next: undefined };
    if (last) last.next = task;
    if (!head) {
      head = task;
      notify();
    } last = task;
  };
};

},{"134":134,"46":46,"68":68}],94:[function(_dereq_,module,exports){
'use strict';
// 25.4.1.5 NewPromiseCapability(C)
var aFunction = _dereq_(31);

function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
}

module.exports.f = function (C) {
  return new PromiseCapability(C);
};

},{"31":31}],95:[function(_dereq_,module,exports){
'use strict';
// 19.1.2.1 Object.assign(target, source, ...)
var DESCRIPTORS = _dereq_(56);
var getKeys = _dereq_(105);
var gOPS = _dereq_(102);
var pIE = _dereq_(106);
var toObject = _dereq_(140);
var IObject = _dereq_(75);
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || _dereq_(62)(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) {
      key = keys[j++];
      if (!DESCRIPTORS || isEnum.call(S, key)) T[key] = S[key];
    }
  } return T;
} : $assign;

},{"102":102,"105":105,"106":106,"140":140,"56":56,"62":62,"75":75}],96:[function(_dereq_,module,exports){
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = _dereq_(36);
var dPs = _dereq_(98);
var enumBugKeys = _dereq_(58);
var IE_PROTO = _dereq_(123)('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = _dereq_(57)('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  _dereq_(71).appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};

},{"123":123,"36":36,"57":57,"58":58,"71":71,"98":98}],97:[function(_dereq_,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"141":141,"27":27,"36":36,"56":56,"72":72}],98:[function(_dereq_,module,exports){
var dP = _dereq_(97);
var anObject = _dereq_(36);
var getKeys = _dereq_(105);

module.exports = _dereq_(56) ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};

},{"105":105,"36":36,"56":56,"97":97}],99:[function(_dereq_,module,exports){
var pIE = _dereq_(106);
var createDesc = _dereq_(114);
var toIObject = _dereq_(138);
var toPrimitive = _dereq_(141);
var has = _dereq_(69);
var IE8_DOM_DEFINE = _dereq_(72);
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = _dereq_(56) ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};

},{"106":106,"114":114,"138":138,"141":141,"56":56,"69":69,"72":72}],100:[function(_dereq_,module,exports){
// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = _dereq_(138);
var gOPN = _dereq_(101).f;
var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};

},{"101":101,"138":138}],101:[function(_dereq_,module,exports){
// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = _dereq_(104);
var hiddenKeys = _dereq_(58).concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};

},{"104":104,"58":58}],102:[function(_dereq_,module,exports){
exports.f = Object.getOwnPropertySymbols;

},{}],103:[function(_dereq_,module,exports){
// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = _dereq_(69);
var toObject = _dereq_(140);
var IE_PROTO = _dereq_(123)('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};

},{"123":123,"140":140,"69":69}],104:[function(_dereq_,module,exports){
var has = _dereq_(69);
var toIObject = _dereq_(138);
var arrayIndexOf = _dereq_(39)(false);
var IE_PROTO = _dereq_(123)('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};

},{"123":123,"138":138,"39":39,"69":69}],105:[function(_dereq_,module,exports){
// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = _dereq_(104);
var enumBugKeys = _dereq_(58);

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};

},{"104":104,"58":58}],106:[function(_dereq_,module,exports){
exports.f = {}.propertyIsEnumerable;

},{}],107:[function(_dereq_,module,exports){
// most Object methods by ES6 should accept primitives
var $export = _dereq_(60);
var core = _dereq_(50);
var fails = _dereq_(62);
module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);
};

},{"50":50,"60":60,"62":62}],108:[function(_dereq_,module,exports){
var DESCRIPTORS = _dereq_(56);
var getKeys = _dereq_(105);
var toIObject = _dereq_(138);
var isEnum = _dereq_(106).f;
module.exports = function (isEntries) {
  return function (it) {
    var O = toIObject(it);
    var keys = getKeys(O);
    var length = keys.length;
    var i = 0;
    var result = [];
    var key;
    while (length > i) {
      key = keys[i++];
      if (!DESCRIPTORS || isEnum.call(O, key)) {
        result.push(isEntries ? [key, O[key]] : O[key]);
      }
    }
    return result;
  };
};

},{"105":105,"106":106,"138":138,"56":56}],109:[function(_dereq_,module,exports){
// all object keys, includes non-enumerable and symbols
var gOPN = _dereq_(101);
var gOPS = _dereq_(102);
var anObject = _dereq_(36);
var Reflect = _dereq_(68).Reflect;
module.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {
  var keys = gOPN.f(anObject(it));
  var getSymbols = gOPS.f;
  return getSymbols ? keys.concat(getSymbols(it)) : keys;
};

},{"101":101,"102":102,"36":36,"68":68}],110:[function(_dereq_,module,exports){
var $parseFloat = _dereq_(68).parseFloat;
var $trim = _dereq_(132).trim;

module.exports = 1 / $parseFloat(_dereq_(133) + '-0') !== -Infinity ? function parseFloat(str) {
  var string = $trim(String(str), 3);
  var result = $parseFloat(string);
  return result === 0 && string.charAt(0) == '-' ? -0 : result;
} : $parseFloat;

},{"132":132,"133":133,"68":68}],111:[function(_dereq_,module,exports){
var $parseInt = _dereq_(68).parseInt;
var $trim = _dereq_(132).trim;
var ws = _dereq_(133);
var hex = /^[-+]?0[xX]/;

module.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix) {
  var string = $trim(String(str), 3);
  return $parseInt(string, (radix >>> 0) || (hex.test(string) ? 16 : 10));
} : $parseInt;

},{"132":132,"133":133,"68":68}],112:[function(_dereq_,module,exports){
module.exports = function (exec) {
  try {
    return { e: false, v: exec() };
  } catch (e) {
    return { e: true, v: e };
  }
};

},{}],113:[function(_dereq_,module,exports){
var anObject = _dereq_(36);
var isObject = _dereq_(79);
var newPromiseCapability = _dereq_(94);

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};

},{"36":36,"79":79,"94":94}],114:[function(_dereq_,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"28":28}],115:[function(_dereq_,module,exports){
var redefine = _dereq_(116);
module.exports = function (target, src, safe) {
  for (var key in src) redefine(target, key, src[key], safe);
  return target;
};

},{"116":116}],116:[function(_dereq_,module,exports){
var global = _dereq_(68);
var hide = _dereq_(70);
var has = _dereq_(69);
var SRC = _dereq_(145)('src');
var $toString = _dereq_(67);
var TO_STRING = 'toString';
var TPL = ('' + $toString).split(TO_STRING);

_dereq_(50).inspectSource = function (it) {
  return $toString.call(it);
};

(module.exports = function (O, key, val, safe) {
  var isFunction = typeof val == 'function';
  if (isFunction) has(val, 'name') || hide(val, 'name', key);
  if (O[key] === val) return;
  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
  if (O === global) {
    O[key] = val;
  } else if (!safe) {
    delete O[key];
    hide(O, key, val);
  } else if (O[key]) {
    O[key] = val;
  } else {
    hide(O, key, val);
  }
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, TO_STRING, function toString() {
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});

},{"145":145,"50":50,"67":67,"68":68,"69":69,"70":70}],117:[function(_dereq_,module,exports){
'use strict';

var classof = _dereq_(45);
var builtinExec = RegExp.prototype.exec;

 // `RegExpExec` abstract operation
// https://tc39.github.io/ecma262/#sec-regexpexec
module.exports = function (R, S) {
  var exec = R.exec;
  if (typeof exec === 'function') {
    var result = exec.call(R, S);
    if (typeof result !== 'object') {
      throw new TypeError('RegExp exec method returned something other than an Object or null');
    }
    return result;
  }
  if (classof(R) !== 'RegExp') {
    throw new TypeError('RegExp#exec called on incompatible receiver');
  }
  return builtinExec.call(R, S);
};

},{"45":45}],118:[function(_dereq_,module,exports){
'use strict';

var regexpFlags = _dereq_(64);

var nativeExec = RegExp.prototype.exec;
// This always refers to the native implementation, because the
// String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
// which loads this file before patching the method.
var nativeReplace = String.prototype.replace;

var patchedExec = nativeExec;

var LAST_INDEX = 'lastIndex';

var UPDATES_LAST_INDEX_WRONG = (function () {
  var re1 = /a/,
      re2 = /b*/g;
  nativeExec.call(re1, 'a');
  nativeExec.call(re2, 'a');
  return re1[LAST_INDEX] !== 0 || re2[LAST_INDEX] !== 0;
})();

// nonparticipating capturing group, copied from es5-shim's String#split patch.
var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;

var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED;

if (PATCH) {
  patchedExec = function exec(str) {
    var re = this;
    var lastIndex, reCopy, match, i;

    if (NPCG_INCLUDED) {
      reCopy = new RegExp('^' + re.source + '$(?!\\s)', regexpFlags.call(re));
    }
    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re[LAST_INDEX];

    match = nativeExec.call(re, str);

    if (UPDATES_LAST_INDEX_WRONG && match) {
      re[LAST_INDEX] = re.global ? match.index + match[0].length : lastIndex;
    }
    if (NPCG_INCLUDED && match && match.length > 1) {
      // Fix browsers whose `exec` methods don't consistently return `undefined`
      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
      // eslint-disable-next-line no-loop-func
      nativeReplace.call(match[0], reCopy, function () {
        for (i = 1; i < arguments.length - 2; i++) {
          if (arguments[i] === undefined) match[i] = undefined;
        }
      });
    }

    return match;
  };
}

module.exports = patchedExec;

},{"64":64}],119:[function(_dereq_,module,exports){
// 7.2.9 SameValue(x, y)
module.exports = Object.is || function is(x, y) {
  // eslint-disable-next-line no-self-compare
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};

},{}],120:[function(_dereq_,module,exports){
// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = _dereq_(79);
var anObject = _dereq_(36);
var check = function (O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function (test, buggy, set) {
      try {
        set = _dereq_(52)(Function.call, _dereq_(99).f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) { buggy = true; }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy) O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};

},{"36":36,"52":52,"79":79,"99":99}],121:[function(_dereq_,module,exports){
'use strict';
var global = _dereq_(68);
var dP = _dereq_(97);
var DESCRIPTORS = _dereq_(56);
var SPECIES = _dereq_(150)('species');

module.exports = function (KEY) {
  var C = global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function () { return this; }
  });
};

},{"150":150,"56":56,"68":68,"97":97}],122:[function(_dereq_,module,exports){
var def = _dereq_(97).f;
var has = _dereq_(69);
var TAG = _dereq_(150)('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};

},{"150":150,"69":69,"97":97}],123:[function(_dereq_,module,exports){
var shared = _dereq_(124)('keys');
var uid = _dereq_(145);
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};

},{"124":124,"145":145}],124:[function(_dereq_,module,exports){
var core = _dereq_(50);
var global = _dereq_(68);
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: core.version,
  mode: _dereq_(87) ? 'pure' : 'global',
  copyright: '© 2019 Denis Pushkarev (zloirock.ru)'
});

},{"50":50,"68":68,"87":87}],125:[function(_dereq_,module,exports){
// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject = _dereq_(36);
var aFunction = _dereq_(31);
var SPECIES = _dereq_(150)('species');
module.exports = function (O, D) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};

},{"150":150,"31":31,"36":36}],126:[function(_dereq_,module,exports){
'use strict';
var fails = _dereq_(62);

module.exports = function (method, arg) {
  return !!method && fails(function () {
    // eslint-disable-next-line no-useless-call
    arg ? method.call(null, function () { /* empty */ }, 1) : method.call(null);
  });
};

},{"62":62}],127:[function(_dereq_,module,exports){
var toInteger = _dereq_(137);
var defined = _dereq_(55);
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};

},{"137":137,"55":55}],128:[function(_dereq_,module,exports){
// helper for String#{startsWith, endsWith, includes}
var isRegExp = _dereq_(80);
var defined = _dereq_(55);

module.exports = function (that, searchString, NAME) {
  if (isRegExp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!");
  return String(defined(that));
};

},{"55":55,"80":80}],129:[function(_dereq_,module,exports){
var $export = _dereq_(60);
var fails = _dereq_(62);
var defined = _dereq_(55);
var quot = /"/g;
// B.2.3.2.1 CreateHTML(string, tag, attribute, value)
var createHTML = function (string, tag, attribute, value) {
  var S = String(defined(string));
  var p1 = '<' + tag;
  if (attribute !== '') p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
  return p1 + '>' + S + '</' + tag + '>';
};
module.exports = function (NAME, exec) {
  var O = {};
  O[NAME] = exec(createHTML);
  $export($export.P + $export.F * fails(function () {
    var test = ''[NAME]('"');
    return test !== test.toLowerCase() || test.split('"').length > 3;
  }), 'String', O);
};

},{"55":55,"60":60,"62":62}],130:[function(_dereq_,module,exports){
// https://github.com/tc39/proposal-string-pad-start-end
var toLength = _dereq_(139);
var repeat = _dereq_(131);
var defined = _dereq_(55);

module.exports = function (that, maxLength, fillString, left) {
  var S = String(defined(that));
  var stringLength = S.length;
  var fillStr = fillString === undefined ? ' ' : String(fillString);
  var intMaxLength = toLength(maxLength);
  if (intMaxLength <= stringLength || fillStr == '') return S;
  var fillLen = intMaxLength - stringLength;
  var stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
  if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);
  return left ? stringFiller + S : S + stringFiller;
};

},{"131":131,"139":139,"55":55}],131:[function(_dereq_,module,exports){
'use strict';
var toInteger = _dereq_(137);
var defined = _dereq_(55);

module.exports = function repeat(count) {
  var str = String(defined(this));
  var res = '';
  var n = toInteger(count);
  if (n < 0 || n == Infinity) throw RangeError("Count can't be negative");
  for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) res += str;
  return res;
};

},{"137":137,"55":55}],132:[function(_dereq_,module,exports){
var $export = _dereq_(60);
var defined = _dereq_(55);
var fails = _dereq_(62);
var spaces = _dereq_(133);
var space = '[' + spaces + ']';
var non = '\u200b\u0085';
var ltrim = RegExp('^' + space + space + '*');
var rtrim = RegExp(space + space + '*$');

var exporter = function (KEY, exec, ALIAS) {
  var exp = {};
  var FORCE = fails(function () {
    return !!spaces[KEY]() || non[KEY]() != non;
  });
  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
  if (ALIAS) exp[ALIAS] = fn;
  $export($export.P + $export.F * FORCE, 'String', exp);
};

// 1 -> String#trimLeft
// 2 -> String#trimRight
// 3 -> String#trim
var trim = exporter.trim = function (string, TYPE) {
  string = String(defined(string));
  if (TYPE & 1) string = string.replace(ltrim, '');
  if (TYPE & 2) string = string.replace(rtrim, '');
  return string;
};

module.exports = exporter;

},{"133":133,"55":55,"60":60,"62":62}],133:[function(_dereq_,module,exports){
module.exports = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
  '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

},{}],134:[function(_dereq_,module,exports){
var ctx = _dereq_(52);
var invoke = _dereq_(74);
var html = _dereq_(71);
var cel = _dereq_(57);
var global = _dereq_(68);
var process = global.process;
var setTask = global.setImmediate;
var clearTask = global.clearImmediate;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;
var run = function () {
  var id = +this;
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function (event) {
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (_dereq_(46)(process) == 'process') {
    defer = function (id) {
      process.nextTick(ctx(run, id, 1));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
    defer = function (id) {
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in cel('script')) {
    defer = function (id) {
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set: setTask,
  clear: clearTask
};

},{"46":46,"52":52,"57":57,"68":68,"71":71,"74":74}],135:[function(_dereq_,module,exports){
var toInteger = _dereq_(137);
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};

},{"137":137}],136:[function(_dereq_,module,exports){
// https://tc39.github.io/ecma262/#sec-toindex
var toInteger = _dereq_(137);
var toLength = _dereq_(139);
module.exports = function (it) {
  if (it === undefined) return 0;
  var number = toInteger(it);
  var length = toLength(number);
  if (number !== length) throw RangeError('Wrong length!');
  return length;
};

},{"137":137,"139":139}],137:[function(_dereq_,module,exports){
// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

},{}],138:[function(_dereq_,module,exports){
// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = _dereq_(75);
var defined = _dereq_(55);
module.exports = function (it) {
  return IObject(defined(it));
};

},{"55":55,"75":75}],139:[function(_dereq_,module,exports){
// 7.1.15 ToLength
var toInteger = _dereq_(137);
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

},{"137":137}],140:[function(_dereq_,module,exports){
// 7.1.13 ToObject(argument)
var defined = _dereq_(55);
module.exports = function (it) {
  return Object(defined(it));
};

},{"55":55}],141:[function(_dereq_,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"29":29,"79":79}],142:[function(_dereq_,module,exports){
'use strict';
if (_dereq_(56)) {
  var LIBRARY = _dereq_(87);
  var global = _dereq_(68);
  var fails = _dereq_(62);
  var $export = _dereq_(60);
  var $typed = _dereq_(144);
  var $buffer = _dereq_(143);
  var ctx = _dereq_(52);
  var anInstance = _dereq_(35);
  var propertyDesc = _dereq_(114);
  var hide = _dereq_(70);
  var redefineAll = _dereq_(115);
  var toInteger = _dereq_(137);
  var toLength = _dereq_(139);
  var toIndex = _dereq_(136);
  var toAbsoluteIndex = _dereq_(135);
  var toPrimitive = _dereq_(141);
  var has = _dereq_(69);
  var classof = _dereq_(45);
  var isObject = _dereq_(79);
  var toObject = _dereq_(140);
  var isArrayIter = _dereq_(76);
  var create = _dereq_(96);
  var getPrototypeOf = _dereq_(103);
  var gOPN = _dereq_(101).f;
  var getIterFn = _dereq_(151);
  var uid = _dereq_(145);
  var wks = _dereq_(150);
  var createArrayMethod = _dereq_(40);
  var createArrayIncludes = _dereq_(39);
  var speciesConstructor = _dereq_(125);
  var ArrayIterators = _dereq_(162);
  var Iterators = _dereq_(86);
  var $iterDetect = _dereq_(84);
  var setSpecies = _dereq_(121);
  var arrayFill = _dereq_(38);
  var arrayCopyWithin = _dereq_(37);
  var $DP = _dereq_(97);
  var $GOPD = _dereq_(99);
  var dP = $DP.f;
  var gOPD = $GOPD.f;
  var RangeError = global.RangeError;
  var TypeError = global.TypeError;
  var Uint8Array = global.Uint8Array;
  var ARRAY_BUFFER = 'ArrayBuffer';
  var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER;
  var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
  var PROTOTYPE = 'prototype';
  var ArrayProto = Array[PROTOTYPE];
  var $ArrayBuffer = $buffer.ArrayBuffer;
  var $DataView = $buffer.DataView;
  var arrayForEach = createArrayMethod(0);
  var arrayFilter = createArrayMethod(2);
  var arraySome = createArrayMethod(3);
  var arrayEvery = createArrayMethod(4);
  var arrayFind = createArrayMethod(5);
  var arrayFindIndex = createArrayMethod(6);
  var arrayIncludes = createArrayIncludes(true);
  var arrayIndexOf = createArrayIncludes(false);
  var arrayValues = ArrayIterators.values;
  var arrayKeys = ArrayIterators.keys;
  var arrayEntries = ArrayIterators.entries;
  var arrayLastIndexOf = ArrayProto.lastIndexOf;
  var arrayReduce = ArrayProto.reduce;
  var arrayReduceRight = ArrayProto.reduceRight;
  var arrayJoin = ArrayProto.join;
  var arraySort = ArrayProto.sort;
  var arraySlice = ArrayProto.slice;
  var arrayToString = ArrayProto.toString;
  var arrayToLocaleString = ArrayProto.toLocaleString;
  var ITERATOR = wks('iterator');
  var TAG = wks('toStringTag');
  var TYPED_CONSTRUCTOR = uid('typed_constructor');
  var DEF_CONSTRUCTOR = uid('def_constructor');
  var ALL_CONSTRUCTORS = $typed.CONSTR;
  var TYPED_ARRAY = $typed.TYPED;
  var VIEW = $typed.VIEW;
  var WRONG_LENGTH = 'Wrong length!';

  var $map = createArrayMethod(1, function (O, length) {
    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
  });

  var LITTLE_ENDIAN = fails(function () {
    // eslint-disable-next-line no-undef
    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
  });

  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () {
    new Uint8Array(1).set({});
  });

  var toOffset = function (it, BYTES) {
    var offset = toInteger(it);
    if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!');
    return offset;
  };

  var validate = function (it) {
    if (isObject(it) && TYPED_ARRAY in it) return it;
    throw TypeError(it + ' is not a typed array!');
  };

  var allocate = function (C, length) {
    if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) {
      throw TypeError('It is not a typed array constructor!');
    } return new C(length);
  };

  var speciesFromList = function (O, list) {
    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
  };

  var fromList = function (C, list) {
    var index = 0;
    var length = list.length;
    var result = allocate(C, length);
    while (length > index) result[index] = list[index++];
    return result;
  };

  var addGetter = function (it, key, internal) {
    dP(it, key, { get: function () { return this._d[internal]; } });
  };

  var $from = function from(source /* , mapfn, thisArg */) {
    var O = toObject(source);
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var iterFn = getIterFn(O);
    var i, length, values, result, step, iterator;
    if (iterFn != undefined && !isArrayIter(iterFn)) {
      for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {
        values.push(step.value);
      } O = values;
    }
    if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2);
    for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) {
      result[i] = mapping ? mapfn(O[i], i) : O[i];
    }
    return result;
  };

  var $of = function of(/* ...items */) {
    var index = 0;
    var length = arguments.length;
    var result = allocate(this, length);
    while (length > index) result[index] = arguments[index++];
    return result;
  };

  // iOS Safari 6.x fails here
  var TO_LOCALE_BUG = !!Uint8Array && fails(function () { arrayToLocaleString.call(new Uint8Array(1)); });

  var $toLocaleString = function toLocaleString() {
    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
  };

  var proto = {
    copyWithin: function copyWithin(target, start /* , end */) {
      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
    },
    every: function every(callbackfn /* , thisArg */) {
      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    fill: function fill(value /* , start, end */) { // eslint-disable-line no-unused-vars
      return arrayFill.apply(validate(this), arguments);
    },
    filter: function filter(callbackfn /* , thisArg */) {
      return speciesFromList(this, arrayFilter(validate(this), callbackfn,
        arguments.length > 1 ? arguments[1] : undefined));
    },
    find: function find(predicate /* , thisArg */) {
      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    findIndex: function findIndex(predicate /* , thisArg */) {
      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    forEach: function forEach(callbackfn /* , thisArg */) {
      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    indexOf: function indexOf(searchElement /* , fromIndex */) {
      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    includes: function includes(searchElement /* , fromIndex */) {
      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    join: function join(separator) { // eslint-disable-line no-unused-vars
      return arrayJoin.apply(validate(this), arguments);
    },
    lastIndexOf: function lastIndexOf(searchElement /* , fromIndex */) { // eslint-disable-line no-unused-vars
      return arrayLastIndexOf.apply(validate(this), arguments);
    },
    map: function map(mapfn /* , thisArg */) {
      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    reduce: function reduce(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
      return arrayReduce.apply(validate(this), arguments);
    },
    reduceRight: function reduceRight(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
      return arrayReduceRight.apply(validate(this), arguments);
    },
    reverse: function reverse() {
      var that = this;
      var length = validate(that).length;
      var middle = Math.floor(length / 2);
      var index = 0;
      var value;
      while (index < middle) {
        value = that[index];
        that[index++] = that[--length];
        that[length] = value;
      } return that;
    },
    some: function some(callbackfn /* , thisArg */) {
      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    sort: function sort(comparefn) {
      return arraySort.call(validate(this), comparefn);
    },
    subarray: function subarray(begin, end) {
      var O = validate(this);
      var length = O.length;
      var $begin = toAbsoluteIndex(begin, length);
      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(
        O.buffer,
        O.byteOffset + $begin * O.BYTES_PER_ELEMENT,
        toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin)
      );
    }
  };

  var $slice = function slice(start, end) {
    return speciesFromList(this, arraySlice.call(validate(this), start, end));
  };

  var $set = function set(arrayLike /* , offset */) {
    validate(this);
    var offset = toOffset(arguments[1], 1);
    var length = this.length;
    var src = toObject(arrayLike);
    var len = toLength(src.length);
    var index = 0;
    if (len + offset > length) throw RangeError(WRONG_LENGTH);
    while (index < len) this[offset + index] = src[index++];
  };

  var $iterators = {
    entries: function entries() {
      return arrayEntries.call(validate(this));
    },
    keys: function keys() {
      return arrayKeys.call(validate(this));
    },
    values: function values() {
      return arrayValues.call(validate(this));
    }
  };

  var isTAIndex = function (target, key) {
    return isObject(target)
      && target[TYPED_ARRAY]
      && typeof key != 'symbol'
      && key in target
      && String(+key) == String(key);
  };
  var $getDesc = function getOwnPropertyDescriptor(target, key) {
    return isTAIndex(target, key = toPrimitive(key, true))
      ? propertyDesc(2, target[key])
      : gOPD(target, key);
  };
  var $setDesc = function defineProperty(target, key, desc) {
    if (isTAIndex(target, key = toPrimitive(key, true))
      && isObject(desc)
      && has(desc, 'value')
      && !has(desc, 'get')
      && !has(desc, 'set')
      // TODO: add validation descriptor w/o calling accessors
      && !desc.configurable
      && (!has(desc, 'writable') || desc.writable)
      && (!has(desc, 'enumerable') || desc.enumerable)
    ) {
      target[key] = desc.value;
      return target;
    } return dP(target, key, desc);
  };

  if (!ALL_CONSTRUCTORS) {
    $GOPD.f = $getDesc;
    $DP.f = $setDesc;
  }

  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
    getOwnPropertyDescriptor: $getDesc,
    defineProperty: $setDesc
  });

  if (fails(function () { arrayToString.call({}); })) {
    arrayToString = arrayToLocaleString = function toString() {
      return arrayJoin.call(this);
    };
  }

  var $TypedArrayPrototype$ = redefineAll({}, proto);
  redefineAll($TypedArrayPrototype$, $iterators);
  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
  redefineAll($TypedArrayPrototype$, {
    slice: $slice,
    set: $set,
    constructor: function () { /* noop */ },
    toString: arrayToString,
    toLocaleString: $toLocaleString
  });
  addGetter($TypedArrayPrototype$, 'buffer', 'b');
  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
  addGetter($TypedArrayPrototype$, 'byteLength', 'l');
  addGetter($TypedArrayPrototype$, 'length', 'e');
  dP($TypedArrayPrototype$, TAG, {
    get: function () { return this[TYPED_ARRAY]; }
  });

  // eslint-disable-next-line max-statements
  module.exports = function (KEY, BYTES, wrapper, CLAMPED) {
    CLAMPED = !!CLAMPED;
    var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array';
    var GETTER = 'get' + KEY;
    var SETTER = 'set' + KEY;
    var TypedArray = global[NAME];
    var Base = TypedArray || {};
    var TAC = TypedArray && getPrototypeOf(TypedArray);
    var FORCED = !TypedArray || !$typed.ABV;
    var O = {};
    var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];
    var getter = function (that, index) {
      var data = that._d;
      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
    };
    var setter = function (that, index, value) {
      var data = that._d;
      if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
    };
    var addElement = function (that, index) {
      dP(that, index, {
        get: function () {
          return getter(this, index);
        },
        set: function (value) {
          return setter(this, index, value);
        },
        enumerable: true
      });
    };
    if (FORCED) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME, '_d');
        var index = 0;
        var offset = 0;
        var buffer, byteLength, length, klass;
        if (!isObject(data)) {
          length = toIndex(data);
          byteLength = length * BYTES;
          buffer = new $ArrayBuffer(byteLength);
        } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          buffer = data;
          offset = toOffset($offset, BYTES);
          var $len = data.byteLength;
          if ($length === undefined) {
            if ($len % BYTES) throw RangeError(WRONG_LENGTH);
            byteLength = $len - offset;
            if (byteLength < 0) throw RangeError(WRONG_LENGTH);
          } else {
            byteLength = toLength($length) * BYTES;
            if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH);
          }
          length = byteLength / BYTES;
        } else if (TYPED_ARRAY in data) {
          return fromList(TypedArray, data);
        } else {
          return $from.call(TypedArray, data);
        }
        hide(that, '_d', {
          b: buffer,
          o: offset,
          l: byteLength,
          e: length,
          v: new $DataView(buffer)
        });
        while (index < length) addElement(that, index++);
      });
      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
      hide(TypedArrayPrototype, 'constructor', TypedArray);
    } else if (!fails(function () {
      TypedArray(1);
    }) || !fails(function () {
      new TypedArray(-1); // eslint-disable-line no-new
    }) || !$iterDetect(function (iter) {
      new TypedArray(); // eslint-disable-line no-new
      new TypedArray(null); // eslint-disable-line no-new
      new TypedArray(1.5); // eslint-disable-line no-new
      new TypedArray(iter); // eslint-disable-line no-new
    }, true)) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME);
        var klass;
        // `ws` module bug, temporarily remove validation length for Uint8Array
        // https://github.com/websockets/ws/pull/645
        if (!isObject(data)) return new Base(toIndex(data));
        if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          return $length !== undefined
            ? new Base(data, toOffset($offset, BYTES), $length)
            : $offset !== undefined
              ? new Base(data, toOffset($offset, BYTES))
              : new Base(data);
        }
        if (TYPED_ARRAY in data) return fromList(TypedArray, data);
        return $from.call(TypedArray, data);
      });
      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) {
        if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);
      });
      TypedArray[PROTOTYPE] = TypedArrayPrototype;
      if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray;
    }
    var $nativeIterator = TypedArrayPrototype[ITERATOR];
    var CORRECT_ITER_NAME = !!$nativeIterator
      && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined);
    var $iterator = $iterators.values;
    hide(TypedArray, TYPED_CONSTRUCTOR, true);
    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
    hide(TypedArrayPrototype, VIEW, true);
    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);

    if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {
      dP(TypedArrayPrototype, TAG, {
        get: function () { return NAME; }
      });
    }

    O[NAME] = TypedArray;

    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);

    $export($export.S, NAME, {
      BYTES_PER_ELEMENT: BYTES
    });

    $export($export.S + $export.F * fails(function () { Base.of.call(TypedArray, 1); }), NAME, {
      from: $from,
      of: $of
    });

    if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);

    $export($export.P, NAME, proto);

    setSpecies(NAME);

    $export($export.P + $export.F * FORCED_SET, NAME, { set: $set });

    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);

    if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString;

    $export($export.P + $export.F * fails(function () {
      new TypedArray(1).slice();
    }), NAME, { slice: $slice });

    $export($export.P + $export.F * (fails(function () {
      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString();
    }) || !fails(function () {
      TypedArrayPrototype.toLocaleString.call([1, 2]);
    })), NAME, { toLocaleString: $toLocaleString });

    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
    if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator);
  };
} else module.exports = function () { /* empty */ };

},{"101":101,"103":103,"114":114,"115":115,"121":121,"125":125,"135":135,"136":136,"137":137,"139":139,"140":140,"141":141,"143":143,"144":144,"145":145,"150":150,"151":151,"162":162,"35":35,"37":37,"38":38,"39":39,"40":40,"45":45,"52":52,"56":56,"60":60,"62":62,"68":68,"69":69,"70":70,"76":76,"79":79,"84":84,"86":86,"87":87,"96":96,"97":97,"99":99}],143:[function(_dereq_,module,exports){
'use strict';
var global = _dereq_(68);
var DESCRIPTORS = _dereq_(56);
var LIBRARY = _dereq_(87);
var $typed = _dereq_(144);
var hide = _dereq_(70);
var redefineAll = _dereq_(115);
var fails = _dereq_(62);
var anInstance = _dereq_(35);
var toInteger = _dereq_(137);
var toLength = _dereq_(139);
var toIndex = _dereq_(136);
var gOPN = _dereq_(101).f;
var dP = _dereq_(97).f;
var arrayFill = _dereq_(38);
var setToStringTag = _dereq_(122);
var ARRAY_BUFFER = 'ArrayBuffer';
var DATA_VIEW = 'DataView';
var PROTOTYPE = 'prototype';
var WRONG_LENGTH = 'Wrong length!';
var WRONG_INDEX = 'Wrong index!';
var $ArrayBuffer = global[ARRAY_BUFFER];
var $DataView = global[DATA_VIEW];
var Math = global.Math;
var RangeError = global.RangeError;
// eslint-disable-next-line no-shadow-restricted-names
var Infinity = global.Infinity;
var BaseBuffer = $ArrayBuffer;
var abs = Math.abs;
var pow = Math.pow;
var floor = Math.floor;
var log = Math.log;
var LN2 = Math.LN2;
var BUFFER = 'buffer';
var BYTE_LENGTH = 'byteLength';
var BYTE_OFFSET = 'byteOffset';
var $BUFFER = DESCRIPTORS ? '_b' : BUFFER;
var $LENGTH = DESCRIPTORS ? '_l' : BYTE_LENGTH;
var $OFFSET = DESCRIPTORS ? '_o' : BYTE_OFFSET;

// IEEE754 conversions based on https://github.com/feross/ieee754
function packIEEE754(value, mLen, nBytes) {
  var buffer = new Array(nBytes);
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0;
  var i = 0;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  var e, m, c;
  value = abs(value);
  // eslint-disable-next-line no-self-compare
  if (value != value || value === Infinity) {
    // eslint-disable-next-line no-self-compare
    m = value != value ? 1 : 0;
    e = eMax;
  } else {
    e = floor(log(value) / LN2);
    if (value * (c = pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * pow(2, eBias - 1) * pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);
  buffer[--i] |= s * 128;
  return buffer;
}
function unpackIEEE754(buffer, mLen, nBytes) {
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = eLen - 7;
  var i = nBytes - 1;
  var s = buffer[i--];
  var e = s & 127;
  var m;
  s >>= 7;
  for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : s ? -Infinity : Infinity;
  } else {
    m = m + pow(2, mLen);
    e = e - eBias;
  } return (s ? -1 : 1) * m * pow(2, e - mLen);
}

function unpackI32(bytes) {
  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
}
function packI8(it) {
  return [it & 0xff];
}
function packI16(it) {
  return [it & 0xff, it >> 8 & 0xff];
}
function packI32(it) {
  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
}
function packF64(it) {
  return packIEEE754(it, 52, 8);
}
function packF32(it) {
  return packIEEE754(it, 23, 4);
}

function addGetter(C, key, internal) {
  dP(C[PROTOTYPE], key, { get: function () { return this[internal]; } });
}

function get(view, bytes, index, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = store.slice(start, start + bytes);
  return isLittleEndian ? pack : pack.reverse();
}
function set(view, bytes, index, conversion, value, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = conversion(+value);
  for (var i = 0; i < bytes; i++) store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
}

if (!$typed.ABV) {
  $ArrayBuffer = function ArrayBuffer(length) {
    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
    var byteLength = toIndex(length);
    this._b = arrayFill.call(new Array(byteLength), 0);
    this[$LENGTH] = byteLength;
  };

  $DataView = function DataView(buffer, byteOffset, byteLength) {
    anInstance(this, $DataView, DATA_VIEW);
    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
    var bufferLength = buffer[$LENGTH];
    var offset = toInteger(byteOffset);
    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!');
    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
    this[$BUFFER] = buffer;
    this[$OFFSET] = offset;
    this[$LENGTH] = byteLength;
  };

  if (DESCRIPTORS) {
    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
    addGetter($DataView, BUFFER, '_b');
    addGetter($DataView, BYTE_LENGTH, '_l');
    addGetter($DataView, BYTE_OFFSET, '_o');
  }

  redefineAll($DataView[PROTOTYPE], {
    getInt8: function getInt8(byteOffset) {
      return get(this, 1, byteOffset)[0] << 24 >> 24;
    },
    getUint8: function getUint8(byteOffset) {
      return get(this, 1, byteOffset)[0];
    },
    getInt16: function getInt16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
    },
    getUint16: function getUint16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return bytes[1] << 8 | bytes[0];
    },
    getInt32: function getInt32(byteOffset /* , littleEndian */) {
      return unpackI32(get(this, 4, byteOffset, arguments[1]));
    },
    getUint32: function getUint32(byteOffset /* , littleEndian */) {
      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
    },
    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
    },
    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
    },
    setInt8: function setInt8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setUint8: function setUint8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packF32, value, arguments[2]);
    },
    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {
      set(this, 8, byteOffset, packF64, value, arguments[2]);
    }
  });
} else {
  if (!fails(function () {
    $ArrayBuffer(1);
  }) || !fails(function () {
    new $ArrayBuffer(-1); // eslint-disable-line no-new
  }) || fails(function () {
    new $ArrayBuffer(); // eslint-disable-line no-new
    new $ArrayBuffer(1.5); // eslint-disable-line no-new
    new $ArrayBuffer(NaN); // eslint-disable-line no-new
    return $ArrayBuffer.name != ARRAY_BUFFER;
  })) {
    $ArrayBuffer = function ArrayBuffer(length) {
      anInstance(this, $ArrayBuffer);
      return new BaseBuffer(toIndex(length));
    };
    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];
    for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) {
      if (!((key = keys[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, BaseBuffer[key]);
    }
    if (!LIBRARY) ArrayBufferProto.constructor = $ArrayBuffer;
  }
  // iOS Safari 7.x bug
  var view = new $DataView(new $ArrayBuffer(2));
  var $setInt8 = $DataView[PROTOTYPE].setInt8;
  view.setInt8(0, 2147483648);
  view.setInt8(1, 2147483649);
  if (view.getInt8(0) || !view.getInt8(1)) redefineAll($DataView[PROTOTYPE], {
    setInt8: function setInt8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    },
    setUint8: function setUint8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    }
  }, true);
}
setToStringTag($ArrayBuffer, ARRAY_BUFFER);
setToStringTag($DataView, DATA_VIEW);
hide($DataView[PROTOTYPE], $typed.VIEW, true);
exports[ARRAY_BUFFER] = $ArrayBuffer;
exports[DATA_VIEW] = $DataView;

},{"101":101,"115":115,"122":122,"136":136,"137":137,"139":139,"144":144,"35":35,"38":38,"56":56,"62":62,"68":68,"70":70,"87":87,"97":97}],144:[function(_dereq_,module,exports){
var global = _dereq_(68);
var hide = _dereq_(70);
var uid = _dereq_(145);
var TYPED = uid('typed_array');
var VIEW = uid('view');
var ABV = !!(global.ArrayBuffer && global.DataView);
var CONSTR = ABV;
var i = 0;
var l = 9;
var Typed;

var TypedArrayConstructors = (
  'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'
).split(',');

while (i < l) {
  if (Typed = global[TypedArrayConstructors[i++]]) {
    hide(Typed.prototype, TYPED, true);
    hide(Typed.prototype, VIEW, true);
  } else CONSTR = false;
}

module.exports = {
  ABV: ABV,
  CONSTR: CONSTR,
  TYPED: TYPED,
  VIEW: VIEW
};

},{"145":145,"68":68,"70":70}],145:[function(_dereq_,module,exports){
var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

},{}],146:[function(_dereq_,module,exports){
var global = _dereq_(68);
var navigator = global.navigator;

module.exports = navigator && navigator.userAgent || '';

},{"68":68}],147:[function(_dereq_,module,exports){
var isObject = _dereq_(79);
module.exports = function (it, TYPE) {
  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
  return it;
};

},{"79":79}],148:[function(_dereq_,module,exports){
var global = _dereq_(68);
var core = _dereq_(50);
var LIBRARY = _dereq_(87);
var wksExt = _dereq_(149);
var defineProperty = _dereq_(97).f;
module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
};

},{"149":149,"50":50,"68":68,"87":87,"97":97}],149:[function(_dereq_,module,exports){
exports.f = _dereq_(150);

},{"150":150}],150:[function(_dereq_,module,exports){
var store = _dereq_(124)('wks');
var uid = _dereq_(145);
var Symbol = _dereq_(68).Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;

},{"124":124,"145":145,"68":68}],151:[function(_dereq_,module,exports){
var classof = _dereq_(45);
var ITERATOR = _dereq_(150)('iterator');
var Iterators = _dereq_(86);
module.exports = _dereq_(50).getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};

},{"150":150,"45":45,"50":50,"86":86}],152:[function(_dereq_,module,exports){
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
var $export = _dereq_(60);

$export($export.P, 'Array', { copyWithin: _dereq_(37) });

_dereq_(33)('copyWithin');

},{"33":33,"37":37,"60":60}],153:[function(_dereq_,module,exports){
'use strict';
var $export = _dereq_(60);
var $every = _dereq_(40)(4);

$export($export.P + $export.F * !_dereq_(126)([].every, true), 'Array', {
  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
  every: function every(callbackfn /* , thisArg */) {
    return $every(this, callbackfn, arguments[1]);
  }
});

},{"126":126,"40":40,"60":60}],154:[function(_dereq_,module,exports){
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
var $export = _dereq_(60);

$export($export.P, 'Array', { fill: _dereq_(38) });

_dereq_(33)('fill');

},{"33":33,"38":38,"60":60}],155:[function(_dereq_,module,exports){
'use strict';
var $export = _dereq_(60);
var $filter = _dereq_(40)(2);

$export($export.P + $export.F * !_dereq_(126)([].filter, true), 'Array', {
  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
  filter: function filter(callbackfn /* , thisArg */) {
    return $filter(this, callbackfn, arguments[1]);
  }
});

},{"126":126,"40":40,"60":60}],156:[function(_dereq_,module,exports){
'use strict';
// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)
var $export = _dereq_(60);
var $find = _dereq_(40)(6);
var KEY = 'findIndex';
var forced = true;
// Shouldn't skip holes
if (KEY in []) Array(1)[KEY](function () { forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  findIndex: function findIndex(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
_dereq_(33)(KEY);

},{"33":33,"40":40,"60":60}],157:[function(_dereq_,module,exports){
'use strict';
// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
var $export = _dereq_(60);
var $find = _dereq_(40)(5);
var KEY = 'find';
var forced = true;
// Shouldn't skip holes
if (KEY in []) Array(1)[KEY](function () { forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  find: function find(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
_dereq_(33)(KEY);

},{"33":33,"40":40,"60":60}],158:[function(_dereq_,module,exports){
'use strict';
var $export = _dereq_(60);
var $forEach = _dereq_(40)(0);
var STRICT = _dereq_(126)([].forEach, true);

$export($export.P + $export.F * !STRICT, 'Array', {
  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
  forEach: function forEach(callbackfn /* , thisArg */) {
    return $forEach(this, callbackfn, arguments[1]);
  }
});

},{"126":126,"40":40,"60":60}],159:[function(_dereq_,module,exports){
'use strict';
var ctx = _dereq_(52);
var $export = _dereq_(60);
var toObject = _dereq_(140);
var call = _dereq_(81);
var isArrayIter = _dereq_(76);
var toLength = _dereq_(139);
var createProperty = _dereq_(51);
var getIterFn = _dereq_(151);

$export($export.S + $export.F * !_dereq_(84)(function (iter) { Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
    var O = toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = getIterFn(O);
    var length, result, step, iterator;
    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);
      for (result = new C(length); length > index; index++) {
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});

},{"139":139,"140":140,"151":151,"51":51,"52":52,"60":60,"76":76,"81":81,"84":84}],160:[function(_dereq_,module,exports){
'use strict';
var $export = _dereq_(60);
var $indexOf = _dereq_(39)(false);
var $native = [].indexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;

$export($export.P + $export.F * (NEGATIVE_ZERO || !_dereq_(126)($native)), 'Array', {
  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
  indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {
    return NEGATIVE_ZERO
      // convert -0 to +0
      ? $native.apply(this, arguments) || 0
      : $indexOf(this, searchElement, arguments[1]);
  }
});

},{"126":126,"39":39,"60":60}],161:[function(_dereq_,module,exports){
// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
var $export = _dereq_(60);

$export($export.S, 'Array', { isArray: _dereq_(77) });

},{"60":60,"77":77}],162:[function(_dereq_,module,exports){
'use strict';
var addToUnscopables = _dereq_(33);
var step = _dereq_(85);
var Iterators = _dereq_(86);
var toIObject = _dereq_(138);

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = _dereq_(83)(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

},{"138":138,"33":33,"83":83,"85":85,"86":86}],163:[function(_dereq_,module,exports){
'use strict';
// 22.1.3.13 Array.prototype.join(separator)
var $export = _dereq_(60);
var toIObject = _dereq_(138);
var arrayJoin = [].join;

// fallback for not array-like strings
$export($export.P + $export.F * (_dereq_(75) != Object || !_dereq_(126)(arrayJoin)), 'Array', {
  join: function join(separator) {
    return arrayJoin.call(toIObject(this), separator === undefined ? ',' : separator);
  }
});

},{"126":126,"138":138,"60":60,"75":75}],164:[function(_dereq_,module,exports){
'use strict';
var $export = _dereq_(60);
var toIObject = _dereq_(138);
var toInteger = _dereq_(137);
var toLength = _dereq_(139);
var $native = [].lastIndexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].lastIndexOf(1, -0) < 0;

$export($export.P + $export.F * (NEGATIVE_ZERO || !_dereq_(126)($native)), 'Array', {
  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
  lastIndexOf: function lastIndexOf(searchElement /* , fromIndex = @[*-1] */) {
    // convert -0 to +0
    if (NEGATIVE_ZERO) return $native.apply(this, arguments) || 0;
    var O = toIObject(this);
    var length = toLength(O.length);
    var index = length - 1;
    if (arguments.length > 1) index = Math.min(index, toInteger(arguments[1]));
    if (index < 0) index = length + index;
    for (;index >= 0; index--) if (index in O) if (O[index] === searchElement) return index || 0;
    return -1;
  }
});

},{"126":126,"137":137,"138":138,"139":139,"60":60}],165:[function(_dereq_,module,exports){
'use strict';
var $export = _dereq_(60);
var $map = _dereq_(40)(1);

$export($export.P + $export.F * !_dereq_(126)([].map, true), 'Array', {
  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
  map: function map(callbackfn /* , thisArg */) {
    return $map(this, callbackfn, arguments[1]);
  }
});

},{"126":126,"40":40,"60":60}],166:[function(_dereq_,module,exports){
'use strict';
var $export = _dereq_(60);
var createProperty = _dereq_(51);

// WebKit Array.of isn't generic
$export($export.S + $export.F * _dereq_(62)(function () {
  function F() { /* empty */ }
  return !(Array.of.call(F) instanceof F);
}), 'Array', {
  // 22.1.2.3 Array.of( ...items)
  of: function of(/* ...args */) {
    var index = 0;
    var aLen = arguments.length;
    var result = new (typeof this == 'function' ? this : Array)(aLen);
    while (aLen > index) createProperty(result, index, arguments[index++]);
    result.length = aLen;
    return result;
  }
});

},{"51":51,"60":60,"62":62}],167:[function(_dereq_,module,exports){
'use strict';
var $export = _dereq_(60);
var $reduce = _dereq_(41);

$export($export.P + $export.F * !_dereq_(126)([].reduceRight, true), 'Array', {
  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
  reduceRight: function reduceRight(callbackfn /* , initialValue */) {
    return $reduce(this, callbackfn, arguments.length, arguments[1], true);
  }
});

},{"126":126,"41":41,"60":60}],168:[function(_dereq_,module,exports){
'use strict';
var $export = _dereq_(60);
var $reduce = _dereq_(41);

$export($export.P + $export.F * !_dereq_(126)([].reduce, true), 'Array', {
  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
  reduce: function reduce(callbackfn /* , initialValue */) {
    return $reduce(this, callbackfn, arguments.length, arguments[1], false);
  }
});

},{"126":126,"41":41,"60":60}],169:[function(_dereq_,module,exports){
'use strict';
var $export = _dereq_(60);
var html = _dereq_(71);
var cof = _dereq_(46);
var toAbsoluteIndex = _dereq_(135);
var toLength = _dereq_(139);
var arraySlice = [].slice;

// fallback for not array-like ES3 strings and DOM objects
$export($export.P + $export.F * _dereq_(62)(function () {
  if (html) arraySlice.call(html);
}), 'Array', {
  slice: function slice(begin, end) {
    var len = toLength(this.length);
    var klass = cof(this);
    end = end === undefined ? len : end;
    if (klass == 'Array') return arraySlice.call(this, begin, end);
    var start = toAbsoluteIndex(begin, len);
    var upTo = toAbsoluteIndex(end, len);
    var size = toLength(upTo - start);
    var cloned = new Array(size);
    var i = 0;
    for (; i < size; i++) cloned[i] = klass == 'String'
      ? this.charAt(start + i)
      : this[start + i];
    return cloned;
  }
});

},{"135":135,"139":139,"46":46,"60":60,"62":62,"71":71}],170:[function(_dereq_,module,exports){
'use strict';
var $export = _dereq_(60);
var $some = _dereq_(40)(3);

$export($export.P + $export.F * !_dereq_(126)([].some, true), 'Array', {
  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
  some: function some(callbackfn /* , thisArg */) {
    return $some(this, callbackfn, arguments[1]);
  }
});

},{"126":126,"40":40,"60":60}],171:[function(_dereq_,module,exports){
'use strict';
var $export = _dereq_(60);
var aFunction = _dereq_(31);
var toObject = _dereq_(140);
var fails = _dereq_(62);
var $sort = [].sort;
var test = [1, 2, 3];

$export($export.P + $export.F * (fails(function () {
  // IE8-
  test.sort(undefined);
}) || !fails(function () {
  // V8 bug
  test.sort(null);
  // Old WebKit
}) || !_dereq_(126)($sort)), 'Array', {
  // 22.1.3.25 Array.prototype.sort(comparefn)
  sort: function sort(comparefn) {
    return comparefn === undefined
      ? $sort.call(toObject(this))
      : $sort.call(toObject(this), aFunction(comparefn));
  }
});

},{"126":126,"140":140,"31":31,"60":60,"62":62}],172:[function(_dereq_,module,exports){
_dereq_(121)('Array');

},{"121":121}],173:[function(_dereq_,module,exports){
// 20.3.3.1 / 15.9.4.4 Date.now()
var $export = _dereq_(60);

$export($export.S, 'Date', { now: function () { return new Date().getTime(); } });

},{"60":60}],174:[function(_dereq_,module,exports){
// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
var $export = _dereq_(60);
var toISOString = _dereq_(53);

// PhantomJS / old WebKit has a broken implementations
$export($export.P + $export.F * (Date.prototype.toISOString !== toISOString), 'Date', {
  toISOString: toISOString
});

},{"53":53,"60":60}],175:[function(_dereq_,module,exports){
'use strict';
var $export = _dereq_(60);
var toObject = _dereq_(140);
var toPrimitive = _dereq_(141);

$export($export.P + $export.F * _dereq_(62)(function () {
  return new Date(NaN).toJSON() !== null
    || Date.prototype.toJSON.call({ toISOString: function () { return 1; } }) !== 1;
}), 'Date', {
  // eslint-disable-next-line no-unused-vars
  toJSON: function toJSON(key) {
    var O = toObject(this);
    var pv = toPrimitive(O);
    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
  }
});

},{"140":140,"141":141,"60":60,"62":62}],176:[function(_dereq_,module,exports){
var TO_PRIMITIVE = _dereq_(150)('toPrimitive');
var proto = Date.prototype;

if (!(TO_PRIMITIVE in proto)) _dereq_(70)(proto, TO_PRIMITIVE, _dereq_(54));

},{"150":150,"54":54,"70":70}],177:[function(_dereq_,module,exports){
var DateProto = Date.prototype;
var INVALID_DATE = 'Invalid Date';
var TO_STRING = 'toString';
var $toString = DateProto[TO_STRING];
var getTime = DateProto.getTime;
if (new Date(NaN) + '' != INVALID_DATE) {
  _dereq_(116)(DateProto, TO_STRING, function toString() {
    var value = getTime.call(this);
    // eslint-disable-next-line no-self-compare
    return value === value ? $toString.call(this) : INVALID_DATE;
  });
}

},{"116":116}],178:[function(_dereq_,module,exports){
// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
var $export = _dereq_(60);

$export($export.P, 'Function', { bind: _dereq_(44) });

},{"44":44,"60":60}],179:[function(_dereq_,module,exports){
'use strict';
var isObject = _dereq_(79);
var getPrototypeOf = _dereq_(103);
var HAS_INSTANCE = _dereq_(150)('hasInstance');
var FunctionProto = Function.prototype;
// 19.2.3.6 Function.prototype[@@hasInstance](V)
if (!(HAS_INSTANCE in FunctionProto)) _dereq_(97).f(FunctionProto, HAS_INSTANCE, { value: function (O) {
  if (typeof this != 'function' || !isObject(O)) return false;
  if (!isObject(this.prototype)) return O instanceof this;
  // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
  while (O = getPrototypeOf(O)) if (this.prototype === O) return true;
  return false;
} });

},{"103":103,"150":150,"79":79,"97":97}],180:[function(_dereq_,module,exports){
var dP = _dereq_(97).f;
var FProto = Function.prototype;
var nameRE = /^\s*function ([^ (]*)/;
var NAME = 'name';

// 19.2.4.2 name
NAME in FProto || _dereq_(56) && dP(FProto, NAME, {
  configurable: true,
  get: function () {
    try {
      return ('' + this).match(nameRE)[1];
    } catch (e) {
      return '';
    }
  }
});

},{"56":56,"97":97}],181:[function(_dereq_,module,exports){
'use strict';
var strong = _dereq_(47);
var validate = _dereq_(147);
var MAP = 'Map';

// 23.1 Map Objects
module.exports = _dereq_(49)(MAP, function (get) {
  return function Map() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key) {
    var entry = strong.getEntry(validate(this, MAP), key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value) {
    return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);
  }
}, strong, true);

},{"147":147,"47":47,"49":49}],182:[function(_dereq_,module,exports){
// 20.2.2.3 Math.acosh(x)
var $export = _dereq_(60);
var log1p = _dereq_(90);
var sqrt = Math.sqrt;
var $acosh = Math.acosh;

$export($export.S + $export.F * !($acosh
  // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
  && Math.floor($acosh(Number.MAX_VALUE)) == 710
  // Tor Browser bug: Math.acosh(Infinity) -> NaN
  && $acosh(Infinity) == Infinity
), 'Math', {
  acosh: function acosh(x) {
    return (x = +x) < 1 ? NaN : x > 94906265.62425156
      ? Math.log(x) + Math.LN2
      : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
  }
});

},{"60":60,"90":90}],183:[function(_dereq_,module,exports){
// 20.2.2.5 Math.asinh(x)
var $export = _dereq_(60);
var $asinh = Math.asinh;

function asinh(x) {
  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
}

// Tor Browser bug: Math.asinh(0) -> -0
$export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', { asinh: asinh });

},{"60":60}],184:[function(_dereq_,module,exports){
// 20.2.2.7 Math.atanh(x)
var $export = _dereq_(60);
var $atanh = Math.atanh;

// Tor Browser bug: Math.atanh(-0) -> 0
$export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {
  atanh: function atanh(x) {
    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
  }
});

},{"60":60}],185:[function(_dereq_,module,exports){
// 20.2.2.9 Math.cbrt(x)
var $export = _dereq_(60);
var sign = _dereq_(91);

$export($export.S, 'Math', {
  cbrt: function cbrt(x) {
    return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
  }
});

},{"60":60,"91":91}],186:[function(_dereq_,module,exports){
// 20.2.2.11 Math.clz32(x)
var $export = _dereq_(60);

$export($export.S, 'Math', {
  clz32: function clz32(x) {
    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
  }
});

},{"60":60}],187:[function(_dereq_,module,exports){
// 20.2.2.12 Math.cosh(x)
var $export = _dereq_(60);
var exp = Math.exp;

$export($export.S, 'Math', {
  cosh: function cosh(x) {
    return (exp(x = +x) + exp(-x)) / 2;
  }
});

},{"60":60}],188:[function(_dereq_,module,exports){
// 20.2.2.14 Math.expm1(x)
var $export = _dereq_(60);
var $expm1 = _dereq_(88);

$export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', { expm1: $expm1 });

},{"60":60,"88":88}],189:[function(_dereq_,module,exports){
// 20.2.2.16 Math.fround(x)
var $export = _dereq_(60);

$export($export.S, 'Math', { fround: _dereq_(89) });

},{"60":60,"89":89}],190:[function(_dereq_,module,exports){
// 20.2.2.17 Math.hypot([value1[, value2[, … ]]])
var $export = _dereq_(60);
var abs = Math.abs;

$export($export.S, 'Math', {
  hypot: function hypot(value1, value2) { // eslint-disable-line no-unused-vars
    var sum = 0;
    var i = 0;
    var aLen = arguments.length;
    var larg = 0;
    var arg, div;
    while (i < aLen) {
      arg = abs(arguments[i++]);
      if (larg < arg) {
        div = larg / arg;
        sum = sum * div * div + 1;
        larg = arg;
      } else if (arg > 0) {
        div = arg / larg;
        sum += div * div;
      } else sum += arg;
    }
    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
  }
});

},{"60":60}],191:[function(_dereq_,module,exports){
// 20.2.2.18 Math.imul(x, y)
var $export = _dereq_(60);
var $imul = Math.imul;

// some WebKit versions fails with big numbers, some has wrong arity
$export($export.S + $export.F * _dereq_(62)(function () {
  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
}), 'Math', {
  imul: function imul(x, y) {
    var UINT16 = 0xffff;
    var xn = +x;
    var yn = +y;
    var xl = UINT16 & xn;
    var yl = UINT16 & yn;
    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
  }
});

},{"60":60,"62":62}],192:[function(_dereq_,module,exports){
// 20.2.2.21 Math.log10(x)
var $export = _dereq_(60);

$export($export.S, 'Math', {
  log10: function log10(x) {
    return Math.log(x) * Math.LOG10E;
  }
});

},{"60":60}],193:[function(_dereq_,module,exports){
// 20.2.2.20 Math.log1p(x)
var $export = _dereq_(60);

$export($export.S, 'Math', { log1p: _dereq_(90) });

},{"60":60,"90":90}],194:[function(_dereq_,module,exports){
// 20.2.2.22 Math.log2(x)
var $export = _dereq_(60);

$export($export.S, 'Math', {
  log2: function log2(x) {
    return Math.log(x) / Math.LN2;
  }
});

},{"60":60}],195:[function(_dereq_,module,exports){
// 20.2.2.28 Math.sign(x)
var $export = _dereq_(60);

$export($export.S, 'Math', { sign: _dereq_(91) });

},{"60":60,"91":91}],196:[function(_dereq_,module,exports){
// 20.2.2.30 Math.sinh(x)
var $export = _dereq_(60);
var expm1 = _dereq_(88);
var exp = Math.exp;

// V8 near Chromium 38 has a problem with very small numbers
$export($export.S + $export.F * _dereq_(62)(function () {
  return !Math.sinh(-2e-17) != -2e-17;
}), 'Math', {
  sinh: function sinh(x) {
    return Math.abs(x = +x) < 1
      ? (expm1(x) - expm1(-x)) / 2
      : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
  }
});

},{"60":60,"62":62,"88":88}],197:[function(_dereq_,module,exports){
// 20.2.2.33 Math.tanh(x)
var $export = _dereq_(60);
var expm1 = _dereq_(88);
var exp = Math.exp;

$export($export.S, 'Math', {
  tanh: function tanh(x) {
    var a = expm1(x = +x);
    var b = expm1(-x);
    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
  }
});

},{"60":60,"88":88}],198:[function(_dereq_,module,exports){
// 20.2.2.34 Math.trunc(x)
var $export = _dereq_(60);

$export($export.S, 'Math', {
  trunc: function trunc(it) {
    return (it > 0 ? Math.floor : Math.ceil)(it);
  }
});

},{"60":60}],199:[function(_dereq_,module,exports){
'use strict';
var global = _dereq_(68);
var has = _dereq_(69);
var cof = _dereq_(46);
var inheritIfRequired = _dereq_(73);
var toPrimitive = _dereq_(141);
var fails = _dereq_(62);
var gOPN = _dereq_(101).f;
var gOPD = _dereq_(99).f;
var dP = _dereq_(97).f;
var $trim = _dereq_(132).trim;
var NUMBER = 'Number';
var $Number = global[NUMBER];
var Base = $Number;
var proto = $Number.prototype;
// Opera ~12 has broken Object#toString
var BROKEN_COF = cof(_dereq_(96)(proto)) == NUMBER;
var TRIM = 'trim' in String.prototype;

// 7.1.3 ToNumber(argument)
var toNumber = function (argument) {
  var it = toPrimitive(argument, false);
  if (typeof it == 'string' && it.length > 2) {
    it = TRIM ? it.trim() : $trim(it, 3);
    var first = it.charCodeAt(0);
    var third, radix, maxCode;
    if (first === 43 || first === 45) {
      third = it.charCodeAt(2);
      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if (first === 48) {
      switch (it.charCodeAt(1)) {
        case 66: case 98: radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i
        case 79: case 111: radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i
        default: return +it;
      }
      for (var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++) {
        code = digits.charCodeAt(i);
        // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols
        if (code < 48 || code > maxCode) return NaN;
      } return parseInt(digits, radix);
    }
  } return +it;
};

if (!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')) {
  $Number = function Number(value) {
    var it = arguments.length < 1 ? 0 : value;
    var that = this;
    return that instanceof $Number
      // check on 1..constructor(foo) case
      && (BROKEN_COF ? fails(function () { proto.valueOf.call(that); }) : cof(that) != NUMBER)
        ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
  };
  for (var keys = _dereq_(56) ? gOPN(Base) : (
    // ES3:
    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
    // ES6 (in case, if modules with ES6 Number statics required before):
    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
  ).split(','), j = 0, key; keys.length > j; j++) {
    if (has(Base, key = keys[j]) && !has($Number, key)) {
      dP($Number, key, gOPD(Base, key));
    }
  }
  $Number.prototype = proto;
  proto.constructor = $Number;
  _dereq_(116)(global, NUMBER, $Number);
}

},{"101":101,"116":116,"132":132,"141":141,"46":46,"56":56,"62":62,"68":68,"69":69,"73":73,"96":96,"97":97,"99":99}],200:[function(_dereq_,module,exports){
// 20.1.2.1 Number.EPSILON
var $export = _dereq_(60);

$export($export.S, 'Number', { EPSILON: Math.pow(2, -52) });

},{"60":60}],201:[function(_dereq_,module,exports){
// 20.1.2.2 Number.isFinite(number)
var $export = _dereq_(60);
var _isFinite = _dereq_(68).isFinite;

$export($export.S, 'Number', {
  isFinite: function isFinite(it) {
    return typeof it == 'number' && _isFinite(it);
  }
});

},{"60":60,"68":68}],202:[function(_dereq_,module,exports){
// 20.1.2.3 Number.isInteger(number)
var $export = _dereq_(60);

$export($export.S, 'Number', { isInteger: _dereq_(78) });

},{"60":60,"78":78}],203:[function(_dereq_,module,exports){
// 20.1.2.4 Number.isNaN(number)
var $export = _dereq_(60);

$export($export.S, 'Number', {
  isNaN: function isNaN(number) {
    // eslint-disable-next-line no-self-compare
    return number != number;
  }
});

},{"60":60}],204:[function(_dereq_,module,exports){
// 20.1.2.5 Number.isSafeInteger(number)
var $export = _dereq_(60);
var isInteger = _dereq_(78);
var abs = Math.abs;

$export($export.S, 'Number', {
  isSafeInteger: function isSafeInteger(number) {
    return isInteger(number) && abs(number) <= 0x1fffffffffffff;
  }
});

},{"60":60,"78":78}],205:[function(_dereq_,module,exports){
// 20.1.2.6 Number.MAX_SAFE_INTEGER
var $export = _dereq_(60);

$export($export.S, 'Number', { MAX_SAFE_INTEGER: 0x1fffffffffffff });

},{"60":60}],206:[function(_dereq_,module,exports){
// 20.1.2.10 Number.MIN_SAFE_INTEGER
var $export = _dereq_(60);

$export($export.S, 'Number', { MIN_SAFE_INTEGER: -0x1fffffffffffff });

},{"60":60}],207:[function(_dereq_,module,exports){
var $export = _dereq_(60);
var $parseFloat = _dereq_(110);
// 20.1.2.12 Number.parseFloat(string)
$export($export.S + $export.F * (Number.parseFloat != $parseFloat), 'Number', { parseFloat: $parseFloat });

},{"110":110,"60":60}],208:[function(_dereq_,module,exports){
var $export = _dereq_(60);
var $parseInt = _dereq_(111);
// 20.1.2.13 Number.parseInt(string, radix)
$export($export.S + $export.F * (Number.parseInt != $parseInt), 'Number', { parseInt: $parseInt });

},{"111":111,"60":60}],209:[function(_dereq_,module,exports){
'use strict';
var $export = _dereq_(60);
var toInteger = _dereq_(137);
var aNumberValue = _dereq_(32);
var repeat = _dereq_(131);
var $toFixed = 1.0.toFixed;
var floor = Math.floor;
var data = [0, 0, 0, 0, 0, 0];
var ERROR = 'Number.toFixed: incorrect invocation!';
var ZERO = '0';

var multiply = function (n, c) {
  var i = -1;
  var c2 = c;
  while (++i < 6) {
    c2 += n * data[i];
    data[i] = c2 % 1e7;
    c2 = floor(c2 / 1e7);
  }
};
var divide = function (n) {
  var i = 6;
  var c = 0;
  while (--i >= 0) {
    c += data[i];
    data[i] = floor(c / n);
    c = (c % n) * 1e7;
  }
};
var numToString = function () {
  var i = 6;
  var s = '';
  while (--i >= 0) {
    if (s !== '' || i === 0 || data[i] !== 0) {
      var t = String(data[i]);
      s = s === '' ? t : s + repeat.call(ZERO, 7 - t.length) + t;
    }
  } return s;
};
var pow = function (x, n, acc) {
  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
};
var log = function (x) {
  var n = 0;
  var x2 = x;
  while (x2 >= 4096) {
    n += 12;
    x2 /= 4096;
  }
  while (x2 >= 2) {
    n += 1;
    x2 /= 2;
  } return n;
};

$export($export.P + $export.F * (!!$toFixed && (
  0.00008.toFixed(3) !== '0.000' ||
  0.9.toFixed(0) !== '1' ||
  1.255.toFixed(2) !== '1.25' ||
  1000000000000000128.0.toFixed(0) !== '1000000000000000128'
) || !_dereq_(62)(function () {
  // V8 ~ Android 4.3-
  $toFixed.call({});
})), 'Number', {
  toFixed: function toFixed(fractionDigits) {
    var x = aNumberValue(this, ERROR);
    var f = toInteger(fractionDigits);
    var s = '';
    var m = ZERO;
    var e, z, j, k;
    if (f < 0 || f > 20) throw RangeError(ERROR);
    // eslint-disable-next-line no-self-compare
    if (x != x) return 'NaN';
    if (x <= -1e21 || x >= 1e21) return String(x);
    if (x < 0) {
      s = '-';
      x = -x;
    }
    if (x > 1e-21) {
      e = log(x * pow(2, 69, 1)) - 69;
      z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);
      z *= 0x10000000000000;
      e = 52 - e;
      if (e > 0) {
        multiply(0, z);
        j = f;
        while (j >= 7) {
          multiply(1e7, 0);
          j -= 7;
        }
        multiply(pow(10, j, 1), 0);
        j = e - 1;
        while (j >= 23) {
          divide(1 << 23);
          j -= 23;
        }
        divide(1 << j);
        multiply(1, 1);
        divide(2);
        m = numToString();
      } else {
        multiply(0, z);
        multiply(1 << -e, 0);
        m = numToString() + repeat.call(ZERO, f);
      }
    }
    if (f > 0) {
      k = m.length;
      m = s + (k <= f ? '0.' + repeat.call(ZERO, f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));
    } else {
      m = s + m;
    } return m;
  }
});

},{"131":131,"137":137,"32":32,"60":60,"62":62}],210:[function(_dereq_,module,exports){
'use strict';
var $export = _dereq_(60);
var $fails = _dereq_(62);
var aNumberValue = _dereq_(32);
var $toPrecision = 1.0.toPrecision;

$export($export.P + $export.F * ($fails(function () {
  // IE7-
  return $toPrecision.call(1, undefined) !== '1';
}) || !$fails(function () {
  // V8 ~ Android 4.3-
  $toPrecision.call({});
})), 'Number', {
  toPrecision: function toPrecision(precision) {
    var that = aNumberValue(this, 'Number#toPrecision: incorrect invocation!');
    return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision);
  }
});

},{"32":32,"60":60,"62":62}],211:[function(_dereq_,module,exports){
// 19.1.3.1 Object.assign(target, source)
var $export = _dereq_(60);

$export($export.S + $export.F, 'Object', { assign: _dereq_(95) });

},{"60":60,"95":95}],212:[function(_dereq_,module,exports){
var $export = _dereq_(60);
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
$export($export.S, 'Object', { create: _dereq_(96) });

},{"60":60,"96":96}],213:[function(_dereq_,module,exports){
var $export = _dereq_(60);
// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
$export($export.S + $export.F * !_dereq_(56), 'Object', { defineProperties: _dereq_(98) });

},{"56":56,"60":60,"98":98}],214:[function(_dereq_,module,exports){
var $export = _dereq_(60);
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !_dereq_(56), 'Object', { defineProperty: _dereq_(97).f });

},{"56":56,"60":60,"97":97}],215:[function(_dereq_,module,exports){
// 19.1.2.5 Object.freeze(O)
var isObject = _dereq_(79);
var meta = _dereq_(92).onFreeze;

_dereq_(107)('freeze', function ($freeze) {
  return function freeze(it) {
    return $freeze && isObject(it) ? $freeze(meta(it)) : it;
  };
});

},{"107":107,"79":79,"92":92}],216:[function(_dereq_,module,exports){
// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
var toIObject = _dereq_(138);
var $getOwnPropertyDescriptor = _dereq_(99).f;

_dereq_(107)('getOwnPropertyDescriptor', function () {
  return function getOwnPropertyDescriptor(it, key) {
    return $getOwnPropertyDescriptor(toIObject(it), key);
  };
});

},{"107":107,"138":138,"99":99}],217:[function(_dereq_,module,exports){
// 19.1.2.7 Object.getOwnPropertyNames(O)
_dereq_(107)('getOwnPropertyNames', function () {
  return _dereq_(100).f;
});

},{"100":100,"107":107}],218:[function(_dereq_,module,exports){
// 19.1.2.9 Object.getPrototypeOf(O)
var toObject = _dereq_(140);
var $getPrototypeOf = _dereq_(103);

_dereq_(107)('getPrototypeOf', function () {
  return function getPrototypeOf(it) {
    return $getPrototypeOf(toObject(it));
  };
});

},{"103":103,"107":107,"140":140}],219:[function(_dereq_,module,exports){
// 19.1.2.11 Object.isExtensible(O)
var isObject = _dereq_(79);

_dereq_(107)('isExtensible', function ($isExtensible) {
  return function isExtensible(it) {
    return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
  };
});

},{"107":107,"79":79}],220:[function(_dereq_,module,exports){
// 19.1.2.12 Object.isFrozen(O)
var isObject = _dereq_(79);

_dereq_(107)('isFrozen', function ($isFrozen) {
  return function isFrozen(it) {
    return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
  };
});

},{"107":107,"79":79}],221:[function(_dereq_,module,exports){
// 19.1.2.13 Object.isSealed(O)
var isObject = _dereq_(79);

_dereq_(107)('isSealed', function ($isSealed) {
  return function isSealed(it) {
    return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
  };
});

},{"107":107,"79":79}],222:[function(_dereq_,module,exports){
// 19.1.3.10 Object.is(value1, value2)
var $export = _dereq_(60);
$export($export.S, 'Object', { is: _dereq_(119) });

},{"119":119,"60":60}],223:[function(_dereq_,module,exports){
// 19.1.2.14 Object.keys(O)
var toObject = _dereq_(140);
var $keys = _dereq_(105);

_dereq_(107)('keys', function () {
  return function keys(it) {
    return $keys(toObject(it));
  };
});

},{"105":105,"107":107,"140":140}],224:[function(_dereq_,module,exports){
// 19.1.2.15 Object.preventExtensions(O)
var isObject = _dereq_(79);
var meta = _dereq_(92).onFreeze;

_dereq_(107)('preventExtensions', function ($preventExtensions) {
  return function preventExtensions(it) {
    return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it;
  };
});

},{"107":107,"79":79,"92":92}],225:[function(_dereq_,module,exports){
// 19.1.2.17 Object.seal(O)
var isObject = _dereq_(79);
var meta = _dereq_(92).onFreeze;

_dereq_(107)('seal', function ($seal) {
  return function seal(it) {
    return $seal && isObject(it) ? $seal(meta(it)) : it;
  };
});

},{"107":107,"79":79,"92":92}],226:[function(_dereq_,module,exports){
// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = _dereq_(60);
$export($export.S, 'Object', { setPrototypeOf: _dereq_(120).set });

},{"120":120,"60":60}],227:[function(_dereq_,module,exports){
'use strict';
// 19.1.3.6 Object.prototype.toString()
var classof = _dereq_(45);
var test = {};
test[_dereq_(150)('toStringTag')] = 'z';
if (test + '' != '[object z]') {
  _dereq_(116)(Object.prototype, 'toString', function toString() {
    return '[object ' + classof(this) + ']';
  }, true);
}

},{"116":116,"150":150,"45":45}],228:[function(_dereq_,module,exports){
var $export = _dereq_(60);
var $parseFloat = _dereq_(110);
// 18.2.4 parseFloat(string)
$export($export.G + $export.F * (parseFloat != $parseFloat), { parseFloat: $parseFloat });

},{"110":110,"60":60}],229:[function(_dereq_,module,exports){
var $export = _dereq_(60);
var $parseInt = _dereq_(111);
// 18.2.5 parseInt(string, radix)
$export($export.G + $export.F * (parseInt != $parseInt), { parseInt: $parseInt });

},{"111":111,"60":60}],230:[function(_dereq_,module,exports){
'use strict';
var LIBRARY = _dereq_(87);
var global = _dereq_(68);
var ctx = _dereq_(52);
var classof = _dereq_(45);
var $export = _dereq_(60);
var isObject = _dereq_(79);
var aFunction = _dereq_(31);
var anInstance = _dereq_(35);
var forOf = _dereq_(66);
var speciesConstructor = _dereq_(125);
var task = _dereq_(134).set;
var microtask = _dereq_(93)();
var newPromiseCapabilityModule = _dereq_(94);
var perform = _dereq_(112);
var userAgent = _dereq_(146);
var promiseResolve = _dereq_(113);
var PROMISE = 'Promise';
var TypeError = global.TypeError;
var process = global.process;
var versions = process && process.versions;
var v8 = versions && versions.v8 || '';
var $Promise = global[PROMISE];
var isNode = classof(process) == 'process';
var empty = function () { /* empty */ };
var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;

var USE_NATIVE = !!function () {
  try {
    // correct subclassing with @@species support
    var promise = $Promise.resolve(1);
    var FakePromise = (promise.constructor = {})[_dereq_(150)('species')] = function (exec) {
      exec(empty, empty);
    };
    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return (isNode || typeof PromiseRejectionEvent == 'function')
      && promise.then(empty) instanceof FakePromise
      // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
      // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
      // we can't detect it synchronously, so just check versions
      && v8.indexOf('6.6') !== 0
      && userAgent.indexOf('Chrome/66') === -1;
  } catch (e) { /* empty */ }
}();

// helpers
var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var notify = function (promise, isReject) {
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () {
    var value = promise._v;
    var ok = promise._s == 1;
    var i = 0;
    var run = function (reaction) {
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;
      try {
        if (handler) {
          if (!ok) {
            if (promise._h == 2) onHandleUnhandled(promise);
            promise._h = 1;
          }
          if (handler === true) result = value;
          else {
            if (domain) domain.enter();
            result = handler(value); // may throw
            if (domain) {
              domain.exit();
              exited = true;
            }
          }
          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (e) {
        if (domain && !exited) domain.exit();
        reject(e);
      }
    };
    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
    promise._c = [];
    promise._n = false;
    if (isReject && !promise._h) onUnhandled(promise);
  });
};
var onUnhandled = function (promise) {
  task.call(global, function () {
    var value = promise._v;
    var unhandled = isUnhandled(promise);
    var result, handler, console;
    if (unhandled) {
      result = perform(function () {
        if (isNode) {
          process.emit('unhandledRejection', value, promise);
        } else if (handler = global.onunhandledrejection) {
          handler({ promise: promise, reason: value });
        } else if ((console = global.console) && console.error) {
          console.error('Unhandled promise rejection', value);
        }
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    } promise._a = undefined;
    if (unhandled && result.e) throw result.v;
  });
};
var isUnhandled = function (promise) {
  return promise._h !== 1 && (promise._a || promise._c).length === 0;
};
var onHandleUnhandled = function (promise) {
  task.call(global, function () {
    var handler;
    if (isNode) {
      process.emit('rejectionHandled', promise);
    } else if (handler = global.onrejectionhandled) {
      handler({ promise: promise, reason: promise._v });
    }
  });
};
var $reject = function (value) {
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
};
var $resolve = function (value) {
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");
    if (then = isThenable(value)) {
      microtask(function () {
        var wrapper = { _w: promise, _d: false }; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch (e) {
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch (e) {
    $reject.call({ _w: promise, _d: false }, e); // wrap
  }
};

// constructor polyfill
if (!USE_NATIVE) {
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor) {
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);
    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch (err) {
      $reject.call(this, err);
    }
  };
  // eslint-disable-next-line no-unused-vars
  Internal = function Promise(executor) {
    this._c = [];             // <- awaiting reactions
    this._a = undefined;      // <- checked in isUnhandled reactions
    this._s = 0;              // <- state
    this._d = false;          // <- done
    this._v = undefined;      // <- value
    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
    this._n = false;          // <- notify
  };
  Internal.prototype = _dereq_(115)($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected) {
      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;
      this._c.push(reaction);
      if (this._a) this._a.push(reaction);
      if (this._s) notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject = ctx($reject, promise, 1);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === $Promise || C === Wrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
_dereq_(122)($Promise, PROMISE);
_dereq_(121)(PROMISE);
Wrapper = _dereq_(50)[PROMISE];

// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    var $$reject = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x) {
    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
  }
});
$export($export.S + $export.F * !(USE_NATIVE && _dereq_(84)(function (iter) {
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var values = [];
      var index = 0;
      var remaining = 1;
      forOf(iterable, false, function (promise) {
        var $index = index++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.e) reject(result.v);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      forOf(iterable, false, function (promise) {
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if (result.e) reject(result.v);
    return capability.promise;
  }
});

},{"112":112,"113":113,"115":115,"121":121,"122":122,"125":125,"134":134,"146":146,"150":150,"31":31,"35":35,"45":45,"50":50,"52":52,"60":60,"66":66,"68":68,"79":79,"84":84,"87":87,"93":93,"94":94}],231:[function(_dereq_,module,exports){
// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
var $export = _dereq_(60);
var aFunction = _dereq_(31);
var anObject = _dereq_(36);
var rApply = (_dereq_(68).Reflect || {}).apply;
var fApply = Function.apply;
// MS Edge argumentsList argument is optional
$export($export.S + $export.F * !_dereq_(62)(function () {
  rApply(function () { /* empty */ });
}), 'Reflect', {
  apply: function apply(target, thisArgument, argumentsList) {
    var T = aFunction(target);
    var L = anObject(argumentsList);
    return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);
  }
});

},{"31":31,"36":36,"60":60,"62":62,"68":68}],232:[function(_dereq_,module,exports){
// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
var $export = _dereq_(60);
var create = _dereq_(96);
var aFunction = _dereq_(31);
var anObject = _dereq_(36);
var isObject = _dereq_(79);
var fails = _dereq_(62);
var bind = _dereq_(44);
var rConstruct = (_dereq_(68).Reflect || {}).construct;

// MS Edge supports only 2 arguments and argumentsList argument is optional
// FF Nightly sets third argument as `new.target`, but does not create `this` from it
var NEW_TARGET_BUG = fails(function () {
  function F() { /* empty */ }
  return !(rConstruct(function () { /* empty */ }, [], F) instanceof F);
});
var ARGS_BUG = !fails(function () {
  rConstruct(function () { /* empty */ });
});

$export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
  construct: function construct(Target, args /* , newTarget */) {
    aFunction(Target);
    anObject(args);
    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
    if (ARGS_BUG && !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget);
    if (Target == newTarget) {
      // w/o altered newTarget, optimization for 0-4 arguments
      switch (args.length) {
        case 0: return new Target();
        case 1: return new Target(args[0]);
        case 2: return new Target(args[0], args[1]);
        case 3: return new Target(args[0], args[1], args[2]);
        case 4: return new Target(args[0], args[1], args[2], args[3]);
      }
      // w/o altered newTarget, lot of arguments case
      var $args = [null];
      $args.push.apply($args, args);
      return new (bind.apply(Target, $args))();
    }
    // with altered newTarget, not support built-in constructors
    var proto = newTarget.prototype;
    var instance = create(isObject(proto) ? proto : Object.prototype);
    var result = Function.apply.call(Target, instance, args);
    return isObject(result) ? result : instance;
  }
});

},{"31":31,"36":36,"44":44,"60":60,"62":62,"68":68,"79":79,"96":96}],233:[function(_dereq_,module,exports){
// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
var dP = _dereq_(97);
var $export = _dereq_(60);
var anObject = _dereq_(36);
var toPrimitive = _dereq_(141);

// MS Edge has broken Reflect.defineProperty - throwing instead of returning false
$export($export.S + $export.F * _dereq_(62)(function () {
  // eslint-disable-next-line no-undef
  Reflect.defineProperty(dP.f({}, 1, { value: 1 }), 1, { value: 2 });
}), 'Reflect', {
  defineProperty: function defineProperty(target, propertyKey, attributes) {
    anObject(target);
    propertyKey = toPrimitive(propertyKey, true);
    anObject(attributes);
    try {
      dP.f(target, propertyKey, attributes);
      return true;
    } catch (e) {
      return false;
    }
  }
});

},{"141":141,"36":36,"60":60,"62":62,"97":97}],234:[function(_dereq_,module,exports){
// 26.1.4 Reflect.deleteProperty(target, propertyKey)
var $export = _dereq_(60);
var gOPD = _dereq_(99).f;
var anObject = _dereq_(36);

$export($export.S, 'Reflect', {
  deleteProperty: function deleteProperty(target, propertyKey) {
    var desc = gOPD(anObject(target), propertyKey);
    return desc && !desc.configurable ? false : delete target[propertyKey];
  }
});

},{"36":36,"60":60,"99":99}],235:[function(_dereq_,module,exports){
'use strict';
// 26.1.5 Reflect.enumerate(target)
var $export = _dereq_(60);
var anObject = _dereq_(36);
var Enumerate = function (iterated) {
  this._t = anObject(iterated); // target
  this._i = 0;                  // next index
  var keys = this._k = [];      // keys
  var key;
  for (key in iterated) keys.push(key);
};
_dereq_(82)(Enumerate, 'Object', function () {
  var that = this;
  var keys = that._k;
  var key;
  do {
    if (that._i >= keys.length) return { value: undefined, done: true };
  } while (!((key = keys[that._i++]) in that._t));
  return { value: key, done: false };
});

$export($export.S, 'Reflect', {
  enumerate: function enumerate(target) {
    return new Enumerate(target);
  }
});

},{"36":36,"60":60,"82":82}],236:[function(_dereq_,module,exports){
// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
var gOPD = _dereq_(99);
var $export = _dereq_(60);
var anObject = _dereq_(36);

$export($export.S, 'Reflect', {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
    return gOPD.f(anObject(target), propertyKey);
  }
});

},{"36":36,"60":60,"99":99}],237:[function(_dereq_,module,exports){
// 26.1.8 Reflect.getPrototypeOf(target)
var $export = _dereq_(60);
var getProto = _dereq_(103);
var anObject = _dereq_(36);

$export($export.S, 'Reflect', {
  getPrototypeOf: function getPrototypeOf(target) {
    return getProto(anObject(target));
  }
});

},{"103":103,"36":36,"60":60}],238:[function(_dereq_,module,exports){
// 26.1.6 Reflect.get(target, propertyKey [, receiver])
var gOPD = _dereq_(99);
var getPrototypeOf = _dereq_(103);
var has = _dereq_(69);
var $export = _dereq_(60);
var isObject = _dereq_(79);
var anObject = _dereq_(36);

function get(target, propertyKey /* , receiver */) {
  var receiver = arguments.length < 3 ? target : arguments[2];
  var desc, proto;
  if (anObject(target) === receiver) return target[propertyKey];
  if (desc = gOPD.f(target, propertyKey)) return has(desc, 'value')
    ? desc.value
    : desc.get !== undefined
      ? desc.get.call(receiver)
      : undefined;
  if (isObject(proto = getPrototypeOf(target))) return get(proto, propertyKey, receiver);
}

$export($export.S, 'Reflect', { get: get });

},{"103":103,"36":36,"60":60,"69":69,"79":79,"99":99}],239:[function(_dereq_,module,exports){
// 26.1.9 Reflect.has(target, propertyKey)
var $export = _dereq_(60);

$export($export.S, 'Reflect', {
  has: function has(target, propertyKey) {
    return propertyKey in target;
  }
});

},{"60":60}],240:[function(_dereq_,module,exports){
// 26.1.10 Reflect.isExtensible(target)
var $export = _dereq_(60);
var anObject = _dereq_(36);
var $isExtensible = Object.isExtensible;

$export($export.S, 'Reflect', {
  isExtensible: function isExtensible(target) {
    anObject(target);
    return $isExtensible ? $isExtensible(target) : true;
  }
});

},{"36":36,"60":60}],241:[function(_dereq_,module,exports){
// 26.1.11 Reflect.ownKeys(target)
var $export = _dereq_(60);

$export($export.S, 'Reflect', { ownKeys: _dereq_(109) });

},{"109":109,"60":60}],242:[function(_dereq_,module,exports){
// 26.1.12 Reflect.preventExtensions(target)
var $export = _dereq_(60);
var anObject = _dereq_(36);
var $preventExtensions = Object.preventExtensions;

$export($export.S, 'Reflect', {
  preventExtensions: function preventExtensions(target) {
    anObject(target);
    try {
      if ($preventExtensions) $preventExtensions(target);
      return true;
    } catch (e) {
      return false;
    }
  }
});

},{"36":36,"60":60}],243:[function(_dereq_,module,exports){
// 26.1.14 Reflect.setPrototypeOf(target, proto)
var $export = _dereq_(60);
var setProto = _dereq_(120);

if (setProto) $export($export.S, 'Reflect', {
  setPrototypeOf: function setPrototypeOf(target, proto) {
    setProto.check(target, proto);
    try {
      setProto.set(target, proto);
      return true;
    } catch (e) {
      return false;
    }
  }
});

},{"120":120,"60":60}],244:[function(_dereq_,module,exports){
// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
var dP = _dereq_(97);
var gOPD = _dereq_(99);
var getPrototypeOf = _dereq_(103);
var has = _dereq_(69);
var $export = _dereq_(60);
var createDesc = _dereq_(114);
var anObject = _dereq_(36);
var isObject = _dereq_(79);

function set(target, propertyKey, V /* , receiver */) {
  var receiver = arguments.length < 4 ? target : arguments[3];
  var ownDesc = gOPD.f(anObject(target), propertyKey);
  var existingDescriptor, proto;
  if (!ownDesc) {
    if (isObject(proto = getPrototypeOf(target))) {
      return set(proto, propertyKey, V, receiver);
    }
    ownDesc = createDesc(0);
  }
  if (has(ownDesc, 'value')) {
    if (ownDesc.writable === false || !isObject(receiver)) return false;
    if (existingDescriptor = gOPD.f(receiver, propertyKey)) {
      if (existingDescriptor.get || existingDescriptor.set || existingDescriptor.writable === false) return false;
      existingDescriptor.value = V;
      dP.f(receiver, propertyKey, existingDescriptor);
    } else dP.f(receiver, propertyKey, createDesc(0, V));
    return true;
  }
  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
}

$export($export.S, 'Reflect', { set: set });

},{"103":103,"114":114,"36":36,"60":60,"69":69,"79":79,"97":97,"99":99}],245:[function(_dereq_,module,exports){
var global = _dereq_(68);
var inheritIfRequired = _dereq_(73);
var dP = _dereq_(97).f;
var gOPN = _dereq_(101).f;
var isRegExp = _dereq_(80);
var $flags = _dereq_(64);
var $RegExp = global.RegExp;
var Base = $RegExp;
var proto = $RegExp.prototype;
var re1 = /a/g;
var re2 = /a/g;
// "new" creates a new object, old webkit buggy here
var CORRECT_NEW = new $RegExp(re1) !== re1;

if (_dereq_(56) && (!CORRECT_NEW || _dereq_(62)(function () {
  re2[_dereq_(150)('match')] = false;
  // RegExp constructor can alter flags and IsRegExp works correct with @@match
  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
}))) {
  $RegExp = function RegExp(p, f) {
    var tiRE = this instanceof $RegExp;
    var piRE = isRegExp(p);
    var fiU = f === undefined;
    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p
      : inheritIfRequired(CORRECT_NEW
        ? new Base(piRE && !fiU ? p.source : p, f)
        : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f)
      , tiRE ? this : proto, $RegExp);
  };
  var proxy = function (key) {
    key in $RegExp || dP($RegExp, key, {
      configurable: true,
      get: function () { return Base[key]; },
      set: function (it) { Base[key] = it; }
    });
  };
  for (var keys = gOPN(Base), i = 0; keys.length > i;) proxy(keys[i++]);
  proto.constructor = $RegExp;
  $RegExp.prototype = proto;
  _dereq_(116)(global, 'RegExp', $RegExp);
}

_dereq_(121)('RegExp');

},{"101":101,"116":116,"121":121,"150":150,"56":56,"62":62,"64":64,"68":68,"73":73,"80":80,"97":97}],246:[function(_dereq_,module,exports){
'use strict';
var regexpExec = _dereq_(118);
_dereq_(60)({
  target: 'RegExp',
  proto: true,
  forced: regexpExec !== /./.exec
}, {
  exec: regexpExec
});

},{"118":118,"60":60}],247:[function(_dereq_,module,exports){
// 21.2.5.3 get RegExp.prototype.flags()
if (_dereq_(56) && /./g.flags != 'g') _dereq_(97).f(RegExp.prototype, 'flags', {
  configurable: true,
  get: _dereq_(64)
});

},{"56":56,"64":64,"97":97}],248:[function(_dereq_,module,exports){
'use strict';

var anObject = _dereq_(36);
var toLength = _dereq_(139);
var advanceStringIndex = _dereq_(34);
var regExpExec = _dereq_(117);

// @@match logic
_dereq_(63)('match', 1, function (defined, MATCH, $match, maybeCallNative) {
  return [
    // `String.prototype.match` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.match
    function match(regexp) {
      var O = defined(this);
      var fn = regexp == undefined ? undefined : regexp[MATCH];
      return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
    },
    // `RegExp.prototype[@@match]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match
    function (regexp) {
      var res = maybeCallNative($match, regexp, this);
      if (res.done) return res.value;
      var rx = anObject(regexp);
      var S = String(this);
      if (!rx.global) return regExpExec(rx, S);
      var fullUnicode = rx.unicode;
      rx.lastIndex = 0;
      var A = [];
      var n = 0;
      var result;
      while ((result = regExpExec(rx, S)) !== null) {
        var matchStr = String(result[0]);
        A[n] = matchStr;
        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
        n++;
      }
      return n === 0 ? null : A;
    }
  ];
});

},{"117":117,"139":139,"34":34,"36":36,"63":63}],249:[function(_dereq_,module,exports){
'use strict';

var anObject = _dereq_(36);
var toObject = _dereq_(140);
var toLength = _dereq_(139);
var toInteger = _dereq_(137);
var advanceStringIndex = _dereq_(34);
var regExpExec = _dereq_(117);
var max = Math.max;
var min = Math.min;
var floor = Math.floor;
var SUBSTITUTION_SYMBOLS = /\$([$&`']|\d\d?|<[^>]*>)/g;
var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&`']|\d\d?)/g;

var maybeToString = function (it) {
  return it === undefined ? it : String(it);
};

// @@replace logic
_dereq_(63)('replace', 2, function (defined, REPLACE, $replace, maybeCallNative) {
  return [
    // `String.prototype.replace` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.replace
    function replace(searchValue, replaceValue) {
      var O = defined(this);
      var fn = searchValue == undefined ? undefined : searchValue[REPLACE];
      return fn !== undefined
        ? fn.call(searchValue, O, replaceValue)
        : $replace.call(String(O), searchValue, replaceValue);
    },
    // `RegExp.prototype[@@replace]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
    function (regexp, replaceValue) {
      var res = maybeCallNative($replace, regexp, this, replaceValue);
      if (res.done) return res.value;

      var rx = anObject(regexp);
      var S = String(this);
      var functionalReplace = typeof replaceValue === 'function';
      if (!functionalReplace) replaceValue = String(replaceValue);
      var global = rx.global;
      if (global) {
        var fullUnicode = rx.unicode;
        rx.lastIndex = 0;
      }
      var results = [];
      while (true) {
        var result = regExpExec(rx, S);
        if (result === null) break;
        results.push(result);
        if (!global) break;
        var matchStr = String(result[0]);
        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
      }
      var accumulatedResult = '';
      var nextSourcePosition = 0;
      for (var i = 0; i < results.length; i++) {
        result = results[i];
        var matched = String(result[0]);
        var position = max(min(toInteger(result.index), S.length), 0);
        var captures = [];
        // NOTE: This is equivalent to
        //   captures = result.slice(1).map(maybeToString)
        // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
        // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
        // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
        for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j]));
        var namedCaptures = result.groups;
        if (functionalReplace) {
          var replacerArgs = [matched].concat(captures, position, S);
          if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
          var replacement = String(replaceValue.apply(undefined, replacerArgs));
        } else {
          replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
        }
        if (position >= nextSourcePosition) {
          accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
          nextSourcePosition = position + matched.length;
        }
      }
      return accumulatedResult + S.slice(nextSourcePosition);
    }
  ];

    // https://tc39.github.io/ecma262/#sec-getsubstitution
  function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
    var tailPos = position + matched.length;
    var m = captures.length;
    var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
    if (namedCaptures !== undefined) {
      namedCaptures = toObject(namedCaptures);
      symbols = SUBSTITUTION_SYMBOLS;
    }
    return $replace.call(replacement, symbols, function (match, ch) {
      var capture;
      switch (ch.charAt(0)) {
        case '$': return '$';
        case '&': return matched;
        case '`': return str.slice(0, position);
        case "'": return str.slice(tailPos);
        case '<':
          capture = namedCaptures[ch.slice(1, -1)];
          break;
        default: // \d\d?
          var n = +ch;
          if (n === 0) return match;
          if (n > m) {
            var f = floor(n / 10);
            if (f === 0) return match;
            if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
            return match;
          }
          capture = captures[n - 1];
      }
      return capture === undefined ? '' : capture;
    });
  }
});

},{"117":117,"137":137,"139":139,"140":140,"34":34,"36":36,"63":63}],250:[function(_dereq_,module,exports){
'use strict';

var anObject = _dereq_(36);
var sameValue = _dereq_(119);
var regExpExec = _dereq_(117);

// @@search logic
_dereq_(63)('search', 1, function (defined, SEARCH, $search, maybeCallNative) {
  return [
    // `String.prototype.search` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.search
    function search(regexp) {
      var O = defined(this);
      var fn = regexp == undefined ? undefined : regexp[SEARCH];
      return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
    },
    // `RegExp.prototype[@@search]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@search
    function (regexp) {
      var res = maybeCallNative($search, regexp, this);
      if (res.done) return res.value;
      var rx = anObject(regexp);
      var S = String(this);
      var previousLastIndex = rx.lastIndex;
      if (!sameValue(previousLastIndex, 0)) rx.lastIndex = 0;
      var result = regExpExec(rx, S);
      if (!sameValue(rx.lastIndex, previousLastIndex)) rx.lastIndex = previousLastIndex;
      return result === null ? -1 : result.index;
    }
  ];
});

},{"117":117,"119":119,"36":36,"63":63}],251:[function(_dereq_,module,exports){
'use strict';

var isRegExp = _dereq_(80);
var anObject = _dereq_(36);
var speciesConstructor = _dereq_(125);
var advanceStringIndex = _dereq_(34);
var toLength = _dereq_(139);
var callRegExpExec = _dereq_(117);
var regexpExec = _dereq_(118);
var fails = _dereq_(62);
var $min = Math.min;
var $push = [].push;
var $SPLIT = 'split';
var LENGTH = 'length';
var LAST_INDEX = 'lastIndex';
var MAX_UINT32 = 0xffffffff;

// babel-minify transpiles RegExp('x', 'y') -> /x/y and it causes SyntaxError
var SUPPORTS_Y = !fails(function () { RegExp(MAX_UINT32, 'y'); });

// @@split logic
_dereq_(63)('split', 2, function (defined, SPLIT, $split, maybeCallNative) {
  var internalSplit;
  if (
    'abbc'[$SPLIT](/(b)*/)[1] == 'c' ||
    'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||
    'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||
    '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||
    '.'[$SPLIT](/()()/)[LENGTH] > 1 ||
    ''[$SPLIT](/.?/)[LENGTH]
  ) {
    // based on es5-shim implementation, need to rework it
    internalSplit = function (separator, limit) {
      var string = String(this);
      if (separator === undefined && limit === 0) return [];
      // If `separator` is not a regex, use native split
      if (!isRegExp(separator)) return $split.call(string, separator, limit);
      var output = [];
      var flags = (separator.ignoreCase ? 'i' : '') +
                  (separator.multiline ? 'm' : '') +
                  (separator.unicode ? 'u' : '') +
                  (separator.sticky ? 'y' : '');
      var lastLastIndex = 0;
      var splitLimit = limit === undefined ? MAX_UINT32 : limit >>> 0;
      // Make `global` and avoid `lastIndex` issues by working with a copy
      var separatorCopy = new RegExp(separator.source, flags + 'g');
      var match, lastIndex, lastLength;
      while (match = regexpExec.call(separatorCopy, string)) {
        lastIndex = separatorCopy[LAST_INDEX];
        if (lastIndex > lastLastIndex) {
          output.push(string.slice(lastLastIndex, match.index));
          if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));
          lastLength = match[0][LENGTH];
          lastLastIndex = lastIndex;
          if (output[LENGTH] >= splitLimit) break;
        }
        if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
      }
      if (lastLastIndex === string[LENGTH]) {
        if (lastLength || !separatorCopy.test('')) output.push('');
      } else output.push(string.slice(lastLastIndex));
      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
    };
  // Chakra, V8
  } else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {
    internalSplit = function (separator, limit) {
      return separator === undefined && limit === 0 ? [] : $split.call(this, separator, limit);
    };
  } else {
    internalSplit = $split;
  }

  return [
    // `String.prototype.split` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.split
    function split(separator, limit) {
      var O = defined(this);
      var splitter = separator == undefined ? undefined : separator[SPLIT];
      return splitter !== undefined
        ? splitter.call(separator, O, limit)
        : internalSplit.call(String(O), separator, limit);
    },
    // `RegExp.prototype[@@split]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@split
    //
    // NOTE: This cannot be properly polyfilled in engines that don't support
    // the 'y' flag.
    function (regexp, limit) {
      var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== $split);
      if (res.done) return res.value;

      var rx = anObject(regexp);
      var S = String(this);
      var C = speciesConstructor(rx, RegExp);

      var unicodeMatching = rx.unicode;
      var flags = (rx.ignoreCase ? 'i' : '') +
                  (rx.multiline ? 'm' : '') +
                  (rx.unicode ? 'u' : '') +
                  (SUPPORTS_Y ? 'y' : 'g');

      // ^(? + rx + ) is needed, in combination with some S slicing, to
      // simulate the 'y' flag.
      var splitter = new C(SUPPORTS_Y ? rx : '^(?:' + rx.source + ')', flags);
      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
      if (lim === 0) return [];
      if (S.length === 0) return callRegExpExec(splitter, S) === null ? [S] : [];
      var p = 0;
      var q = 0;
      var A = [];
      while (q < S.length) {
        splitter.lastIndex = SUPPORTS_Y ? q : 0;
        var z = callRegExpExec(splitter, SUPPORTS_Y ? S : S.slice(q));
        var e;
        if (
          z === null ||
          (e = $min(toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p
        ) {
          q = advanceStringIndex(S, q, unicodeMatching);
        } else {
          A.push(S.slice(p, q));
          if (A.length === lim) return A;
          for (var i = 1; i <= z.length - 1; i++) {
            A.push(z[i]);
            if (A.length === lim) return A;
          }
          q = p = e;
        }
      }
      A.push(S.slice(p));
      return A;
    }
  ];
});

},{"117":117,"118":118,"125":125,"139":139,"34":34,"36":36,"62":62,"63":63,"80":80}],252:[function(_dereq_,module,exports){
'use strict';
_dereq_(247);
var anObject = _dereq_(36);
var $flags = _dereq_(64);
var DESCRIPTORS = _dereq_(56);
var TO_STRING = 'toString';
var $toString = /./[TO_STRING];

var define = function (fn) {
  _dereq_(116)(RegExp.prototype, TO_STRING, fn, true);
};

// 21.2.5.14 RegExp.prototype.toString()
if (_dereq_(62)(function () { return $toString.call({ source: 'a', flags: 'b' }) != '/a/b'; })) {
  define(function toString() {
    var R = anObject(this);
    return '/'.concat(R.source, '/',
      'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);
  });
// FF44- RegExp#toString has a wrong name
} else if ($toString.name != TO_STRING) {
  define(function toString() {
    return $toString.call(this);
  });
}

},{"116":116,"247":247,"36":36,"56":56,"62":62,"64":64}],253:[function(_dereq_,module,exports){
'use strict';
var strong = _dereq_(47);
var validate = _dereq_(147);
var SET = 'Set';

// 23.2 Set Objects
module.exports = _dereq_(49)(SET, function (get) {
  return function Set() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value) {
    return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value);
  }
}, strong);

},{"147":147,"47":47,"49":49}],254:[function(_dereq_,module,exports){
'use strict';
// B.2.3.2 String.prototype.anchor(name)
_dereq_(129)('anchor', function (createHTML) {
  return function anchor(name) {
    return createHTML(this, 'a', 'name', name);
  };
});

},{"129":129}],255:[function(_dereq_,module,exports){
'use strict';
// B.2.3.3 String.prototype.big()
_dereq_(129)('big', function (createHTML) {
  return function big() {
    return createHTML(this, 'big', '', '');
  };
});

},{"129":129}],256:[function(_dereq_,module,exports){
'use strict';
// B.2.3.4 String.prototype.blink()
_dereq_(129)('blink', function (createHTML) {
  return function blink() {
    return createHTML(this, 'blink', '', '');
  };
});

},{"129":129}],257:[function(_dereq_,module,exports){
'use strict';
// B.2.3.5 String.prototype.bold()
_dereq_(129)('bold', function (createHTML) {
  return function bold() {
    return createHTML(this, 'b', '', '');
  };
});

},{"129":129}],258:[function(_dereq_,module,exports){
'use strict';
var $export = _dereq_(60);
var $at = _dereq_(127)(false);
$export($export.P, 'String', {
  // 21.1.3.3 String.prototype.codePointAt(pos)
  codePointAt: function codePointAt(pos) {
    return $at(this, pos);
  }
});

},{"127":127,"60":60}],259:[function(_dereq_,module,exports){
// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])
'use strict';
var $export = _dereq_(60);
var toLength = _dereq_(139);
var context = _dereq_(128);
var ENDS_WITH = 'endsWith';
var $endsWith = ''[ENDS_WITH];

$export($export.P + $export.F * _dereq_(61)(ENDS_WITH), 'String', {
  endsWith: function endsWith(searchString /* , endPosition = @length */) {
    var that = context(this, searchString, ENDS_WITH);
    var endPosition = arguments.length > 1 ? arguments[1] : undefined;
    var len = toLength(that.length);
    var end = endPosition === undefined ? len : Math.min(toLength(endPosition), len);
    var search = String(searchString);
    return $endsWith
      ? $endsWith.call(that, search, end)
      : that.slice(end - search.length, end) === search;
  }
});

},{"128":128,"139":139,"60":60,"61":61}],260:[function(_dereq_,module,exports){
'use strict';
// B.2.3.6 String.prototype.fixed()
_dereq_(129)('fixed', function (createHTML) {
  return function fixed() {
    return createHTML(this, 'tt', '', '');
  };
});

},{"129":129}],261:[function(_dereq_,module,exports){
'use strict';
// B.2.3.7 String.prototype.fontcolor(color)
_dereq_(129)('fontcolor', function (createHTML) {
  return function fontcolor(color) {
    return createHTML(this, 'font', 'color', color);
  };
});

},{"129":129}],262:[function(_dereq_,module,exports){
'use strict';
// B.2.3.8 String.prototype.fontsize(size)
_dereq_(129)('fontsize', function (createHTML) {
  return function fontsize(size) {
    return createHTML(this, 'font', 'size', size);
  };
});

},{"129":129}],263:[function(_dereq_,module,exports){
var $export = _dereq_(60);
var toAbsoluteIndex = _dereq_(135);
var fromCharCode = String.fromCharCode;
var $fromCodePoint = String.fromCodePoint;

// length should be 1, old FF problem
$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
  // 21.1.2.2 String.fromCodePoint(...codePoints)
  fromCodePoint: function fromCodePoint(x) { // eslint-disable-line no-unused-vars
    var res = [];
    var aLen = arguments.length;
    var i = 0;
    var code;
    while (aLen > i) {
      code = +arguments[i++];
      if (toAbsoluteIndex(code, 0x10ffff) !== code) throw RangeError(code + ' is not a valid code point');
      res.push(code < 0x10000
        ? fromCharCode(code)
        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
      );
    } return res.join('');
  }
});

},{"135":135,"60":60}],264:[function(_dereq_,module,exports){
// 21.1.3.7 String.prototype.includes(searchString, position = 0)
'use strict';
var $export = _dereq_(60);
var context = _dereq_(128);
var INCLUDES = 'includes';

$export($export.P + $export.F * _dereq_(61)(INCLUDES), 'String', {
  includes: function includes(searchString /* , position = 0 */) {
    return !!~context(this, searchString, INCLUDES)
      .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
  }
});

},{"128":128,"60":60,"61":61}],265:[function(_dereq_,module,exports){
'use strict';
// B.2.3.9 String.prototype.italics()
_dereq_(129)('italics', function (createHTML) {
  return function italics() {
    return createHTML(this, 'i', '', '');
  };
});

},{"129":129}],266:[function(_dereq_,module,exports){
'use strict';
var $at = _dereq_(127)(true);

// 21.1.3.27 String.prototype[@@iterator]()
_dereq_(83)(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});

},{"127":127,"83":83}],267:[function(_dereq_,module,exports){
'use strict';
// B.2.3.10 String.prototype.link(url)
_dereq_(129)('link', function (createHTML) {
  return function link(url) {
    return createHTML(this, 'a', 'href', url);
  };
});

},{"129":129}],268:[function(_dereq_,module,exports){
var $export = _dereq_(60);
var toIObject = _dereq_(138);
var toLength = _dereq_(139);

$export($export.S, 'String', {
  // 21.1.2.4 String.raw(callSite, ...substitutions)
  raw: function raw(callSite) {
    var tpl = toIObject(callSite.raw);
    var len = toLength(tpl.length);
    var aLen = arguments.length;
    var res = [];
    var i = 0;
    while (len > i) {
      res.push(String(tpl[i++]));
      if (i < aLen) res.push(String(arguments[i]));
    } return res.join('');
  }
});

},{"138":138,"139":139,"60":60}],269:[function(_dereq_,module,exports){
var $export = _dereq_(60);

$export($export.P, 'String', {
  // 21.1.3.13 String.prototype.repeat(count)
  repeat: _dereq_(131)
});

},{"131":131,"60":60}],270:[function(_dereq_,module,exports){
'use strict';
// B.2.3.11 String.prototype.small()
_dereq_(129)('small', function (createHTML) {
  return function small() {
    return createHTML(this, 'small', '', '');
  };
});

},{"129":129}],271:[function(_dereq_,module,exports){
// 21.1.3.18 String.prototype.startsWith(searchString [, position ])
'use strict';
var $export = _dereq_(60);
var toLength = _dereq_(139);
var context = _dereq_(128);
var STARTS_WITH = 'startsWith';
var $startsWith = ''[STARTS_WITH];

$export($export.P + $export.F * _dereq_(61)(STARTS_WITH), 'String', {
  startsWith: function startsWith(searchString /* , position = 0 */) {
    var that = context(this, searchString, STARTS_WITH);
    var index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));
    var search = String(searchString);
    return $startsWith
      ? $startsWith.call(that, search, index)
      : that.slice(index, index + search.length) === search;
  }
});

},{"128":128,"139":139,"60":60,"61":61}],272:[function(_dereq_,module,exports){
'use strict';
// B.2.3.12 String.prototype.strike()
_dereq_(129)('strike', function (createHTML) {
  return function strike() {
    return createHTML(this, 'strike', '', '');
  };
});

},{"129":129}],273:[function(_dereq_,module,exports){
'use strict';
// B.2.3.13 String.prototype.sub()
_dereq_(129)('sub', function (createHTML) {
  return function sub() {
    return createHTML(this, 'sub', '', '');
  };
});

},{"129":129}],274:[function(_dereq_,module,exports){
'use strict';
// B.2.3.14 String.prototype.sup()
_dereq_(129)('sup', function (createHTML) {
  return function sup() {
    return createHTML(this, 'sup', '', '');
  };
});

},{"129":129}],275:[function(_dereq_,module,exports){
'use strict';
// 21.1.3.25 String.prototype.trim()
_dereq_(132)('trim', function ($trim) {
  return function trim() {
    return $trim(this, 3);
  };
});

},{"132":132}],276:[function(_dereq_,module,exports){
'use strict';
// ECMAScript 6 symbols shim
var global = _dereq_(68);
var has = _dereq_(69);
var DESCRIPTORS = _dereq_(56);
var $export = _dereq_(60);
var redefine = _dereq_(116);
var META = _dereq_(92).KEY;
var $fails = _dereq_(62);
var shared = _dereq_(124);
var setToStringTag = _dereq_(122);
var uid = _dereq_(145);
var wks = _dereq_(150);
var wksExt = _dereq_(149);
var wksDefine = _dereq_(148);
var enumKeys = _dereq_(59);
var isArray = _dereq_(77);
var anObject = _dereq_(36);
var isObject = _dereq_(79);
var toObject = _dereq_(140);
var toIObject = _dereq_(138);
var toPrimitive = _dereq_(141);
var createDesc = _dereq_(114);
var _create = _dereq_(96);
var gOPNExt = _dereq_(100);
var $GOPD = _dereq_(99);
var $GOPS = _dereq_(102);
var $DP = _dereq_(97);
var $keys = _dereq_(105);
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function' && !!$GOPS.f;
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function () { return dP(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, { enumerable: createDesc(0, false) });
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  _dereq_(101).f = gOPNExt.f = $getOwnPropertyNames;
  _dereq_(106).f = $propertyIsEnumerable;
  $GOPS.f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !_dereq_(87)) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

for (var es6Symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () { setter = true; },
  useSimple: function () { setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
// https://bugs.chromium.org/p/v8/issues/detail?id=3443
var FAILS_ON_PRIMITIVES = $fails(function () { $GOPS.f(1); });

$export($export.S + $export.F * FAILS_ON_PRIMITIVES, 'Object', {
  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
    return $GOPS.f(toObject(it));
  }
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) args.push(arguments[i++]);
    $replacer = replacer = args[1];
    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    if (!isArray(replacer)) replacer = function (key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || _dereq_(70)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);

},{"100":100,"101":101,"102":102,"105":105,"106":106,"114":114,"116":116,"122":122,"124":124,"138":138,"140":140,"141":141,"145":145,"148":148,"149":149,"150":150,"36":36,"56":56,"59":59,"60":60,"62":62,"68":68,"69":69,"70":70,"77":77,"79":79,"87":87,"92":92,"96":96,"97":97,"99":99}],277:[function(_dereq_,module,exports){
'use strict';
var $export = _dereq_(60);
var $typed = _dereq_(144);
var buffer = _dereq_(143);
var anObject = _dereq_(36);
var toAbsoluteIndex = _dereq_(135);
var toLength = _dereq_(139);
var isObject = _dereq_(79);
var ArrayBuffer = _dereq_(68).ArrayBuffer;
var speciesConstructor = _dereq_(125);
var $ArrayBuffer = buffer.ArrayBuffer;
var $DataView = buffer.DataView;
var $isView = $typed.ABV && ArrayBuffer.isView;
var $slice = $ArrayBuffer.prototype.slice;
var VIEW = $typed.VIEW;
var ARRAY_BUFFER = 'ArrayBuffer';

$export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), { ArrayBuffer: $ArrayBuffer });

$export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {
  // 24.1.3.1 ArrayBuffer.isView(arg)
  isView: function isView(it) {
    return $isView && $isView(it) || isObject(it) && VIEW in it;
  }
});

$export($export.P + $export.U + $export.F * _dereq_(62)(function () {
  return !new $ArrayBuffer(2).slice(1, undefined).byteLength;
}), ARRAY_BUFFER, {
  // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)
  slice: function slice(start, end) {
    if ($slice !== undefined && end === undefined) return $slice.call(anObject(this), start); // FF fix
    var len = anObject(this).byteLength;
    var first = toAbsoluteIndex(start, len);
    var fin = toAbsoluteIndex(end === undefined ? len : end, len);
    var result = new (speciesConstructor(this, $ArrayBuffer))(toLength(fin - first));
    var viewS = new $DataView(this);
    var viewT = new $DataView(result);
    var index = 0;
    while (first < fin) {
      viewT.setUint8(index++, viewS.getUint8(first++));
    } return result;
  }
});

_dereq_(121)(ARRAY_BUFFER);

},{"121":121,"125":125,"135":135,"139":139,"143":143,"144":144,"36":36,"60":60,"62":62,"68":68,"79":79}],278:[function(_dereq_,module,exports){
var $export = _dereq_(60);
$export($export.G + $export.W + $export.F * !_dereq_(144).ABV, {
  DataView: _dereq_(143).DataView
});

},{"143":143,"144":144,"60":60}],279:[function(_dereq_,module,exports){
_dereq_(142)('Float32', 4, function (init) {
  return function Float32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"142":142}],280:[function(_dereq_,module,exports){
_dereq_(142)('Float64', 8, function (init) {
  return function Float64Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"142":142}],281:[function(_dereq_,module,exports){
_dereq_(142)('Int16', 2, function (init) {
  return function Int16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"142":142}],282:[function(_dereq_,module,exports){
_dereq_(142)('Int32', 4, function (init) {
  return function Int32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"142":142}],283:[function(_dereq_,module,exports){
_dereq_(142)('Int8', 1, function (init) {
  return function Int8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"142":142}],284:[function(_dereq_,module,exports){
_dereq_(142)('Uint16', 2, function (init) {
  return function Uint16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"142":142}],285:[function(_dereq_,module,exports){
_dereq_(142)('Uint32', 4, function (init) {
  return function Uint32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"142":142}],286:[function(_dereq_,module,exports){
_dereq_(142)('Uint8', 1, function (init) {
  return function Uint8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"142":142}],287:[function(_dereq_,module,exports){
_dereq_(142)('Uint8', 1, function (init) {
  return function Uint8ClampedArray(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
}, true);

},{"142":142}],288:[function(_dereq_,module,exports){
'use strict';
var global = _dereq_(68);
var each = _dereq_(40)(0);
var redefine = _dereq_(116);
var meta = _dereq_(92);
var assign = _dereq_(95);
var weak = _dereq_(48);
var isObject = _dereq_(79);
var validate = _dereq_(147);
var NATIVE_WEAK_MAP = _dereq_(147);
var IS_IE11 = !global.ActiveXObject && 'ActiveXObject' in global;
var WEAK_MAP = 'WeakMap';
var getWeak = meta.getWeak;
var isExtensible = Object.isExtensible;
var uncaughtFrozenStore = weak.ufstore;
var InternalMap;

var wrapper = function (get) {
  return function WeakMap() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
};

var methods = {
  // 23.3.3.3 WeakMap.prototype.get(key)
  get: function get(key) {
    if (isObject(key)) {
      var data = getWeak(key);
      if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);
      return data ? data[this._i] : undefined;
    }
  },
  // 23.3.3.5 WeakMap.prototype.set(key, value)
  set: function set(key, value) {
    return weak.def(validate(this, WEAK_MAP), key, value);
  }
};

// 23.3 WeakMap Objects
var $WeakMap = module.exports = _dereq_(49)(WEAK_MAP, wrapper, methods, weak, true, true);

// IE11 WeakMap frozen keys fix
if (NATIVE_WEAK_MAP && IS_IE11) {
  InternalMap = weak.getConstructor(wrapper, WEAK_MAP);
  assign(InternalMap.prototype, methods);
  meta.NEED = true;
  each(['delete', 'has', 'get', 'set'], function (key) {
    var proto = $WeakMap.prototype;
    var method = proto[key];
    redefine(proto, key, function (a, b) {
      // store frozen objects on internal weakmap shim
      if (isObject(a) && !isExtensible(a)) {
        if (!this._f) this._f = new InternalMap();
        var result = this._f[key](a, b);
        return key == 'set' ? this : result;
      // store all the rest on native weakmap
      } return method.call(this, a, b);
    });
  });
}

},{"116":116,"147":147,"40":40,"48":48,"49":49,"68":68,"79":79,"92":92,"95":95}],289:[function(_dereq_,module,exports){
'use strict';
var weak = _dereq_(48);
var validate = _dereq_(147);
var WEAK_SET = 'WeakSet';

// 23.4 WeakSet Objects
_dereq_(49)(WEAK_SET, function (get) {
  return function WeakSet() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.4.3.1 WeakSet.prototype.add(value)
  add: function add(value) {
    return weak.def(validate(this, WEAK_SET), value, true);
  }
}, weak, false, true);

},{"147":147,"48":48,"49":49}],290:[function(_dereq_,module,exports){
'use strict';
// https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatMap
var $export = _dereq_(60);
var flattenIntoArray = _dereq_(65);
var toObject = _dereq_(140);
var toLength = _dereq_(139);
var aFunction = _dereq_(31);
var arraySpeciesCreate = _dereq_(43);

$export($export.P, 'Array', {
  flatMap: function flatMap(callbackfn /* , thisArg */) {
    var O = toObject(this);
    var sourceLen, A;
    aFunction(callbackfn);
    sourceLen = toLength(O.length);
    A = arraySpeciesCreate(O, 0);
    flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments[1]);
    return A;
  }
});

_dereq_(33)('flatMap');

},{"139":139,"140":140,"31":31,"33":33,"43":43,"60":60,"65":65}],291:[function(_dereq_,module,exports){
'use strict';
// https://github.com/tc39/Array.prototype.includes
var $export = _dereq_(60);
var $includes = _dereq_(39)(true);

$export($export.P, 'Array', {
  includes: function includes(el /* , fromIndex = 0 */) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

_dereq_(33)('includes');

},{"33":33,"39":39,"60":60}],292:[function(_dereq_,module,exports){
// https://github.com/tc39/proposal-object-values-entries
var $export = _dereq_(60);
var $entries = _dereq_(108)(true);

$export($export.S, 'Object', {
  entries: function entries(it) {
    return $entries(it);
  }
});

},{"108":108,"60":60}],293:[function(_dereq_,module,exports){
// https://github.com/tc39/proposal-object-getownpropertydescriptors
var $export = _dereq_(60);
var ownKeys = _dereq_(109);
var toIObject = _dereq_(138);
var gOPD = _dereq_(99);
var createProperty = _dereq_(51);

$export($export.S, 'Object', {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
    var O = toIObject(object);
    var getDesc = gOPD.f;
    var keys = ownKeys(O);
    var result = {};
    var i = 0;
    var key, desc;
    while (keys.length > i) {
      desc = getDesc(O, key = keys[i++]);
      if (desc !== undefined) createProperty(result, key, desc);
    }
    return result;
  }
});

},{"109":109,"138":138,"51":51,"60":60,"99":99}],294:[function(_dereq_,module,exports){
// https://github.com/tc39/proposal-object-values-entries
var $export = _dereq_(60);
var $values = _dereq_(108)(false);

$export($export.S, 'Object', {
  values: function values(it) {
    return $values(it);
  }
});

},{"108":108,"60":60}],295:[function(_dereq_,module,exports){
// https://github.com/tc39/proposal-promise-finally
'use strict';
var $export = _dereq_(60);
var core = _dereq_(50);
var global = _dereq_(68);
var speciesConstructor = _dereq_(125);
var promiseResolve = _dereq_(113);

$export($export.P + $export.R, 'Promise', { 'finally': function (onFinally) {
  var C = speciesConstructor(this, core.Promise || global.Promise);
  var isFunction = typeof onFinally == 'function';
  return this.then(
    isFunction ? function (x) {
      return promiseResolve(C, onFinally()).then(function () { return x; });
    } : onFinally,
    isFunction ? function (e) {
      return promiseResolve(C, onFinally()).then(function () { throw e; });
    } : onFinally
  );
} });

},{"113":113,"125":125,"50":50,"60":60,"68":68}],296:[function(_dereq_,module,exports){
'use strict';
// https://github.com/tc39/proposal-string-pad-start-end
var $export = _dereq_(60);
var $pad = _dereq_(130);
var userAgent = _dereq_(146);

// https://github.com/zloirock/core-js/issues/280
var WEBKIT_BUG = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(userAgent);

$export($export.P + $export.F * WEBKIT_BUG, 'String', {
  padEnd: function padEnd(maxLength /* , fillString = ' ' */) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
  }
});

},{"130":130,"146":146,"60":60}],297:[function(_dereq_,module,exports){
'use strict';
// https://github.com/tc39/proposal-string-pad-start-end
var $export = _dereq_(60);
var $pad = _dereq_(130);
var userAgent = _dereq_(146);

// https://github.com/zloirock/core-js/issues/280
var WEBKIT_BUG = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(userAgent);

$export($export.P + $export.F * WEBKIT_BUG, 'String', {
  padStart: function padStart(maxLength /* , fillString = ' ' */) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
  }
});

},{"130":130,"146":146,"60":60}],298:[function(_dereq_,module,exports){
'use strict';
// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
_dereq_(132)('trimLeft', function ($trim) {
  return function trimLeft() {
    return $trim(this, 1);
  };
}, 'trimStart');

},{"132":132}],299:[function(_dereq_,module,exports){
'use strict';
// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
_dereq_(132)('trimRight', function ($trim) {
  return function trimRight() {
    return $trim(this, 2);
  };
}, 'trimEnd');

},{"132":132}],300:[function(_dereq_,module,exports){
_dereq_(148)('asyncIterator');

},{"148":148}],301:[function(_dereq_,module,exports){
var $iterators = _dereq_(162);
var getKeys = _dereq_(105);
var redefine = _dereq_(116);
var global = _dereq_(68);
var hide = _dereq_(70);
var Iterators = _dereq_(86);
var wks = _dereq_(150);
var ITERATOR = wks('iterator');
var TO_STRING_TAG = wks('toStringTag');
var ArrayValues = Iterators.Array;

var DOMIterables = {
  CSSRuleList: true, // TODO: Not spec compliant, should be false.
  CSSStyleDeclaration: false,
  CSSValueList: false,
  ClientRectList: false,
  DOMRectList: false,
  DOMStringList: false,
  DOMTokenList: true,
  DataTransferItemList: false,
  FileList: false,
  HTMLAllCollection: false,
  HTMLCollection: false,
  HTMLFormElement: false,
  HTMLSelectElement: false,
  MediaList: true, // TODO: Not spec compliant, should be false.
  MimeTypeArray: false,
  NamedNodeMap: false,
  NodeList: true,
  PaintRequestList: false,
  Plugin: false,
  PluginArray: false,
  SVGLengthList: false,
  SVGNumberList: false,
  SVGPathSegList: false,
  SVGPointList: false,
  SVGStringList: false,
  SVGTransformList: false,
  SourceBufferList: false,
  StyleSheetList: true, // TODO: Not spec compliant, should be false.
  TextTrackCueList: false,
  TextTrackList: false,
  TouchList: false
};

for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {
  var NAME = collections[i];
  var explicit = DOMIterables[NAME];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  var key;
  if (proto) {
    if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
    if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
    Iterators[NAME] = ArrayValues;
    if (explicit) for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true);
  }
}

},{"105":105,"116":116,"150":150,"162":162,"68":68,"70":70,"86":86}],302:[function(_dereq_,module,exports){
var $export = _dereq_(60);
var $task = _dereq_(134);
$export($export.G + $export.B, {
  setImmediate: $task.set,
  clearImmediate: $task.clear
});

},{"134":134,"60":60}],303:[function(_dereq_,module,exports){
// ie9- setTimeout & setInterval additional parameters fix
var global = _dereq_(68);
var $export = _dereq_(60);
var userAgent = _dereq_(146);
var slice = [].slice;
var MSIE = /MSIE .\./.test(userAgent); // <- dirty ie9- check
var wrap = function (set) {
  return function (fn, time /* , ...args */) {
    var boundArgs = arguments.length > 2;
    var args = boundArgs ? slice.call(arguments, 2) : false;
    return set(boundArgs ? function () {
      // eslint-disable-next-line no-new-func
      (typeof fn == 'function' ? fn : Function(fn)).apply(this, args);
    } : fn, time);
  };
};
$export($export.G + $export.B + $export.F * MSIE, {
  setTimeout: wrap(global.setTimeout),
  setInterval: wrap(global.setInterval)
});

},{"146":146,"60":60,"68":68}],304:[function(_dereq_,module,exports){
_dereq_(303);
_dereq_(302);
_dereq_(301);
module.exports = _dereq_(50);

},{"301":301,"302":302,"303":303,"50":50}],305:[function(_dereq_,module,exports){
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;

    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList),
      PromiseImpl
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
  typeof module === "object" ? module.exports : {}
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}

},{}],306:[function(_dereq_,module,exports){
"use strict";

_dereq_(307);

var _global = _interopRequireDefault(_dereq_(13));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

if (_global["default"]._babelPolyfill && typeof console !== "undefined" && console.warn) {
  console.warn("@babel/polyfill is loaded more than once on this page. This is probably not desirable/intended " + "and may have consequences if different versions of the polyfills are applied sequentially. " + "If you do need to load the polyfill more than once, use @babel/polyfill/noConflict " + "instead to bypass the warning.");
}

_global["default"]._babelPolyfill = true;
},{"13":13,"307":307}],307:[function(_dereq_,module,exports){
"use strict";

_dereq_(1);

_dereq_(3);

_dereq_(2);

_dereq_(9);

_dereq_(8);

_dereq_(11);

_dereq_(10);

_dereq_(12);

_dereq_(5);

_dereq_(6);

_dereq_(4);

_dereq_(7);

_dereq_(304);

_dereq_(305);
},{"1":1,"10":10,"11":11,"12":12,"2":2,"3":3,"304":304,"305":305,"4":4,"5":5,"6":6,"7":7,"8":8,"9":9}]},{},[306]);

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.data.IListData": {},
      "qx.util.OOUtil": {}
    }
  };

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * Create namespace
   *
   * @ignore(qx.data)
   * @ignore(qx.data.IListData)
   * @ignore(qx.util.OOUtil)
   */
  if (!window.qx) {
    window.qx = {};
  }
  /**
   * Bootstrap qx.Bootstrap to create myself later
   * This is needed for the API browser etc. to let them detect me
   */


  qx.Bootstrap = {
    genericToString: function () {
      return "[Class " + this.classname + "]";
    },
    createNamespace: function (name, object) {
      var splits = name.split(".");
      var part = splits[0];
      var parent = qx.$$namespaceRoot && qx.$$namespaceRoot[part] ? qx.$$namespaceRoot : window;

      for (var i = 0, len = splits.length - 1; i < len; i++, part = splits[i]) {
        if (!parent[part]) {
          parent = parent[part] = {};
        } else {
          parent = parent[part];
        }
      } // store object


      parent[part] = object; // return last part name (e.g. classname)

      return part;
    },
    setDisplayName: function (fcn, classname, name) {
      fcn.displayName = classname + "." + name + "()";
    },
    setDisplayNames: function (functionMap, classname) {
      for (var name in functionMap) {
        var value = functionMap[name];

        if (value instanceof Function) {
          value.displayName = classname + "." + (value.name || name) + "()";
        }
      }
    },
    base: function (args, varargs) {
      if (qx.Bootstrap.DEBUG) {
        if (!qx.Bootstrap.isFunction(args.callee.base)) {
          throw new Error("Cannot call super class. Method is not derived: " + args.callee.displayName);
        }
      }

      if (arguments.length === 1) {
        return args.callee.base.call(this);
      } else {
        return args.callee.base.apply(this, Array.prototype.slice.call(arguments, 1));
      }
    },
    define: function (name, config) {
      var isStrictMode = function () {
        return typeof this == 'undefined';
      };

      if (!config) {
        config = {
          statics: {}
        };
      }

      var clazz;
      var proto = null;
      qx.Bootstrap.setDisplayNames(config.statics, name);

      if (config.members || config.extend) {
        qx.Bootstrap.setDisplayNames(config.members, name + ".prototype");
        clazz = config.construct || new Function();

        if (config.extend) {
          this.extendClass(clazz, clazz, config.extend, name, basename);
        }

        var statics = config.statics || {}; // use keys to include the shadowed in IE

        for (var i = 0, keys = qx.Bootstrap.keys(statics), l = keys.length; i < l; i++) {
          var key = keys[i];
          clazz[key] = statics[key];
        }

        proto = clazz.prototype; // Enable basecalls within constructor

        proto.base = qx.Bootstrap.base;
        proto.name = proto.classname = name;
        var members = config.members || {};
        var key, member; // use keys to include the shadowed in IE

        for (var i = 0, keys = qx.Bootstrap.keys(members), l = keys.length; i < l; i++) {
          key = keys[i];
          member = members[key]; // Enable basecalls for methods
          // Hint: proto[key] is not yet overwritten here

          if (member instanceof Function && proto[key]) {
            member.base = proto[key];
          }

          proto[key] = member;
        }
      } else {
        clazz = config.statics || {}; // Merge class into former class (needed for 'optimize: ["statics"]')

        if (qx.Bootstrap.$$registry && qx.Bootstrap.$$registry[name]) {
          var formerClass = qx.Bootstrap.$$registry[name]; // Add/overwrite properties and return early if necessary

          if (this.keys(clazz).length !== 0) {
            // Execute defer to prevent too early overrides
            if (config.defer) {
              config.defer(clazz, proto);
            }

            for (var curProp in clazz) {
              formerClass[curProp] = clazz[curProp];
            }

            return formerClass;
          }
        }
      } // Store type info


      clazz.$$type = "Class"; // Attach toString

      if (!clazz.hasOwnProperty("toString")) {
        clazz.toString = this.genericToString;
      } // Create namespace


      var basename = name ? this.createNamespace(name, clazz) : ""; // Store names in constructor/object

      clazz.classname = name;

      if (!isStrictMode()) {
        try {
          clazz.name = name;
        } catch (ex) {// Nothing
        }
      }

      clazz.basename = basename;
      clazz.$$events = config.events; // Execute defer section

      if (config.defer) {
        this.addPendingDefer(clazz, function () {
          config.defer(clazz, proto);
        });
      } // Store class reference in global class registry


      if (name != null) {
        qx.Bootstrap.$$registry[name] = clazz;
      }

      return clazz;
    },

    /**
     * Tests whether an object is an instance of qx.core.Object without using instanceof - this
     * is only for certain low level instances which would otherwise cause a circular, load time 
     * dependency
     * 
     * @param object {Object?} the object to test
     * @return {Boolean} true if object is an instance of qx.core.Object
     */
    isQxCoreObject: function (object) {
      if (object === object.constructor) {
        return false;
      }

      var clz = object.constructor;

      while (clz) {
        if (clz.classname === "qx.core.Object") {
          return true;
        }

        clz = clz.superclass;
      }

      return false;
    }
  };
  /**
   * Internal class that is responsible for bootstrapping the qooxdoo
   * framework at load time.
   */

  qx.Bootstrap.define("qx.Bootstrap", {
    statics: {
      /** Timestamp of qooxdoo based application startup */
      LOADSTART: qx.$$start || new Date(),

      /**
       * Mapping for early use of the qx.debug environment setting.
       */
      DEBUG: function () {
        // make sure to reflect all changes here to the environment class!
        var debug = true;

        if (qx.$$environment && qx.$$environment["qx.debug"] === false) {
          debug = false;
        }

        return debug;
      }(),

      /**
       * Minimal accessor API for the environment settings given from the
       * generator.
       *
       * WARNING: This method only should be used if the
       * {@link qx.core.Environment} class is not loaded!
       *
       * @param key {String} The key to get the value from.
       * @return {var} The value of the setting or <code>undefined</code>.
       */
      getEnvironmentSetting: function (key) {
        if (qx.$$environment) {
          return qx.$$environment[key];
        }
      },

      /**
       * Minimal mutator for the environment settings given from the generator.
       * It checks for the existence of the environment settings and sets the
       * key if its not given from the generator. If a setting is available from
       * the generator, the setting will be ignored.
       *
       * WARNING: This method only should be used if the
       * {@link qx.core.Environment} class is not loaded!
       *
       * @param key {String} The key of the setting.
       * @param value {var} The value for the setting.
       */
      setEnvironmentSetting: function (key, value) {
        if (!qx.$$environment) {
          qx.$$environment = {};
        }

        if (qx.$$environment[key] === undefined) {
          qx.$$environment[key] = value;
        }
      },

      /**
       * Creates a namespace and assigns the given object to it.
       *
       * @internal
       * @signature function(name, object)
       * @param name {String} The complete namespace to create. Typically, the last part is the class name itself
       * @param object {Object} The object to attach to the namespace
       * @return {String} last part of the namespace (which object is assigned to)
       * @throws {Error} when the given object already exists.
       */
      createNamespace: qx.Bootstrap.createNamespace,

      /**
       * Offers the ability to change the root for creating namespaces from window to
       * whatever object is given.
       *
       * @param root {Object} The root to use.
       * @internal
       */
      setRoot: function (root) {
        qx.$$namespaceRoot = root;
      },

      /**
       * Call the same method of the super class.
       *
       * @signature function(args, varargs)
       * @param args {arguments} the arguments variable of the calling method
       * @param varargs {var} variable number of arguments passed to the overwritten function
       * @return {var} the return value of the method of the base class.
       */
      base: qx.Bootstrap.base,

      /**
       * Define a new class using the qooxdoo class system.
       * Lightweight version of {@link qx.Class#define} with less features.
       *
       * @signature function(name, config)
       * @param name {String?} Name of the class. If null, the class will not be
       *   attached to a namespace.
       * @param config {Map ? null} Class definition structure. The configuration map has the following keys:
       *     <table>
       *       <tr><th>Name</th><th>Type</th><th>Description</th></tr>
       *       <tr><th>extend</th><td>Class</td><td>The super class the current class inherits from.</td></tr>
       *       <tr><th>construct</th><td>Function</td><td>The constructor of the class.</td></tr>
       *       <tr><th>statics</th><td>Map</td><td>Map of static values / functions of the class.</td></tr>
       *       <tr><th>members</th><td>Map</td><td>Map of instance members of the class.</td></tr>
       *       <tr><th>defer</th><td>Function</td><td>Function that is called at the end of
       *          processing the class declaration.</td></tr>
       *     </table>
       * @return {Class} The defined class.
       */
      define: qx.Bootstrap.define,

      /**
       * Tests whether an object is an instance of qx.core.Object without using instanceof - this
       * is only for certain low level instances which would otherwise cause a circular, load time 
       * dependency
       * 
       * @param object {Object?} the object to test
       * @return {Boolean} true if object is an instance of qx.core.Object
       */
      isQxCoreObject: qx.Bootstrap.isQxCoreObject,

      /**
       * Sets the display name of the given function
       *
       * @signature function(fcn, classname, name)
       * @param fcn {Function} the function to set the display name for
       * @param classname {String} the name of the class the function is defined in
       * @param name {String} the function name
       */
      setDisplayName: qx.Bootstrap.setDisplayName,

      /**
       * Set the names of all functions defined in the given map
       *
       * @signature function(functionMap, classname)
       * @param functionMap {Object} a map with functions as values
       * @param classname {String} the name of the class, the functions are
       *   defined in
       */
      setDisplayNames: qx.Bootstrap.setDisplayNames,

      /**
       * This method will be attached to all classes to return
       * a nice identifier for them.
       *
       * @internal
       * @signature function()
       * @return {String} The class identifier
       */
      genericToString: qx.Bootstrap.genericToString,

      /**
       * Inherit a clazz from a super class.
       *
       * This function differentiates between class and constructor because the
       * constructor written by the user might be wrapped and the <code>base</code>
       * property has to be attached to the constructor, while the <code>superclass</code>
       * property has to be attached to the wrapped constructor.
       *
       * @param clazz {Function} The class's wrapped constructor
       * @param construct {Function} The unwrapped constructor
       * @param superClass {Function} The super class
       * @param name {Function} fully qualified class name
       * @param basename {Function} the base name
       */
      extendClass: function (clazz, construct, superClass, name, basename) {
        var superproto = superClass.prototype; // Use helper function/class to save the unnecessary constructor call while
        // setting up inheritance.

        var helper = new Function();
        helper.prototype = superproto;
        var proto = new helper(); // Apply prototype to new helper instance

        clazz.prototype = proto; // Store names in prototype

        proto.name = proto.classname = name;
        proto.basename = basename;
        /*
          - Store base constructor to constructor-
          - Store reference to extend class
        */

        construct.base = superClass;
        clazz.superclass = superClass;
        /*
          - Store statics/constructor onto constructor/prototype
          - Store correct constructor
          - Store statics onto prototype
        */

        construct.self = clazz.constructor = proto.constructor = clazz;
      },

      /** Private list of classes which have a defer method that needs to be executed */
      __P_60_0: [],

      /**
       * Adds a callback for a class so that it's defer method can be called, either after all classes
       * are loaded or when absolutely necessary because of load-time requirements of other classes.
       *
       * @param clazz {Class} Class to add a callback to
       * @param cb {Function} Callback function
       */
      addPendingDefer: function (clazz, cb) {
        if (qx.$$loader && qx.$$loader.delayDefer) {
          this.__P_60_0.push(clazz);

          clazz.$$pendingDefer = cb;
        } else {
          cb.call(clazz);
        }
      },

      /**
       * Executes the defer methods for classes which are required by the dependency information in
       * dbClassInfo (which is a map in the format generated by qxcompiler).  Defer methods are of course
       * only executed once but they are always put off until absolutely necessary to avoid potential
       * side effects and recursive and/or difficult to resolve dependencies.
       *
       * @param dbClassInfo {Object} qxcompiler map
       */
      executePendingDefers: function (dbClassInfo) {
        var executeForDbClassInfo = function (dbClassInfo) {
          if (dbClassInfo.environment) {
            var required = dbClassInfo.environment.required;

            if (required) {
              for (var key in required) {
                var info = required[key];

                if (info.load && info.className) {
                  executeForClassName(info.className);
                }
              }
            }
          }

          for (var key in dbClassInfo.dependsOn) {
            var depInfo = dbClassInfo.dependsOn[key];

            if (depInfo.require || depInfo.usage === "dynamic") {
              executeForClassName(key);
            }
          }
        };

        var executeForClassName = function (className) {
          var clazz = getByName(className);

          if (!clazz) {
            return;
          }

          if (clazz.$$deferComplete) {
            return;
          }

          var dbClassInfo = clazz.$$dbClassInfo;

          if (dbClassInfo) {
            executeForDbClassInfo(dbClassInfo);
          }

          execute(clazz);
        };

        var execute = function (clazz) {
          var cb = clazz.$$pendingDefer;

          if (cb) {
            delete clazz.$$pendingDefer;
            clazz.$$deferComplete = true;
            cb.call(clazz);
          }
        };

        var getByName = function (name) {
          var clazz = qx.Bootstrap.getByName(name);

          if (!clazz) {
            var splits = name.split(".");
            var part = splits[0];
            var root = qx.$$namespaceRoot && qx.$$namespaceRoot[part] ? qx.$$namespaceRoot : window;
            var tmp = root;

            for (var i = 0, len = splits.length - 1; tmp && i < len; i++, part = splits[i]) {
              tmp = tmp[part];
            }

            if (tmp != root) {
              clazz = tmp;
            }
          }

          return clazz;
        };

        if (!dbClassInfo) {
          var pendingDefers = this.__P_60_0;
          this.__P_60_0 = [];
          pendingDefers.forEach(execute);
          return;
        }

        executeForDbClassInfo(dbClassInfo);
      },

      /**
       * Find a class by its name
       *
       * @param name {String} class name to resolve
       * @return {Class} the class
       */
      getByName: function (name) {
        return qx.Bootstrap.$$registry[name];
      },

      /** @type {Map} Stores all defined classes */
      $$registry: {},

      /*
      ---------------------------------------------------------------------------
        OBJECT UTILITY FUNCTIONS
      ---------------------------------------------------------------------------
      */

      /**
       * Get the number of own properties in the object.
       *
       * @param map {Object} the map
       * @return {Integer} number of objects in the map
       * @lint ignoreUnused(key)
       */
      objectGetLength: function (map) {
        return qx.Bootstrap.keys(map).length;
      },

      /**
       * Inserts all keys of the source object into the
       * target objects. Attention: The target map gets modified.
       *
       * @param target {Object} target object
       * @param source {Object} object to be merged
       * @param overwrite {Boolean ? true} If enabled existing keys will be overwritten
       * @return {Object} Target with merged values from the source object
       */
      objectMergeWith: function (target, source, overwrite) {
        if (overwrite === undefined) {
          overwrite = true;
        }

        for (var key in source) {
          if (overwrite || target[key] === undefined) {
            target[key] = source[key];
          }
        }

        return target;
      },

      /**
       * IE does not return "shadowed" keys even if they are defined directly
       * in the object.
       *
       * @internal
       * @type {String[]}
       */
      __P_60_1: ["isPrototypeOf", "hasOwnProperty", "toLocaleString", "toString", "valueOf", "propertyIsEnumerable", "constructor"],

      /**
       * Get the keys of a map as array as returned by a "for ... in" statement.
       *
       * @signature function(map)
       * @internal
       * @param map {Object} the map
       * @return {Array} array of the keys of the map
       */
      keys: {
        "ES5": Object.keys,
        "BROKEN_IE": function (map) {
          if (map === null || typeof map !== "object" && typeof map !== "function") {
            throw new TypeError("Object.keys requires an object as argument.");
          }

          var arr = [];
          var hasOwnProperty = Object.prototype.hasOwnProperty;

          for (var key in map) {
            if (hasOwnProperty.call(map, key)) {
              arr.push(key);
            }
          } // IE does not return "shadowed" keys even if they are defined directly
          // in the object. This is incompatible with the ECMA standard!!
          // This is why this checks are needed.


          var shadowedKeys = qx.Bootstrap.__P_60_1;

          for (var i = 0, a = shadowedKeys, l = a.length; i < l; i++) {
            if (hasOwnProperty.call(map, a[i])) {
              arr.push(a[i]);
            }
          }

          return arr;
        },
        "default": function (map) {
          if (map === null || typeof map !== "object" && typeof map !== "function") {
            throw new TypeError("Object.keys requires an object as argument.");
          }

          var arr = [];
          var hasOwnProperty = Object.prototype.hasOwnProperty;

          for (var key in map) {
            if (hasOwnProperty.call(map, key)) {
              arr.push(key);
            }
          }

          return arr;
        }
      }[typeof Object.keys === "function" ? "ES5" : function () {
        for (var key in {
          toString: 1
        }) {
          return key;
        }
      }() !== "toString" ? "BROKEN_IE" : "default"],

      /**
       * Mapping from JavaScript string representation of objects to names
       * @internal
       * @type {Map}
       */
      __P_60_2: {
        "[object String]": "String",
        "[object Array]": "Array",
        "[object Object]": "Object",
        "[object RegExp]": "RegExp",
        "[object Number]": "Number",
        "[object Boolean]": "Boolean",
        "[object Date]": "Date",
        "[object Function]": "Function",
        "[object AsyncFunction]": "Function",
        "[object Error]": "Error",
        "[object Blob]": "Blob",
        "[object ArrayBuffer]": "ArrayBuffer",
        "[object FormData]": "FormData"
      },

      /*
      ---------------------------------------------------------------------------
        FUNCTION UTILITY FUNCTIONS
      ---------------------------------------------------------------------------
      */

      /**
       * Returns a function whose "this" is altered.
       *
       * *Syntax*
       *
       * <pre class='javascript'>qx.Bootstrap.bind(myFunction, [self, [varargs...]]);</pre>
       *
       * *Example*
       *
       * <pre class='javascript'>
       * function myFunction()
       * {
       *   this.setStyle('color', 'red');
       *   // note that 'this' here refers to myFunction, not an element
       *   // we'll need to bind this function to the element we want to alter
       * };
       *
       * var myBoundFunction = qx.Bootstrap.bind(myFunction, myElement);
       * myBoundFunction(); // this will make the element myElement red.
       * </pre>
       *
       * @param func {Function} Original function to wrap
       * @param self {Object ? null} The object that the "this" of the function will refer to.
       * @param varargs {arguments ? null} The arguments to pass to the function.
       * @return {Function} The bound function.
       */
      bind: function (func, self, varargs) {
        var fixedArgs = Array.prototype.slice.call(arguments, 2, arguments.length);
        return function () {
          var args = Array.prototype.slice.call(arguments, 0, arguments.length);
          return func.apply(self, fixedArgs.concat(args));
        };
      },

      /*
      ---------------------------------------------------------------------------
        STRING UTILITY FUNCTIONS
      ---------------------------------------------------------------------------
      */

      /**
       * Convert the first character of the string to upper case.
       *
       * @param str {String} the string
       * @return {String} the string with an upper case first character
       */
      firstUp: function (str) {
        return str.charAt(0).toUpperCase() + str.substr(1);
      },

      /**
       * Convert the first character of the string to lower case.
       *
       * @param str {String} the string
       * @return {String} the string with a lower case first character
       */
      firstLow: function (str) {
        return str.charAt(0).toLowerCase() + str.substr(1);
      },

      /*
      ---------------------------------------------------------------------------
        TYPE UTILITY FUNCTIONS
      ---------------------------------------------------------------------------
      */

      /**
       * Get the internal class of the value. See
       * http://perfectionkills.com/instanceof-considered-harmful-or-how-to-write-a-robust-isarray/
       * for details.
       *
       * @param value {var} value to get the class for
       * @return {String} the internal class of the value
       */
      getClass: function (value) {
        // The typeof null and undefined is "object" under IE8
        if (value === undefined) {
          return "Undefined";
        } else if (value === null) {
          return "Null";
        }

        var classString = Object.prototype.toString.call(value);
        return qx.Bootstrap.__P_60_2[classString] || classString.slice(8, -1);
      },

      /**
       * Whether the value is a string.
       *
       * @param value {var} Value to check.
       * @return {Boolean} Whether the value is a string.
       */
      isString: function (value) {
        // Added "value !== null" because IE throws an exception "Object expected"
        // by executing "value instanceof String" if value is a DOM element that
        // doesn't exist. It seems that there is an internal difference between a
        // JavaScript null and a null returned from calling DOM.
        // e.q. by document.getElementById("ReturnedNull").
        return value !== null && (typeof value === "string" || qx.Bootstrap.getClass(value) === "String" || value instanceof String || !!value && !!value.$$isString);
      },

      /**
       * Whether the value is an array.
       *
       * @param value {var} Value to check.
       * @return {Boolean} Whether the value is an array.
       */
      isArray: function (value) {
        // Added "value !== null" because IE throws an exception "Object expected"
        // by executing "value instanceof Array" if value is a DOM element that
        // doesn't exist. It seems that there is an internal difference between a
        // JavaScript null and a null returned from calling DOM.
        // e.q. by document.getElementById("ReturnedNull").
        return value !== null && (value instanceof Array || value && qx.data && qx.data.IListData && qx.util.OOUtil.hasInterface(value.constructor, qx.data.IListData) || qx.Bootstrap.getClass(value) === "Array" || !!value && !!value.$$isArray);
      },

      /**
       * Whether the value is an object. Note that built-in types like Window are
       * not reported to be objects.
       *
       * @param value {var} Value to check.
       * @return {Boolean} Whether the value is an object.
       */
      isObject: function (value) {
        return value !== undefined && value !== null && qx.Bootstrap.getClass(value) === "Object";
      },

      /**
       * Whether the value is a function.
       *
       * @param value {var} Value to check.
       * @return {Boolean} Whether the value is a function.
       */
      isFunction: function (value) {
        return qx.Bootstrap.getClass(value) === "Function";
      },

      /**
       * Whether the value is a function or an async function.
       *
       * @param value {var} Value to check.
       * @return {Boolean} Whether the value is a function.
       */
      isFunctionOrAsyncFunction: function (value) {
        var name = qx.Bootstrap.getClass(value);
        return name === "Function" || name === "AsyncFunction";
      },

      /*
      ---------------------------------------------------------------------------
        LOGGING UTILITY FUNCTIONS
      ---------------------------------------------------------------------------
      */
      $$logs: [],

      /**
       * Sending a message at level "debug" to the logger.
       *
       * @param object {Object} Contextual object (either instance or static class)
       * @param message {var} Any number of arguments supported. An argument may
       *   have any JavaScript data type. All data is serialized immediately and
       *   does not keep references to other objects.
       */
      debug: function (object, message) {
        qx.Bootstrap.$$logs.push(["debug", arguments]);
      },

      /**
       * Sending a message at level "info" to the logger.
       *
       * @param object {Object} Contextual object (either instance or static class)
       * @param message {var} Any number of arguments supported. An argument may
       *   have any JavaScript data type. All data is serialized immediately and
       *   does not keep references to other objects.
       */
      info: function (object, message) {
        qx.Bootstrap.$$logs.push(["info", arguments]);
      },

      /**
       * Sending a message at level "warn" to the logger.
       *
       * @param object {Object} Contextual object (either instance or static class)
       * @param message {var} Any number of arguments supported. An argument may
       *   have any JavaScript data type. All data is serialized immediately and
       *   does not keep references to other objects.
       */
      warn: function (object, message) {
        qx.Bootstrap.$$logs.push(["warn", arguments]);
      },

      /**
       * Sending a message at level "error" to the logger.
       *
       * @param object {Object} Contextual object (either instance or static class)
       * @param message {var} Any number of arguments supported. An argument may
       *   have any JavaScript data type. All data is serialized immediately and
       *   does not keep references to other objects.
       */
      error: function (object, message) {
        qx.Bootstrap.$$logs.push(["error", arguments]);
      },

      /**
       * Prints the current stack trace at level "info"
       *
       * @param object {Object} Contextual object (either instance or static class)
       */
      trace: function (object) {}
    }
  });
  qx.Bootstrap.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.log.Logger": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
  
  ************************************************************************ */

  /**
   * Registration for all instances of qooxdoo classes. Mainly
   * used to manage them for the final shutdown sequence and to
   * use weak references when connecting widgets to DOM nodes etc.
   *
   * @ignore(qx.dev, qx.dev.Debug.*)
   */
  qx.Bootstrap.define("qx.core.ObjectRegistry", {
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics: {
      /** 
       * @type {Boolean} Whether the application is in the shutdown phase
       * @deprecated {6.0} shutdown is not a valid mechanism to terminate apps 
       * */
      inShutDown: false,

      /** @type {Map} Internal data structure to store objects */
      __P_76_0: {},

      /** @type {Integer} Next new hash code. */
      __P_76_1: 0,

      /** @type {String} Post id for hash code creation. */
      __P_76_2: "",

      /** @type {Map} Object hashes to stack traces (for dispose profiling only) */
      __P_76_3: {},

      /**
       * Registers an object into the database. This adds a hashcode
       * to the object (if not already done before) and stores it under
       * this hashcode. You can access this object later using the hashcode
       * by calling {@link #fromHashCode}.
       *
       * All registered objects are automatically disposed on application
       * shutdown. Each registered object must at least have a method
       * called <code>dispose</code>.
       *
       * @param obj {Object} Any object with a dispose() method
       */
      register: function (obj) {
        var registry = this.__P_76_0;

        if (!registry) {
          return;
        }

        var hash = qx.core.ObjectRegistry.toHashCode(obj);
        registry[hash] = obj;
      },

      /**
       * Removes the given object from the database.
       *
       * @param obj {Object} Any previously registered object
       */
      unregister: function (obj) {
        var hash = obj.$$hash;

        if (hash == null) {
          return;
        }

        var registry = this.__P_76_0;

        if (registry && registry[hash]) {
          delete registry[hash];
        }

        this.clearHashCode(obj);
      },

      /**
       * Returns an unique identifier for the given object. If such an identifier
       * does not yet exist, create it.
       *
       * @param obj {Object} the object to get the hashcode for
       * @return {String} unique identifier for the given object
       */
      toHashCode: function (obj) {
        var hash = obj.$$hash;

        if (hash != null) {
          return hash;
        } // Create new hash code


        hash = this.createHashCode(); // Store

        obj.$$hash = hash;
        return obj.$$hash;
      },

      /**
       * Creates a hash code
       * 
       * @return {String}
       */
      createHashCode: function () {
        var hash = String(this.__P_76_1++ + this.__P_76_2);
        return hash;
      },

      /**
       * Clears the unique identifier on the given object.
       *
       * @param obj {Object} the object to clear the hashcode for
       */
      clearHashCode: function (obj) {
        var hash = obj.$$hash;

        if (hash != null) {
          // Delete the hash code
          try {
            obj.$$discardedHashCode = hash;
            delete obj.$$hash;
          } catch (ex) {
            // IE has trouble directly removing the hash
            // but it's ok with using removeAttribute
            if (obj.removeAttribute) {
              obj.removeAttribute("$$hash");
            }
          }
        }
      },

      /**
       * Get an object instance by its hash code as returned by {@link #toHashCode}.
       * If the object is already disposed or the hashCode is invalid,
       * <code>null</code> is returned.
       *
       * @param hash {String} The object's hash code.
       * @param suppressWarnings {Boolean?} if true warnings are suppressed; default is false
       * @return {qx.core.Object} The corresponding object or <code>null</code>.
       */
      fromHashCode: function (hash, suppressWarnings) {
        var obj = this.__P_76_0[hash] || null;

        if (!obj && !suppressWarnings) {
          qx.log.Logger.warn(this, "Object with hash code " + hash + " does not exist (since Qooxdoo 6.0 fromHashCode requires that you explicitly register objects with qx.core.ObjectRegistry.register)");
        }

        return obj;
      },

      /**
       * Detects whether an object instance is indexed by its hash code as returned by {@link #toHashCode}.
       * Unlike {@link #fromHashCode} this does not output warnings if the object does not exist
       *
       * @param hash {String} The object's hash code.
       * @return {qx.core.Object} The corresponding object or <code>null</code>.
       */
      hasHashCode: function (hash) {
        return !!this.__P_76_0[hash];
      },

      /**
       * Disposing all registered object and cleaning up registry. This is
       * automatically executed at application shutdown.
       * 
       * @deprecated {6.0} shutdown is not a valid means to clean up because destruction order
       * is not defined and dispose()/destructors are deprecated in favour of automatic
       * garbage collection
       */
      shutdown: function () {
        this.inShutDown = true;
        var registry = this.__P_76_0;
        var hashes = [];

        for (var hash in registry) {
          hashes.push(hash);
        } // sort the objects! Remove the objecs created at startup
        // as late as possible


        hashes.sort(function (a, b) {
          return parseInt(b, 10) - parseInt(a, 10);
        });
        var obj,
            i = 0,
            l = hashes.length;

        while (true) {
          try {
            for (; i < l; i++) {
              hash = hashes[i];
              obj = registry[hash];

              if (obj && obj.dispose) {
                obj.dispose();
              }
            }
          } catch (ex) {
            qx.Bootstrap.error(this, "Could not dispose object " + obj.toString() + ": " + ex, ex);

            if (i !== l) {
              i++;
              continue;
            }
          }

          break;
        }

        qx.Bootstrap.debug(this, "Disposed " + l + " objects");
        delete this.__P_76_0;
      },

      /**
       * Returns the object registry.
       *
       * @return {Object} The registry
       */
      getRegistry: function () {
        return this.__P_76_0;
      },

      /**
       * Returns the next hash code that will be used.
       * 
       * @return {Integer} The next hash code
       * @internal
       */
      getNextHash: function () {
        return this.__P_76_1;
      },

      /**
       * Returns the postfix that identifies the current iframe
       *
       * @return {Integer} The next hash code
       * @internal
       */
      getPostId: function () {
        return this.__P_76_2;
      },

      /**
       * Returns the map of stack traces recorded when objects are registered
       * (for dispose profiling)
       * @return {Map} Map: object hash codes to stack traces
       * @internal
       */
      getStackTraces: function () {
        return this.__P_76_3;
      }
    },
    defer: function (statics) {
      if (window && window.top) {
        var frames = window.top.frames;

        for (var i = 0; i < frames.length; i++) {
          if (frames[i] === window) {
            statics.__P_76_2 = "-" + (i + 1);
            return;
          }
        }
      }

      statics.__P_76_2 = "-0";
    }
  });
  qx.core.ObjectRegistry.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2005-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * This class is the single point to access all settings that may be different
   * in different environments. This contains e.g. the browser name, engine
   * version but also qooxdoo or application specific settings.
   *
   * Its public API can be found in its four main methods. One pair of methods
   * is used to check the synchronous values of the environment. The other pair
   * of methods is used for asynchronous checks.
   *
   * The most often used method should be {@link #get}, which returns the
   * current value for a given environment check.
   *
   * All qooxdoo settings can be changed at compile time. See the manual
   * for more details about the environment key in the config. As you can see
   * from the methods API, there is no way to override an existing key. So if you
   * need to change a qooxdoo setting, you have to use the compiler to do so.
   *
   * The compiler is also responsible for requiring the necessary implementation
   * classes for each check. When using a check of a new category, make sure to
   * rebuild you application and let the compiler include the necessary files.
   *
   * When you define a new environment check, the compiler needs to know which class
   * implements the check; to do this, you can either prefix the name of your check 
   * with your class name (eg `my.package.MyClass.someEnvCheck`) or you can create
   * short names like the ones below and then add an entry to your library's
   * Manifest.json (under `provides.environmentChecks`).
   *
   * The following table shows the available checks. If you are
   * interested in more details, check the reference to the implementation of
   * each check. Please do not use those check implementations directly, as the
   * Environment class comes with a smart caching feature.
   *
   * <table border="0" cellspacing="10">
   *   <tbody>
   *     <tr>
   *       <td colspan="4"><h2>Synchronous checks</h2>
   *       </td>
   *     </tr>
   *     <tr>
   *       <th><h3>Key</h3></th>
   *       <th><h3>Type</h3></th>
   *       <th><h3>Example</h3></th>
   *       <th><h3>Details</h3></th>
   *     </tr>
   *     <tr>
   *       <td colspan="4"><b>browser</b></td>
   *     </tr>
   *     <tr>
   *       <td>browser.documentmode</td><td><i>Integer</i></td><td><code>0</code></td>
   *       <td>{@link qx.bom.client.Browser#getDocumentMode}</td>
   *     </tr>
   *     <tr>
   *       <td>browser.name</td><td><i>String</i></td><td><code> chrome </code></td>
   *       <td>{@link qx.bom.client.Browser#getName}</td>
   *     </tr>
   *     <tr>
   *       <td>browser.quirksmode</td><td><i>Boolean</i></td><td><code>false</code></td>
   *       <td>{@link qx.bom.client.Browser#getQuirksMode}</td>
   *     </tr>
   *     <tr>
   *       <td>browser.version</td><td><i>String</i></td><td><code>11.0</code></td>
   *       <td>{@link qx.bom.client.Browser#getVersion}</td>
   *     </tr>
   *     <tr>
   *       <td colspan="4"><b>runtime</b></td>
   *     </tr>
   *     <tr>
   *       <td>runtime.name</td><td><i> String </i></td><td><code> node.js </code></td>
   *       <td>{@link qx.bom.client.Runtime#getName}</td>
   *     </tr>
   *     <tr>
   *       <td colspan="4"><b>css</b></td>
   *     </tr>
   *     <tr>
   *       <td>css.borderradius</td><td><i>String</i> or <i>null</i></td><td><code>borderRadius</code></td>
   *       <td>{@link qx.bom.client.Css#getBorderRadius}</td>
   *     </tr>
   *     <tr>
   *       <td>css.borderimage</td><td><i>String</i> or <i>null</i></td><td><code>WebkitBorderImage</code></td>
   *       <td>{@link qx.bom.client.Css#getBorderImage}</td>
   *     </tr>
   *     <tr>
   *       <td>css.borderimage.standardsyntax</td><td><i>Boolean</i> or <i>null</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Css#getBorderImageSyntax}</td>
   *     </tr>
   *     <tr>
   *       <td>css.boxmodel</td><td><i>String</i></td><td><code>content</code></td>
   *       <td>{@link qx.bom.client.Css#getBoxModel}</td>
   *     </tr>
   *     <tr>
   *       <td>css.boxshadow</td><td><i>String</i> or <i>null</i></td><td><code>boxShadow</code></td>
   *       <td>{@link qx.bom.client.Css#getBoxShadow}</td>
   *     </tr>
   *     <tr>
   *       <td>css.gradient.linear</td><td><i>String</i> or <i>null</i></td><td><code>-moz-linear-gradient</code></td>
   *       <td>{@link qx.bom.client.Css#getLinearGradient}</td>
   *     </tr>
   *     <tr>
   *       <td>css.gradient.radial</td><td><i>String</i> or <i>null</i></td><td><code>-moz-radial-gradient</code></td>
   *       <td>{@link qx.bom.client.Css#getRadialGradient}</td>
   *     </tr>
   *     <tr>
   *       <td>css.gradient.legacywebkit</td><td><i>Boolean</i></td><td><code>false</code></td>
   *       <td>{@link qx.bom.client.Css#getLegacyWebkitGradient}</td>
   *     </tr>
   *     <tr>
   *       <td>css.placeholder</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Css#getPlaceholder}</td>
   *     </tr>
   *     <tr>
   *       <td>css.textoverflow</td><td><i>String</i> or <i>null</i></td><td><code>textOverflow</code></td>
   *       <td>{@link qx.bom.client.Css#getTextOverflow}</td>
   *     </tr>
   *     <tr>
   *       <td>css.rgba</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Css#getRgba}</td>
   *     </tr>
   *     <tr>
   *       <td>css.usermodify</td><td><i>String</i> or <i>null</i></td><td><code>WebkitUserModify</code></td>
   *       <td>{@link qx.bom.client.Css#getUserModify}</td>
   *     </tr>
   *     <tr>
   *       <td>css.appearance</td><td><i>String</i> or <i>null</i></td><td><code>WebkitAppearance</code></td>
   *       <td>{@link qx.bom.client.Css#getAppearance}</td>
   *     </tr>
   *     <tr>
   *       <td>css.float</td><td><i>String</i> or <i>null</i></td><td><code>cssFloat</code></td>
   *       <td>{@link qx.bom.client.Css#getFloat}</td>
   *     </tr>
   *     <tr>
   *       <td>css.userselect</td><td><i>String</i> or <i>null</i></td><td><code>WebkitUserSelect</code></td>
   *       <td>{@link qx.bom.client.Css#getUserSelect}</td>
   *     </tr>
   *     <tr>
   *       <td>css.userselect.none</td><td><i>String</i> or <i>null</i></td><td><code>-moz-none</code></td>
   *       <td>{@link qx.bom.client.Css#getUserSelectNone}</td>
   *     </tr>
   *     <tr>
   *       <td>css.boxsizing</td><td><i>String</i> or <i>null</i></td><td><code>boxSizing</code></td>
   *       <td>{@link qx.bom.client.Css#getBoxSizing}</td>
   *     </tr>
   *     <tr>
   *       <td>css.animation</td><td><i>Object</i> or <i>null</i></td><td><code>{end-event: "webkitAnimationEnd", keyframes: "@-webkit-keyframes", play-state: null, name: "WebkitAnimation"}</code></td>
   *       <td>{@link qx.bom.client.CssAnimation#getSupport}</td>
   *     </tr>
   *     <tr>
   *       <td>css.animation.requestframe</td><td><i>String</i> or <i>null</i></td><td><code>mozRequestAnimationFrame</code></td>
   *       <td>{@link qx.bom.client.CssAnimation#getRequestAnimationFrame}</td>
   *     </tr>
   *     <tr>
   *       <td>css.transform</td><td><i>Object</i> or <i>null</i></td><td><code>{3d: true, origin: "WebkitTransformOrigin", name: "WebkitTransform", style: "WebkitTransformStyle", perspective: "WebkitPerspective", perspective-origin: "WebkitPerspectiveOrigin", backface-visibility: "WebkitBackfaceVisibility"}</code></td>
   *       <td>{@link qx.bom.client.CssTransform#getSupport}</td>
   *     </tr>
   *     <tr>
   *       <td>css.transform.3d</td><td><i>Boolean</i></td><td><code>false</code></td>
   *       <td>{@link qx.bom.client.CssTransform#get3D}</td>
   *     </tr>
   *     <tr>
   *       <td>css.transition</td><td><i>Object</i> or <i>null</i></td><td><code>{end-event: "webkitTransitionEnd", name: "WebkitTransition"}</code></td>
   *       <td>{@link qx.bom.client.CssTransition#getSupport}</td>
   *     </tr>
   *     <tr>
   *       <td>css.inlineblock</td><td><i>String</i> or <i>null</i></td><td><code>inline-block</code></td>
   *       <td>{@link qx.bom.client.Css#getInlineBlock}</td>
   *     </tr>
   *     <tr>
   *       <td>css.opacity</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Css#getOpacity}</td>
   *     </tr>
   *     <tr>
   *       <td>css.textShadow</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Css#getTextShadow}</td>
   *     </tr>
   *     <tr>
   *       <td>css.alphaimageloaderneeded</td><td><i>Boolean</i></td><td><code>false</code></td>
   *       <td>{@link qx.bom.client.Css#getAlphaImageLoaderNeeded}</td>
   *     </tr>
   *     <tr>
   *       <td>css.pointerevents</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Css#getPointerEvents}</td>
   *     </tr>
   *     <tr>
   *       <td>css.flexboxSyntax</td><td><i>String</i> or <i>null</i></td><td><code>"flex"</code></td>
   *       <td>{@link qx.bom.client.Css#getFlexboxSyntax}</td>
   *     </tr>
   *     <tr>
   *       <td colspan="4"><b>device</b></td>
   *     </tr>
   *     <tr>
   *       <td>device.name</td><td><i>String</i></td><td><code>pc</code></td>
   *       <td>{@link qx.bom.client.Device#getName}</td>
   *     </tr>
   *     <tr>
   *       <td>device.type</td><td><i>String</i></td><td><code>mobile</code></td>
   *       <td>{@link qx.bom.client.Device#getType}</td>
   *     </tr>
   *     <tr>
   *       <td>device.pixelRatio</td><td><i>Number</i></td><td><code>2</code></td>
   *       <td>{@link qx.bom.client.Device#getDevicePixelRatio}</td>
   *     </tr>
   *     <tr>
   *       <td>device.touch</td><td><i>String</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Device#getTouch}</td>
   *     </tr>
   *     <tr>
   *       <td colspan="4"><b>ecmascript</b></td>
   *     </tr>
   *     <tr>
   *       <td>ecmascript.error.stacktrace</td><td><i>String</i> or <i>null</i></td><td><code>stack</code></td>
   *       <td>{@link qx.bom.client.EcmaScript#getStackTrace}</td>
   *     </tr>
   *     <tr>
   *       <td>ecmascript.mutationobserver</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.EcmaScript#getMutationObserver}</td>
   *     </tr>
   *     <tr>
   *       <td>ecmascript.bigint</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.EcmaScript#getBigInt}</td>
   *     </tr>
   *     <tr>
   *       <td>ecmascript.bigint.tolocalestring</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.EcmaScript#getBigIntToLocaleString}</td>
   *     </tr>
   *     <tr>
   *       <td>ecmascript.array.indexof<td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.EcmaScript#getArrayIndexOf}</td>
   *     </tr>
   *     <tr>
   *       <td>ecmascript.array.lastindexof<td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.EcmaScript#getArrayLastIndexOf}</td>
   *     </tr>
   *     <tr>
   *       <td>ecmascript.array.foreach<td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.EcmaScript#getArrayForEach}</td>
   *     </tr>
   *     <tr>
   *       <td>ecmascript.array.filter<td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.EcmaScript#getArrayFilter}</td>
   *     </tr>
   *     <tr>
   *       <td>ecmascript.array.map<td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.EcmaScript#getArrayMap}</td>
   *     </tr>
   *     <tr>
   *       <td>ecmascript.array.some<td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.EcmaScript#getArraySome}</td>
   *     </tr>
   *     <tr>
   *       <td>ecmascript.array.find<td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.EcmaScript#getArrayFind}</td>
   *     </tr>
   *     <tr>
   *       <td>ecmascript.array.findIndex<td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.EcmaScript#getArrayFindIndex}</td>
   *     </tr>
   *     <tr>
   *       <td>ecmascript.array.every<td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.EcmaScript#getArrayEvery}</td>
   *     </tr>
   *     <tr>
   *       <td>ecmascript.array.reduce<td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.EcmaScript#getArrayReduce}</td>
   *     </tr>
   *     <tr>
   *       <td>ecmascript.array.reduceright<td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.EcmaScript#getArrayReduceRight}</td>
   *     </tr>
   *     <tr>
   *       <td>ecmascript.function.bind<td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.EcmaScript#getFunctionBind}</td>
   *     </tr>
   *     <tr>
   *       <td>ecmascript.object.keys<td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.EcmaScript#getObjectKeys}</td>
   *     </tr>
   *     <tr>
   *       <td>ecmascript.date.now<td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.EcmaScript#getDateNow}</td>
   *     </tr>
   *     <tr>
   *       <td>ecmascript.date.parse<td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.EcmaScript#getDateParse}</td>
   *     </tr>
   *     <tr>
   *       <td>ecmascript.error.toString</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.EcmaScript#getErrorToString}</td>
   *     </tr>
   *     <tr>
   *       <td>ecmascript.string.trim</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.EcmaScript#getStringTrim}</td>
   *     </tr>
   *     <tr>
   *       <td>ecmascript.string.startsWith</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.EcmaScript#getStringStartsWith}</td>
   *     </tr>
   *     <tr>
   *       <td>ecmascript.string.endsWith</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.EcmaScript#getStringEndsWith}</td>
   *     </tr>
   *     <tr>
   *       <td colspan="4"><b>engine</b></td>
   *     </tr>
   *     <tr>
   *       <td>engine.name</td><td><i>String</i></td><td><code>webkit</code></td>
   *       <td>{@link qx.bom.client.Engine#getName}</td>
   *     </tr>
   *     <tr>
   *       <td>engine.version</td><td><i>String</i></td><td><code>534.24</code></td>
   *       <td>{@link qx.bom.client.Engine#getVersion}</td>
   *     </tr>
  
   *     <tr>
   *       <td colspan="4"><b>event</b></td>
   *     </tr>
   *      <tr>
   *       <td>event.mspointer</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Event#getMsPointer}</td>
   *     </tr>
   *     <tr>
   *       <td>event.touch</td><td><i>Boolean</i></td><td><code>false</code></td>
   *       <td>{@link qx.bom.client.Event#getTouch}</td>
   *     </tr>
   *     <tr>
   *       <td>event.help</td><td><i>Boolean</i></td><td><code>false</code></td>
   *       <td>{@link qx.bom.client.Event#getHelp}</td>
   *     </tr>
   *     <tr>
   *       <td>event.hashchange</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Event#getHashChange}</td>
   *     </tr>
   *     <tr>
   *       <td>event.dispatchevent</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Event#getDispatchEvent}</td>
   *     </tr>
   *     <tr>
   *       <td>event.customevent</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Event#getCustomEvent}</td>
   *     </tr>
   *     <tr>
   *       <td>event.mouseevent</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Event#getMouseEvent}</td>
   *     </tr>
   *     <tr>
   *       <td>event.mousecreateevent</td><td><i>String</i></td><td><code>UIEvents</code></td>
   *       <td>{@link qx.bom.client.Event#getMouseCreateEvent}</td>
   *     </tr>
   *     <tr>
   *       <td>event.mousewheel</td><td><i>Map</i></td><td><code>{type: "wheel", target: window}</code></td>
   *       <td>{@link qx.bom.client.Event#getMouseWheel}</td>
   *     </tr>
   *     <tr>
   *       <td>event.auxclick</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Event#getAuxclickEvent}</td>
   *     </tr>
   *     <tr>
   *       <td>event.passive</td><td><i>Map</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Event#getPassive}</td>
   *     </tr>
   *
   *     <tr>
   *       <td colspan="4"><b>html</b></td>
   *     </tr>
   *     <tr>
   *       <td>html.audio</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Html#getAudio}</td>
   *     </tr>
   *     <tr>
   *       <td>html.audio.mp3</td><td><i>String</i></td><td><code>""</code></td>
   *       <td>{@link qx.bom.client.Html#getAudioMp3}</td>
   *     </tr>
   *     <tr>
   *       <td>html.audio.ogg</td><td><i>String</i></td><td><code>"maybe"</code></td>
   *       <td>{@link qx.bom.client.Html#getAudioOgg}</td>
   *     </tr>
   *     <tr>
   *       <td>html.audio.wav</td><td><i>String</i></td><td><code>"probably"</code></td>
   *       <td>{@link qx.bom.client.Html#getAudioWav}</td>
   *     </tr>
   *     <tr>
   *       <td>html.audio.au</td><td><i>String</i></td><td><code>"maybe"</code></td>
   *       <td>{@link qx.bom.client.Html#getAudioAu}</td>
   *     </tr>
   *     <tr>
   *       <td>html.audio.aif</td><td><i>String</i></td><td><code>"probably"</code></td>
   *       <td>{@link qx.bom.client.Html#getAudioAif}</td>
   *     </tr>
   *     <tr>
   *       <td>html.canvas</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Html#getCanvas}</td>
   *     </tr>
   *     <tr>
   *       <td>html.classlist</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Html#getClassList}</td>
   *     </tr>
   *     <tr>
   *       <td>html.fullscreen</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Html#getFullScreen}</td>
   *     </tr>
   *     <tr>
   *       <td>html.geolocation</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Html#getGeoLocation}</td>
   *     </tr>
   *     <tr>
   *       <td>html.storage.local</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Html#getLocalStorage}</td>
   *     </tr>
   *     <tr>
   *       <td>html.storage.session</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Html#getSessionStorage}</td>
   *     </tr>
   *     <tr>
   *       <td>html.storage.userdata</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Html#getUserDataStorage}</td>
   *     </tr>
   *     <tr>
   *       <td>html.svg</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Html#getSvg}</td>
   *     </tr>
   *     <tr>
   *       <td>html.video</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Html#getVideo}</td>
   *     </tr>
   *     <tr>
   *       <td>html.video.h264</td><td><i>String</i></td><td><code>"probably"</code></td>
   *       <td>{@link qx.bom.client.Html#getVideoH264}</td>
   *     </tr>
   *     <tr>
   *       <td>html.video.ogg</td><td><i>String</i></td><td><code>""</code></td>
   *       <td>{@link qx.bom.client.Html#getVideoOgg}</td>
   *     </tr>
   *     <tr>
   *       <td>html.video.webm</td><td><i>String</i></td><td><code>"maybe"</code></td>
   *       <td>{@link qx.bom.client.Html#getVideoWebm}</td>
   *     </tr>
   *     <tr>
   *       <td>html.vml</td><td><i>Boolean</i></td><td><code>false</code></td>
   *       <td>{@link qx.bom.client.Html#getVml}</td>
   *     </tr>
   *     <tr>
   *       <td>html.webworker</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Html#getWebWorker}</td>
   *     <tr>
   *       <td>html.filereader</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Html#getFileReader}</td>
   *     </tr>
   *     <tr>
   *       <td>html.xpath</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Html#getXPath}</td>
   *     </tr>
   *     <tr>
   *       <td>html.xul</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Html#getXul}</td>
   *     </tr>
   *     <tr>
   *       <td>html.console</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Html#getConsole}</td>
   *     </tr>
   *     <tr>
   *       <td>html.element.contains</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Html#getContains}</td>
   *     </tr>
   *     <tr>
   *       <td>html.element.compareDocumentPosition</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Html#getCompareDocumentPosition}</td>
   *     </tr>
   *     <tr>
   *       <td>html.element.textContent</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Html#getTextContent}</td>
   *     </tr>
   *     <tr>
   *       <td>html.image.naturaldimensions</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Html#getNaturalDimensions}</td>
   *     </tr>
   *     <tr>
   *       <td>html.history.state</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Html#getHistoryState}</td>
   *     </tr>
   *     <tr>
   *       <td>html.selection</td><td><i>String</i></td><td><code>getSelection</code></td>
   *       <td>{@link qx.bom.client.Html#getSelection}</td>
   *     </tr>
   *     <tr>
   *       <td>html.node.isequalnode</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Html#getIsEqualNode}</td>
   *     </tr>
   *     <tr>
   *       <td colspan="4"><b>XML</b></td>
   *     </tr>
   *     <tr>
   *       <td>xml.implementation</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Xml#getImplementation}</td>
   *     </tr>
   *     <tr>
   *       <td>xml.domparser</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Xml#getDomParser}</td>
   *     </tr>
   *     <tr>
   *       <td>xml.selectsinglenode</td><td><i>Boolean</i></td><td><code>false</code></td>
   *       <td>{@link qx.bom.client.Xml#getSelectSingleNode}</td>
   *     </tr>
   *     <tr>
   *       <td>xml.selectnodes</td><td><i>Boolean</i></td><td><code>false</code></td>
   *       <td>{@link qx.bom.client.Xml#getSelectNodes}</td>
   *     </tr>
   *     <tr>
   *       <td>xml.getelementsbytagnamens</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Xml#getElementsByTagNameNS}</td>
   *     </tr>
   *     <tr>
   *       <td>xml.domproperties</td><td><i>Boolean</i></td><td><code>false</code></td>
   *       <td>{@link qx.bom.client.Xml#getDomProperties}</td>
   *     </tr>
   *     <tr>
   *       <td>xml.attributens</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Xml#getAttributeNS}</td>
   *     </tr>
   *     <tr>
   *       <td>xml.createelementns</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Xml#getCreateElementNS}</td>
   *     </tr>
   *     <tr>
   *       <td>xml.createnode</td><td><i>Boolean</i></td><td><code>false</code></td>
   *       <td>{@link qx.bom.client.Xml#getCreateNode}</td>
   *     </tr>
   *     <tr>
   *       <td>xml.getqualifieditem</td><td><i>Boolean</i></td><td><code>false</code></td>
   *       <td>{@link qx.bom.client.Xml#getQualifiedItem}</td>
   *     </tr>
  
   *     <tr>
   *       <td colspan="4"><b>Stylesheets</b></td>
   *     </tr>
   *     <tr>
   *       <td>html.stylesheet.createstylesheet</td><td><i>Boolean</i></td><td><code>false</code></td>
   *       <td>{@link qx.bom.client.Stylesheet#getCreateStyleSheet}</td>
   *     </tr>
   *     <tr>
   *       <td>html.stylesheet.insertrule</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Stylesheet#getInsertRule}</td>
   *     </tr>
   *     <tr>
   *       <td>html.stylesheet.deleterule</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Stylesheet#getDeleteRule}</td>
   *     </tr>
   *     <tr>
   *       <td>html.stylesheet.addimport</td><td><i>Boolean</i></td><td><code>false</code></td>
   *       <td>{@link qx.bom.client.Stylesheet#getAddImport}</td>
   *     </tr>
   *     <tr>
   *       <td>html.stylesheet.removeimport</td><td><i>Boolean</i></td><td><code>false</code></td>
   *       <td>{@link qx.bom.client.Stylesheet#getRemoveImport}</td>
   *     </tr>
  
   *     <tr>
   *       <td colspan="4"><b>io</b></td>
   *     </tr>
   *     <tr>
   *       <td>io.maxrequests</td><td><i>Integer</i></td><td><code>4</code></td>
   *       <td>{@link qx.bom.client.Transport#getMaxConcurrentRequestCount}</td>
   *     </tr>
   *     <tr>
   *       <td>io.ssl</td><td><i>Boolean</i></td><td><code>false</code></td>
   *       <td>{@link qx.bom.client.Transport#getSsl}</td>
   *     </tr>
   *     <tr>
   *       <td>io.xhr</td><td><i>String</i></td><td><code>xhr</code></td>
   *       <td>{@link qx.bom.client.Transport#getXmlHttpRequest}</td>
   *     </tr>
  
   *     <tr>
   *       <td colspan="4"><b>locale</b></td>
   *     </tr>
   *     <tr>
   *       <td>locale</td><td><i>String</i></td><td><code>de</code></td>
   *       <td>{@link qx.bom.client.Locale#getLocale}</td>
   *     </tr>
   *     <tr>
   *       <td>locale.variant</td><td><i>String</i></td><td><code>de</code></td>
   *       <td>{@link qx.bom.client.Locale#getVariant}</td>
   *     </tr>
   *     <tr>
   *       <td>locale.default</td><td><i>String</i></td><td><code>C</code></td>
   *       <td>default locale C as in good tradition of unix {@link qx.bom.client.Locale}</td>
   *     </tr>
  
   *     <tr>
   *       <td colspan="4"><b>os</b></td>
   *     </tr>
   *     <tr>
   *       <td>os.name</td><td><i>String</i></td><td><code>osx</code></td>
   *       <td>{@link qx.bom.client.OperatingSystem#getName}</td>
   *     </tr>
   *     <tr>
   *       <td>os.version</td><td><i>String</i></td><td><code>10.6</code></td>
   *       <td>{@link qx.bom.client.OperatingSystem#getVersion}</td>
   *     </tr>
   *     <tr>
   *       <td>os.scrollBarOverlayed</td><td><i>Boolean</i></td><td><code>false</code></td>
   *       <td>{@link qx.bom.client.Scroll#scrollBarOverlayed}</td>
   *     </tr>
  
   *     <tr>
   *       <td colspan="4"><b>phonegap</b></td>
   *     </tr>
   *     <tr>
   *       <td>phonegap</td><td><i>Boolean</i></td><td><code>false</code></td>
   *       <td>{@link qx.bom.client.PhoneGap#getPhoneGap}</td>
   *     </tr>
   *     <tr>
   *       <td>phonegap.notification</td><td><i>Boolean</i></td><td><code>false</code></td>
   *       <td>{@link qx.bom.client.PhoneGap#getNotification}</td>
   *     </tr>
  
   *     <tr>
   *       <td colspan="4"><b>plugin</b></td>
   *     </tr>
   *     <tr>
   *       <td>plugin.divx</td><td><i>Boolean</i></td><td><code>false</code></td>
   *       <td>{@link qx.bom.client.Plugin#getDivX}</td>
   *     </tr>
   *     <tr>
   *       <td>plugin.divx.version</td><td><i>String</i></td><td></td>
   *       <td>{@link qx.bom.client.Plugin#getDivXVersion}</td>
   *     </tr>
   *     <tr>
   *       <td>plugin.flash</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Flash#isAvailable}</td>
   *     </tr>
   *     <tr>
   *       <td>plugin.flash.express</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Flash#getExpressInstall}</td>
   *     </tr>
   *     <tr>
   *       <td>plugin.flash.strictsecurity</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Flash#getStrictSecurityModel}</td>
   *     </tr>
   *     <tr>
   *       <td>plugin.flash.version</td><td><i>String</i></td><td><code>10.2.154</code></td>
   *       <td>{@link qx.bom.client.Flash#getVersion}</td>
   *     </tr>
   *     <tr>
   *       <td>plugin.gears</td><td><i>Boolean</i></td><td><code>false</code></td>
   *       <td>{@link qx.bom.client.Plugin#getGears}</td>
   *     </tr>
   *     <tr>
   *       <td>plugin.activex</td><td><i>Boolean</i></td><td><code>false</code></td>
   *       <td>{@link qx.bom.client.Plugin#getActiveX}</td>
   *     </tr>
   *     <tr>
   *       <td>plugin.skype</td><td><i>Boolean</i></td><td><code>false</code></td>
   *       <td>{@link qx.bom.client.Plugin#getSkype}</td>
   *     </tr>
   *     <tr>
   *       <td>plugin.pdf</td><td><i>Boolean</i></td><td><code>false</code></td>
   *       <td>{@link qx.bom.client.Plugin#getPdf}</td>
   *     </tr>
   *     <tr>
   *       <td>plugin.pdf.version</td><td><i>String</i></td><td></td>
   *       <td>{@link qx.bom.client.Plugin#getPdfVersion}</td>
   *     </tr>
   *     <tr>
   *       <td>plugin.quicktime</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Plugin#getQuicktime}</td>
   *     </tr>
   *     <tr>
   *       <td>plugin.quicktime.version</td><td><i>String</i></td><td><code>7.6</code></td>
   *       <td>{@link qx.bom.client.Plugin#getQuicktimeVersion}</td>
   *     </tr>
   *     <tr>
   *       <td>plugin.silverlight</td><td><i>Boolean</i></td><td><code>false</code></td>
   *       <td>{@link qx.bom.client.Plugin#getSilverlight}</td>
   *     </tr>
   *     <tr>
   *       <td>plugin.silverlight.version</td><td><i>String</i></td><td></td>
   *       <td>{@link qx.bom.client.Plugin#getSilverlightVersion}</td>
   *     </tr>
   *     <tr>
   *       <td>plugin.windowsmedia</td><td><i>Boolean</i></td><td><code>false</code></td>
   *       <td>{@link qx.bom.client.Plugin#getWindowsMedia}</td>
   *     </tr>
   *     <tr>
   *       <td>plugin.windowsmedia.version</td><td><i>String</i></td><td></td>
   *       <td>{@link qx.bom.client.Plugin#getWindowsMediaVersion}</td>
   *     </tr>
  
   *     <tr>
   *       <td colspan="4"><b>qx</b></td>
   *     </tr>
   *     <tr>
   *       <td>qx.allowUrlSettings</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td><i>default:</i> <code>false</code></td>
   *     </tr>
   *     <tr>
   *       <td>qx.allowUrlVariants</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td><i>default:</i> <code>false</code></td>
   *     </tr>
   *     <tr>
   *       <td>qx.application</td><td><i>String</i></td><td><code>name.space</code></td>
   *       <td><i>default:</i> <code>&lt;&lt;application name&gt;&gt;</code></td>
   *     </tr>
   *     <tr>
   *       <td>qx.aspects</td><td><i>Boolean</i></td><td><code>false</code></td>
   *       <td><i>default:</i> <code>false</code></td>
   *     </tr>
   *     <tr>
   *       <td>qx.debug</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td><i>default:</i> <code>true</code></td>
   *     </tr>
   *     <tr>
   *       <td>qx.debug.databinding</td><td><i>Boolean</i></td><td><code>false</code></td>
   *       <td><i>default:</i> <code>false</code></td>
   *     </tr>
   *     <tr>
   *       <td>qx.debug.dispose</td><td><i>Boolean</i></td><td><code>false</code></td>
   *       <td><i>default:</i> <code>false</code></td>
   *     </tr>
   *     <tr>
   *       <td>qx.debug.dispose.level</td><td><i>Integer</i></td><td><code>0</code></td>
   *       <td><i>default:</i> <code>0</code></td>
   *     </tr>
   *     <tr>
   *       <td>qx.debug.io</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td><i>default:</i> <code>false</code></td>
   *     </tr>
   *     <tr>
   *     <tr>
   *       <td>qx.debug.io.remote</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td><i>default:</i> <code>false</code></td>
   *     </tr>
   *     <tr>
   *     <tr>
   *       <td>qx.debug.io.remote.data</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td><i>default:</i> <code>false</code></td>
   *     </tr>
   *     <tr>
   *       <td>qx.debug.property.level</td><td><i>Integer</i></td><td><code>0</code></td>
   *       <td><i>default:</i> <code>0</code></td>
   *     </tr>
   *     <tr>
   *       <td>qx.debug.ui.queue</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td><i>default:</i> <code>true</code></td>
   *     </tr>
   *     <tr>
   *       <td>qx.dynlocale</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td><i>default:</i> <code>true</code></td>
   *     </tr>
   *     <tr>
   *       <td>qx.dyntheme</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td><i>default:</i> <code>true</code></td>
   *     </tr>
   *     <tr>
   *       <td>qx.globalErrorHandling</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td><i>default:</i> <code>true</code> {@link qx.event.GlobalError}</td>
   *     </tr>
   *     <tr>
   *       <td>qx.mobile.nativescroll</td><td><i>Boolean</i></td><td><code>false</code></td>
   *       <td>{@link qx.bom.client.Scroll#getNativeScroll}</td>
   *     </tr>
   *     <tr>
   *       <td>qx.promise.warnings</td><td><i>Boolean</i></td><td>same as <code>qx.debug</code></td>
   *       <td>true to enable runtime warnings in promises {@link qx.Promise}</td>
   *     </tr>
   *     <tr>
   *       <td>qx.promise.longStackTraces</td><td><i>Boolean</i></td><td><code>false</code></td>
   *       <td>true to enable long stack traces in promises; this has a performance penalty but makes debugging asynchronous functions easier {@link qx.Promise}</td>
   *     </tr>
   *     <tr>
   *       <td>qx.optimization.basecalls</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>true if the corresponding <i>optimize</i> key is set in the config</td>
   *     </tr>
   *     <tr>
   *       <td>qx.optimization.comments</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>true if the corresponding <i>optimize</i> key is set in the config</td>
   *     </tr>
   *     <tr>
   *       <td>qx.optimization.privates</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>true if the corresponding <i>optimize</i> key is set in the config</td>
   *     </tr>
   *     <tr>
   *       <td>qx.optimization.strings</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>true if the corresponding <i>optimize</i> key is set in the config</td>
   *     </tr>
   *     <tr>
   *       <td>qx.optimization.variables</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>true if the corresponding <i>optimize</i> key is set in the config</td>
   *     </tr>
   *     <tr>
   *       <td>qx.optimization.variants</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>true if the corresponding <i>optimize</i> key is set in the config</td>
   *     </tr>
   *     <tr>
   *       <td>qx.revision</td><td><i>String</i></td><td><code>27348</code></td>
   *     </tr>
   *     <tr>
   *       <td>qx.theme</td><td><i>String</i></td><td><code>qx.theme.Modern</code></td>
   *       <td><i>default:</i> <code>&lt;&lt;initial theme name&gt;&gt;</code></td>
   *     </tr>
   *     <tr>
   *       <td>qx.version</td><td><i>String</i></td><td><code>${qxversion}</code></td>
   *     </tr>
   *     <tr>
   *       <td>qx.blankpage</td><td><i>String</i></td><td><code>URI to blank.html page</code></td>
   *     </tr>
  
   *     <tr>
   *       <td colspan="4"><b>module</b></td>
   *     </tr>
   *     <tr>
   *       <td>module.databinding</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td><i>default:</i> <code>true</code></td>
   *     </tr>
   *     <tr>
   *       <td>module.logger</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td><i>default:</i> <code>true</code></td>
   *     </tr>
   *     <tr>
   *       <td>module.property</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td><i>default:</i> <code>true</code></td>
   *     </tr>
   *     <tr>
   *       <td>module.events</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td><i>default:</i> <code>true</code></td>
   *     </tr>
   *     <tr>
   *       <td>module.objectid</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td><i>default:</i> <code>true</code></td>
   *     </tr>
   *     <tr>
   *       <td colspan="4"><h3>Asynchronous checks</h3>
   *       </td>
   *     </tr>
   *     <tr>
   *       <td>html.dataurl</td><td><i>Boolean</i></td><td><code>true</code></td>
   *       <td>{@link qx.bom.client.Html#getDataUrl}</td>
   *     </tr>
   *     <tr>
   *       <td>plugin.pdfjs</td><td><i>Boolean</i></td><td><code>false</code></td>
   *       <td>{@link qx.bom.client.Pdfjs#getPdfjs}</td>
   *     </tr>
   *   </tbody>
   * </table>
   *
   */
  qx.Bootstrap.define("qx.core.Environment", {
    statics: {
      /** Map containing the synchronous check functions. */
      _checks: {},

      /** Map containing the asynchronous check functions. */
      _asyncChecks: {},

      /** Internal cache for all checks. */
      __P_55_0: {},

      /**
       * Internal map for environment keys to check methods.
       * Gets populated dynamically at runtime.
       */
      _checksMap: {},
      _defaults: {
        // an always-true key (e.g. for use in qx.core.Environment.filter() calls)
        "true": true,
        // old settings retTrue
        "qx.allowUrlSettings": false,
        "qx.allowUrlVariants": false,
        "qx.debug.property.level": 0,
        // old variants
        // make sure to reflect all changes to qx.debug here in the bootstrap class!
        "qx.debug": true,
        "qx.debug.ui.queue": true,
        "qx.debug.touchpad.detection": false,
        "qx.aspects": false,
        "qx.dynlocale": true,
        "qx.dyntheme": true,
        "qx.blankpage": "qx/static/blank.html",
        "qx.debug.databinding": false,
        "qx.debug.dispose": false,
        // generator optimization vectors
        "qx.optimization.basecalls": false,
        "qx.optimization.comments": false,
        "qx.optimization.privates": false,
        "qx.optimization.strings": false,
        "qx.optimization.variables": false,
        "qx.optimization.variants": false,
        // qooxdoo modules
        "module.databinding": true,
        "module.logger": true,
        "module.property": true,
        "module.events": true,
        "module.objectid": true,
        "qx.nativeScrollBars": false,
        "qx.automaticMemoryManagement": true,
        "qx.promise": true,
        "qx.promise.warnings": true,
        "qx.promise.longStackTraces": true,
        "qx.command.bindEnabled": false
      },

      /**
       * The default accessor for the checks. It returns the value the current
       * environment has for the given key. The key could be something like
       * "qx.debug", "css.textoverflow" or "io.ssl". A complete list of
       * checks can be found in the class comment of this class.
       *
       * Please keep in mind that the result is cached. If you want to run the
       * check function again in case something could have been changed, take a
       * look at the {@link #invalidateCacheKey} function.
       *
       * @param key {String} The name of the check you want to query.
       * @return {var} The stored value depending on the given key.
       *   (Details in the class doc)
       */
      get: function (key) {
        // check the cache
        if (this.__P_55_0[key] != undefined) {
          return this.__P_55_0[key];
        } // search for a matching check


        var check = this._checks[key];

        if (check) {
          // execute the check and write the result in the cache
          var value = check();
          this.__P_55_0[key] = value;
          return value;
        } // try class lookup


        var classAndMethod = this._getClassNameFromEnvKey(key);

        if (classAndMethod[0] != undefined) {
          var clazz = classAndMethod[0];
          var method = classAndMethod[1];
          var value = clazz[method](); // call the check method

          this.__P_55_0[key] = value;
          return value;
        } // debug flag


        if (qx.Bootstrap.DEBUG) {
          qx.Bootstrap.warn("The environment key '" + key + "' is undefined.");
          qx.Bootstrap.trace(this);
        }
      },

      /**
       * Maps an environment key to a check class and method name.
       *
       * @param key {String} The name of the check you want to query.
       * @return {Array} [className, methodName] of
       *  the corresponding implementation.
       */
      _getClassNameFromEnvKey: function (key) {
        var envmappings = this._checksMap;

        if (envmappings[key] != undefined) {
          var implementation = envmappings[key]; // separate class from method

          var lastdot = implementation.lastIndexOf(".");

          if (lastdot > -1) {
            var classname = implementation.slice(0, lastdot);
            var methodname = implementation.slice(lastdot + 1);
            var clazz = qx.Bootstrap.getByName(classname);

            if (clazz != undefined) {
              return [clazz, methodname];
            }
          }
        }

        return [undefined, undefined];
      },

      /**
       * Invokes the callback as soon as the check has been done. If no check
       * could be found, a warning will be printed.
       *
       * @param key {String} The key of the asynchronous check.
       * @param callback {Function} The function to call as soon as the check is
       *   done. The function should have one argument which is the result of the
       *   check.
       * @param self {var} The context to use when invoking the callback.
       */
      getAsync: function (key, callback, self) {
        // check the cache
        var env = this;

        if (this.__P_55_0[key] != undefined) {
          // force async behavior
          window.setTimeout(function () {
            callback.call(self, env.__P_55_0[key]);
          }, 0);
          return;
        }

        var check = this._asyncChecks[key];

        if (check) {
          check(function (result) {
            env.__P_55_0[key] = result;
            callback.call(self, result);
          });
          return;
        } // try class lookup


        var classAndMethod = this._getClassNameFromEnvKey(key);

        if (classAndMethod[0] != undefined) {
          var clazz = classAndMethod[0];
          var method = classAndMethod[1];
          clazz[method](function (result) {
            // call the check method
            env.__P_55_0[key] = result;
            callback.call(self, result);
          });
          return;
        } // debug flag


        if (qx.Bootstrap.DEBUG) {
          qx.Bootstrap.warn("The environment key '" + key + "' is undefined.");
          qx.Bootstrap.trace(this);
        }
      },

      /**
       * Returns the proper value dependent on the check for the given key.
       *
       * @param key {String} The name of the check the select depends on.
       * @param values {Map} A map containing the values which should be returned
       *   in any case. The "default" key could be used as a catch all statement.
       * @return {var} The value which is stored in the map for the given
       *   check of the key.
       */
      select: function (key, values) {
        return this.__P_55_1(this.get(key), values);
      },

      /**
       * Selects the proper function dependent on the asynchronous check.
       *
       * @param key {String} The key for the async check.
       * @param values {Map} A map containing functions. The map keys should
       *   contain all possibilities which could be returned by the given check
       *   key. The "default" key could be used as a catch all statement.
       *   The called function will get one parameter, the result of the query.
       * @param self {var} The context which should be used when calling the
       *   method in the values map.
       */
      selectAsync: function (key, values, self) {
        this.getAsync(key, function (result) {
          var value = this.__P_55_1(key, values);

          value.call(self, result);
        }, this);
      },

      /**
       * Internal helper which tries to pick the given key from the given values
       * map. If that key is not found, it tries to use a key named "default".
       * If there is also no default key, it prints out a warning and returns
       * undefined.
       *
       * @param key {String} The key to search for in the values.
       * @param values {Map} A map containing some keys.
       * @return {var} The value stored as values[key] usually.
       */
      __P_55_1: function (key, values) {
        var value = values[key];

        if (values.hasOwnProperty(key)) {
          return value;
        } // check for piped values


        for (var id in values) {
          if (id.indexOf("|") != -1) {
            var ids = id.split("|");

            for (var i = 0; i < ids.length; i++) {
              if (ids[i] == key) {
                return values[id];
              }
            }

            ;
          }
        }

        if (values["default"] !== undefined) {
          return values["default"];
        }

        if (qx.Bootstrap.DEBUG) {
          throw new Error('No match for variant "' + key + '" (' + typeof key + ' type)' + ' in variants [' + qx.Bootstrap.keys(values) + '] found, and no default ("default") given');
        }
      },

      /**
       * Takes a given map containing the check names as keys and converts
       * the map to an array only containing the values for check evaluating
       * to <code>true</code>. This is especially handy for conditional
       * includes of mixins.
       * @param map {Map} A map containing check names as keys and values.
       * @return {Array} An array containing the values.
       */
      filter: function (map) {
        var returnArray = [];

        for (var check in map) {
          if (this.get(check)) {
            returnArray.push(map[check]);
          }
        }

        return returnArray;
      },

      /**
       * Invalidates the cache for the given key.
       *
       * @param key {String} The key of the check.
       */
      invalidateCacheKey: function (key) {
        delete this.__P_55_0[key];
      },

      /**
       * Add a check to the environment class. If there is already a check
       * added for the given key, the add will be ignored.
       *
       * @param key {String} The key for the check e.g. html.featurexyz.
       * @param check {var} It could be either a function or a simple value.
       *   The function should be responsible for the check and should return the
       *   result of the check.
       */
      add: function (key, check) {
        // ignore already added checks.
        if (this._checks[key] == undefined) {
          // add functions directly
          if (check instanceof Function) {
            if (!this._checksMap[key] && check.displayName) {
              this._checksMap[key] = check.displayName.substr(0, check.displayName.length - 2);
            }

            this._checks[key] = check; // otherwise, create a check function and use that
          } else {
            this._checks[key] = this.__P_55_2(check);
          }
        }
      },

      /**
       * Adds an asynchronous check to the environment. If there is already a check
       * added for the given key, the add will be ignored.
       *
       * @param key {String} The key of the check e.g. html.featureabc
       * @param check {Function} A function which should check for a specific
       *   environment setting in an asynchronous way. The method should take two
       *   arguments. First one is the callback and the second one is the context.
       */
      addAsync: function (key, check) {
        if (this._checks[key] == undefined) {
          this._asyncChecks[key] = check;
        }
      },

      /**
       * Returns all currently defined synchronous checks.
       *
       * @internal
       * @return {Map} The map of synchronous checks
       */
      getChecks: function () {
        return this._checks;
      },

      /**
       * Returns all currently defined asynchronous checks.
       *
       * @internal
       * @return {Map} The map of asynchronous checks
       */
      getAsyncChecks: function () {
        return this._asyncChecks;
      },

      /**
       * Initializer for the default values of the framework settings.
       */
      _initDefaultQxValues: function () {
        var createFuncReturning = function (val) {
          return function () {
            return val;
          };
        };

        for (var prop in this._defaults) {
          this.add(prop, createFuncReturning(this._defaults[prop]));
        }
      },

      /**
       * Import checks from global qx.$$environment into the Environment class.
       */
      __P_55_3: function () {
        // import the environment map
        if (qx && qx.$$environment) {
          for (var key in qx.$$environment) {
            var value = qx.$$environment[key];
            this._checks[key] = this.__P_55_2(value);
          }
        }
      },

      /**
       * Checks the URL for environment settings and imports these into the
       * Environment class.
       */
      __P_55_4: function () {
        if (window.document && window.document.location) {
          var urlChecks = window.document.location.search.slice(1).split("&");

          for (var i = 0; i < urlChecks.length; i++) {
            var check = urlChecks[i].split(":");

            if (check.length != 3 || check[0] != "qxenv") {
              continue;
            }

            var key = check[1];
            var value = decodeURIComponent(check[2]); // implicit type conversion

            if (value == "true") {
              value = true;
            } else if (value == "false") {
              value = false;
            } else if (/^(\d|\.)+$/.test(value)) {
              value = parseFloat(value);
            }

            this._checks[key] = this.__P_55_2(value);
          }
        }
      },

      /**
       * Internal helper which creates a function returning the given value.
       *
       * @param value {var} The value which should be returned.
       * @return {Function} A function which could be used by a test.
       */
      __P_55_2: function (value) {
        return qx.Bootstrap.bind(function (value) {
          return value;
        }, null, value);
      }
    },
    defer: function (statics) {
      // create default values for the environment class
      statics._initDefaultQxValues(); // load the checks from the generator


      statics.__P_55_3(); // load the checks from the url


      if (statics.get("qx.allowUrlSettings") === true) {
        statics.__P_55_4();
      }
    }
  });
  qx.core.Environment.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Environment": {
        "defer": "runtime"
      }
    },
    "environment": {
      "provided": ["ecmascript.array.indexof", "ecmascript.array.lastindexof", "ecmascript.array.foreach", "ecmascript.array.filter", "ecmascript.array.map", "ecmascript.array.some", "ecmascript.array.find", "ecmascript.array.findIndex", "ecmascript.array.every", "ecmascript.array.reduce", "ecmascript.array.reduceright", "ecmascript.array.includes", "ecmascript.date.now", "ecmascript.date.parse", "ecmascript.error.toString", "ecmascript.error.stacktrace", "ecmascript.function.bind", "ecmascript.object.keys", "ecmascript.object.values", "ecmascript.object.is", "ecmascript.object.assign", "ecmascript.number.EPSILON", "ecmascript.string.startsWith", "ecmascript.string.endsWith", "ecmascript.string.trim", "ecmascript.string.codePointAt", "ecmascript.string.fromCodePoint", "ecmascript.function.async", "ecmascript.mutationobserver", "ecmascript.bigint", "ecmascript.bigint.tolocalestring", "ecmascript.promise.native"],
      "required": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * The main purpose of this class to hold all checks about ECMAScript.
   *
   * This class is used by {@link qx.core.Environment} and should not be used
   * directly. Please check its class comment for details how to use it.
   *
   * @internal
   */
  qx.Bootstrap.define("qx.bom.client.EcmaScript", {
    statics: {
      /**
       * Returns the name of the Error object property that holds stack trace
       * information or null if the client does not provide any.
       *
       * @internal
       * @return {String|null} <code>stack</code>, <code>stacktrace</code> or
       * <code>null</code>
       */
      getStackTrace: function () {
        var propName;
        var e = new Error("e");
        propName = e.stack ? "stack" : e.stacktrace ? "stacktrace" : null; // only thrown errors have the stack property in IE10 and PhantomJS

        if (!propName) {
          try {
            throw e;
          } catch (ex) {
            e = ex;
          }
        }

        return e.stacktrace ? "stacktrace" : e.stack ? "stack" : null;
      },

      /**
       * Checks if 'MutationObserver' is supported.
       * @internal
       * @ignore(MutationObserver)
       * @return {Boolean} <code>true</code>, if MutationObserver is available.
       */
      getMutationObserver: function () {
        return typeof MutationObserver != "undefined";
      },

      /**
       * Checks if 'indexOf' is supported on the Array object.
       * @internal
       * @return {Boolean} <code>true</code>, if the method is available.
       */
      getArrayIndexOf: function () {
        return !!Array.prototype.indexOf;
      },

      /**
       * Checks if 'lastIndexOf' is supported on the Array object.
       * @internal
       * @return {Boolean} <code>true</code>, if the method is available.
       */
      getArrayLastIndexOf: function () {
        return !!Array.prototype.lastIndexOf;
      },

      /**
       * Checks if 'forEach' is supported on the Array object.
       * @internal
       * @return {Boolean} <code>true</code>, if the method is available.
       */
      getArrayForEach: function () {
        return !!Array.prototype.forEach;
      },

      /**
       * Checks if 'filter' is supported on the Array object.
       * @internal
       * @return {Boolean} <code>true</code>, if the method is available.
       */
      getArrayFilter: function () {
        return !!Array.prototype.filter;
      },

      /**
       * Checks if 'map' is supported on the Array object.
       * @internal
       * @return {Boolean} <code>true</code>, if the method is available.
       */
      getArrayMap: function () {
        return !!Array.prototype.map;
      },

      /**
       * Checks if 'some' is supported on the Array object.
       * @internal
       * @return {Boolean} <code>true</code>, if the method is available.
       */
      getArraySome: function () {
        return !!Array.prototype.some;
      },

      /**
       * Checks if 'find' is supported on the Array object.
       * @internal
       * @return {Boolean} <code>true</code>, if the method is available.
       */
      getArrayFind: function () {
        return !!Array.prototype.find;
      },

      /**
       * Checks if 'findIndex' is supported on the Array object.
       * @internal
       * @return {Boolean} <code>true</code>, if the method is available.
       */
      getArrayFindIndex: function () {
        return !!Array.prototype.findIndex;
      },

      /**
       * Checks if 'every' is supported on the Array object.
       * @internal
       * @return {Boolean} <code>true</code>, if the method is available.
       */
      getArrayEvery: function () {
        return !!Array.prototype.every;
      },

      /**
       * Checks if 'reduce' is supported on the Array object.
       * @internal
       * @return {Boolean} <code>true</code>, if the method is available.
       */
      getArrayReduce: function () {
        return !!Array.prototype.reduce;
      },

      /**
       * Checks if 'reduceRight' is supported on the Array object.
       * @internal
       * @return {Boolean} <code>true</code>, if the method is available.
       */
      getArrayReduceRight: function () {
        return !!Array.prototype.reduceRight;
      },

      /**
       * Checks if 'includes' is supported on the Array object.
       * @internal
       * @return {Boolean} <code>true</code>, if the method is available.
       */
      getArrayIncludes: function () {
        return !!Array.prototype.includes;
      },

      /**
       * Checks if 'toString' is supported on the Error object and
       * its working as expected.
       * @internal
       * @return {Boolean} <code>true</code>, if the method is available.
       */
      getErrorToString: function () {
        return typeof Error.prototype.toString == "function" && Error.prototype.toString() !== "[object Error]";
      },

      /**
       * Checks if 'bind' is supported on the Function object.
       * @internal
       * @return {Boolean} <code>true</code>, if the method is available.
       */
      getFunctionBind: function () {
        return typeof Function.prototype.bind === "function";
      },

      /**
       * Checks if creating async functions are supported
       *
       * @lint ignoreDeprecated(alert, eval)
       *
       * @internal
       * @return {Boolean} <code>true</code>, if async functions are supported
       */
      getAsyncFunction: function () {
        var f;

        try {
          eval("f = async function(){};");
        } catch (e) {
          return false;
        }

        ;
        return qx.Bootstrap.getClass(f) === "AsyncFunction";
      },

      /**
       * Checks if 'keys' is supported on the Object object.
       * @internal
       * @return {Boolean} <code>true</code>, if the method is available.
       */
      getObjectKeys: function () {
        return !!Object.keys;
      },

      /**
       * Checks if 'values' is supported on the Object object.
       * @internal
       * @return {Boolean} <code>true</code>, if the method is available.
       */
      getObjectValues: function () {
        return !!Object.values;
      },

      /**
       * Checks if 'is' is supported on the Object object.
       * @internal
       * @return {Boolean} <code>true</code>, if the method is available.
       */
      getObjectIs: function () {
        return !!Object.is;
      },

      /**
       * Checks if 'assign' is supported on the Object object.
       * @internal
       * @return {Boolean} <code>true</code>, if the method is available.
       */
      getObjectAssign: function () {
        return !!Object.assign;
      },

      /**
       * Checks if 'now' is supported on the Date object.
       * @internal
       * @return {Boolean} <code>true</code>, if the method is available.
       */
      getDateNow: function () {
        return !!Date.now;
      },

      /**
       * Checks if 'parse' is supported on the Date object and whether it
       * supports ISO-8601 parsing. Additionally it checks if 'parse' takes
       * ISO-8601 date strings without timezone specifier and treats them as
       * local (as per specification)
       * @internal
       * @return {Boolean} <code>true</code>, if the method supports ISO-8601
       *   dates.
       */
      getDateParse: function () {
        return typeof Date.parse === "function" // Date.parse() is present...
        && Date.parse("2001-02-03T04:05:06.007") != // ...and it treats local
        Date.parse("2001-02-03T04:05:06.007Z"); // dates as expected
      },

      /**
       * Checks if 'startsWith' is supported on the String object.
       * @internal
       * @return {Boolean} <code>true</code>, if the method is available.
       */
      getStringStartsWith: function () {
        return typeof String.prototype.startsWith === "function";
      },

      /**
       * Checks if 'endsWith' is supported on the String object.
       * @internal
       * @return {Boolean} <code>true</code>, if the method is available.
       */
      getStringEndsWith: function () {
        return typeof String.prototype.endsWith === "function";
      },

      /**
       * Checks if 'trim' is supported on the String object.
       * @internal
       * @return {Boolean} <code>true</code>, if the method is available.
       */
      getStringTrim: function () {
        return typeof String.prototype.trim === "function";
      },

      /**
       * Checks if 'codePointAt' is supported on the String object.
       * @internal
       * @return {Boolean} <code>true</code>, if the method is available.
       */
      getStringCodePointAt: function () {
        return typeof String.prototype.codePointAt === "function";
      },

      /**
       * Checks if 'fromCodePoint' is supported on the String object.
       * @internal
       * @return {Boolean} <code>true</code>, if the method is available.
       */
      getStringFromCodePoint: function () {
        return !!String.fromCodePoint;
      },

      /**
       * Checks if 'BigInt' type is supported.
       * @internal
       * @ignore(BigInt)
       * @return {Boolean} <code>true</code>, if BigInt is available.
       */
      getBigInt: function () {
        return typeof BigInt !== "undefined";
      },

      /**
       * Checks if 'toLocaleString' is supported on the BigInt object and whether
       * it actually works
       * @internal
       * @ignore(BigInt)
       * @ignore(BigInt.prototype.toLocaleString)
       * @return {Boolean} <code>true</code>, if the method is supported and
       *   works at least rudimentary.
       */
      getBigIntToLocaleString: function () {
        return typeof BigInt !== "undefined" // BigInt type supported...
        && typeof BigInt.prototype.toLocaleString === "function" // ...method is present...
        && BigInt(1234).toLocaleString("de-DE") === "1,234"; // ...and works as expected
      },

      /**
       * Checks whether Native promises are available
       */
      getPromiseNative: function () {
        return typeof window.Promise !== "undefined" && window.Promise.toString().indexOf("[native code]") !== -1;
      },

      /**
       * Checks whether Native promises are available
       */
      getEpsilon: function () {
        return typeof Number.prototype.EPSILON !== "undefined";
      }
    },
    defer: function (statics) {
      // array polyfill
      qx.core.Environment.add("ecmascript.array.indexof", statics.getArrayIndexOf);
      qx.core.Environment.add("ecmascript.array.lastindexof", statics.getArrayLastIndexOf);
      qx.core.Environment.add("ecmascript.array.foreach", statics.getArrayForEach);
      qx.core.Environment.add("ecmascript.array.filter", statics.getArrayFilter);
      qx.core.Environment.add("ecmascript.array.map", statics.getArrayMap);
      qx.core.Environment.add("ecmascript.array.some", statics.getArraySome);
      qx.core.Environment.add("ecmascript.array.find", statics.getArrayFind);
      qx.core.Environment.add("ecmascript.array.findIndex", statics.getArrayFindIndex);
      qx.core.Environment.add("ecmascript.array.every", statics.getArrayEvery);
      qx.core.Environment.add("ecmascript.array.reduce", statics.getArrayReduce);
      qx.core.Environment.add("ecmascript.array.reduceright", statics.getArrayReduceRight);
      qx.core.Environment.add("ecmascript.array.includes", statics.getArrayIncludes); // date polyfill

      qx.core.Environment.add("ecmascript.date.now", statics.getDateNow);
      qx.core.Environment.add("ecmascript.date.parse", statics.getDateParse); // error bugfix

      qx.core.Environment.add("ecmascript.error.toString", statics.getErrorToString);
      qx.core.Environment.add("ecmascript.error.stacktrace", statics.getStackTrace); // function polyfill

      qx.core.Environment.add("ecmascript.function.bind", statics.getFunctionBind); // object polyfill

      qx.core.Environment.add("ecmascript.object.keys", statics.getObjectKeys);
      qx.core.Environment.add("ecmascript.object.values", statics.getObjectValues);
      qx.core.Environment.add("ecmascript.object.is", statics.getObjectIs);
      qx.core.Environment.add("ecmascript.object.assign", statics.getObjectAssign); // number polyfill

      qx.core.Environment.add("ecmascript.number.EPSILON", statics.getEpsilon); // string polyfill

      qx.core.Environment.add("ecmascript.string.startsWith", statics.getStringStartsWith);
      qx.core.Environment.add("ecmascript.string.endsWith", statics.getStringEndsWith);
      qx.core.Environment.add("ecmascript.string.trim", statics.getStringTrim);
      qx.core.Environment.add("ecmascript.string.codePointAt", statics.getStringCodePointAt);
      qx.core.Environment.add("ecmascript.string.fromCodePoint", statics.getStringFromCodePoint); // ES7 async function support

      qx.core.Environment.add("ecmascript.function.async", statics.getAsyncFunction); // MutationObserver

      qx.core.Environment.add("ecmascript.mutationobserver", statics.getMutationObserver); // BigInt

      qx.core.Environment.add("ecmascript.bigint", statics.getBigInt);
      qx.core.Environment.add("ecmascript.bigint.tolocalestring", statics.getBigIntToLocaleString); // Promises

      qx.core.Environment.add("ecmascript.promise.native", statics.getPromiseNative);
    }
  });
  qx.bom.client.EcmaScript.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.bom.client.EcmaScript": {
        "require": true,
        "defer": "runtime"
      },
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Environment": {
        "defer": "runtime"
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (wittemann)
  
  ************************************************************************ */

  /**
   * This class is responsible for the normalization of the native 'Array' object.
   * It checks if these methods are available and, if not, appends them to
   * ensure compatibility in all browsers.
   * For usage samples, check out the attached links.
   *
   * MDN documentation &copy; Mozilla Contributors.
   *
   * @group (Polyfill)
   * @require(qx.bom.client.EcmaScript)
   */
  qx.Bootstrap.define("qx.lang.normalize.Array", {
    statics: {
      /**
       * The <code>indexOf()</code> method returns the first index at which a given
       * element can be found in the array, or -1 if it is not present.
       *
       * <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf">MDN documentation</a> |
       * <a href="http://es5.github.com/#x15.4.4.14">Annotated ES5 Spec</a>
       *
       * @param searchElement {var} Element to locate in the array.
       * @param fromIndex {Integer?} The index to start the search at.
       * If the index is greater than or equal to the array's length,
       * -1 is returned, which means the array will not be searched.
       * If the provided index value is a negative number, it is taken
       * as the offset from the end of the array. Note: if the provided
       * index is negative, the array is still searched from front to
       * back. If the calculated index is less than 0, then the whole
       * array will be searched. Default: 0 (Entire array is searched)
       * @return {Integer} The first index at which the element was found or -1
       * if the element was not found in the array
       */
      indexOf: function (searchElement, fromIndex) {
        if (fromIndex == null) {
          fromIndex = 0;
        } else if (fromIndex < 0) {
          fromIndex = Math.max(0, this.length + fromIndex);
        }

        for (var i = fromIndex; i < this.length; i++) {
          if (this[i] === searchElement) {
            return i;
          }
        }

        return -1;
      },

      /**
       * The <code>lastIndexOf()</code> method returns the last index
       * at which a given element can be found in the array, or -1 if
       * it is not present. The array is searched backwards, starting at
       * <code>fromIndex</code>.
       *
       * <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf">MDN documentation</a> |
       * <a href="http://es5.github.com/#x15.4.4.15">Annotated ES5 Spec</a>
       *
       * @param searchElement {var} Element to locate in the array.
       * @param fromIndex {Integer?} The index at which to start
       * searching backwards. Defaults to the array's length, i.e. the
       * whole array will be searched. If the index is greater than or
       * equal to the length of the array, the whole array will be
       * searched. If negative, it is taken as the offset from the end
       * of the array. Note that even when the index is negative, the
       * array is still searched from back to front. If the calculated
       * index is less than 0, -1 is returned, i.e. the array will not
       * be searched.
       * @return {Integer} The last index at which the element was found or -1
       * if the element was not found in the array
       */
      lastIndexOf: function (searchElement, fromIndex) {
        if (fromIndex == null) {
          fromIndex = this.length - 1;
        } else if (fromIndex < 0) {
          fromIndex = Math.max(0, this.length + fromIndex);
        }

        for (var i = fromIndex; i >= 0; i--) {
          if (this[i] === searchElement) {
            return i;
          }
        }

        return -1;
      },

      /**
       * The <code>forEach()</code> method executes a provided function
       * once per array element. You can not break the loop with this function.
       * If you want to do so, use {@link #some} or {@link #every}.
       *
       * <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach">MDN documentation</a> |
       * <a href="http://es5.github.com/#x15.4.4.18">Annotated ES5 Spec</a>
       *
       * @param callback {Function} Function to execute for each element.
       * @param obj {Object?} Value to use as <code>this</code> when executing <code>callback</code>.
       */
      forEach: function (callback, obj) {
        var l = this.length;

        for (var i = 0; i < l; i++) {
          var value = this[i];

          if (value !== undefined) {
            callback.call(obj || window, value, i, this);
          }
        }
      },

      /**
       * The <code>filter()</code> method creates a new array with
       * all elements that pass the test implemented by the provided
       * function.
       *
       * <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter">MDN documentation</a> |
       * <a href="http://es5.github.com/#x15.4.4.20">Annotated ES5 Spec</a>
       *
       * @param callback {Function} Function to test each element of the array.
       * @param obj {Object?} Value to use as <code>this</code> when executing <code>callback</code>.
       * @return {Array} filtered array
       */
      filter: function (callback, obj) {
        var res = [];
        var l = this.length;

        for (var i = 0; i < l; i++) {
          var value = this[i];

          if (value !== undefined) {
            if (callback.call(obj || window, value, i, this)) {
              res.push(this[i]);
            }
          }
        }

        return res;
      },

      /**
       * The <code>map()</code> method creates a new array with
       * the results of calling a provided function on every
       * element in this array.
       *
       * <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map">MDN documentation</a> |
       * <a href="http://es5.github.com/#x15.4.4.19">Annotated ES5 Spec</a>
       *
       * @param callback {Function} Function that produces an element of the new Array,
       * taking three arguments:
       * <ul>
       *   <li><code>currentValue</code> The current element being processed in the array.</li>
       *   <li><code>index</code> The index of the current element being processed in the array.</li>
       *   <li><code>array</code> The array map was called upon.</li>
       * </ul>
       * @param obj {Object?} Value to use as <code>this</code> when executing <code>callback</code>.
       * @return {Array} result array
       */
      map: function (callback, obj) {
        var res = [];
        var l = this.length;

        for (var i = 0; i < l; i++) {
          var value = this[i];

          if (value !== undefined) {
            res[i] = callback.call(obj || window, value, i, this);
          }
        }

        return res;
      },

      /**
       * The <code>some()</code> method tests whether some
       * element in the array passes the test implemented by
       * the provided function.
       *
       * <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some">MDN documentation</a> |
       * <a href="http://es5.github.com/#x15.4.4.17">Annotated ES5 Spec</a>
       *
       * @param callback {Function} Function to test for each element.
       * @param obj {Object?} Value to use as <code>this</code> when executing <code>callback</code>.
       * @return {Array} result array
       */
      some: function (callback, obj) {
        var l = this.length;

        for (var i = 0; i < l; i++) {
          var value = this[i];

          if (value !== undefined) {
            if (callback.call(obj || window, value, i, this)) {
              return true;
            }
          }
        }

        return false;
      },

      /**
       * The <code>every()</code> method tests whether all elements
       * in the array pass the test implemented by the provided function.
       *
       * <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every">MDN documentation</a> |
       * <a href="http://es5.github.com/#x15.4.4.16">Annotated ES5 Spec</a>
       *
       * @param callback {Function} Function to test for each element.
       * @param obj {Object?} Value to use as <code>this</code> when executing <code>callback</code>.
       * @return {Array} result array
       */
      every: function (callback, obj) {
        var l = this.length;

        for (var i = 0; i < l; i++) {
          var value = this[i];

          if (value !== undefined) {
            if (!callback.call(obj || window, value, i, this)) {
              return false;
            }
          }
        }

        return true;
      },

      /**
       * The <code>find()</code> method returns a value in the array, if an element in the 
       * array satisfies the provided testing function. Otherwise undefined is returned.
       *
       * <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find">MDN documentation</a> |
       *
       * @param callback {Function} Function to test for each element.
       * @param obj {Object?} Value to use as <code>this</code> when executing <code>callback</code>.
       * @return {Object} result, undefined if not found
       */
      find: function (callback, obj) {
        var l = this.length;

        for (var i = 0; i < l; i++) {
          var value = this[i];

          if (callback.call(obj || window, value, i, this)) {
            return value;
          }
        }

        return undefined;
      },

      /**
       * The <code>findIndex()</code> method returns an index in the array, if an element in the 
       * array satisfies the provided testing function. Otherwise -1 is returned.
       *
       * <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex">MDN documentation</a> |
       *
       * @param callback {Function} Function to test for each element.
       * @param obj {Object?} Value to use as <code>this</code> when executing <code>callback</code>.
       * @return {Integer} the index in the array, -1 if not found
       */
      findIndex: function (callback, obj) {
        var l = this.length;

        for (var i = 0; i < l; i++) {
          var value = this[i];

          if (callback.call(obj || window, value, i, this)) {
            return i;
          }
        }

        return -1;
      },

      /**
       * The <code>reduce()</code> method applies a function against
       * an accumulator and each value of the array (from left-to-right)
       * has to reduce it to a single value.
       *
       * <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce">MDN documentation</a> |
       * <a href="http://es5.github.com/#x15.4.4.21">Annotated ES5 Spec</a>
       *
       * @param callback {Function} Function to execute on each value in
       * the array, taking four arguments:
       * <ul>
       *   <li><code>previousValue</code> The value previously returned in
       *   the last invocation of the callback, or initialValue, if supplied.
       *   (See below.)</li>
       *   <li><code>currentValue</code> The current element being processed in the array.</li>
       *   <li><code>index</code> The index of the current element being processed in the array.</li>
       *   <li><code>array</code> The array <code>reduce</code> was called upon.</li>
       * </ul>
       * @param init {Object?} Object to use as the first argument to the first call of the callback.
       * @return {var} result value
       */
      reduce: function (callback, init) {
        if (typeof callback !== "function") {
          throw new TypeError("First argument is not callable");
        }

        if (init === undefined && this.length === 0) {
          throw new TypeError("Length is 0 and no second argument given");
        }

        var ret = init === undefined ? this[0] : init;

        for (var i = init === undefined ? 1 : 0; i < this.length; i++) {
          if (i in this) {
            ret = callback.call(undefined, ret, this[i], i, this);
          }
        }

        return ret;
      },

      /**
       * The reduceRight() method applies a function against an
       * accumulator and each value of the array (from right-to-left)
       * as to reduce it to a single value.
       *
       * <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight">MDN documentation</a> |
       * <a href="http://es5.github.com/#x15.4.4.22">Annotated ES5 Spec</a>
       *
       * @param callback {Function} Function to execute on each value in
       * the array, taking four arguments:
       * <ul>
       *   <li><code>previousValue</code> The value previously returned in
       *   the last invocation of the callback, or initialValue, if supplied.
       *   (See below.)</li>
       *   <li><code>currentValue</code> The current element being processed in the array.</li>
       *   <li><code>index</code> The index of the current element being processed in the array.</li>
       *   <li><code>array</code> The array <code>reduce</code> was called upon.</li>
       * </ul>
       * @param init {Object?} Object to use as the first argument to the first call of the callback.
       * @return {var} return value
       */
      reduceRight: function (callback, init) {
        if (typeof callback !== "function") {
          throw new TypeError("First argument is not callable");
        }

        if (init === undefined && this.length === 0) {
          throw new TypeError("Length is 0 and no second argument given");
        }

        var ret = init === undefined ? this[this.length - 1] : init;

        for (var i = init === undefined ? this.length - 2 : this.length - 1; i >= 0; i--) {
          if (i in this) {
            ret = callback.call(undefined, ret, this[i], i, this);
          }
        }

        return ret;
      },

      /**
       * The includes() method determines whether an array includes a certain element, returning
       * true or false as appropriate.
       *
       * <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes">MDN documentation</a> |
       *
       * @param searchElement {var} Element which is checked for.
       * @param fromIndex {Number} Index to start search from
       * @return {bool} true if element is included
       */
      includes: function (searchElement, fromIndex) {
        if (this == null) {
          throw new TypeError('"this" is null or not defined');
        } // 1. Let O be ? ToObject(this value).


        var o = Object(this); // 2. Let len be ? ToLength(? Get(O, "length")).

        var len = o.length >>> 0; // 3. If len is 0, return false.

        if (len === 0) {
          return false;
        } // 4. Let n be ? ToInteger(fromIndex).
        //    (If fromIndex is undefined, this step produces the value 0.)


        var n = fromIndex | 0; // 5. If n ≥ 0, then
        //  a. Let k be n.
        // 6. Else n < 0,
        //  a. Let k be len + n.
        //  b. If k < 0, let k be 0.

        var k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);

        function sameValueZero(x, y) {
          return x === y || typeof x === 'number' && typeof y === 'number' && isNaN(x) && isNaN(y);
        } // 7. Repeat, while k < len


        while (k < len) {
          // a. Let elementK be the result of ? Get(O, ! ToString(k)).
          // b. If SameValueZero(searchElement, elementK) is true, return true.
          if (sameValueZero(o[k], searchElement)) {
            return true;
          } // c. Increase k by 1. 


          k++;
        } // 8. Return false


        return false;
      }
    },

    /**
     * @lint environmentNonLiteralKey()
     */
    defer: function (statics) {
      var install = function (key, name) {
        if (!qx.core.Environment.get(key)) {
          Object.defineProperty(Array.prototype, name, {
            enumerable: false,
            value: statics[name]
          });
        }
      };

      install("ecmascript.array.indexof", "indexOf");
      install("ecmascript.array.lastindexof", "lastIndexOf");
      install("ecmascript.array.foreach", "forEach");
      install("ecmascript.array.filter", "filter");
      install("ecmascript.array.map", "map");
      install("ecmascript.array.some", "some");
      install("ecmascript.array.find", "find");
      install("ecmascript.array.findIndex", "findIndex");
      install("ecmascript.array.every", "every");
      install("ecmascript.array.reduce", "reduce");
      install("ecmascript.array.reduceright", "reduceRight");
      install("ecmascript.array.includes", "includes");
    }
  });
  qx.lang.normalize.Array.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.lang.normalize.Array": {
        "require": true
      },
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.util.OOUtil": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
  
  ************************************************************************ */

  /**
   * This class is used to define interfaces (similar to Java interfaces).
   *
   * See the description of the {@link #define} method how an interface is
   * defined.
   *
   * @require(qx.lang.normalize.Array)
   */
  qx.Bootstrap.define("qx.Interface", {
    statics: {
      /*
      ---------------------------------------------------------------------------
         PUBLIC API
      ---------------------------------------------------------------------------
      */

      /**
       * Define a new interface. Interface definitions look much like class definitions.
       *
       * The main difference is that the bodies of functions defined in <code>members</code>
       * and <code>statics</code> are called before the original function with the
       * same arguments. This can be used to check the passed arguments. If the
       * checks fail, an exception should be thrown. It is convenient to use the
       * method defined in {@link qx.core.MAssert} to check the arguments.
       *
       * In the <code>build</code> version the checks are omitted.
       *
       * For properties only the names are required so the value of the properties
       * can be empty maps.
       *
       * Example:
       * <pre class='javascript'>
       * qx.Interface.define("name",
       * {
       *   extend: [SuperInterfaces],
       *
       *   statics:
       *   {
       *     PI : 3.14
       *   },
       *
       *   properties: {"color": {}, "name": {} },
       *
       *   members:
       *   {
       *     meth1: function() {},
       *     meth2: function(a, b) { this.assertArgumentsCount(arguments, 2, 2); },
       *     meth3: function(c) { this.assertInterface(c.constructor, qx.some.Interface); }
       *   },
       *
       *   events :
       *   {
       *     keydown : "qx.event.type.KeySequence"
       *   }
       * });
       * </pre>
       *
       * @param name {String} name of the interface
       * @param config {Map ? null} Interface definition structure. The configuration map has the following keys:
       *   <table>
       *     <tr><th>Name</th><th>Type</th><th>Description</th></tr>
       *     <tr><th>extend</th><td>Interface |<br>Interface[]</td><td>Single interface or array of interfaces this interface inherits from.</td></tr>
       *     <tr><th>members</th><td>Map</td><td>Map of members of the interface.</td></tr>
       *     <tr><th>statics</th><td>Map</td><td>
       *         Map of statics of the interface. The statics will not get copied into the target class.
       *         This is the same behaviour as statics in mixins ({@link qx.Mixin#define}).
       *     </td></tr>
       *     <tr><th>properties</th><td>Map</td><td>Map of properties and their definitions.</td></tr>
       *     <tr><th>events</th><td>Map</td><td>Map of event names and the corresponding event class name.</td></tr>
       *   </table>
       *
       * @return {qx.Interface} The configured interface
       */
      define: function (name, config) {
        if (config) {
          // Normalize include
          if (config.extend && !(qx.Bootstrap.getClass(config.extend) === "Array")) {
            config.extend = [config.extend];
          } // Validate incoming data


          // Create interface from statics
          var iface = config.statics ? config.statics : {}; // Attach configuration

          if (config.extend) {
            iface.$$extends = config.extend;
          }

          if (config.properties) {
            iface.$$properties = config.properties;
          }

          if (config.members) {
            iface.$$members = config.members;
          }

          if (config.events) {
            iface.$$events = config.events;
          }
        } else {
          // Create empty interface
          var iface = {};
        } // Add Basics


        iface.$$type = "Interface";
        iface.name = name; // Attach toString

        iface.toString = this.genericToString; // Assign to namespace

        iface.basename = qx.Bootstrap.createNamespace(name, iface); // Add to registry

        qx.Interface.$$registry[name] = iface; // Return final interface

        return iface;
      },

      /**
       * Returns an interface by name
       *
       * @param name {String} class name to resolve
       * @return {Class} the class
       */
      getByName: function (name) {
        return this.$$registry[name];
      },

      /**
       * Determine if interface exists
       *
       * @param name {String} Interface name to check
       * @return {Boolean} true if interface exists
       */
      isDefined: function (name) {
        return this.getByName(name) !== undefined;
      },

      /**
       * Determine the number of interfaces which are defined
       *
       * @return {Number} the number of interfaces
       */
      getTotalNumber: function () {
        return qx.Bootstrap.objectGetLength(this.$$registry);
      },

      /**
       * Generates a list of all interfaces including their super interfaces
       * (resolved recursively)
       *
       * @param ifaces {Interface[] ? []} List of interfaces to be resolved
       * @return {Array} List of all interfaces
       */
      flatten: function (ifaces) {
        if (!ifaces) {
          return [];
        } // we need to create a copy and not to modify the existing array


        var list = ifaces.concat();

        for (var i = 0, l = ifaces.length; i < l; i++) {
          if (ifaces[i].$$extends) {
            list.push.apply(list, this.flatten(ifaces[i].$$extends));
          }
        }

        return list;
      },

      /**
       * Assert members
       *
       * @param object {qx.core.Object} The object, which contains the methods
       * @param clazz {Class} class of the object
       * @param iface {Interface} the interface to verify
       * @param wrap {Boolean ? false} wrap functions required by interface to
       *     check parameters etc.
       * @param shouldThrow {Boolean} if <code>false</code>, the method
       *   will return a boolean instead of throwing an exception
       * @return {Boolean} <code>true</code> if all members are supported
       */
      __P_69_0: function (object, clazz, iface, wrap, shouldThrow) {
        // Validate members
        var members = iface.$$members;

        if (members) {
          for (var key in members) {
            if (qx.Bootstrap.isFunction(members[key])) {
              var isPropertyMethod = this.__P_69_1(clazz, key);

              var hasMemberFunction = isPropertyMethod || qx.Bootstrap.isFunction(object[key]);

              if (!hasMemberFunction) {
                if (shouldThrow) {
                  throw new Error('Implementation of method "' + key + '" is missing in class "' + clazz.classname + '" required by interface "' + iface.name + '"');
                } else {
                  return false;
                }
              } // Only wrap members if the interface was not been applied yet. This
              // can easily be checked by the recursive hasInterface method.


              var shouldWrapFunction = wrap === true && !isPropertyMethod && !qx.util.OOUtil.hasInterface(clazz, iface);

              if (shouldWrapFunction) {
                object[key] = this.__P_69_2(iface, object[key], key, members[key]);
              }
            } else {
              // Other members are not checked more detailed because of
              // JavaScript's loose type handling
              if (typeof object[key] === undefined) {
                if (typeof object[key] !== "function") {
                  if (shouldThrow) {
                    throw new Error('Implementation of member "' + key + '" is missing in class "' + clazz.classname + '" required by interface "' + iface.name + '"');
                  } else {
                    return false;
                  }
                }
              }
            }
          }
        }

        if (!shouldThrow) {
          return true;
        }
      },

      /**
       * Internal helper to detect if the method will be generated by the
       * property system.
       *
       * @param clazz {Class} The current class.
       * @param methodName {String} The name of the method.
       *
       * @return {Boolean} true, if the method will be generated by the property
       *   system.
       */
      __P_69_1: function (clazz, methodName) {
        var match = methodName.match(/^(is|toggle|get|set|reset)(.*)$/);

        if (!match) {
          return false;
        }

        var propertyName = qx.Bootstrap.firstLow(match[2]);
        var isPropertyMethod = qx.util.OOUtil.getPropertyDefinition(clazz, propertyName);

        if (!isPropertyMethod) {
          return false;
        }

        var isBoolean = match[0] === "is" || match[0] === "toggle";

        if (isBoolean) {
          return qx.util.OOUtil.getPropertyDefinition(clazz, propertyName).check === "Boolean";
        }

        return true;
      },

      /**
       * Assert properties
       *
       * @param clazz {Class} class to check interface for
       * @param iface {Interface} the interface to verify
       * @param shouldThrow {Boolean} if <code>false</code>, the method
       *   will return a boolean instead of throwing an exception
       * @return {Boolean} <code>true</code> if all properties are supported
       */
      __P_69_3: function (clazz, iface, shouldThrow) {
        if (iface.$$properties) {
          for (var key in iface.$$properties) {
            if (!qx.util.OOUtil.getPropertyDefinition(clazz, key)) {
              if (shouldThrow) {
                throw new Error('The property "' + key + '" is not supported by Class "' + clazz.classname + '"!');
              } else {
                return false;
              }
            }
          }
        }

        if (!shouldThrow) {
          return true;
        }
      },

      /**
       * Assert events
       *
       * @param clazz {Class} class to check interface for
       * @param iface {Interface} the interface to verify
       * @param shouldThrow {Boolean} if <code>false</code>, the method
       *   will return a boolean instead of throwing an exception
       * @return {Boolean} <code>true</code> if all events are supported
       */
      __P_69_4: function (clazz, iface, shouldThrow) {
        if (iface.$$events) {
          for (var key in iface.$$events) {
            if (!qx.util.OOUtil.supportsEvent(clazz, key)) {
              if (shouldThrow) {
                throw new Error('The event "' + key + '" is not supported by Class "' + clazz.classname + '"!');
              } else {
                return false;
              }
            }
          }
        }

        if (!shouldThrow) {
          return true;
        }
      },

      /**
       * Asserts that the given object implements all the methods defined in the
       * interface. This method throws an exception if the object does not
       * implement the interface.
       *
       *  @param object {qx.core.Object} Object to check interface for
       *  @param iface {Interface} The interface to verify
       */
      assertObject: function (object, iface) {
        var clazz = object.constructor;

        this.__P_69_0(object, clazz, iface, false, true);

        this.__P_69_3(clazz, iface, true);

        this.__P_69_4(clazz, iface, true); // Validate extends, recursive


        var extend = iface.$$extends;

        if (extend) {
          for (var i = 0, l = extend.length; i < l; i++) {
            this.assertObject(object, extend[i]);
          }
        }
      },

      /**
       * Checks if an interface is implemented by a class
       *
       * @param clazz {Class} class to check interface for
       * @param iface {Interface} the interface to verify
       * @param wrap {Boolean ? false} wrap functions required by interface to
       *     check parameters etc.
       */
      assert: function (clazz, iface, wrap) {
        this.__P_69_0(clazz.prototype, clazz, iface, wrap, true);

        this.__P_69_3(clazz, iface, true);

        this.__P_69_4(clazz, iface, true); // Validate extends, recursive


        var extend = iface.$$extends;

        if (extend) {
          for (var i = 0, l = extend.length; i < l; i++) {
            this.assert(clazz, extend[i], wrap);
          }
        }
      },

      /**
       * Asserts that the given object implements all the methods defined in the
       * interface.
       *
       *  @param object {qx.core.Object} Object to check interface for
       *  @param iface {Interface} The interface to verify
       * @return {Boolean} <code>true</code> if the objects implements the interface
       */
      objectImplements: function (object, iface) {
        var clazz = object.constructor;

        if (!this.__P_69_0(object, clazz, iface) || !this.__P_69_3(clazz, iface) || !this.__P_69_4(clazz, iface)) {
          return false;
        } // Validate extends, recursive


        var extend = iface.$$extends;

        if (extend) {
          for (var i = 0, l = extend.length; i < l; i++) {
            if (!this.objectImplements(object, extend[i])) {
              return false;
            }
          }
        }

        return true;
      },

      /**
       * Tests whether an interface is implemented by a class, without throwing an
       * exception when it doesn't.
       *
       * @param clazz {Class} class to check interface for
       * @param iface {Interface} the interface to verify
       * @return {Boolean} <code>true</code> if interface is implemented
       */
      classImplements: function (clazz, iface) {
        if (!this.__P_69_0(clazz.prototype, clazz, iface) || !this.__P_69_3(clazz, iface) || !this.__P_69_4(clazz, iface)) {
          return false;
        } // Validate extends, recursive


        var extend = iface.$$extends;

        if (extend) {
          for (var i = 0, l = extend.length; i < l; i++) {
            if (!this.has(clazz, extend[i])) {
              return false;
            }
          }
        }

        return true;
      },

      /*
      ---------------------------------------------------------------------------
         PRIVATE/INTERNAL API
      ---------------------------------------------------------------------------
      */

      /**
       * This method will be attached to all interface to return
       * a nice identifier for them.
       *
       * @internal
       * @return {String} The interface identifier
       */
      genericToString: function () {
        return "[Interface " + this.name + "]";
      },

      /** Registry of all defined interfaces */
      $$registry: {},

      /**
       * Wrap a method with a precondition check.
       *
       * @signature function(iface, origFunction, functionName, preCondition)
       * @param iface {String} Name of the interface, where the pre condition
       *   was defined. (Used in error messages).
       * @param origFunction {Function} function to wrap.
       * @param functionName {String} name of the function. (Used in error messages).
       * @param preCondition {Function}. This function gets called with the arguments of the
       *   original function. If this function return true the original function is called.
       *   Otherwise an exception is thrown.
       * @return {Function} wrapped function
       */
      __P_69_2: function (iface, origFunction, functionName, preCondition) {},

      /** @type {Map} allowed keys in interface definition */
      __P_69_5: null,

      /**
       * Validates incoming configuration and checks keys and values
       *
       * @signature function(name, config)
       * @param name {String} The name of the class
       * @param config {Map} Configuration map
       */
      __P_69_6: function (name, config) {}
    }
  });
  qx.Interface.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.lang.normalize.Array": {
        "require": true
      },
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.util.OOUtil": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
  
  ************************************************************************ */

  /**
   * This class is used to define mixins (similar to mixins in Ruby).
   *
   * Mixins are collections of code and variables, which can be merged into
   * other classes. They are similar to classes but don't support inheritance.
   *
   * See the description of the {@link #define} method how a mixin is defined.
   *
   * @require(qx.lang.normalize.Array)
   */
  qx.Bootstrap.define("qx.Mixin", {
    statics: {
      /*
      ---------------------------------------------------------------------------
         PUBLIC API
      ---------------------------------------------------------------------------
      */

      /**
       * Define a new mixin.
       *
       * Example:
       * <pre class='javascript'>
       * qx.Mixin.define("name",
       * {
       *   include: [SuperMixins],
       *
       *   properties: {
       *     tabIndex: {type: "number", init: -1}
       *   },
       *
       *   members:
       *   {
       *     prop1: "foo",
       *     meth1: function() {},
       *     meth2: function() {}
       *   }
       * });
       * </pre>
       *
       * @param name {String} name of the mixin
       * @param config {Map ? null} Mixin definition structure. The configuration map has the following keys:
       *   <table>
       *     <tr><th>Name</th><th>Type</th><th>Description</th></tr>
       *     <tr><th>construct</th><td>Function</td><td>An optional mixin constructor. It is called on instantiation each
       *         class including this mixin. The constructor takes no parameters.</td></tr>
       *     <tr><th>destruct</th><td>Function</td><td>An optional mixin destructor.</td></tr>
       *     <tr><th>include</th><td>Mixin[]</td><td>Array of mixins, which will be merged into the mixin.</td></tr>
       *     <tr><th>statics</th><td>Map</td><td>
       *         Map of statics of the mixin. The statics will not get copied into the target class. They remain
       *         accessible from the mixin. This is the same behaviour as statics in interfaces ({@link qx.Interface#define}).
       *     </td></tr>
       *     <tr><th>members</th><td>Map</td><td>Map of members of the mixin.</td></tr>
       *     <tr><th>properties</th><td>Map</td><td>Map of property definitions. For a description of the format of a property definition see
       *           {@link qx.core.Property}.</td></tr>
       *     <tr><th>events</th><td>Map</td><td>
       *         Map of events the mixin fires. The keys are the names of the events and the values are
       *         corresponding event type classes.
       *     </td></tr>
       *   </table>
       *
       * @return {qx.Mixin} The configured mixin
       */
      define: function (name, config) {
        if (config) {
          // Normalize include
          if (config.include && !(qx.Bootstrap.getClass(config.include) === "Array")) {
            config.include = [config.include];
          } // Validate incoming data


          // Create Interface from statics
          var mixin = config.statics ? config.statics : {};
          qx.Bootstrap.setDisplayNames(mixin, name);

          for (var key in mixin) {
            if (mixin[key] instanceof Function) {
              mixin[key].$$mixin = mixin;
            }
          } // Attach configuration


          if (config.construct) {
            mixin.$$constructor = config.construct;
            qx.Bootstrap.setDisplayName(config.construct, name, "constructor");
          }

          if (config.include) {
            mixin.$$includes = config.include;
          }

          if (config.properties) {
            mixin.$$properties = config.properties;
          }

          if (config.members) {
            mixin.$$members = config.members;
            qx.Bootstrap.setDisplayNames(config.members, name + ".prototype");
          }

          for (var key in mixin.$$members) {
            if (mixin.$$members[key] instanceof Function) {
              mixin.$$members[key].$$mixin = mixin;
            }
          }

          if (config.events) {
            mixin.$$events = config.events;
          }

          if (config.destruct) {
            mixin.$$destructor = config.destruct;
            qx.Bootstrap.setDisplayName(config.destruct, name, "destruct");
          }
        } else {
          var mixin = {};
        } // Add basics


        mixin.$$type = "Mixin";
        mixin.name = name; // Attach toString

        mixin.toString = this.genericToString; // Assign to namespace

        mixin.basename = qx.Bootstrap.createNamespace(name, mixin); // Store class reference in global mixin registry

        this.$$registry[name] = mixin; // Return final mixin

        return mixin;
      },

      /**
       * Check compatibility between mixins (including their includes)
       *
       * @param mixins {Mixin[]} an array of mixins
       * @throws {Error} when there is a conflict between the mixins
       * @return {Boolean} <code>true</code> if the mixin passed the compatibility check
       */
      checkCompatibility: function (mixins) {
        var list = this.flatten(mixins);
        var len = list.length;

        if (len < 2) {
          return true;
        }

        var properties = {};
        var members = {};
        var events = {};
        var mixin;

        for (var i = 0; i < len; i++) {
          mixin = list[i];

          for (var key in mixin.events) {
            if (events[key]) {
              throw new Error('Conflict between mixin "' + mixin.name + '" and "' + events[key] + '" in member "' + key + '"!');
            }

            events[key] = mixin.name;
          }

          for (var key in mixin.properties) {
            if (properties[key]) {
              throw new Error('Conflict between mixin "' + mixin.name + '" and "' + properties[key] + '" in property "' + key + '"!');
            }

            properties[key] = mixin.name;
          }

          for (var key in mixin.members) {
            if (members[key]) {
              throw new Error('Conflict between mixin "' + mixin.name + '" and "' + members[key] + '" in member "' + key + '"!');
            }

            members[key] = mixin.name;
          }
        }

        return true;
      },

      /**
       * Checks if a class is compatible to the given mixin (no conflicts)
       *
       * @param mixin {Mixin} mixin to check
       * @param clazz {Class} class to check
       * @throws {Error} when the given mixin is incompatible to the class
       * @return {Boolean} true if the mixin is compatible to the given class
       */
      isCompatible: function (mixin, clazz) {
        var list = qx.util.OOUtil.getMixins(clazz);
        list.push(mixin);
        return qx.Mixin.checkCompatibility(list);
      },

      /**
       * Returns a mixin by name
       *
       * @param name {String} class name to resolve
       * @return {Class} the class
       */
      getByName: function (name) {
        return this.$$registry[name];
      },

      /**
       * Determine if mixin exists
       *
       * @param name {String} mixin name to check
       * @return {Boolean} true if mixin exists
       */
      isDefined: function (name) {
        return this.getByName(name) !== undefined;
      },

      /**
       * Determine the number of mixins which are defined
       *
       * @return {Number} the number of mixins
       */
      getTotalNumber: function () {
        return qx.Bootstrap.objectGetLength(this.$$registry);
      },

      /**
       * Generates a list of all mixins given plus all the
       * mixins these includes plus... (deep)
       *
       * @param mixins {Mixin[] ? []} List of mixins
       * @return {Array} List of all mixins
       */
      flatten: function (mixins) {
        if (!mixins) {
          return [];
        } // we need to create a copy and not to modify the existing array


        var list = mixins.concat();

        for (var i = 0, l = mixins.length; i < l; i++) {
          if (mixins[i].$$includes) {
            list.push.apply(list, this.flatten(mixins[i].$$includes));
          }
        }

        return list;
      },

      /**
       * This method is used to determine the base method to call at runtime, and is used
       * by Mixins where the mixin method calls `this.base()`.  It is only required by the
       * compiler, and not the generator.
       *
       * The problem is that while Mixin's cannot override the same methods in a single class,
       * they can override methods that were implemented in a base base - but the compiler
       * cannot emit compile-time code which knows the base class method because that depends
       * on the class that the mixin is mixed-into.
       *
       * This method will search the hierarchy of the class at runtime, and figure out the 
       * nearest superclass method to call; the result is cached, and it is acceptable for
       * a mixin's method to override a method mixed into a superclass.
       *
       * Technically, this method should be private - it is internal and no notification will
       * be given if the API changes.  However, because it needs to be called by generated code
       * in any class, it has to appear as public.  Do not use it directly.
       *
       * @param clazz {Class} the class that is to be examined
       * @param mixin {Mixin} the mixin that is calling `this.base`
       * @param methodName {String} the name of the method in `mixin` that is calling `this.base`
       * @return {Function} the base class function to call
       */
      baseClassMethod: function (clazz, mixin, methodName) {
        {
          if (clazz.$$mixinBaseClassMethods && clazz.$$mixinBaseClassMethods[mixin.name] !== undefined && clazz.$$mixinBaseClassMethods[mixin.name][methodName] !== undefined) {
            return clazz.$$mixinBaseClassMethods[mixin.name][methodName];
          }

          var mixedInAt = null;
          var mixedInIndex = -1;

          for (var searchClass = clazz; searchClass; searchClass = searchClass.superclass) {
            if (searchClass.$$flatIncludes) {
              var pos = searchClass.$$flatIncludes.indexOf(mixin);

              if (pos > -1) {
                mixedInAt = searchClass;
                mixedInIndex = pos;
              }
            }
          }

          var fn = null;

          if (mixedInAt) {
            for (var i = mixedInIndex - 1; i > -1; i--) {
              var peerMixin = mixedInAt.$$flatIncludes[i];

              if (peerMixin.$$members[methodName]) {
                fn = peerMixin.$$members[methodName];
                break;
              }
            }

            if (!fn && mixedInAt.superclass) {
              fn = mixedInAt.superclass.prototype[methodName];
            }
          }

          if (fn) {
            if (!clazz.$$mixinBaseClassMethods) {
              clazz.$$mixinBaseClassMethods = {};
            }

            if (!clazz.$$mixinBaseClassMethods[mixin.name]) {
              clazz.$$mixinBaseClassMethods[mixin.name] = {};
            }

            clazz.$$mixinBaseClassMethods[mixin.name][methodName] = fn;
          } else {}

          return fn;
        }
      },

      /*
      ---------------------------------------------------------------------------
         PRIVATE/INTERNAL API
      ---------------------------------------------------------------------------
      */

      /**
       * This method will be attached to all mixins to return
       * a nice identifier for them.
       *
       * @internal
       * @return {String} The mixin identifier
       */
      genericToString: function () {
        return "[Mixin " + this.name + "]";
      },

      /** Registers all defined mixins */
      $$registry: {},

      /** @type {Map} allowed keys in mixin definition */
      __P_70_0: null,

      /**
       * Validates incoming configuration and checks keys and values
       *
       * @signature function(name, config)
       * @param name {String} The name of the class
       * @param config {Map} Configuration map
       */
      __P_70_1: function (name, config) {}
    }
  });
  qx.Mixin.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.bom.client.EcmaScript": {
        "defer": "load",
        "require": true
      }
    },
    "environment": {
      "provided": [],
      "required": {
        "ecmascript.date.now": {
          "defer": true,
          "className": "qx.bom.client.EcmaScript"
        },
        "ecmascript.date.parse": {
          "defer": true,
          "className": "qx.bom.client.EcmaScript"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (wittemann)
  
  ************************************************************************ */

  /**
   * This class is responsible for the normalization of the native 'Date' object.
   * It checks if these methods are available and, if not, appends them to
   * ensure compatibility in all browsers.
   * For usage samples, check out the attached links.
   *
   * @group (Polyfill)
   */
  qx.Bootstrap.define("qx.lang.normalize.Date", {
    statics: {
      /**
       * Returns the time elapsed since January 1, 1970 in milliseconds.
       *
       * <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/now">MDN documentation</a> |
       * <a href="http://es5.github.com/#x15.9.4.4">Annotated ES5 Spec</a>
       *
       * @return {Integer} Milliseconds since the Unix Epoch
       */
      now: function () {
        return +new Date();
      },

      /**
       * Parses a string representation of a date and return number of
       * milliseconds since Epoch or NaN if string is unrecognized.
       *
       * <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/parse">MDN documentation</a>
       *
       * Derived from <https://github.com/csnover/js-iso8601>: ©2011 Colin Snover
       * <http://zetafleet.com>, MIT license
       *
       * @param dateString {String} A string representing an RFC2822 or ISO 8601
       *   date (other formats may be used, but results may be unexpected).
       * @return {Number|NaN} A number representing the milliseconds elapsed
       *   since January 1, 1970, 00:00:00 UTC and the date obtained by parsing
       *   the given string representation of a date.
       *   If the argument doesn't represent a valid date, NaN is returned.
       */
      parse: function (dateString) {
        // Match input against ISO8601 regular expression
        var captureGroups = /^(\d{4}|[+\-]\d{6})(?:-(\d{2})(?:-(\d{2}))?)?(?:T(\d{2}):(\d{2})(?::(\d{2})(?:\.(\d{3}))?)?(?:(Z)|([+\-])(\d{2})(?::(\d{2}))?)?)?$/.exec(dateString);

        if (!captureGroups) {
          //
          // if the regular expression does not match parse the string
          // using the original function. 
          // Additionally check if it returns a real time value, which we 
          // ensure by using setTime with an intermediate Date object and the 
          // parsed time value. 
          // Safari 11 e.g. parses the date string '19700101' successfully 
          // into a time value, but returns NaN if that value is used in setTime.
          // 
          // See:
          //   https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/parse
          //   https://github.com/qooxdoo/qooxdoo/issues/9451
          //
          var time = Date.originalParse(dateString);

          if (isNaN(time) || isNaN(new Date().setTime(time))) {
            return NaN;
          }

          return time;
        } // Just a date without time?


        var noTime = [4, 5, 6, 7].every(function (i) {
          return captureGroups[i] === undefined;
        }); // Avoid invalid timestamps caused by undefined values being passed to Date.UTC

        [1, 4, 5, 6, 7, 10, 11].forEach(function (i) {
          captureGroups[i] = +captureGroups[i] || 0;
        });
        captureGroups[2] = (+captureGroups[2] || 1) - 1; // Allow undefined months

        captureGroups[3] = +captureGroups[3] || 1; // Allow undefined days
        // No timezone offset given and *not* just a date (without time)

        if (captureGroups[8] !== "Z" && captureGroups[9] === undefined && !noTime) {
          // => Treat as local
          return new Date(captureGroups[1], captureGroups[2], captureGroups[3], captureGroups[4], captureGroups[5], captureGroups[6], captureGroups[7]).getTime();
        } // Handle timezone offsets


        var minutesOffset = 0;

        if (captureGroups[8] !== "Z") {
          minutesOffset = captureGroups[10] * 60 + captureGroups[11];

          if (captureGroups[9] === "+") {
            minutesOffset = -minutesOffset;
          }
        } // Return the number of milliseconds since Epoch


        return Date.UTC(captureGroups[1], captureGroups[2], captureGroups[3], captureGroups[4], captureGroups[5] + minutesOffset, captureGroups[6], captureGroups[7]);
      }
    },
    defer: function (statics) {
      // Date.now
      if (!qx.core.Environment.get("ecmascript.date.now")) {
        Date.now = statics.now;
      } // Date.parse


      if (!qx.core.Environment.get("ecmascript.date.parse")) {
        Date.originalParse = Date.parse || function (dateString) {
          return NaN;
        };

        Date.parse = statics.parse;
      }
    }
  });
  qx.lang.normalize.Date.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.bom.client.EcmaScript": {
        "defer": "load",
        "require": true
      }
    },
    "environment": {
      "provided": [],
      "required": {
        "ecmascript.error.toString": {
          "defer": true,
          "className": "qx.bom.client.EcmaScript"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (wittemann)
  
  ************************************************************************ */

  /**
   * This class is responsible for the normalization of the native 'Error' object.
   * It contains a simple bugfix for toString which might not print out the proper
   * error message.
   *
   * @group (Polyfill)
   */
  qx.Bootstrap.define("qx.lang.normalize.Error", {
    statics: {
      /**
       * Returns a string representation of the Error object.
       *
       * <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Error/toString">MDN documentation</a> |
       * <a href="http://es5.github.com/#x15.11.4.4">Annotated ES5 Spec</a>
       *
       * @return {String} Error message
       */
      toString: function () {
        var name = this.name || "Error";
        var message = this.message || "";

        if (name === "" && message === "") {
          return "Error";
        }

        if (name === "") {
          return message;
        }

        if (message === "") {
          return name;
        }

        return name + ": " + message;
      }
    },
    defer: function (statics) {
      // toString
      if (!qx.core.Environment.get("ecmascript.error.toString")) {
        Error.prototype.toString = statics.toString;
      }
    }
  });
  qx.lang.normalize.Error.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.bom.client.EcmaScript": {
        "defer": "load",
        "require": true
      }
    },
    "environment": {
      "provided": [],
      "required": {
        "ecmascript.function.bind": {
          "defer": true,
          "className": "qx.bom.client.EcmaScript"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (wittemann)
  
     ======================================================================
  
     This class contains code based on the following work:
  
     * es5-shim
  
       Code:
         https://github.com/kriskowal/es5-shim/
  
       Copyright:
         (c) 2009, 2010 Kristopher Michael Kowal
  
       License:
         https://github.com/kriskowal/es5-shim/blob/master/LICENSE
  
     ----------------------------------------------------------------------
  
     Copyright 2009, 2010 Kristopher Michael Kowal. All rights reserved.
     Permission is hereby granted, free of charge, to any person obtaining a copy
     of this software and associated documentation files (the "Software"), to
     deal in the Software without restriction, including without limitation the
     rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
     sell copies of the Software, and to permit persons to whom the Software is
     furnished to do so, subject to the following conditions:
  
     The above copyright notice and this permission notice shall be included in
     all copies or substantial portions of the Software.
  
     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
     IN THE SOFTWARE.
  
     ----------------------------------------------------------------------
  
     Version:
       Snapshot taken on 2012-07-25,:
       commit  9f539abd9aa9950e1d907077a4be7f5133a00e52
  
  ************************************************************************ */

  /**
   * This class is responsible for the normalization of the native 'Function' object.
   * It checks if these methods are available and, if not, appends them to
   * ensure compatibility in all browsers.
   * For usage samples, check out the attached links.
   *
   * @group (Polyfill)
   */
  qx.Bootstrap.define("qx.lang.normalize.Function", {
    statics: {
      /**
       * <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Function/bind">MDN documentation</a> |
       * <a href="http://es5.github.com/#x15.3.4.5">Annotated ES5 Spec</a>
       *
       * @param that {var?} Context for the bound function
       * @return {Function} The bound function
       */
      bind: function (that) {
        var slice = Array.prototype.slice; // .length is 1
        // 1. Let Target be the this value.

        var target = this; // 2. If IsCallable(Target) is false, throw a TypeError exception.

        if (typeof target != "function") {
          throw new TypeError("Function.prototype.bind called on incompatible " + target);
        } // 3. Let A be a new (possibly empty) internal list of all of the
        //   argument values provided after thisArg (arg1, arg2 etc), in order.
        // XXX slicedArgs will stand in for "A" if used


        var args = slice.call(arguments, 1); // for normal call
        // 4. Let F be a new native ECMAScript object.
        // 11. Set the [[Prototype]] internal property of F to the standard
        //   built-in Function prototype object as specified in 15.3.3.1.
        // 12. Set the [[Call]] internal property of F as described in
        //   15.3.4.5.1.
        // 13. Set the [[Construct]] internal property of F as described in
        //   15.3.4.5.2.
        // 14. Set the [[HasInstance]] internal property of F as described in
        //   15.3.4.5.3.

        var bound = function () {
          if (this instanceof bound) {
            // 15.3.4.5.2 [[Construct]]
            // When the [[Construct]] internal method of a function object,
            // F that was created using the bind function is called with a
            // list of arguments ExtraArgs, the following steps are taken:
            // 1. Let target be the value of F's [[TargetFunction]]
            //   internal property.
            // 2. If target has no [[Construct]] internal method, a
            //   TypeError exception is thrown.
            // 3. Let boundArgs be the value of F's [[BoundArgs]] internal
            //   property.
            // 4. Let args be a new list containing the same values as the
            //   list boundArgs in the same order followed by the same
            //   values as the list ExtraArgs in the same order.
            // 5. Return the result of calling the [[Construct]] internal
            //   method of target providing args as the arguments.
            var F = function () {};

            F.prototype = target.prototype;
            var self = new F();
            var result = target.apply(self, args.concat(slice.call(arguments)));

            if (Object(result) === result) {
              return result;
            }

            return self;
          } else {
            // 15.3.4.5.1 [[Call]]
            // When the [[Call]] internal method of a function object, F,
            // which was created using the bind function is called with a
            // this value and a list of arguments ExtraArgs, the following
            // steps are taken:
            // 1. Let boundArgs be the value of F's [[BoundArgs]] internal
            //   property.
            // 2. Let boundThis be the value of F's [[BoundThis]] internal
            //   property.
            // 3. Let target be the value of F's [[TargetFunction]] internal
            //   property.
            // 4. Let args be a new list containing the same values as the
            //   list boundArgs in the same order followed by the same
            //   values as the list ExtraArgs in the same order.
            // 5. Return the result of calling the [[Call]] internal method
            //   of target providing boundThis as the this value and
            //   providing args as the arguments.
            // equiv: target.call(this, ...boundArgs, ...args)
            return target.apply(that, args.concat(slice.call(arguments)));
          }
        }; // XXX bound.length is never writable, so don't even try
        //
        // 15. If the [[Class]] internal property of Target is "Function", then
        //     a. Let L be the length property of Target minus the length of A.
        //     b. Set the length own property of F to either 0 or L, whichever is
        //       larger.
        // 16. Else set the length own property of F to 0.
        // 17. Set the attributes of the length own property of F to the values
        //   specified in 15.3.5.1.
        // (Not implemented but in the spec)
        // 18. Set the [[Extensible]] internal property of F to true.
        // (Not implemented but in the spec)
        // 19. Let thrower be the [[ThrowTypeError]] function Object (13.2.3).
        // 20. Call the [[DefineOwnProperty]] internal method of F with
        //   arguments "caller", PropertyDescriptor {[[Get]]: thrower, [[Set]]:
        //   thrower, [[Enumerable]]: false, [[Configurable]]: false}, and
        //   false.
        // 21. Call the [[DefineOwnProperty]] internal method of F with
        //   arguments "arguments", PropertyDescriptor {[[Get]]: thrower,
        //   [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false},
        //   and false.
        // NOTE Function objects created using Function.prototype.bind do not
        // have a prototype property or the [[Code]], [[FormalParameters]], and
        // [[Scope]] internal properties.
        // XXX can't delete prototype in pure-js.
        // 22. Return F.


        return bound;
      }
    },
    defer: function (statics) {
      if (!qx.core.Environment.get("ecmascript.function.bind")) {
        Function.prototype.bind = statics.bind;
      }
    }
  });
  qx.lang.normalize.Function.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.bom.client.EcmaScript": {
        "defer": "load",
        "require": true
      }
    },
    "environment": {
      "provided": [],
      "required": {
        "ecmascript.string.trim": {
          "defer": true,
          "className": "qx.bom.client.EcmaScript"
        },
        "ecmascript.string.startsWith": {
          "defer": true,
          "className": "qx.bom.client.EcmaScript"
        },
        "ecmascript.string.endsWith": {
          "defer": true,
          "className": "qx.bom.client.EcmaScript"
        },
        "ecmascript.string.codePointAt": {
          "defer": true,
          "className": "qx.bom.client.EcmaScript"
        },
        "ecmascript.string.fromCodePoint": {
          "defer": true,
          "className": "qx.bom.client.EcmaScript"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (wittemann)
  
  ************************************************************************ */

  /**
   * This class is responsible for the normalization of the native 'String' object.
   * It checks if these methods are available and, if not, appends them to
   * ensure compatibility in all browsers.
   * For usage samples, check out the attached links.
   *
   * @group (Polyfill)
   */
  qx.Bootstrap.define("qx.lang.normalize.String", {
    statics: {
      /**
       * Removes whitespace from both ends of the string.
       *
       * <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/Trim">MDN documentation</a> |
       * <a href="http://es5.github.com/#x15.5.4.20">Annotated ES5 Spec</a>
       *
       * @return {String} The trimmed string
       */
      trim: function () {
        return this.replace(/^\s+|\s+$/g, '');
      },

      /**
       * Determines whether a string begins with the characters of another
       * string, returning true or false as appropriate.
       *
       * @param searchString {String} The characters to be searched for at the
       *   start of this string.
       * @param position {Integer?0} The position in this string at which to
       *   begin searching for <code>searchString</code>.
       * @return {Boolean} Whether the string begins with the other string.
       */
      startsWith: function (searchString, position) {
        position = position || 0;
        return this.substr(position, searchString.length) === searchString;
      },

      /**
       * Determines whether a ends with the characters of another string,
       * returning true or false as appropriate.
       *
       * @param searchString {String} The characters to be searched for at the
       *   end of this string.
       * @param position {Integer?length} Search within this string as if this
       *   string were only this long; defaults to this string's actual length,
       *   clamped within the range established by this string's length.
       * @return {Boolean} Whether the string ends with the other string.
       */
      endsWith: function (searchString, position) {
        var subjectString = this.toString();

        if (typeof position !== 'number' || !isFinite(position) || Math.floor(position) !== position || position > subjectString.length) {
          position = subjectString.length;
        }

        position -= searchString.length;
        var lastIndex = subjectString.indexOf(searchString, position);
        return lastIndex !== -1 && lastIndex === position;
      },

      /**
       * Returns a non-negative integer that is the Unicode code point value.
       *   see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/codePointAt
       *
       * @param position {Integer} Position of an element in the string to 
       *   return the code point value from.
       * @return {Integer} A number representing the code point value of 
       *   the character at the given pos. If there is no element at pos, 
       *   returns undefined..
       */
      codePointAt: function (position) {
        if (this == null) {
          throw TypeError();
        }

        var string = String(this);
        var size = string.length; // `ToInteger`

        var index = position ? Number(position) : 0;

        if (index != index) {
          // better `isNaN`
          index = 0;
        } // Account for out-of-bounds indices:


        if (index < 0 || index >= size) {
          return undefined;
        } // Get the first code unit


        var first = string.charCodeAt(index);
        var second;

        if ( // check if it’s the start of a surrogate pair
        first >= 0xD800 && first <= 0xDBFF && // high surrogate
        size > index + 1 // there is a next code unit
        ) {
            second = string.charCodeAt(index + 1);

            if (second >= 0xDC00 && second <= 0xDFFF) {
              // low surrogate
              // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
              return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
            }
          }

        return first;
      },

      /**
       * Returns a string created by using the specified sequence of code points.
       *   https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCodePoint
       *
       * @param var_args {Integer} A sequence of code points as a variable argument list
       *   The undescore is used as a throwaway variable.  
       * @return {String} A string created by using 
       *   the specified sequence of code points.
       */
      fromCodePoint: function (_) {
        var codeUnits = [],
            codeLen = 0,
            result = "";

        for (var index = 0, len = arguments.length; index !== len; ++index) {
          var codePoint = +arguments[index]; // correctly handles all cases including `NaN`, `-Infinity`, `+Infinity`
          // The surrounding `!(...)` is required to correctly handle `NaN` cases
          // The (codePoint>>>0) === codePoint clause handles decimals and negatives

          if (!(codePoint < 0x10FFFF && codePoint >>> 0 === codePoint)) {
            throw RangeError("Invalid code point: " + codePoint);
          }

          if (codePoint <= 0xFFFF) {
            // BMP code point
            codeLen = codeUnits.push(codePoint);
          } else {
            // Astral code point; split in surrogate halves
            // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
            codePoint -= 0x10000;
            codeLen = codeUnits.push((codePoint >> 10) + 0xD800, // highSurrogate
            codePoint % 0x400 + 0xDC00 // lowSurrogate
            );
          }

          if (codeLen >= 0x3fff) {
            result += String.fromCharCode.apply(null, codeUnits);
            codeUnits.length = 0;
          }
        }

        return result + String.fromCharCode.apply(null, codeUnits);
      }
    },
    defer: function (statics) {
      // trim
      if (!qx.core.Environment.get("ecmascript.string.trim")) {
        String.prototype.trim = statics.trim;
      } // startsWith


      if (!qx.core.Environment.get("ecmascript.string.startsWith")) {
        String.prototype.startsWith = statics.startsWith;
      } // endsWith


      if (!qx.core.Environment.get("ecmascript.string.endsWith")) {
        String.prototype.endsWith = statics.endsWith;
      } // codePointAt


      if (!qx.core.Environment.get("ecmascript.string.codePointAt")) {
        String.prototype.codePointAt = statics.codePointAt;
      } // fromCodePoint


      if (!qx.core.Environment.get("ecmascript.string.fromCodePoint")) {
        String.fromCodePoint = statics.fromCodePoint;
      }
    }
  });
  qx.lang.normalize.String.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.bom.client.EcmaScript": {
        "defer": "load",
        "require": true
      }
    },
    "environment": {
      "provided": [],
      "required": {
        "ecmascript.object.keys": {
          "defer": true,
          "className": "qx.bom.client.EcmaScript"
        },
        "ecmascript.object.values": {
          "defer": true,
          "className": "qx.bom.client.EcmaScript"
        },
        "ecmascript.object.is": {
          "defer": true,
          "className": "qx.bom.client.EcmaScript"
        },
        "ecmascript.object.assign": {
          "defer": true,
          "className": "qx.bom.client.EcmaScript"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (wittemann)
  
  ************************************************************************ */

  /**
   * This class is responsible for the normalization of the native Object.
   * It checks if these methods are available and, if not, appends them to
   * ensure compatibility in all browsers.
   * For usage samples, check out the attached links.
   *
   * @group (Polyfill)
   */
  qx.Bootstrap.define("qx.lang.normalize.Object", {
    statics: {
      /**
       * Get the keys of a map as array as returned by a "for ... in" statement.
       *
       * <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/keys">MDN documentation</a> |
       * <a href="http://es5.github.com/#x15.2.3.14">Annotated ES5 Spec</a>
       *
       * @signature function(map)
       * @param map {Object} the map
       * @return {Array} array of the keys of the map
       */
      keys: qx.Bootstrap.keys,

      /**
       * Get the values of a map as array
       *
       * @param map {Object} the map
       * @return {Array} array of the values of the map
       */
      values: function (map) {
        var arr = [];
        var keys = Object.keys(map);

        for (var i = 0, l = keys.length; i < l; i++) {
          arr.push(map[keys[i]]);
        }

        return arr;
      },

      /**
       * Determines whether two values are the same value.
       *
       * <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is">MDN web docs: Object.is()</a>
       *
       * @signature function(x,y)
       * @param x {Object} the first value to compare
       * @param y {Object} the second value to compare
       * @return {Boolean} indicating whether or not the two arguments are the same value.
       */
      is: function (x, y) {
        // SameValue algorithm
        if (x === y) {
          // Steps 1-5, 7-10
          // Steps 6.b-6.e: +0 != -0
          return x !== 0 || 1 / x === 1 / y;
        } else {
          // Step 6.a: NaN == NaN
          return x !== x && y !== y;
        }
      },

      /**
       * Copies all enumerable own properties from one or more source objects to a target object..
       *
       * <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign">MDN web docs: Object.assign()</a>
       *
       * @signature function(target,varArgs)
       * @param target {Object} The target object - what to apply the sources’ properties to, which is returned after it is modified. 
       * @param sources {Object} The source object(s) - objects containing the properties you want to apply.
       * @return {Object} The target object.
       */
      assign: function (target, sources) {
        // .length of function is 2
        'use strict';

        if (target === null || target === undefined) {
          throw new TypeError('Cannot convert undefined or null to object');
        }

        var to = Object(target);

        for (var index = 1; index < arguments.length; index++) {
          var nextSource = arguments[index];

          if (nextSource !== null && nextSource !== undefined) {
            for (var nextKey in nextSource) {
              // Avoid bugs when hasOwnProperty is shadowed
              if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
                to[nextKey] = nextSource[nextKey];
              }
            }
          }
        }

        return to;
      }
    },
    defer: function (statics) {
      // keys
      if (!qx.core.Environment.get("ecmascript.object.keys")) {
        Object.keys = statics.keys;
      } // values


      if (!qx.core.Environment.get("ecmascript.object.values")) {
        Object.values = statics.values;
      } // is


      if (!qx.core.Environment.get("ecmascript.object.is")) {
        Object.is = statics.is;
      } // assign


      if (!qx.core.Environment.get("ecmascript.object.assign")) {
        Object.assign = statics.assign;
      }
    }
  });
  qx.lang.normalize.Object.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.bom.client.EcmaScript": {
        "defer": "load",
        "require": true
      }
    },
    "environment": {
      "provided": [],
      "required": {
        "ecmascript.number.EPSILON": {
          "defer": true,
          "className": "qx.bom.client.EcmaScript"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2017 The Qooxdoo Project
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Cajus Pollmeier (cajus)
  
  ************************************************************************ */

  /**
   * This class is responsible for the normalization of the native 'String' object.
   * It checks if these methods are available and, if not, appends them to
   * ensure compatibility in all browsers.
   * For usage samples, check out the attached links.
   *
   * @group (Polyfill)
   */
  qx.Bootstrap.define("qx.lang.normalize.Number", {
    statics: {
      EPSILON: 2e-52
    },
    defer: function (statics) {
      if (!qx.core.Environment.get("ecmascript.number.EPSILON")) {
        Number.prototype.EPSILON = statics.EPSILON;
      }
    }
  });
  qx.lang.normalize.Number.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.event.type.Data": {},
      "qx.event.dispatch.Direct": {},
      "qx.Promise": {},
      "qx.lang.String": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * Internal class for handling of dynamic properties. Should only be used
   * through the methods provided by {@link qx.Class}.
   *
   * For a complete documentation of properties take a look at
   * http://qooxdoo.org/docs/#core/property_features.md.
   *
   *
   * *Normal properties*
   *
   * The <code>properties</code> key in the class definition map of {@link qx.Class#define}
   * is used to generate the properties.
   *
   * Valid keys of a property definition are:
   *
   * <table>
   *   <tr><th>Name</th><th>Type</th><th>Description</th></tr>
   *   <tr><th>check</th><td>Array, String, Function</td><td>
   *     The check is used to check the type the incoming value of a property. This will only
   *     be executed in the source version. The build version will not contain the checks.
   *     The check can be:
   *     <ul>
   *       <li>a custom check function. The function takes the incoming value as a parameter and must
   *           return a boolean value to indicate whether the values is valid.
   *       </li>
   *       <li>inline check code as a string e.g. <code>"value &gt; 0 && value &lt; 100"</code></li>
   *       <li>a class name e.g. <code>qx.ui.form.Button</code></li>
   *       <li>a name of an interface the value must implement</li>
   *       <li>an array of all valid values</li>
   *       <li>one of the predefined checks: Boolean, String, Number, Integer, Float, Double,
   *           Object, Array, Map, Class, Mixin, Interface, Theme, Error, RegExp, Function,
   *           Date, Node, Element, Document, Window, Event
   *       </li>
   *     <ul>
   *   </td></tr>
   *   <tr><th>init</th><td>var</td><td>
   *     Sets the default/initial value of the property. If no property value is set or the property
   *     gets reset, the getter will return the <code>init</code> value.
   *   </td></tr>
   *   <tr><th>apply</th><td>String</td><td>
   *     On change of the property value the method of the specified name will be called. The signature of
   *     the method is <code>function(newValue, oldValue, propertyName)</code>. It is conventional to name
   *     the callback <code>_apply</code> + <i>PropertyName</i>, with the property name camel-cased (e.g.
   *     "<i>_applyFooBar</i>" for a property <i>fooBar</i>).
   *   </td></tr>
   *   <tr><th>event</th><td>String</td><td>
   *     On change of the property value an event with the given name will be dispatched. The event type is
   *     {@link qx.event.type.Data}.
   *   </td></tr>
   *   <tr><th>themeable</th><td>Boolean</td><td>
   *     Whether this property can be set using themes.
   *   </td></tr>
   *   <tr><th>inheritable</th><td>Boolean</td><td>
   *     Whether the property value should be inheritable. If the property does not have an user defined or an
   *     init value, the property will try to get the value from the parent of the current object.
   *   </td></tr>
   *   <tr><th>nullable</th><td>Boolean</td><td>
   *     Whether <code>null</code> is an allowed value of the property. This is complementary to the check
   *     defined using the <code>check</code> key.
   *   </td></tr>
   *   <tr><th>refine</th><td>Boolean</td><td>
   *     Whether the property definition is a refinement of a property in one of the super classes of the class.
   *     Only the <code>init</code> value can be changed using refine.
   *   </td></tr>
   *   <tr><th>transform</th><td>String</td><td>
   *     On setting of the property value the method of the specified name will
   *     be called. The signature of the method is <code>function(value, oldValue)</code>.
   *     The parameter <code>value</code> is the value passed to the setter, the
   *     parameter <code>oldValue</code> is the current value, or undefined if no value
   *     has been set previously.
   *     The function must return the modified or unmodified value.
   *     Transformation occurs before the check function, so both may be
   *     specified if desired.  Alternatively, the transform function may throw
   *     an error if the value passed to it is invalid.
   *   </td></tr>
   *   <tr><th>validate</th><td>Function, String</td><td>
   *     On setting of the property value the method of the specified name will
   *     be called. The signature of the method is <code>function(value)</code>.
   *     The parameter <code>value</code> is the value passed to the setter.
   *     If the validation fails, an <code>qx.core.ValidationError</code> should
   *     be thrown by the validation function. Otherwise, just do nothing in the
   *     function.<br>
   *     If a string is given, the string should hold a reference to a member
   *     method.<br>
   *     <code>"<i>methodname</i>"</code> for example
   *     <code>"__validateProperty"</code><br>
   *     There are some default validators in the {@link qx.util.Validate} class.
   *     See this documentation for usage examples.
   *   </td></tr>
   *   <tr><th>dereference</th><td>Boolean</td><td>
   *     By default, the references to the values (current, init, ...) of the
   *     property will be stored as references on the object. When disposing
   *     this object, the references will not be deleted. Setting the
   *     dereference key to true tells the property system to delete all
   *     connections made by this property on dispose. This can be necessary for
   *     disconnecting DOM objects to allow the garbage collector to work
   *     properly.
   *   </td></tr>
   *   <tr><th>deferredInit</th><td>Boolean</td><td>
   *     Allow for a deferred initialization for reference types. Defaults to false.
   *   </td></tr>
   *   <tr><th>isEqual</th><td>Function, String</td><td>
   *     On setting of the property value the method of the specified name will
   *     be called to test if two values are equal. These checks for equality are
   *     performed by the Property-System to decide whether further actions (like
   *     e.g. calling applier methods or firing of events) are needed.
   *     The signature of the method is <code>function(valueA, valueB)</code>.
   *     <br/>
   *     The <i>isEqual</i>-value can be:
   *     <ul>
   *       <li>a custom check function.
   *           The function takes two values as parameter and must return a
   *           boolean value to indicate whether the values are considered
   *           equal e.g. <code>function (a, b) { return Object.is(a, b); }</code>.</li>
   *       <li>inline check code as a string
   *           which will be invoked with two parameters <code>a</code> and
   *           <code>b</code> and results in a boolean value to indicate whether
   *           the values are equal e.g. <code>"a.length() == b.length()"</code>.</li>
   *       <li>reference to a member method as string
   *           <code>"<i>methodname</i>"</code> which will be invoked with two
   *           parameters and returns a boolean value indicating whether the two
   *           values are considered equal for example <code>"__areTheSame"</code>.</li>
   *     </ul>
   *     The default implementation (if this key is undefined) will check the
   *     equality by using the <i>identity</i> operator (===) as if defined like
   *     <code>"a===b"</code>.
   *   </td></tr>
   * </table>
   *
   * *Property groups*
   *
   * Property groups are defined in a similar way but support a different set of keys:
   *
   * <table>
   *   <tr><th>Name</th><th>Type</th><th>Description</th></tr>
   *   <tr><th>group</th><td>String[]</td><td>
   *     A list of property names which should be set using the property group.
   *   </td></tr>
   *   <tr><th>mode</th><td>String</td><td>
   *     If mode is set to <code>"shorthand"</code>, the properties can be set using a CSS like shorthand mode.
   *   </td></tr>
   *   <tr><th>themeable</th><td>Boolean</td><td>
   *     Whether this property can be set using themes.
   *   </td></tr>
   * </table>
   *
   * @internal
   * @ignore(qx.Interface)
   */
  qx.Bootstrap.define("qx.core.Property", {
    statics: {
      /**
       * This is a method which does nothing than gathering dependencies for the
       * module system. Calling this method is useless because it does nothing.
       */
      __P_71_0: function () {
        {
          qx.event.type.Data;
          qx.event.dispatch.Direct;
        }
        {
          qx.Promise;
        }
      },

      /**
       * Built-in checks
       * The keys could be used in the check of the properties
       */
      __P_71_1: {
        "Boolean": 'qx.core.Assert.assertBoolean(value, msg) || true',
        "String": 'qx.core.Assert.assertString(value, msg) || true',
        "Number": 'qx.core.Assert.assertNumber(value, msg) || true',
        "Integer": 'qx.core.Assert.assertInteger(value, msg) || true',
        "PositiveNumber": 'qx.core.Assert.assertPositiveNumber(value, msg) || true',
        "PositiveInteger": 'qx.core.Assert.assertPositiveInteger(value, msg) || true',
        "Error": 'qx.core.Assert.assertInstance(value, Error, msg) || true',
        "RegExp": 'qx.core.Assert.assertInstance(value, RegExp, msg) || true',
        "Object": 'qx.core.Assert.assertObject(value, msg) || true',
        "Array": 'qx.core.Assert.assertArray(value, msg) || true',
        "Map": 'qx.core.Assert.assertMap(value, msg) || true',
        "Function": 'qx.core.Assert.assertFunction(value, msg) || true',
        "Date": 'qx.core.Assert.assertInstance(value, Date, msg) || true',
        "Node": 'value !== null && value.nodeType !== undefined',
        "Element": 'value !== null && value.nodeType === 1 && value.attributes',
        "Document": 'value !== null && value.nodeType === 9 && value.documentElement',
        "Window": 'value !== null && value.document',
        "Event": 'value !== null && value.type !== undefined',
        "Class": 'value !== null && value.$$type === "Class"',
        "Mixin": 'value !== null && value.$$type === "Mixin"',
        "Interface": 'value !== null && value.$$type === "Interface"',
        "Theme": 'value !== null && value.$$type === "Theme"',
        "Color": 'qx.lang.Type.isString(value) && qx.util.ColorUtil.isValidPropertyValue(value)',
        "Decorator": 'value !== null && qx.theme.manager.Decoration.getInstance().isValidPropertyValue(value)',
        "Font": 'value !== null && qx.theme.manager.Font.getInstance().isDynamic(value)'
      },

      /**
       * Contains types from {@link #__checks} list which need to be dereferenced
       */
      __P_71_2: {
        "Node": true,
        "Element": true,
        "Document": true,
        "Window": true,
        "Event": true
      },

      /**
       * Inherit value, used to override defaults etc. to force inheritance
       * even if property value is not undefined (through multi-values)
       *
       * @internal
       */
      $$inherit: "inherit",

      /**
       * Caching field names for each property created
       *
       * @internal
       */
      $$store: {
        runtime: {},
        user: {},
        theme: {},
        inherit: {},
        init: {},
        useinit: {}
      },

      /**
       * Caching function names for each property created
       *
       * @internal
       */
      $$method: {
        get: {},
        getAsync: {},
        set: {},
        setImpl: {},
        setAsync: {},
        reset: {},
        init: {},
        refresh: {},
        setRuntime: {},
        resetRuntime: {},
        setThemed: {},
        resetThemed: {}
      },

      /**
       * Supported keys for property definitions
       *
       * @internal
       */
      $$allowedKeys: {
        "@": "object",
        // Anything
        name: "string",
        // String
        dereference: "boolean",
        // Boolean
        inheritable: "boolean",
        // Boolean
        nullable: "boolean",
        // Boolean
        themeable: "boolean",
        // Boolean
        refine: "boolean",
        // Boolean
        init: null,
        // var
        apply: "string",
        // String
        event: "string",
        // String
        check: null,
        // Array, String, Function
        transform: "string",
        // String
        async: "boolean",
        // Boolean
        deferredInit: "boolean",
        // Boolean
        validate: null,
        // String, Function
        isEqual: null // String, Function

      },

      /**
       * Supported keys for property group definitions
       *
       * @internal
       */
      $$allowedGroupKeys: {
        "@": "object",
        // Anything
        name: "string",
        // String
        group: "object",
        // Array
        mode: "string",
        // String
        themeable: "boolean" // Boolean

      },

      /** Contains names of inheritable properties, filled by {@link qx.Class.define} */
      $$inheritable: {},

      /**
       * Generate optimized refresh method and  attach it to the class' prototype
       *
       * @param clazz {Class} clazz to which the refresher should be added
       */
      __P_71_3: function (clazz) {
        var inheritables = this.__P_71_4(clazz);

        if (!inheritables.length) {
          var refresher = function () {};
        } else {
          refresher = this.__P_71_5(inheritables);
        }

        clazz.prototype.$$refreshInheritables = refresher;
      },

      /**
       * Get the names of all inheritable properties of the given class
       *
       * @param clazz {Class} class to get the inheritable properties of
       * @return {String[]} List of property names
       */
      __P_71_4: function (clazz) {
        var inheritable = [];

        while (clazz) {
          var properties = clazz.$$properties;

          if (properties) {
            for (var name in this.$$inheritable) {
              // Whether the property is available in this class
              // and whether it is inheritable in this class as well
              if (properties[name] && properties[name].inheritable) {
                inheritable.push(name);
              }
            }
          }

          clazz = clazz.superclass;
        }

        return inheritable;
      },

      /**
       * Assemble the refresher code and return the generated function
       *
       * @param inheritables {String[]} list of inheritable properties
       * @return {Function} refresher function
       */
      __P_71_5: function (inheritables) {
        var inherit = this.$$store.inherit;
        var init = this.$$store.init;
        var refresh = this.$$method.refresh;
        var code = ["var parent = this.getLayoutParent();", "if (!parent) return;"];

        for (var i = 0, l = inheritables.length; i < l; i++) {
          var name = inheritables[i];
          code.push("var value = parent.", inherit[name], ";", "if (value===undefined) value = parent.", init[name], ";", "this.", refresh[name], "(value);");
        }

        return new Function(code.join(""));
      },

      /**
       * Attach $$refreshInheritables method stub to the given class
       *
       * @param clazz {Class} clazz to which the refresher should be added
       */
      attachRefreshInheritables: function (clazz) {
        clazz.prototype.$$refreshInheritables = function () {
          qx.core.Property.__P_71_3(clazz);

          return this.$$refreshInheritables();
        };
      },

      /**
       * Attach one property to class
       *
       * @param clazz {Class} Class to attach properties to
       * @param name {String} Name of property
       * @param config {Map} Configuration map of property
       */
      attachMethods: function (clazz, name, config) {
        // Divide groups from "normal" properties
        config.group ? this.__P_71_6(clazz, config, name) : this.__P_71_7(clazz, config, name);
      },

      /**
       * Attach group methods
       *
       * @param clazz {Class} Class to attach properties to
       * @param config {Map} Property configuration
       * @param name {String} Name of the property
       */
      __P_71_6: function (clazz, config, name) {
        var upname = qx.Bootstrap.firstUp(name);
        var members = clazz.prototype;
        var themeable = config.themeable === true;
        var setter = [];
        var resetter = [];

        if (themeable) {
          var styler = [];
          var unstyler = [];
        }

        var argHandler = "var a=arguments[0] instanceof Array?arguments[0]:arguments;";
        setter.push(argHandler);

        if (themeable) {
          styler.push(argHandler);
        }

        if (config.mode == "shorthand") {
          var shorthand = "a=qx.lang.Array.fromShortHand(qx.lang.Array.fromArguments(a));";
          setter.push(shorthand);

          if (themeable) {
            styler.push(shorthand);
          }
        }

        for (var i = 0, a = config.group, l = a.length; i < l; i++) {
          setter.push("this.", this.$$method.set[a[i]], "(a[", i, "]);");
          resetter.push("this.", this.$$method.reset[a[i]], "();");

          if (themeable) {
            styler.push("this.", this.$$method.setThemed[a[i]], "(a[", i, "]);");
            unstyler.push("this.", this.$$method.resetThemed[a[i]], "();");
          }
        } // Attach setter


        this.$$method.set[name] = "set" + upname;
        members[this.$$method.set[name]] = new Function(setter.join("")); // Attach resetter

        this.$$method.reset[name] = "reset" + upname;
        members[this.$$method.reset[name]] = new Function(resetter.join(""));

        if (themeable) {
          // Attach styler
          this.$$method.setThemed[name] = "setThemed" + upname;
          members[this.$$method.setThemed[name]] = new Function(styler.join("")); // Attach unstyler

          this.$$method.resetThemed[name] = "resetThemed" + upname;
          members[this.$$method.resetThemed[name]] = new Function(unstyler.join(""));
        }
      },

      /**
       * Attach property methods
       *
       * @param clazz {Class} Class to attach properties to
       * @param config {Map} Property configuration
       * @param name {String} Name of the property
       */
      __P_71_7: function (clazz, config, name) {
        var upname = qx.Bootstrap.firstUp(name);
        var members = clazz.prototype;

        // Fill dispose value
        if (config.dereference === undefined && typeof config.check === "string") {
          config.dereference = this.__P_71_8(config.check);
        }

        var method = this.$$method;
        var store = this.$$store;
        store.runtime[name] = "$$runtime_" + name;
        store.user[name] = "$$user_" + name;
        store.theme[name] = "$$theme_" + name;
        store.init[name] = "$$init_" + name;
        store.inherit[name] = "$$inherit_" + name;
        store.useinit[name] = "$$useinit_" + name;
        var getName = method.get[name] = "get" + upname;
        members[method.get[name]] = new Function("this." + getName + ".$$install && this." + getName + ".$$install();" + "return this." + getName + ".apply(this, arguments);");

        if (config.async) {
          method.getAsync[name] = getName + "Async";
          members[method.getAsync[name]] = new Function("this." + getName + ".$$install && this." + getName + ".$$install.call(this);" + "return this." + getName + "Async.apply(this, arguments);");
        }

        members[method.get[name]].$$install = function () {
          qx.core.Property.__P_71_9(clazz, name, "get", arguments);

          if (config.async) {
            qx.core.Property.__P_71_9(clazz, name, "getAsync", arguments);
          }
        };

        var setName = method.set[name] = "set" + upname;
        members[setName] = new Function("this." + setName + ".$$install && this." + setName + ".$$install.call(this);" + "return this." + setName + ".apply(this, arguments);");
        method.setAsync[name] = "set" + upname + "Async";

        if (config.async) {
          members[setName + "Async"] = new Function("this." + setName + ".$$install && this." + setName + ".$$install.call(this);" + "return this." + setName + "Async.apply(this, arguments);");
        }

        method.setImpl[name] = "$$set" + upname + "Impl";

        members[setName].$$install = function () {
          qx.core.Property.__P_71_10(clazz, name, "set");

          qx.core.Property.__P_71_10(clazz, name, "setImpl");

          if (config.async) {
            qx.core.Property.__P_71_10(clazz, name, "setAsync");
          }
        };

        method.reset[name] = "reset" + upname;

        members[method.reset[name]] = function () {
          return qx.core.Property.executeOptimizedSetter(this, clazz, name, "reset");
        };

        members[method.reset[name]].$$install = function () {
          qx.core.Property.__P_71_10(clazz, name, "reset");
        };

        if (config.inheritable || config.apply || config.event || config.deferredInit) {
          method.init[name] = "init" + upname;

          members[method.init[name]] = function (value) {
            return qx.core.Property.executeOptimizedSetter(this, clazz, name, "init", arguments);
          };
        }

        if (config.inheritable) {
          method.refresh[name] = "refresh" + upname;

          members[method.refresh[name]] = function (value) {
            return qx.core.Property.executeOptimizedSetter(this, clazz, name, "refresh", arguments);
          };
        }

        method.setRuntime[name] = "setRuntime" + upname;

        members[method.setRuntime[name]] = function (value) {
          return qx.core.Property.executeOptimizedSetter(this, clazz, name, "setRuntime", arguments);
        };

        method.resetRuntime[name] = "resetRuntime" + upname;

        members[method.resetRuntime[name]] = function () {
          return qx.core.Property.executeOptimizedSetter(this, clazz, name, "resetRuntime");
        };

        if (config.themeable) {
          method.setThemed[name] = "setThemed" + upname;

          members[method.setThemed[name]] = function (value) {
            return qx.core.Property.executeOptimizedSetter(this, clazz, name, "setThemed", arguments);
          };

          method.resetThemed[name] = "resetThemed" + upname;

          members[method.resetThemed[name]] = function () {
            return qx.core.Property.executeOptimizedSetter(this, clazz, name, "resetThemed");
          };
        }

        if (config.check === "Boolean") {
          members["toggle" + upname] = new Function("return this." + method.set[name] + "(!this." + method.get[name] + "())");
          members["is" + upname] = new Function("return this." + method.get[name] + "()");
        } // attach a flag to make generated property methods

      },

      /**
       * Returns if the reference for the given property check should be removed
       * on dispose.
       *
       * @param check {var} The check of the property definition.
       * @return {Boolean} If the dereference key should be set.
       */
      __P_71_8: function (check) {
        return !!this.__P_71_2[check];
      },

      /** @type {Map} Internal data field for error messages used by {@link #error} */
      __P_71_11: {
        0: 'Could not change or apply init value after constructing phase!',
        1: 'Requires exactly one argument!',
        2: 'Undefined value is not allowed!',
        3: 'Does not allow any arguments!',
        4: 'Null value is not allowed!',
        5: 'Is invalid!'
      },

      /**
       * Error method used by the property system to report errors.
       *
       * @param obj {qx.core.Object} Any qooxdoo object
       * @param id {Integer} Numeric error identifier
       * @param property {String} Name of the property
       * @param variant {String} Name of the method variant e.g. "set", "reset", ...
       * @param value {var} Incoming value
       */
      error: function (obj, id, property, variant, value) {
        var classname = obj.constructor.classname;
        var msg = "Error in property " + property + " of class " + classname + " in method " + this.$$method[variant][property] + " with incoming value '" + value + "': ";
        throw new Error(msg + (this.__P_71_11[id] || "Unknown reason: " + id));
      },

      /**
       * Compiles a string builder object to a function, executes the function and
       * returns the return value.
       *
       * @param instance {Object} Instance which have called the original method
       * @param members {Object} Prototype members map where the new function should be stored
       * @param name {String} Name of the property
       * @param variant {String} Function variant e.g. get, set, reset, ...
       * @param code {Array} Array which contains the code
       * @param args {arguments} Incoming arguments of wrapper method
       * @return {var} Return value of the generated function
       */
      __P_71_12: function (instance, members, name, variant, code, args) {
        var fn = this.__P_71_13(instance.constructor, name, variant, code, args); // Executing new function


        if (args === undefined) {
          return fn.call(instance);
        } else {
          return fn.call(instance, args[0]);
        }
      },

      /**
       * Takes a string builder object, converts it into a function, and installs it as
       * a property accessor
       *
       * @param clazz {Class} Class to install the method into
       * @param name {String} Name of the property
       * @param variant {String} Function variant e.g. get, set, reset, ...
       * @param code {Array} Array which contains the code
       * @param args {arguments} Incoming arguments of wrapper method
       * @return {var} Return value of the generated function
       */
      __P_71_13: function (clazz, name, variant, code, args) {
        var store = this.$$method[variant][name]; // Output generate code

        {
          clazz.prototype[store] = new Function("value", code.join(""));
        } // Enable profiling code

        qx.Bootstrap.setDisplayName(clazz.prototype[store], clazz.classname + ".prototype", store);
        return clazz.prototype[store];
      },

      /**
       * Generates the optimized getter, installs it into the class prototype, and executes it
       * Supported variants: get
       *
       * @param instance {Object} the instance which calls the method
       * @param clazz {Class} the class which originally defined the property
       * @param name {String} name of the property
       * @param variant {String} Method variant.
       * @return {var} Execute return value of apply generated function, generally the incoming value
       */
      executeOptimizedGetter: function (instance, clazz, name, variant) {
        var code = this.__P_71_14(clazz, name, variant);

        var members = clazz.prototype;
        return this.__P_71_12(instance, members, name, variant, code);
      },

      /**
       * Installs a getter into the class prototype, without executing it
       * Supported variants: get
       *
       * @param clazz {Class} the class which originally defined the property
       * @param name {String} name of the property
       * @param variant {String} Method variant.
       */
      __P_71_9: function (clazz, name, variant) {
        var code = this.__P_71_14(clazz, name, variant);

        this.__P_71_13(clazz, name, variant, code);
      },

      /**
       * Compiles a getter into a string builder array
       * Supported variants: get
       *
       * @param clazz {Class} the class which originally defined the property
       * @param name {String} name of the property
       * @param variant {String} Method variant.
       * @return {String[]} the string builder array
       */
      __P_71_14: function (clazz, name, variant) {
        var config = clazz.$$properties[name];
        var code = [];
        var store = this.$$store;

        if (variant == "getAsync") {
          code.push("return qx.Promise.resolve(this." + this.$$method.get[name] + "());");
          return code;
        }

        code.push('if(this.', store.runtime[name], '!==undefined)');
        code.push('return this.', store.runtime[name], ';');

        if (config.inheritable) {
          code.push('else if(this.', store.inherit[name], '!==undefined)');
          code.push('return this.', store.inherit[name], ';');
          code.push('else ');
        }

        code.push('if(this.', store.user[name], '!==undefined)');
        code.push('return this.', store.user[name], ';');

        if (config.themeable) {
          code.push('else if(this.', store.theme[name], '!==undefined)');
          code.push('return this.', store.theme[name], ';');
        }

        if (config.deferredInit && config.init === undefined) {
          code.push('else if(this.', store.init[name], '!==undefined)');
          code.push('return this.', store.init[name], ';');
        }

        code.push('else ');

        if (config.init !== undefined) {
          if (config.inheritable) {
            code.push('var init=this.', store.init[name], ';');

            if (config.nullable) {
              code.push('if(init==qx.core.Property.$$inherit)init=null;');
            }

            code.push('return init;');
          } else {
            code.push('return this.', store.init[name], ';');
          }
        } else if (config.inheritable || config.nullable) {
          code.push('return null;');
        } else {
          code.push('throw new Error("Property ', name, ' of an instance of ', clazz.classname, ' is not (yet) ready!");');
        }

        return code;
      },

      /**
       * Generates the optimized setter
       * Supported variants: set, reset, init, refresh, style, unstyle
       *
       * @param instance {Object} the instance which calls the method
       * @param clazz {Class} the class which originally defined the property
       * @param name {String} name of the property
       * @param variant {String} Method variant.
       * @param args {arguments} Incoming arguments of wrapper method
       * @return {var} Execute return value of apply generated function, generally the incoming value
       */
      executeOptimizedSetter: function (instance, clazz, name, variant, args) {
        var code = this.__P_71_15(clazz, name, variant);

        var members = clazz.prototype;
        return this.__P_71_12(instance, members, name, variant, code, args);
      },

      /**
       * Installs a setter into the class prototype, without executing it
       * Supported variants: set
       *
       * @param clazz {Class} the class which originally defined the property
       * @param name {String} name of the property
       * @param variant {String} Method variant.
       * @return {var} Return value of the generated function
       */
      __P_71_10: function (clazz, name, variant) {
        var code = this.__P_71_15(clazz, name, variant);

        return this.__P_71_13(clazz, name, variant, code);
      },

      /**
       * Compiles a setter into a string builder array
       * Supported variants: set, setThemed, setRuntime, init
       *
       * @param instance {Object} the instance which calls the method
       * @param clazz {Class} the class which originally defined the property
       * @param name {String} name of the property
       * @param variant {String} Method variant.
       * @return {String[]} the string builder array
       */
      __P_71_15: function (clazz, name, variant) {
        var config = clazz.$$properties[name];
        var members = clazz.prototype;
        var code = [];
        var upname = qx.lang.String.firstUp(name);

        if (variant == "setAsync") {
          code.push('return qx.Promise.resolve(this.$$set' + upname + "Impl.apply(this, arguments));");
          return code;
        } else if (variant == "set") {
          code.push('this.$$set' + upname + "Impl.apply(this, arguments);", 'return value;');
          return code;
        }

        var incomingValue = variant === "setImpl" || variant === "setThemed" || variant === "setRuntime" || variant === "init" && config.init === undefined;
        var hasCallback = config.apply || config.event || config.inheritable;

        var store = this.__P_71_16(variant, name);

        this.__P_71_17(code, clazz, config, name);

        this.__P_71_18(code, config, name, variant, incomingValue);

        if (incomingValue || hasCallback) {
          this.__P_71_19(code, config, name);
        }

        if (incomingValue) {
          this.__P_71_20(code, clazz, config, name);
        }

        if (hasCallback) {
          this.__P_71_21(code, incomingValue, store, variant);
        }

        if (config.inheritable) {
          code.push('var inherit=prop.$$inherit;');
        }

        if (!hasCallback) {
          this.__P_71_22(code, name, variant, incomingValue);
        } else {
          this.__P_71_23(code, config, name, variant, incomingValue);
        }

        if (config.inheritable) {
          this.__P_71_24(code, config, name, variant);
        } else if (hasCallback) {
          this.__P_71_25(code, config, name, variant);
        }

        if (hasCallback) {
          // Emit callback and event firing; Refreshing children (5th parameter) requires the parent/children interface
          this.__P_71_26(code, config, name, variant, !!(config.inheritable && members._getChildren));
        } // Return value


        if (incomingValue) {
          code.unshift('function set(value){');
          code.push('}');

          if (true && (!config.check || config.check != "qx.Promise")) {
            code.push('var promise;', 'if (value instanceof qx.Promise) ', 'promise = value.then(set.bind(this));', 'else ', 'promise = set.apply(this, arguments);');

            if (variant == "setImpl") {
              code.push("return promise;");
            } else {
              code.push('return value;');
            }
          } else {
            code.push('set.apply(this, arguments);', 'return value;');
          }
        }

        return code;
      },

      /**
       * Get the object to store the value for the given variant
       *
       * @param variant {String} Method variant.
       * @param name {String} name of the property
       *
       * @return {Object} the value store
       */
      __P_71_16: function (variant, name) {
        if (variant === "setRuntime" || variant === "resetRuntime") {
          var store = this.$$store.runtime[name];
        } else if (variant === "setThemed" || variant === "resetThemed") {
          store = this.$$store.theme[name];
        } else if (variant === "init") {
          store = this.$$store.init[name];
        } else {
          store = this.$$store.user[name];
        }

        return store;
      },

      /**
       * Emit code for the equality check evaluation
       *
       * @param code {String[]} String array to append the code to
       * @param clazz {Class} the class which originally defined the property
       * @param config {Object} The property configuration map
       * @param name {String} name of the property
       */
      __P_71_17: function (code, clazz, config, name) {
        code.push('var equ=');

        if (typeof config.isEqual === "function") {
          code.push('function(a,b){return !!', clazz.classname, '.$$properties.', name, '.isEqual.call(this,a,b);};');
        } else if (typeof config.isEqual === "string") {
          var members = clazz.prototype; // Name of member?

          if (members[config.isEqual] !== undefined) {
            code.push('this.', config.isEqual, ';');
          } else // 'inline' code
            {
              code.push('function(a,b){return !!(', config.isEqual, ');};');
            }
        } else if (typeof config.isEqual === "undefined") {
          code.push('function(a,b){return a===b;};');
        } else {
          throw new Error("Invalid type for 'isEqual' attribute of property '" + name + "' in class '" + clazz.classname + "'");
        }
      },

      /**
       * Emit code to check the arguments preconditions
       *
       * @param code {String[]} String array to append the code to
       * @param config {Object} The property configuration map
       * @param name {String} name of the property
       * @param variant {String} Method variant.
       * @param incomingValue {Boolean} Whether the setter has an incoming value
       */
      __P_71_18: function (code, config, name, variant, incomingValue) {
        {
          if (!config.nullable || config.check || config.inheritable) {
            code.push('var prop=qx.core.Property;');
          } // Undefined check


          if (variant === "setImpl") {
            code.push('if(value===undefined)prop.error(this,2,"', name, '","', variant, '",value);');
          }
        }
      },

      /**
       * Emit code to apply the "validate" and "transform" config keys.
       *
       * @param code {String[]} String array to append the code to
       * @param clazz {Class} the class which originally defined the property
       * @param config {Object} The property configuration map
       * @param name {String} name of the property
       */
      __P_71_20: function (code, clazz, config, name) {
        // Call user-provided transform method, if one is provided.  Transform
        // method should either throw an error or return the new value.
        if (config.transform) {
          code.push('value=this.', config.transform, '(value, old);');
        } // Call user-provided validate method, if one is provided.  Validate
        // method should either throw an error or do nothing.


        if (config.validate) {
          // if it is a string
          if (typeof config.validate === "string") {
            code.push('this.', config.validate, '(value);'); // if its a function otherwise
          } else if (config.validate instanceof Function) {
            code.push(clazz.classname, '.$$properties.', name);
            code.push('.validate.call(this, value);');
          }
        }
      },

      /**
       * Emit code, which returns if the incoming value equals the current value.
       *
       * @param code {String[]} String array to append the code to
       * @param incomingValue {Boolean} Whether the setter has an incoming value
       * @param store {Object} The data store to use for the incoming value
       * @param variant {String} Method variant.
       */
      __P_71_21: function (code, incomingValue, store, variant) {
        var resetValue = variant === "reset" || variant === "resetThemed" || variant === "resetRuntime";

        if (incomingValue) {
          code.push('if(equ.call(this,this.', store, ',value))return value;');
        } else if (resetValue) {
          code.push('if(this.', store, '===undefined)return;');
        }
      },

      /**
       * Emit code, which performs validation of the incoming value according to
       * the "nullable", "check" and "inheritable" config keys.
       *
       * @signature function(code, config, clazz, name, variant)
       * @param code {String[]} String array to append the code to
       * @param config {Object} The property configuration map
       * @param clazz {Class} the class which originally defined the property
       * @param name {String} name of the property
       * @param variant {String} Method variant.
       */
      __P_71_27: undefined,

      /**
       * Emit code to store the incoming value
       *
       * @param code {String[]} String array to append the code to
       * @param name {String} name of the property
       * @param variant {String} Method variant.
       * @param incomingValue {Boolean} Whether the setter has an incoming value
       */
      __P_71_22: function (code, name, variant, incomingValue) {
        if (variant === "setRuntime") {
          code.push('this.', this.$$store.runtime[name], '=value;');
        } else if (variant === "resetRuntime") {
          code.push('if(this.', this.$$store.runtime[name], '!==undefined)');
          code.push('delete this.', this.$$store.runtime[name], ';');
        } else if (variant === "setImpl") {
          code.push('this.', this.$$store.user[name], '=value;');
        } else if (variant === "reset") {
          code.push('if(this.', this.$$store.user[name], '!==undefined)');
          code.push('delete this.', this.$$store.user[name], ';');
        } else if (variant === "setThemed") {
          code.push('this.', this.$$store.theme[name], '=value;');
        } else if (variant === "resetThemed") {
          code.push('if(this.', this.$$store.theme[name], '!==undefined)');
          code.push('delete this.', this.$$store.theme[name], ';');
        } else if (variant === "init" && incomingValue) {
          code.push('this.', this.$$store.init[name], '=value;');
        }
      },

      /**
       * Emit code to store the incoming value and compute the "old" and "computed"
       * values.
       *
       * @param code {String[]} String array to append the code to
       * @param config {Object} The property configuration map
       * @param name {String} name of the property
       * @param variant {String} Method variant.
       * @param incomingValue {Boolean} Whether the setter has an incoming value
       */
      __P_71_23: function (code, config, name, variant, incomingValue) {
        code.push('var computed;'); // OLD = RUNTIME VALUE

        code.push('if(this.', this.$$store.runtime[name], '!==undefined){');

        if (variant === "setRuntime") {
          // Replace it with new value
          code.push('computed=this.', this.$$store.runtime[name], '=value;');
        } else if (variant === "resetRuntime") {
          // Delete field
          code.push('delete this.', this.$$store.runtime[name], ';'); // Complex computation of new value

          code.push('if(this.', this.$$store.user[name], '!==undefined)');
          code.push('computed=this.', this.$$store.user[name], ';');
          code.push('else if(this.', this.$$store.theme[name], '!==undefined)');
          code.push('computed=this.', this.$$store.theme[name], ';');
          code.push('else if(this.', this.$$store.init[name], '!==undefined){');
          code.push('computed=this.', this.$$store.init[name], ';');
          code.push('this.', this.$$store.useinit[name], '=true;');
          code.push('}');
        } else {
          // Use runtime value as it has higher priority
          code.push('computed=this.', this.$$store.runtime[name], ';'); // Store incoming value

          if (variant === "setImpl") {
            code.push('this.', this.$$store.user[name], '=value;');
          } else if (variant === "reset") {
            code.push('delete this.', this.$$store.user[name], ';');
          } else if (variant === "setThemed") {
            code.push('this.', this.$$store.theme[name], '=value;');
          } else if (variant === "resetThemed") {
            code.push('delete this.', this.$$store.theme[name], ';');
          } else if (variant === "init" && incomingValue) {
            code.push('this.', this.$$store.init[name], '=value;');
          }
        }

        code.push('}'); // OLD = USER VALUE

        code.push('else if(this.', this.$$store.user[name], '!==undefined){');

        if (variant === "setImpl") {
          // Replace it with new value
          code.push('computed=this.', this.$$store.user[name], '=value;');
        } else if (variant === "reset") {
          // Delete field
          code.push('delete this.', this.$$store.user[name], ';'); // Complex computation of new value

          code.push('if(this.', this.$$store.runtime[name], '!==undefined)');
          code.push('computed=this.', this.$$store.runtime[name], ';');
          code.push('if(this.', this.$$store.theme[name], '!==undefined)');
          code.push('computed=this.', this.$$store.theme[name], ';');
          code.push('else if(this.', this.$$store.init[name], '!==undefined){');
          code.push('computed=this.', this.$$store.init[name], ';');
          code.push('this.', this.$$store.useinit[name], '=true;');
          code.push('}');
        } else {
          if (variant === "setRuntime") {
            // Use runtime value where it has higher priority
            code.push('computed=this.', this.$$store.runtime[name], '=value;');
          } else if (config.inheritable) {
            // Use user value where it has higher priority
            code.push('computed=this.', this.$$store.user[name], ';');
          } else {
            // Use user value where it has higher priority
            code.push('computed=this.', this.$$store.user[name], ';');
          } // Store incoming value


          if (variant === "setThemed") {
            code.push('this.', this.$$store.theme[name], '=value;');
          } else if (variant === "resetThemed") {
            code.push('delete this.', this.$$store.theme[name], ';');
          } else if (variant === "init" && incomingValue) {
            code.push('this.', this.$$store.init[name], '=value;');
          }
        }

        code.push('}'); // OLD = THEMED VALUE

        if (config.themeable) {
          code.push('else if(this.', this.$$store.theme[name], '!==undefined){');

          if (variant === "setRuntime") {
            code.push('computed=this.', this.$$store.runtime[name], '=value;');
          } else if (variant === "setImpl") {
            code.push('computed=this.', this.$$store.user[name], '=value;');
          } // reset() is impossible, because the user has higher priority than
          // the themed value, so the themed value has no chance to ever get used,
          // when there is an user value, too.
          else if (variant === "setThemed") {
              code.push('computed=this.', this.$$store.theme[name], '=value;');
            } else if (variant === "resetThemed") {
              // Delete entry
              code.push('delete this.', this.$$store.theme[name], ';'); // Fallback to init value

              code.push('if(this.', this.$$store.init[name], '!==undefined){');
              code.push('computed=this.', this.$$store.init[name], ';');
              code.push('this.', this.$$store.useinit[name], '=true;');
              code.push('}');
            } else if (variant === "init") {
              if (incomingValue) {
                code.push('this.', this.$$store.init[name], '=value;');
              }

              code.push('computed=this.', this.$$store.theme[name], ';');
            } else if (variant === "refresh") {
              code.push('computed=this.', this.$$store.theme[name], ';');
            }

          code.push('}');
        } // OLD = INIT VALUE


        code.push('else if(this.', this.$$store.useinit[name], '){');

        if (variant === "init") {
          if (incomingValue) {
            code.push('computed=this.', this.$$store.init[name], '=value;');
          } else {
            code.push('computed=this.', this.$$store.init[name], ';');
          } // useinit flag is already initialized

        } // reset(), resetRuntime() and resetStyle() are impossible, because the user and themed values have a
        // higher priority than the init value, so the init value has no chance to ever get used,
        // when there is an user or themed value, too.
        else if (variant === "setImpl" || variant === "setRuntime" || variant === "setThemed" || variant === "refresh") {
            code.push('delete this.', this.$$store.useinit[name], ';');

            if (variant === "setRuntime") {
              code.push('computed=this.', this.$$store.runtime[name], '=value;');
            } else if (variant === "setImpl") {
              code.push('computed=this.', this.$$store.user[name], '=value;');
            } else if (variant === "setThemed") {
              code.push('computed=this.', this.$$store.theme[name], '=value;');
            } else if (variant === "refresh") {
              code.push('computed=this.', this.$$store.init[name], ';');
            }
          }

        code.push('}'); // OLD = NONE
        // reset(), resetRuntime() and resetStyle() are impossible because otherwise there
        // is already an old value

        if (variant === "setImpl" || variant === "setRuntime" || variant === "setThemed" || variant === "init") {
          code.push('else{');

          if (variant === "setRuntime") {
            code.push('computed=this.', this.$$store.runtime[name], '=value;');
          } else if (variant === "setImpl") {
            code.push('computed=this.', this.$$store.user[name], '=value;');
          } else if (variant === "setThemed") {
            code.push('computed=this.', this.$$store.theme[name], '=value;');
          } else if (variant === "init") {
            if (incomingValue) {
              code.push('computed=this.', this.$$store.init[name], '=value;');
            } else {
              code.push('computed=this.', this.$$store.init[name], ';');
            }

            code.push('this.', this.$$store.useinit[name], '=true;');
          } // refresh() will work with the undefined value, later


          code.push('}');
        }
      },

      /**
       * Emit code to compute the "old" value.
       *
       * @param code {String[]} String array to append the code to
       * @param config {Object} The property configuration map
       * @param name {String} name of the property
       */
      __P_71_19: function (code, config, name) {
        if (config.inheritable) {
          code.push('var old=this.', this.$$store.inherit[name], ';');
        } else {
          code.push('var old;');
        } // OLD = RUNTIME VALUE


        code.push('if(this.', this.$$store.runtime[name], '!==undefined){');
        code.push('old=this.', this.$$store.runtime[name], ';');
        code.push('}'); // OLD = USER VALUE

        if (!config.inheritable) {
          code.push('else if(this.', this.$$store.user[name], '!==undefined){');
          code.push('old=this.', this.$$store.user[name], ';');
          code.push('}'); // OLD = THEMED VALUE

          if (config.themeable) {
            code.push('else if(this.', this.$$store.theme[name], '!==undefined){');
            code.push('old=this.', this.$$store.theme[name], ';');
            code.push('}');
          } // OLD = INIT VALUE


          code.push('else if(this.', this.$$store.useinit[name], '){');
          code.push('old=this.', this.$$store.init[name], ';');
          code.push('}');
        }
      },

      /**
       * Emit code to store the value of an inheritable property
       *
       * @param code {String[]} String array to append the code to
       * @param config {Object} The property configuration map
       * @param name {String} name of the property
       * @param variant {String} Method variant.
       */
      __P_71_24: function (code, config, name, variant) {
        code.push('if(computed===undefined||computed===inherit){');

        if (variant === "refresh") {
          code.push('computed=value;');
        } else {
          code.push('var pa=this.getLayoutParent();if(pa)computed=pa.', this.$$store.inherit[name], ';');
        } // Fallback to init value if inheritance was unsuccessful


        code.push('if((computed===undefined||computed===inherit)&&');
        code.push('this.', this.$$store.init[name], '!==undefined&&');
        code.push('this.', this.$$store.init[name], '!==inherit){');
        code.push('computed=this.', this.$$store.init[name], ';');
        code.push('this.', this.$$store.useinit[name], '=true;');
        code.push('}else{');
        code.push('delete this.', this.$$store.useinit[name], ';}');
        code.push('}'); // Compare old/new computed value

        code.push('if(equ.call(this,old,computed))return value;'); // Note: At this point computed can be "inherit" or "undefined".
        // Normalize "inherit" to undefined and delete inherited value

        code.push('if(computed===inherit){');
        code.push('computed=undefined;delete this.', this.$$store.inherit[name], ';');
        code.push('}'); // Only delete inherited value

        code.push('else if(computed===undefined)');
        code.push('delete this.', this.$$store.inherit[name], ';'); // Store inherited value

        code.push('else this.', this.$$store.inherit[name], '=computed;'); // Protect against normalization

        code.push('var backup=computed;'); // After storage finally normalize computed and old value

        if (config.init !== undefined && variant !== "init") {
          code.push('if(old===undefined)old=this.', this.$$store.init[name], ";");
        } else {
          code.push('if(old===undefined)old=null;');
        }

        code.push('if(computed===undefined||computed==inherit)computed=null;');
      },

      /**
       * Emit code to normalize the old and incoming values from undefined to
       * <code>null</code>.
       *
       * @param code {String[]} String array to append the code to
       * @param config {Object} The property configuration map
       * @param name {String} name of the property
       * @param variant {String} Method variant.
       */
      __P_71_25: function (code, config, name, variant) {
        // Properties which are not inheritable have no possibility to get
        // undefined at this position. (Hint: set(), setRuntime() and setThemed() only allow non undefined values)
        if (variant !== "setImpl" && variant !== "setRuntime" && variant !== "setThemed") {
          code.push('if(computed===undefined)computed=null;');
        } // Compare old/new computed value


        code.push('if(equ.call(this,old,computed))return value;'); // Normalize old value

        if (config.init !== undefined && variant !== "init") {
          code.push('if(old===undefined)old=this.', this.$$store.init[name], ";");
        } else {
          code.push('if(old===undefined)old=null;');
        }
      },

      /**
       * Emit code to call the apply method and fire the change event
       *
       * @param code {String[]} String array to append the code to
       * @param config {Object} The property configuration map
       * @param name {String} name of the property
       * @param variant {String} variant of the method e.g. setThemed
       * @param refresh {Boolean} if true, emit code to update the inherited values of child objects
       */
      __P_71_26: function (code, config, name, variant, refresh) {
        // Execute user configured setter
        code.push('var promise;');

        if (config.apply) {
          code.push('promise = this.', config.apply, '(computed, old, "', name, '", "', variant, '");');
        }

        if (config.async) {
          code.push("function fire() {", "var promiseData = qx.Promise.resolve(computed);", "var promise = promiseData;"); // Fire event

          if (config.event) {
            code.push("var reg=qx.event.Registration;", "if(reg.hasListener(this, '", config.event, "')) {", "promise = reg.fireEventAsync(this, '", config.event, "', qx.event.type.Data, [computed, old]", ");", "promise = promise.then(function() { return computed; });", "}", "if(reg.hasListener(this, '", config.event, "Async'))", "promise = promise.then(function() {", "return reg.fireEventAsync(this, '", config.event, "Async', qx.event.type.Data, [promiseData, old]", ");", "}, this);");
          } // Emit code to update the inherited values of child objects


          if (refresh) {
            code.push('var a=this._getChildren();', 'if(a)', 'for(var i=0,l=a.length;i<l;i++){', 'if(a[i].', this.$$method.refresh[name], ')', 'a[i].', this.$$method.refresh[name], '(backup);', '}');
          }

          code.push("return promise;", "}");
        } else {
          code.push("function fire() {", "  var tracker={};"); // Fire event

          if (config.event) {
            code.push("var reg=qx.event.Registration;", "if(reg.hasListener(this, '", config.event, "'))", "qx.event.Utils.track(tracker, reg.fireEvent(this, '", config.event, "', qx.event.type.Data, [computed, old]", "));");
            {
              code.push("if(reg.hasListener(this, '", config.event, "Async'))", "qx.event.Utils.then(tracker, function() {\n  return reg.fireEventAsync(this, '", config.event, "Async', qx.event.type.Data, [qx.Promise.resolve(computed), old]", ");\n});");
            }
          } // Emit code to update the inherited values of child objects


          if (refresh) {
            code.push('var a=this._getChildren();', 'if(a)', 'for(var i=0,l=a.length;i<l;i++){', 'if(a[i].', this.$$method.refresh[name], ')', 'a[i].', this.$$method.refresh[name], '(backup);', '}');
          }

          code.push("if (tracker.promise)\n", "  return tracker.promise.then(function() { return computed; });", "return computed;", "}");
        }

        {
          code.push("if(promise instanceof qx.Promise) return promise.then(fire, this); ");
        }
        code.push("return fire.call(this);");
      }
    }
  });
  qx.core.Property.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (wittemann)
  
  ************************************************************************ */

  /**
   * This class is a base class for the OO system defined by Class, Mixin
   * and Interface. It contains helper which are basically needed to create the
   * Classes which define the OO system.
   */
  qx.Bootstrap.define("qx.util.OOUtil", {
    statics: {
      /**
       * Whether the given class exists
       *
       * @param name {String} class name to check
       * @return {Boolean} true if class exists
       */
      classIsDefined: function (name) {
        return qx.Bootstrap.getByName(name) !== undefined;
      },

      /**
       * Returns the definition of the given property, if not redefined.
       * Returns null if the property does not exist.
       *
       * @param clazz {Class} class to check
       * @param name {String} name of the class to check for
       * @return {Map|null} whether the object support the given event.
       */
      getPropertyDefinition: function (clazz, name) {
        while (clazz) {
          if (clazz.$$properties && clazz.$$properties[name]) {
            return clazz.$$properties[name];
          }

          clazz = clazz.superclass;
        }

        return null;
      },

      /**
       * Whether a class has the given property
       *
       * @param clazz {Class} class to check
       * @param name {String} name of the property to check for
       * @return {Boolean} whether the class includes the given property.
       */
      hasProperty: function (clazz, name) {
        return !!qx.util.OOUtil.getPropertyDefinition(clazz, name);
      },

      /**
       * Returns the event type of the given event. Returns null if
       * the event does not exist.
       *
       * @param clazz {Class} class to check
       * @param name {String} name of the event
       * @return {String|null} Event type of the given event.
       */
      getEventType: function (clazz, name) {
        var clazz = clazz.constructor;

        while (clazz.superclass) {
          if (clazz.$$events && clazz.$$events[name] !== undefined) {
            return clazz.$$events[name];
          }

          clazz = clazz.superclass;
        }

        return null;
      },

      /**
       * Whether a class supports the given event type
       *
       * @param clazz {Class} class to check
       * @param name {String} name of the event to check for
       * @return {Boolean} whether the class supports the given event.
       */
      supportsEvent: function (clazz, name) {
        return !!qx.util.OOUtil.getEventType(clazz, name);
      },

      /**
       * Returns the class or one of its super classes which contains the
       * declaration of the given interface. Returns null if the interface is not
       * specified anywhere.
       *
       * @param clazz {Class} class to look for the interface
       * @param iface {Interface} interface to look for
       * @return {Class | null} the class which directly implements the given interface
       */
      getByInterface: function (clazz, iface) {
        var list, i, l;

        while (clazz) {
          if (clazz.$$implements) {
            list = clazz.$$flatImplements;

            for (i = 0, l = list.length; i < l; i++) {
              if (list[i] === iface) {
                return clazz;
              }
            }
          }

          clazz = clazz.superclass;
        }

        return null;
      },

      /**
       * Whether a given class or any of its super classes includes a given interface.
       *
       * This function will return "true" if the interface was defined
       * in the class declaration ({@link qx.Class#define}) of the class
       * or any of its super classes using the "implement"
       * key.
       *
       * @param clazz {Class} class to check
       * @param iface {Interface} the interface to check for
       * @return {Boolean} whether the class includes the interface.
       */
      hasInterface: function (clazz, iface) {
        return !!qx.util.OOUtil.getByInterface(clazz, iface);
      },

      /**
       * Returns a list of all mixins available in a given class.
       *
       * @param clazz {Class} class which should be inspected
       * @return {Mixin[]} array of mixins this class uses
       */
      getMixins: function (clazz) {
        var list = [];

        while (clazz) {
          if (clazz.$$includes) {
            list.push.apply(list, clazz.$$flatIncludes);
          }

          clazz = clazz.superclass;
        }

        return list;
      }
    }
  });
  qx.util.OOUtil.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Interface": {
        "require": true,
        "defer": "runtime"
      },
      "qx.Mixin": {
        "require": true,
        "defer": "runtime"
      },
      "qx.lang.normalize.Array": {
        "require": true,
        "defer": "runtime"
      },
      "qx.lang.normalize.Date": {
        "require": true,
        "defer": "runtime"
      },
      "qx.lang.normalize.Error": {
        "require": true,
        "defer": "runtime"
      },
      "qx.lang.normalize.Function": {
        "require": true,
        "defer": "runtime"
      },
      "qx.lang.normalize.String": {
        "require": true,
        "defer": "runtime"
      },
      "qx.lang.normalize.Object": {
        "require": true,
        "defer": "runtime"
      },
      "qx.lang.normalize.Number": {
        "require": true,
        "defer": "runtime"
      },
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Property": {
        "require": true
      },
      "qx.core.Environment": {},
      "qx.util.OOUtil": {
        "require": true
      },
      "qx.lang.Type": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * John Spackman (john.spackman@zenesis.com)
  
  ************************************************************************ */

  /**
   * This class is one of the most important parts of qooxdoo's
   * object-oriented features.
   *
   * Its {@link #define} method is used to create qooxdoo classes.
   *
   * Each instance of a class defined by {@link #define} has
   * the following keys attached to the constructor and the prototype:
   *
   * <table>
   * <tr><th><code>classname</code></th><td>The fully-qualified name of the class (e.g. <code>"qx.ui.core.Widget"</code>).</td></tr>
   * <tr><th><code>basename</code></th><td>The namespace part of the class name (e.g. <code>"qx.ui.core"</code>).</td></tr>
   * <tr><th><code>constructor</code></th><td>A reference to the constructor of the class.</td></tr>
   * <tr><th><code>superclass</code></th><td>A reference to the constructor of the super class.</td></tr>
   * </table>
   *
   * Each method may access static members of the same class by using
   * <code>this.self(arguments)</code> ({@link qx.core.Object#self}):
   * <pre class='javascript'>
   * statics : { FOO : "bar" },
   * members: {
   *   baz: function(x) {
   *     this.self(arguments).FOO;
   *     ...
   *   }
   * }
   * </pre>
   *
   * Each overriding method may call the overridden method by using
   * <code>this.base(arguments [, ...])</code> ({@link qx.core.Object#base}). This is also true for calling
   * the constructor of the superclass.
   * <pre class='javascript'>
   * members: {
   *   foo: function(x) {
   *     this.base(arguments, x);
   *     ...
   *   }
   * }
   * </pre>
   *
   * By using <code>qx.Class</code> within an app, the native JS data types are
   * conveniently polyfilled according to {@link qx.lang.normalize}.
   * 
   * Annotations can be added to classes, constructors, destructors, and methods, properties, and statics - 
   * see <code>qx.Annotation</code> for examples and means access annotations at runtime.
   *
   * @require(qx.Interface)
   * @require(qx.Mixin)
   * @require(qx.lang.normalize.Array)
   * @require(qx.lang.normalize.Date)
   * @require(qx.lang.normalize.Error)
   * @require(qx.lang.normalize.Function)
   * @require(qx.lang.normalize.String)
   * @require(qx.lang.normalize.Object)
   * @require(qx.lang.normalize.Number)
   */
  qx.Bootstrap.define("qx.Class", {
    statics: {
      /**
       * A static reference to the property implementation in the case it
       * should be included.
       */
      __P_56_0: true ? qx.core.Property : null,

      /*
      ---------------------------------------------------------------------------
         PUBLIC METHODS
      ---------------------------------------------------------------------------
      */

      /**
       * Define a new class using the qooxdoo class system. This sets up the
       * namespace for the class and generates the class from the definition map.
       *
       * Example:
       * <pre class='javascript'>
       * qx.Class.define("name",
       * {
       *   extend : Object, // superclass
       *   implement : [Interfaces],
       *   include : [Mixins],
       *
       *   statics:
       *   {
       *     CONSTANT : 3.141,
       *
       *     publicMethod: function() {},
       *     _protectedMethod: function() {},
       *     __privateMethod: function() {}
       *   },
       *
       *   properties:
       *   {
       *     "tabIndex": { check: "Number", init : -1 }
       *   },
       *
       *   members:
       *   {
       *     publicField: "foo",
       *     publicMethod: function() {},
       *
       *     _protectedField: "bar",
       *     _protectedMethod: function() {},
       *
       *     __privateField: "baz",
       *     __privateMethod: function() {}
       *   }
       * });
       * </pre>
       *
       * @param name {String?null} Name of the class. If <code>null</code>, the class
       *   will not be added to any namespace which could be handy for testing.
       * @param config {Map ? null} Class definition structure. The configuration map has the following keys:
       *     <table>
       *       <tr><th>Name</th><th>Type</th><th>Description</th></tr>
       *       <tr><th>type</th><td>String</td><td>
       *           Type of the class. Valid types are "abstract", "static" and "singleton".
       *           If unset it defaults to a regular non-static class.
       *       </td></tr>
       *       <tr><th>extend</th><td>Class</td><td>The super class the current class inherits from.</td></tr>
       *       <tr><th>implement</th><td>Interface | Interface[]</td><td>Single interface or array of interfaces the class implements.</td></tr>
       *       <tr><th>include</th><td>Mixin | Mixin[]</td><td>Single mixin or array of mixins, which will be merged into the class.</td></tr>
       *       <tr><th>construct</th><td>Function</td><td>The constructor of the class.</td></tr>
       *       <tr><th>statics</th><td>Map</td><td>Map of static members of the class.</td></tr>
       *       <tr><th>properties</th><td>Map</td><td>Map of property definitions. For a description of the format of a property definition see
       *           {@link qx.core.Property}.</td></tr>
       *       <tr><th>members</th><td>Map</td><td>Map of instance members of the class.</td></tr>
       *       <tr><th>environment</th><td>Map</td><td>Map of environment settings for this class. For a description of the format of a setting see
       *           {@link qx.core.Environment}.</td></tr>
       *       <tr><th>events</th><td>Map</td><td>
       *           Map of events the class fires. The keys are the names of the events and the values are the
       *           corresponding event type class names.
       *       </td></tr>
       *       <tr><th>defer</th><td>Function</td><td>Function that is called at the end of processing the class declaration. It allows access to the declared statics, members and properties.</td></tr>
       *       <tr><th>destruct</th><td>Function</td><td>The destructor of the class.</td></tr>
       *     </table>
       * @return {Class} The defined class
       */
      define: function (name, config) {
        if (!config) {
          config = {};
        } // Normalize include to array


        if (config.include && !(qx.Bootstrap.getClass(config.include) === "Array")) {
          config.include = [config.include];
        } // Normalize implement to array


        if (config.implement && !(qx.Bootstrap.getClass(config.implement) === "Array")) {
          config.implement = [config.implement];
        } // Normalize type


        var implicitType = false;

        if (!config.hasOwnProperty("extend") && !config.type) {
          config.type = "static";
          implicitType = true;
        } // Validate incoming data


        // Create the class
        var clazz = this.__P_56_1(name, config.type, config.extend, config.statics, config.construct, config.destruct, config.include); // Initialise class and constructor/destructor annotations


        ["@", "@construct", "@destruct"].forEach(function (id) {
          this.__P_56_2(clazz, id, null, config[id]);
        }, this); // Members, properties, events and mixins are only allowed for non-static classes

        if (config.extend) {
          // Attach properties
          if (config.properties) {
            this.__P_56_3(clazz, config.properties, true);
          } // Attach members


          if (config.members) {
            this.__P_56_4(clazz, config.members, true, true, false);
          } // Process events


          if (config.events) {
            this.__P_56_5(clazz, config.events, true);
          } // Include mixins
          // Must be the last here to detect conflicts


          if (config.include) {
            for (var i = 0, l = config.include.length; i < l; i++) {
              this.__P_56_6(clazz, config.include[i], false);
            }
          }
        } // If config has a 'extend' key but it's null or undefined
        else if (config.hasOwnProperty('extend') && false) {
            throw new Error('"extend" parameter is null or undefined');
          } // Process environment


        if (config.environment) {
          for (var key in config.environment) {
            qx.core.Environment.add(key, config.environment[key]);
          }
        } // Interface support for non-static classes


        if (config.implement) {
          for (var i = 0, l = config.implement.length; i < l; i++) {
            this.__P_56_7(clazz, config.implement[i]);
          }
        }

        // Process defer
        if (config.defer) {
          config.defer.self = clazz;
          qx.Bootstrap.addPendingDefer(clazz, function () {
            clazz = qx.Class.getByName(clazz.classname);
            config.defer(clazz, clazz.prototype, {
              add: function (name, config) {
                // build pseudo properties map
                var properties = {};
                properties[name] = config; // execute generic property handler

                qx.Class.__P_56_3(clazz, properties, true);
              }
            });
          });
        }

        return clazz;
      },

      /**
       * Removes a class from qooxdoo defined by {@link #define}
       *
       * @param name {String} Name of the class
       */
      undefine: function (name) {
        // first, delete the class from the registry
        delete this.$$registry[name]; // delete the class reference from the namespaces and all empty namespaces

        var ns = name.split("."); // build up an array containing all namespace objects including window

        var objects = [window];

        for (var i = 0; i < ns.length; i++) {
          objects.push(objects[i][ns[i]]);
        } // go through all objects and check for the constructor or empty namespaces


        for (var i = objects.length - 1; i >= 1; i--) {
          var last = objects[i];
          var parent = objects[i - 1];

          if (qx.Bootstrap.isFunction(last) || qx.Bootstrap.objectGetLength(last) === 0) {
            delete parent[ns[i - 1]];
          } else {
            break;
          }
        }
      },

      /**
       * Whether the given class exists
       *
       * @signature function(name)
       * @param name {String} class name to check
       * @return {Boolean} true if class exists
       */
      isDefined: qx.util.OOUtil.classIsDefined,

      /**
       * Determine the total number of classes
       *
       * @return {Number} the total number of classes
       */
      getTotalNumber: function () {
        return qx.Bootstrap.objectGetLength(this.$$registry);
      },

      /**
       * Find a class by its name
       *
       * @signature function(name)
       * @param name {String} class name to resolve
       * @return {Class} the class
       */
      getByName: qx.Bootstrap.getByName,

      /**
       * Include all features of the given mixin into the class. The mixin must
       * not include any methods or properties that are already available in the
       * class. This would only be possible using the {@link #patch} method.
       *
       * @param clazz {Class} An existing class which should be augmented by including a mixin.
       * @param mixin {Mixin} The mixin to be included.
       */
      include: function (clazz, mixin) {
        qx.Class.__P_56_6(clazz, mixin, false);
      },

      /**
       * Include all features of the given mixin into the class. The mixin may
       * include features, which are already defined in the target class. Existing
       * features of equal name will be overwritten.
       * Please keep in mind that this functionality is not intended for regular
       * use, but as a formalized way (and a last resort) in order to patch
       * existing classes.
       * 
       * <b>WARNING</b>: You may break working classes and features.
       *
       * @param clazz {Class} An existing class which should be modified by including a mixin.
       * @param mixin {Mixin} The mixin to be included.
       * @return {Class} the new class definition
       */
      patch: function (clazz, mixin) {
        qx.Class.__P_56_6(clazz, mixin, true);

        return qx.Class.getByName(clazz.classname);
      },

      /**
       * Detects whether the object is a Class (and not an instance of a class)
       * 
       *  @param obj {Object?} the object to inspect
       *  @return {Boolean} true if it is a class, false if it is anything else
       */
      isClass: function (obj) {
        return obj && obj.$$type === "Class" && obj.constructor === obj;
      },

      /**
       * Whether a class is a direct or indirect sub class of another class,
       * or both classes coincide.
       *
       * @param clazz {Class} the class to check.
       * @param superClass {Class} the potential super class
       * @return {Boolean} whether clazz is a sub class of superClass.
       */
      isSubClassOf: function (clazz, superClass) {
        if (!clazz) {
          return false;
        }

        if (clazz == superClass) {
          return true;
        }

        if (clazz.prototype instanceof superClass) {
          return true;
        }

        return false;
      },

      /**
       * Returns the definition of the given property. Returns null
       * if the property does not exist.
       *
       * @signature function(clazz, name)
       * @param clazz {Class} class to check
       * @param name {String} name of the class to check for
       * @return {Map|null} whether the object support the given event.
       */
      getPropertyDefinition: qx.util.OOUtil.getPropertyDefinition,

      /**
       * Returns a list of all properties supported by the given class
       *
       * @param clazz {Class} Class to query
       * @return {String[]} List of all property names
       */
      getProperties: function (clazz) {
        var list = [];

        while (clazz) {
          if (clazz.$$properties) {
            list.push.apply(list, Object.keys(clazz.$$properties));
          }

          clazz = clazz.superclass;
        }

        return list;
      },

      /**
       * Returns the class or one of its superclasses which contains the
       * declaration for the given property in its class definition. Returns null
       * if the property is not specified anywhere.
       *
       * @param clazz {Class} class to look for the property
       * @param name {String} name of the property
       * @return {Class | null} The class which includes the property
       */
      getByProperty: function (clazz, name) {
        while (clazz) {
          if (clazz.$$properties && clazz.$$properties[name]) {
            return clazz;
          }

          clazz = clazz.superclass;
        }

        return null;
      },

      /**
       * Whether a class has the given property
       *
       * @signature function(clazz, name)
       * @param clazz {Class} class to check
       * @param name {String} name of the property to check for
       * @return {Boolean} whether the class includes the given property.
       */
      hasProperty: qx.util.OOUtil.hasProperty,

      /**
       * Returns the event type of the given event. Returns null if
       * the event does not exist.
       *
       * @signature function(clazz, name)
       * @param clazz {Class} class to check
       * @param name {String} name of the event
       * @return {String|null} Event type of the given event.
       */
      getEventType: qx.util.OOUtil.getEventType,

      /**
       * Whether a class supports the given event type
       *
       * @signature function(clazz, name)
       * @param clazz {Class} class to check
       * @param name {String} name of the event to check for
       * @return {Boolean} whether the class supports the given event.
       */
      supportsEvent: qx.util.OOUtil.supportsEvent,

      /**
       * Whether a class directly includes a mixin.
       *
       * @param clazz {Class} class to check
       * @param mixin {Mixin} the mixin to check for
       * @return {Boolean} whether the class includes the mixin directly.
       */
      hasOwnMixin: function (clazz, mixin) {
        return clazz.$$includes && clazz.$$includes.indexOf(mixin) !== -1;
      },

      /**
       * Returns the class or one of its superclasses which contains the
       * declaration for the given mixin. Returns null if the mixin is not
       * specified anywhere.
       *
       * @param clazz {Class} class to look for the mixin
       * @param mixin {Mixin} mixin to look for
       * @return {Class | null} The class which directly includes the given mixin
       */
      getByMixin: function (clazz, mixin) {
        var list, i, l;

        while (clazz) {
          if (clazz.$$includes) {
            list = clazz.$$flatIncludes;

            for (i = 0, l = list.length; i < l; i++) {
              if (list[i] === mixin) {
                return clazz;
              }
            }
          }

          clazz = clazz.superclass;
        }

        return null;
      },

      /**
       * Returns a list of all mixins available in a given class.
       *
       * @signature function(clazz)
       * @param clazz {Class} class which should be inspected
       * @return {Mixin[]} array of mixins this class uses
       */
      getMixins: qx.util.OOUtil.getMixins,

      /**
       * Whether a given class or any of its superclasses includes a given mixin.
       *
       * @param clazz {Class} class to check
       * @param mixin {Mixin} the mixin to check for
       * @return {Boolean} whether the class includes the mixin.
       */
      hasMixin: function (clazz, mixin) {
        return !!this.getByMixin(clazz, mixin);
      },

      /**
       * Whether a given class directly includes an interface.
       *
       * This function will only return "true" if the interface was defined
       * in the class declaration ({@link qx.Class#define}) using the "implement"
       * key.
       *
       * @param clazz {Class} class or instance to check
       * @param iface {Interface} the interface to check for
       * @return {Boolean} whether the class includes the mixin directly.
       */
      hasOwnInterface: function (clazz, iface) {
        return clazz.$$implements && clazz.$$implements.indexOf(iface) !== -1;
      },

      /**
       * Returns the class or one of its super classes which contains the
       * declaration of the given interface. Returns null if the interface is not
       * specified anywhere.
       *
       * @signature function(clazz, iface)
       * @param clazz {Class} class to look for the interface
       * @param iface {Interface} interface to look for
       * @return {Class | null} the class which directly implements the given interface
       */
      getByInterface: qx.util.OOUtil.getByInterface,

      /**
       * Returns a list of all interfaces a given class has to implement.
       *
       * @param clazz {Class} class which should be inspected
       * @return {Interface[]} array of interfaces this class implements
       */
      getInterfaces: function (clazz) {
        var list = [];

        while (clazz) {
          if (clazz.$$implements) {
            list.push.apply(list, clazz.$$flatImplements);
          }

          clazz = clazz.superclass;
        }

        return list;
      },

      /**
       * Whether a given class or any of its super classes includes a given interface.
       *
       * This function will return "true" if the interface was defined
       * in the class declaration ({@link qx.Class#define}) of the class
       * or any of its super classes using the "implement"
       * key.
       *
       * @signature function(clazz, iface)
       * @param clazz {Class} class to check
       * @param iface {Interface} the interface to check for
       * @return {Boolean} whether the class includes the interface.
       */
      hasInterface: qx.util.OOUtil.hasInterface,

      /**
       * Whether a given class complies to an interface.
       *
       * Checks whether all methods defined in the interface are
       * implemented. The class does not need to implement
       * the interface explicitly in the <code>extend</code> key.
       *
       * @param obj {Object} class to check
       * @param iface {Interface} the interface to check for
       * @return {Boolean} whether the class conforms to the interface.
       */
      implementsInterface: function (obj, iface) {
        var clazz = obj.constructor;

        if (this.hasInterface(clazz, iface)) {
          return true;
        }

        if (qx.Interface.objectImplements(obj, iface)) {
          return true;
        }

        if (qx.Interface.classImplements(clazz, iface)) {
          return true;
        }

        return false;
      },

      /**
       * Helper method to handle singletons
       *
       * @internal
       * @return {Object} The singleton instance
       */
      getInstance: function () {
        if (this.$$instance === null) {
          throw new Error("Singleton instance of " + this + " is requested, but not ready yet. This is most likely due to a recursive call in the constructor path.");
        }

        if (!this.$$instance) {
          this.$$allowconstruct = true;
          this.$$instance = null; // null means "object is being created"; needed for another call of getInstance() during instantiation

          this.$$instance = new this();
          delete this.$$allowconstruct;
        }

        return this.$$instance;
      },

      /**
       * Retreive all subclasses of a given class
       *
       * @param clazz {Class} the class which should be inspected
       * 
       * @return {Object} class name hash holding the references to the subclasses or null if the class does not exist.
       */
      getSubclasses: function (clazz) {
        if (!clazz) {
          return null;
        }

        var subclasses = {};
        var registry = qx.Class.$$registry;

        for (var name in registry) {
          if (registry[name].superclass && registry[name].superclass == clazz) {
            subclasses[name] = registry[name];
          }
        }

        return subclasses;
      },

      /*
      ---------------------------------------------------------------------------
         PRIVATE/INTERNAL BASICS
      ---------------------------------------------------------------------------
      */

      /**
       * This method will be attached to all classes to return
       * a nice identifier for them.
       *
       * @internal
       * @return {String} The class identifier
       */
      genericToString: function () {
        return "[Class " + this.classname + "]";
      },

      /** Stores all defined classes */
      $$registry: qx.Bootstrap.$$registry,

      /** @type {Map} allowed keys in non-static class definition */
      __P_56_8: null,

      /** @type {Map} allowed keys in static class definition */
      __P_56_9: null,

      /**
       * Validates an incoming configuration and checks for proper keys and values
       *
       * @signature function(name, config)
       * @param name {String} The name of the class
       * @param config {Map} Configuration map
       */
      __P_56_10: function (name, config) {},

      /**
       * Validates the interfaces required by abstract base classes
       *
       * @signature function(clazz)
       * @param clazz {Class} The configured class.
       */
      __P_56_11: function (clazz) {},

      /**
       * Attaches an annotation to a class
       *
       * @param clazz {Map} Static methods or fields
       * @param group {String} Group name
       * @param key {String} Name of the annotated item
       * @param anno {Object} Annotation object
       */
      __P_56_2: function (clazz, group, key, anno) {
        if (anno !== undefined) {
          if (clazz.$$annotations === undefined) {
            clazz.$$annotations = {};
            clazz.$$annotations[group] = {};
          } else if (clazz.$$annotations[group] === undefined) {
            clazz.$$annotations[group] = {};
          }

          if (!qx.lang.Type.isArray(anno)) {
            anno = [anno];
          }

          if (key) {
            clazz.$$annotations[group][key] = anno;
          } else {
            clazz.$$annotations[group] = anno;
          }
        }
      },

      /**
       * Creates a class by type. Supports modern inheritance etc.
       *
       * @param name {String} Full name of the class
       * @param type {String} type of the class, i.e. "static", "abstract" or "singleton"
       * @param extend {Class} Superclass to inherit from
       * @param statics {Map} Static methods or fields
       * @param construct {Function} Constructor of the class
       * @param destruct {Function} Destructor of the class
       * @param mixins {Mixin[]} array of mixins of the class
       * @return {Class} The generated class
       */
      __P_56_1: function (name, type, extend, statics, construct, destruct, mixins) {
        var isStrictMode = function () {
          return typeof this == 'undefined';
        };

        var clazz;

        if (!extend && true) {
          // Create empty/non-empty class
          clazz = statics || {};
          qx.Bootstrap.setDisplayNames(clazz, name);
        } else {
          clazz = {};

          if (extend) {
            // Create default constructor
            if (!construct) {
              construct = this.__P_56_12();
            }

            clazz = this.__P_56_13(construct, name, type); // Add singleton getInstance()

            if (type === "singleton") {
              clazz.getInstance = this.getInstance;
            }

            qx.Bootstrap.setDisplayName(construct, name, "constructor");
          } // Copy statics


          if (statics) {
            qx.Bootstrap.setDisplayNames(statics, name);
            var key;

            for (var i = 0, a = Object.keys(statics), l = a.length; i < l; i++) {
              key = a[i];
              var staticValue = statics[key];

              if (key.charAt(0) === '@') {
                continue;
              }

              {
                clazz[key] = staticValue;
              } // Attach annotations

              this.__P_56_2(clazz, "statics", key, statics["@" + key]);
            }
          }
        } // Create namespace


        var basename = name ? qx.Bootstrap.createNamespace(name, clazz) : ""; // Store names in constructor/object

        clazz.classname = name;

        if (!isStrictMode()) {
          try {
            clazz.name = name;
          } catch (ex) {// Nothing
          }
        }

        clazz.basename = basename; // Store type info

        clazz.$$type = "Class";

        if (type) {
          clazz.$$classtype = type;
        } // Attach toString


        if (!clazz.hasOwnProperty("toString")) {
          clazz.toString = this.genericToString;
        }

        if (extend) {
          qx.Bootstrap.extendClass(clazz, construct, extend, name, basename); // Store destruct onto class

          if (destruct) {
            clazz.$$destructor = destruct;
            qx.Bootstrap.setDisplayName(destruct, name, "destruct");
          }
        } // Store class reference in global class registry


        this.$$registry[name] = clazz; // Return final class object

        return clazz;
      },

      /*
      ---------------------------------------------------------------------------
         PRIVATE ADD HELPERS
      ---------------------------------------------------------------------------
      */

      /**
       * Attach events to the class
       *
       * @param clazz {Class} class to add the events to
       * @param events {Map} map of event names the class fires.
       * @param patch {Boolean ? false} Enable redefinition of event type?
       */
      __P_56_5: function (clazz, events, patch) {
        if (clazz.$$events) {
          for (var key in events) {
            clazz.$$events[key] = events[key];
          }
        } else {
          clazz.$$events = events;
        }
      },

      /**
       * Attach properties to classes
       *
       * @param clazz {Class} class to add the properties to
       * @param properties {Map} map of properties
       * @param patch {Boolean ? false} Overwrite property with the limitations of a property
                 which means you are able to refine but not to replace (esp. for new properties)
       */
      __P_56_3: function (clazz, properties, patch) {
        // check for the property module
        var config;

        if (patch === undefined) {
          patch = false;
        }

        var proto = clazz.prototype;

        for (var name in properties) {
          config = properties[name]; // Check incoming configuration

          // Store name into configuration
          config.name = name; // Add config to local registry

          if (!config.refine) {
            if (clazz.$$properties === undefined) {
              clazz.$$properties = {};
            }

            clazz.$$properties[name] = config;
          } // Store init value to prototype. This makes it possible to
          // overwrite this value in derived classes.


          if (config.init !== undefined) {
            clazz.prototype["$$init_" + name] = config.init;
          } // register event name


          if (config.event !== undefined) {
            // break if no events layer loaded
            var event = {};
            event[config.event] = "qx.event.type.Data";

            if (config.async) {
              event[config.event + "Async"] = "qx.event.type.Data";
            }

            this.__P_56_5(clazz, event, patch);
          } // Remember inheritable properties


          if (config.inheritable) {
            this.__P_56_0.$$inheritable[name] = true;

            if (!proto.$$refreshInheritables) {
              this.__P_56_0.attachRefreshInheritables(clazz);
            }
          }

          if (!config.refine) {
            this.__P_56_0.attachMethods(clazz, name, config);
          } // Add annotations


          this.__P_56_2(clazz, "properties", name, config["@"]);
        }
      },

      /**
       * Validates the given property
       *
       * @signature function(clazz, name, config, patch)
       * @param clazz {Class} class to add property to
       * @param name {String} name of the property
       * @param config {Map} configuration map
       * @param patch {Boolean ? false} enable refine/patch?
       */
      __P_56_14: null,

      /**
       * Attach members to a class
       *
       * @param clazz {Class} clazz to add members to
       * @param members {Map} The map of members to attach
       * @param patch {Boolean ? false} Enable patching of
       * @param base {Boolean ? true} Attach base flag to mark function as members
       *     of this class
       * @param wrap {Boolean ? false} Whether the member method should be wrapped.
       *     this is needed to allow base calls in patched mixin members.
       */
      __P_56_4: function (clazz, members, patch, base, wrap) {
        var proto = clazz.prototype;
        var key, member;
        qx.Bootstrap.setDisplayNames(members, clazz.classname + ".prototype");

        for (var i = 0, a = Object.keys(members), l = a.length; i < l; i++) {
          key = a[i];
          member = members[key];

          // Annotations are not members
          if (key.charAt(0) === '@') {
            var annoKey = key.substring(1);

            if (members[annoKey] === undefined) {
              this.__P_56_2(clazz, "members", annoKey, members[key]);
            }

            continue;
          } // If it's a property accessor, we need to install it now so that this.base can refer to it


          if (proto[key] != undefined && proto[key].$$install) {
            proto[key].$$install();
          } // Added helper stuff to functions
          // Hint: Could not use typeof function because RegExp objects are functions, too
          // Protect to apply base property and aspect support on special attributes e.g.
          // classes which are function like as well.


          if (base !== false && member instanceof Function && member.$$type == null) {
            if (false && wrap == true) {
              // wrap "patched" mixin member
              member = this.__P_56_15(member, proto[key]);
            } else if (wrap != true) {
              // Configure extend (named base here)
              // Hint: proto[key] is not yet overwritten here
              if (proto[key]) {
                member.base = proto[key];
              }

              member.self = clazz;
            }
          } // Attach member


          proto[key] = member; // Attach annotations

          this.__P_56_2(clazz, "members", key, members["@" + key]);
        }
      },

      /**
       * Wraps a member function of a mixin, which is included using "patch". This
       * allows "base" calls in the mixin member function.
       *
       * @param member {Function} The mixin method to wrap
       * @param base {Function} The overwritten method
       * @return {Function} the wrapped mixin member
       */
      __P_56_15: function (member, base) {
        {
          throw new Error("This function should not be used except with code compiled by the generator (ie python toolchain)");
        }
      },

      /**
       * Add a single interface to a class
       *
       * @param clazz {Class} class to add interface to
       * @param iface {Interface} the Interface to add
       */
      __P_56_7: function (clazz, iface) {
        // Store interface reference
        var list = qx.Interface.flatten([iface]);

        if (clazz.$$implements) {
          clazz.$$implements.push(iface);
          clazz.$$flatImplements.push.apply(clazz.$$flatImplements, list);
        } else {
          clazz.$$implements = [iface];
          clazz.$$flatImplements = list;
        }
      },

      /**
       * Include all features of the mixin into the given class, recursively.
       *
       * @param clazz {Class} The class onto which the mixin should be attached.
       * @param mixin {Mixin} Include all features of this mixin
       * @param patch {Boolean} Overwrite existing fields, functions and properties
       */
      __P_56_6: function (clazz, mixin, patch) {
        if (this.hasMixin(clazz, mixin)) {
          return;
        } // Attach content


        var list = qx.Mixin.flatten([mixin]);
        var entry;

        for (var i = 0, l = list.length; i < l; i++) {
          entry = list[i]; // Attach events

          if (entry.$$events) {
            this.__P_56_5(clazz, entry.$$events, patch);
          } // Attach properties (Properties are already readonly themselves, no patch handling needed)


          if (entry.$$properties) {
            this.__P_56_3(clazz, entry.$$properties, patch);
          } // Attach members (Respect patch setting, but dont apply base variables)


          if (entry.$$members) {
            this.__P_56_4(clazz, entry.$$members, patch, patch, patch);
          }
        } // Store mixin reference


        if (clazz.$$includes) {
          clazz.$$includes.push(mixin);
          clazz.$$flatIncludes.push.apply(clazz.$$flatIncludes, list);
        } else {
          clazz.$$includes = [mixin];
          clazz.$$flatIncludes = list;
        }
      },

      /*
      ---------------------------------------------------------------------------
         PRIVATE FUNCTION HELPERS
      ---------------------------------------------------------------------------
      */

      /**
       * Returns the default constructor.
       * This constructor just calls the constructor of the base class.
       *
       * @return {Function} The default constructor.
       */
      __P_56_12: function () {
        function defaultConstructor() {
          defaultConstructor.base.apply(this, arguments);
        }

        return defaultConstructor;
      },

      /**
       * Generate a wrapper of the original class constructor in order to enable
       * some of the advanced OO features (e.g. abstract class, singleton, mixins)
       *
       * @param construct {Function} the original constructor
       * @param name {String} name of the class
       * @param type {String} the user specified class type
       * @return {Function} The wrapped constructor
       */
      __P_56_13: function (construct, name, type) {
        var wrapper = function () {
          var clazz = wrapper;
          // Execute default constructor
          var retval = clazz.$$original.apply(this, arguments); // Initialize local mixins

          if (clazz.$$includes) {
            var mixins = clazz.$$flatIncludes;

            for (var i = 0, l = mixins.length; i < l; i++) {
              if (mixins[i].$$constructor) {
                mixins[i].$$constructor.apply(this, arguments);
              }
            }
          }

          // Return optional return value
          return retval;
        };

        // Store original constructor
        wrapper.$$original = construct; // Store wrapper into constructor (needed for base calls etc.)

        construct.wrapper = wrapper; // Return generated wrapper

        return wrapper;
      }
    },
    defer: function () {}
  });
  qx.Class.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Mixin": {
        "usage": "dynamic",
        "require": true
      },
      "qx.data.SingleValueBinding": {},
      "qx.Promise": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * This mixin is forwarding the static methods of
   * {@link qx.data.SingleValueBinding} to the instance including the mixin.
   * The source object will be <code>this</code>.
   */
  qx.Mixin.define("qx.data.MBinding", {
    members: {
      /**
       * The bind method delegates the call to the
       * {@link qx.data.SingleValueBinding#bind} function. As source, the current
       * object (this) will be used.
       *
       * @param sourcePropertyChain {String} The property chain which represents
       *   the source property.
       * @param targetObject {qx.core.Object} The object which the source should
       *   be bind to.
       * @param targetProperty {String} The property name of the target object.
       * @param options {Map?null} A map containing the options. See
       *   {@link qx.data.SingleValueBinding#bind} for more
       *   information.
       *
       * @return {var} Returns the internal id for that binding. This can be used
       *   for referencing the binding e.g. for removing. This is not an atomic
       *   id so you can't you use it as a hash-map index.
       *
       * @throws {qx.core.AssertionError} If the event is no data event or
       *   there is no property definition for object and property (source and
       *   target).
       */
      bind: function (sourcePropertyChain, targetObject, targetProperty, options) {
        return qx.data.SingleValueBinding.bind(this, sourcePropertyChain, targetObject, targetProperty, options);
      },

      /**
       * The bind method delegates the call to the
       * {@link qx.data.SingleValueBinding#bind} function. As source, the current
       * object (this) will be used.
       *
       * @param sourcePropertyChain {String} The property chain which represents
       *   the source property.
       * @param targetObject {qx.core.Object} The object which the source should
       *   be bind to.
       * @param targetProperty {String} The property name of the target object.
       * @param options {Map} A map containing the options. See
       *   {@link qx.data.SingleValueBinding#bind} for more
       *   information.
       *
       * @return {qx.Promise} A promise which is resolved when the initial value
       * 	 has been set on the target.  Note that this does NOT resolve when subsequent
       *   values are returned.  The promise value is the internal id for that binding. 
       *   The id can be used for referencing the binding e.g. for removing. This is not 
       *   an atomic id so you can't you use it as a hash-map index.
       *
       * @throws {qx.core.AssertionError} If the event is no data event or
       *   there is no property definition for object and property (source and
       *   target).
       */
      bindAsync: function (sourcePropertyChain, targetObject, targetProperty, options) {
        var id = qx.data.SingleValueBinding.bind(this, sourcePropertyChain, targetObject, targetProperty, options);

        if (id.initialPromise) {
          return id.initialPromise.then(function () {
            id.initialPromise = null;
            return id;
          });
        } else {
          return qx.Promise.resolve(id);
        }
      },

      /**
       * Removes the binding with the given id from the current object. The
       * id has to be the id returned by any of the bind functions.
       *
       * @param id {var} The id of the binding.
       * @throws {Error} If the binding could not be found.
       */
      removeBinding: function (id) {
        qx.data.SingleValueBinding.removeBindingFromObject(this, id);
      },

      /**
       * Removes all bindings between the object and the related one.
       *
       * @param relatedObject {qx.core.Object} The object of which related
       *   bindings should be removed.
       * @throws {Error} If one of the bindings listed internally can not be
       *   removed.
       */
      removeRelatedBindings: function (relatedObject) {
        qx.data.SingleValueBinding.removeRelatedBindings(this, relatedObject);
      },

      /**
       * Removes all bindings from the object.
       *
       * @throws {qx.core.AssertionError} If the object is not in the internal
       *   registry of the bindings.
       * @throws {Error} If one of the bindings listed internally can not be
       *   removed.
       */
      removeAllBindings: function () {
        qx.data.SingleValueBinding.removeAllBindingsForObject(this);
      },

      /**
       * Returns an array which lists all bindings for the object.
       *
       * @return {Array} An array of binding informations. Every binding
       *   information is an array itself containing id, sourceObject, sourceEvent,
       *   targetObject and targetProperty in that order.
       */
      getBindings: function () {
        return qx.data.SingleValueBinding.getAllBindingsForObject(this);
      }
    },
    destruct: function () {
      // restore the object hash for disposing the bindings
      this.$$hash = this.$$discardedHashCode;
      this.removeAllBindings();
      delete this.$$hash;
    }
  });
  qx.data.MBinding.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.lang.normalize.String": {
        "require": true,
        "defer": "runtime"
      },
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.bom.client.EcmaScript": {
        "require": true
      },
      "qx.lang.Array": {},
      "qx.lang.Function": {},
      "qx.core.ObjectRegistry": {},
      "qx.lang.Type": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "ecmascript.error.stacktrace": {
          "className": "qx.bom.client.EcmaScript"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * Methods to get information about the JavaScript call stack.
   *
   * @require(qx.lang.normalize.String)
   * @ignore(qx.bom.client.EcmaScript.*)
   * @ignore(qx.bom.client)
   * @ignore(qx.bom)
   * @ignore(qx.Class.*)
   */
  qx.Bootstrap.define("qx.dev.StackTrace", {
    statics: {
      /**
       * Optional user-defined function to convert source file names into readable
       * class names. Will be called with the source file name extracted from the
       * browser's stack trace information as the only argument. The returned
       * string is used in the output of {@link #getStackTraceFromError}
       */
      FILENAME_TO_CLASSNAME: null,

      /**
       * Optional user-defined formatting function for stack trace information.
       * Will be called by with an array of strings representing the calls in the
       * stack trace. {@link #getStackTraceFromError} will return the output of
       * this function. Must return an array of strings.
       */
      FORMAT_STACKTRACE: null,

      /**
       * Get a stack trace of the current position in the code.
       *
       * Browser compatibility:
       * <ul>
       *   <li>In new versions of Gecko, WebKit and Opera, the output of
       *   {@link #getStackTraceFromError} and {@link #getStackTraceFromCaller} is
       *   combined to generate the richest trace, including line numbers.</li>
       *   <li>For Internet Explorer (and other engines that do not provide stack
       *    traces), {@link #getStackTraceFromCaller} is used</li>
       * </ul>
       *
       * @return {String[]} Stack trace of the current position in the code. Each line in the array
       *     represents one call in the stack trace.
       */
      getStackTrace: function () {
        var trace = [];

        try {
          throw new Error();
        } catch (ex) {
          if (qx.dev.StackTrace.hasEnvironmentCheck && qx.core.Environment.get("ecmascript.error.stacktrace")) {
            var errorTrace = qx.dev.StackTrace.getStackTraceFromError(ex);
            var callerTrace = qx.dev.StackTrace.getStackTraceFromCaller(arguments);
            qx.lang.Array.removeAt(errorTrace, 0);
            trace = callerTrace.length > errorTrace.length ? callerTrace : errorTrace;

            for (var i = 0; i < Math.min(callerTrace.length, errorTrace.length); i++) {
              var callerCall = callerTrace[i];

              if (callerCall.indexOf("anonymous") >= 0) {
                continue;
              }

              var methodName = null;
              var callerArr = callerCall.split(".");
              var mO = /(.*?)\(/.exec(callerArr[callerArr.length - 1]);

              if (mO && mO.length == 2) {
                methodName = mO[1];
                callerArr.pop();
              }

              if (callerArr[callerArr.length - 1] == "prototype") {
                callerArr.pop();
              }

              var callerClassName = callerArr.join(".");
              var errorCall = errorTrace[i];
              var errorArr = errorCall.split(":");
              var errorClassName = errorArr[0];
              var lineNumber = errorArr[1];
              var columnNumber;

              if (errorArr[2]) {
                columnNumber = errorArr[2];
              }

              var className = null;

              if (qx.Class && qx.Class.getByName(errorClassName)) {
                className = errorClassName;
              } else {
                className = callerClassName;
              }

              var line = className;

              if (methodName) {
                line += "." + methodName;
              }

              line += ":" + lineNumber;

              if (columnNumber) {
                line += ":" + columnNumber;
              }

              trace[i] = line;
            }
          } else {
            trace = this.getStackTraceFromCaller(arguments);
          }
        }

        return trace;
      },

      /**
       * Get a stack trace from the arguments special variable using the
       * <code>caller</code> property.
       *
       * This methods returns class/mixin and function names of each step
       * in the call stack.
       *
       * Recursion is not supported.
       *
       * @param args {arguments} arguments variable.
       * @return {String[]} Stack trace of caller of the function the arguments variable belongs to.
       *     Each line in the array represents one call in the stack trace.
       * @signature function(args)
       */
      getStackTraceFromCaller: function (args) {
        var isStrictMode = function () {
          return typeof this == 'undefined';
        };

        var trace = [];
        var fcn = null;

        if (!isStrictMode()) {
          try {
            fcn = qx.lang.Function.getCaller(args);
          } catch (ex) {// Nothing
          }
        }

        var knownFunction = {};

        while (fcn) {
          var fcnName = qx.lang.Function.getName(fcn);
          trace.push(fcnName);

          try {
            fcn = fcn.caller;
          } catch (ex) {
            break;
          }

          if (!fcn) {
            break;
          } // avoid infinite recursion


          var hash = qx.core.ObjectRegistry.toHashCode(fcn);

          if (knownFunction[hash]) {
            trace.push("...");
            break;
          }

          knownFunction[hash] = fcn;
        }

        return trace;
      },

      /**
       * Try to get a stack trace from an Error object. Mozilla sets the field
       * <code>stack</code> for Error objects thrown using <code>throw new Error()</code>.
       * From this field it is possible to get a stack trace from the position
       * the exception was thrown at.
       *
       * This will get the JavaScript file names and the line numbers of each call.
       * The file names are converted into qooxdoo class names if possible (customizable
       * via {@link #FILENAME_TO_CLASSNAME}).
       *
       * The stack trace can be custom formatted using {@link #FORMAT_STACKTRACE}.
       *
       * This works reliably in Gecko-based browsers. Later Opera versions and
       * Chrome also provide a useful stack trace. For Safari, only the class or
       * file name and line number where the error occurred are returned.
       * IE 6/7/8/9 does not attach any stack information to error objects so an
       * empty array is returned.
       *
       * @param error {Error} Error exception instance.
       * @return {String[]} Stack trace of the exception. Each line in the array
       *     represents one call in the stack trace.
       */
      getStackTraceFromError: function (error) {
        var trace = [];
        var lineRe, hit, className, lineNumber, columnNumber, fileName, url;
        var traceProp = qx.dev.StackTrace.hasEnvironmentCheck ? qx.core.Environment.get("ecmascript.error.stacktrace") : null;

        if (traceProp === "stack") {
          if (!error.stack) {
            return trace;
          } // Gecko style, e.g. "()@http://localhost:8080/webcomponent-test-SNAPSHOT/webcomponent/js/com/ptvag/webcomponent/common/log/Logger:253"


          lineRe = /@(.+):(\d+)$/gm;

          while ((hit = lineRe.exec(error.stack)) != null) {
            url = hit[1];
            lineNumber = hit[2];
            className = this.__P_72_0(url);
            trace.push(className + ":" + lineNumber);
          }

          if (trace.length > 0) {
            return this.__P_72_1(trace);
          }
          /*
           * Chrome trace info comes in two flavors:
           * at [jsObject].function (fileUrl:line:char)
           * at fileUrl:line:char
           */


          lineRe = /at (.*)/gm;
          var fileReParens = /\((.*?)(:[\d:]+)\)/;
          var fileRe = /(.*?)(:[\d:]+$)/;

          while ((hit = lineRe.exec(error.stack)) != null) {
            var fileMatch = fileReParens.exec(hit[1]);

            if (!fileMatch) {
              fileMatch = fileRe.exec(hit[1]);
            }

            if (fileMatch) {
              className = this.__P_72_0(fileMatch[1]);
              trace.push(className + fileMatch[2]);
            } else {
              trace.push(hit[1]);
            }
          }
        } else if (traceProp === "stacktrace") {
          // Opera
          var stacktrace = error.stacktrace;

          if (!stacktrace) {
            return trace;
          }

          if (stacktrace.indexOf("Error created at") >= 0) {
            stacktrace = stacktrace.split("Error created at")[0];
          } // new Opera style (10.6+)


          lineRe = /line\ (\d+?),\ column\ (\d+?)\ in\ (?:.*?)\ in\ (.*?):[^\/]/gm;

          while ((hit = lineRe.exec(stacktrace)) != null) {
            lineNumber = hit[1];
            columnNumber = hit[2];
            url = hit[3];
            className = this.__P_72_0(url);
            trace.push(className + ":" + lineNumber + ":" + columnNumber);
          }

          if (trace.length > 0) {
            return this.__P_72_1(trace);
          } // older Opera style


          lineRe = /Line\ (\d+?)\ of\ linked\ script\ (.*?)$/gm;

          while ((hit = lineRe.exec(stacktrace)) != null) {
            lineNumber = hit[1];
            url = hit[2];
            className = this.__P_72_0(url);
            trace.push(className + ":" + lineNumber);
          }
        } else if (error.message && error.message.indexOf("Backtrace:") >= 0) {
          // Some old Opera versions append the trace to the message property
          var traceString = error.message.split("Backtrace:")[1].trim();
          var lines = traceString.split("\n");

          for (var i = 0; i < lines.length; i++) {
            var reResult = lines[i].match(/\s*Line ([0-9]+) of.* (\S.*)/);

            if (reResult && reResult.length >= 2) {
              lineNumber = reResult[1];
              fileName = this.__P_72_0(reResult[2]);
              trace.push(fileName + ":" + lineNumber);
            }
          }
        } else if (error.sourceURL && error.line) {
          // Safari
          trace.push(this.__P_72_0(error.sourceURL) + ":" + error.line);
        }

        return this.__P_72_1(trace);
      },

      /**
       * Converts the URL of a JavaScript file to a class name using either a
       * user-defined ({@link #FILENAME_TO_CLASSNAME}) or default
       * ({@link #__fileNameToClassNameDefault}) converter
       *
       * @param fileName {String} URL of the JavaScript file
       * @return {String} Result of the conversion
       */
      __P_72_0: function (fileName) {
        if (typeof qx.dev.StackTrace.FILENAME_TO_CLASSNAME == "function") {
          var convertedName = qx.dev.StackTrace.FILENAME_TO_CLASSNAME(fileName);

          if (false && !qx.lang.Type.isString(convertedName)) {
            throw new Error("FILENAME_TO_CLASSNAME must return a string!");
          }

          return convertedName;
        }

        return qx.dev.StackTrace.__P_72_2(fileName);
      },

      /**
       * Converts the URL of a JavaScript file to a class name if the file is
       * named using the qooxdoo naming conventions.
       *
       * @param fileName {String} URL of the JavaScript file
       * @return {String} class name of the file if conversion was possible.
       * Otherwise the fileName is returned unmodified.
       */
      __P_72_2: function (fileName) {
        var scriptDir = "/source/class/";
        var jsPos = fileName.indexOf(scriptDir);
        var paramPos = fileName.indexOf("?");

        if (paramPos >= 0) {
          fileName = fileName.substring(0, paramPos);
        }

        var className = jsPos == -1 ? fileName : fileName.substring(jsPos + scriptDir.length).replace(/\//g, ".").replace(/\.js$/, "");
        return className;
      },

      /**
       * Runs the given stack trace array through the formatter function
       * ({@link #FORMAT_STACKTRACE}) if available and returns it. Otherwise, the
       * original array is returned
       *
       * @param trace {String[]} Stack trace information
       * @return {String[]} Formatted stack trace info
       */
      __P_72_1: function (trace) {
        if (typeof qx.dev.StackTrace.FORMAT_STACKTRACE == "function") {
          trace = qx.dev.StackTrace.FORMAT_STACKTRACE(trace); // Can't use qx.core.Assert here since it throws an AssertionError which
          // calls getStackTrace in its constructor, leading to infinite recursion

          if (false && !qx.lang.Type.isArray(trace)) {
            throw new Error("FORMAT_STACKTRACE must return an array of strings!");
          }
        }

        return trace;
      }
    },
    defer: function (statics) {
      // This is necessary to avoid an infinite loop when logging the absence
      // of the "ecmascript.error.stacktrace" environment key.
      statics.hasEnvironmentCheck = qx.bom && qx.bom.client && qx.bom.client.EcmaScript && qx.bom.client.EcmaScript.getStackTrace;
    }
  });
  qx.dev.StackTrace.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
       2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Carsten Lergenmueller (carstenl)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * An memory container which stores arbitrary data up to a maximum number of
   * entries. When new entries come in an the maximum is reached, the oldest
   * entries are deleted.
   *
   * A mark feature also exists which can be used to remember a point in time.
   * When retrieving entries, it is possible to get only those entries
   * after the marked time. This is useful if data from the buffer is extracted
   * and processed. Whenever this happens, a mark() call can be used so that the
   * next extraction will only get new data.
   */
  qx.Bootstrap.define("qx.util.RingBuffer", {
    extend: Object,

    /**
     * Constructor.
     *
     * @param maxEntries {Integer ? 50} Maximum number of entries in the buffer
     */
    construct: function (maxEntries) {
      this.setMaxEntries(maxEntries || 50);
    },
    members: {
      //Next slot in ringbuffer to use
      __P_87_0: 0,
      //Number of elements in ring buffer
      __P_87_1: 0,
      //Was a mark set?
      __P_87_2: false,
      //How many elements were stored since setting of mark?
      __P_87_3: 0,
      //ring buffer
      __P_87_4: null,
      //Maximum number of messages to store. Could be converted to a qx property.
      __P_87_5: null,

      /**
       * Set the maximum number of messages to hold. If null the number of
       * messages is not limited.
       *
       * Warning: Changing this property will clear the events logged so far.
       *
       * @param maxEntries {Integer} the maximum number of messages to hold
       */
      setMaxEntries: function (maxEntries) {
        this.__P_87_5 = maxEntries;
        this.clear();
      },

      /**
       * Get the maximum number of entries to hold
       *
       * @return {Integer}
       */
      getMaxEntries: function () {
        return this.__P_87_5;
      },

      /**
       * Adds a single entry
       *
       * @param entry {var} The data to store
       */
      addEntry: function (entry) {
        this.__P_87_4[this.__P_87_0] = entry;
        this.__P_87_0 = this.__P_87_6(this.__P_87_0, 1); //Count # of stored entries

        var max = this.getMaxEntries();

        if (this.__P_87_1 < max) {
          this.__P_87_1++;
        } //Count # of stored elements since last mark call


        if (this.__P_87_2 && this.__P_87_3 < max) {
          this.__P_87_3++;
        }
      },

      /**
       * Returns the number of entries stored
       * @return {Integer}
       */
      getNumEntriesStored: function () {
        return this.__P_87_1;
      },

      /**
       * Remembers the current position in the ring buffer
       *
       */
      mark: function () {
        this.__P_87_2 = true;
        this.__P_87_3 = 0;
      },

      /**
       * Removes the current mark position
       */
      clearMark: function () {
        this.__P_87_2 = false;
      },

      /**
       * Returns all stored entries. Mark is ignored.
       *
       * @return {Array} array of stored entries
       */
      getAllEntries: function () {
        return this.getEntries(this.getMaxEntries(), false);
      },

      /**
       * Returns entries which have been added previously.
       *
       * @param count {Integer} The number of entries to retrieve. If there are
       *    more entries than the given count, the oldest ones will not be returned.
       *
       * @param startingFromMark {Boolean ? false} If true, only entries since
       *   the last call to mark() will be returned
       * @return {Array} array of stored entries
       */
      getEntries: function (count, startingFromMark) {
        //Trim count so it does not exceed ringbuffer size
        if (count > this.__P_87_1) {
          count = this.__P_87_1;
        } // Trim count so it does not exceed last call to mark (if mark was called
        // and startingFromMark was true)


        if (startingFromMark && this.__P_87_2 && count > this.__P_87_3) {
          count = this.__P_87_3;
        }

        if (count > 0) {
          var indexOfYoungestElementInHistory = this.__P_87_6(this.__P_87_0, -1);

          var startIndex = this.__P_87_6(indexOfYoungestElementInHistory, -count + 1);

          var result;

          if (startIndex <= indexOfYoungestElementInHistory) {
            //Requested segment not wrapping around ringbuffer boundary, get in one run
            result = this.__P_87_4.slice(startIndex, indexOfYoungestElementInHistory + 1);
          } else {
            //Requested segment wrapping around ringbuffer boundary, get two parts & concat
            result = this.__P_87_4.slice(startIndex, this.__P_87_1).concat(this.__P_87_4.slice(0, indexOfYoungestElementInHistory + 1));
          }
        } else {
          result = [];
        }

        return result;
      },

      /**
       * Clears all entries
       */
      clear: function () {
        this.__P_87_4 = new Array(this.getMaxEntries());
        this.__P_87_1 = 0;
        this.__P_87_3 = 0;
        this.__P_87_0 = 0;
      },

      /**
       * Adds a number to an ringbuffer index. Does a modulus calculation,
       * i. e. if the index leaves the ringbuffer space it will wrap around to
       * the other end of the ringbuffer.
       *
       * @param idx {Number} The current index.
       * @param addMe {Number} The number to add.
       * @return {Number} The new index
       */
      __P_87_6: function (idx, addMe) {
        var max = this.getMaxEntries();
        var result = (idx + addMe) % max; //If negative, wrap up into the ringbuffer space

        if (result < 0) {
          result += max;
        }

        return result;
      }
    }
  });
  qx.util.RingBuffer.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.util.RingBuffer": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2006 STZ-IDA, Germany, http://www.stz-ida.de
       2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Carsten Lergenmueller (carstenl)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * An appender that writes all messages to a memory container. The messages
   * can be retrieved later, f. i. when an error dialog pops up and the question
   * arises what actions have caused the error.
   *
   * A mark feature also exists which can be used to remember a point in time.
   * When retrieving log events, it is possible to get only those events
   * after the marked time. This is useful if data from the buffer is extracted
   * and f. i. sent to a logging system. Whenever this happens, a mark() call
   * can be used so that the next extraction will only get new data.
   */
  qx.Bootstrap.define("qx.log.appender.RingBuffer", {
    extend: qx.util.RingBuffer,

    /**
     * @param maxMessages {Integer?50} Maximum number of messages in the buffer
     */
    construct: function (maxMessages) {
      this.setMaxMessages(maxMessages || 50);
    },
    members: {
      /**
       * Set the maximum number of messages to hold. If null the number of
       * messages is not limited.
       *
       * Warning: Changing this property will clear the events logged so far.
       *
       * @param maxMessages {Integer} the maximum number of messages to hold
       */
      setMaxMessages: function (maxMessages) {
        this.setMaxEntries(maxMessages);
      },

      /**
       * Get the maximum number of messages to hold
       *
       * @return {Integer} the maximum number of messages
       */
      getMaxMessages: function () {
        return this.getMaxEntries();
      },

      /**
       * Processes a single log entry
       *
       * @param entry {Map} The entry to process
       */
      process: function (entry) {
        this.addEntry(entry);
      },

      /**
       * Returns all stored log events
       *
       * @return {Array} array of stored log events
       */
      getAllLogEvents: function () {
        return this.getAllEntries();
      },

      /**
       * Returns log events which have been logged previously.
       *
       * @param count {Integer} The number of events to retrieve. If there are
       *    more events than the given count, the oldest ones will not be returned.
       *
       * @param startingFromMark {Boolean ? false} If true, only entries since the last call to mark()
       *                                           will be returned
       * @return {Array} array of stored log events
       */
      retrieveLogEvents: function (count, startingFromMark) {
        return this.getEntries(count, startingFromMark);
      },

      /**
       * Clears the log history
       */
      clearHistory: function () {
        this.clear();
      }
    }
  });
  qx.log.appender.RingBuffer.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.dev.StackTrace": {
        "require": true,
        "defer": "runtime"
      },
      "qx.Bootstrap": {
        "usage": "dynamic",
        "defer": "runtime",
        "require": true
      },
      "qx.lang.Array": {},
      "qx.log.appender.RingBuffer": {
        "usage": "dynamic",
        "require": true
      },
      "qx.lang.Function": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * John Spackman (john.spackman@zenesis.com)
  
  ************************************************************************ */

  /**
   * Main qooxdoo logging class.
   *
   * Used as central logging feature by qx.core.Object.
   *
   * Extremely modular and lightweight to support logging at bootstrap and
   * at shutdown as well.
   *
   * * Supports dynamic appenders to push the output to the user
   * * Supports buffering of the last 50 messages (configurable)
   * * Supports different debug levels ("debug", "info", "warn" or "error")
   * * Simple data serialization for incoming messages
   *
   * Typical use of this class is via qx.core.MLogging which is included into most
   * classes, so you would use "this.debug(...)" etc, but qx.log.Logger.debug(),
   * .warn(), .error(), .info(), and .trace() can be used directly for static code.
   *
   * The first parameter is expected to be the context object, ie the object which
   * is sending the log; this can be null but that will prevent the filtering from
   * filtering on class name so ideally it will be a real qx.core.Object derived
   * object.  Other parameters are any Javascript object which will be serialized
   * into the log message
   *
   * <pre class="javascript">
   *  qx.log.Logger.warn(myObject, "This is a message to log", myParam, otherData);
   * </pre>
   *
   *
   * The output of logging is controlled by "appenders", which are classes that
   * accept a log message and output it somehow (see examples in qx.log.appender.*);
   * typical examples are qx.log.appender.Console which outputs to the browser
   * console, or qx.log.appender.Native which outputs messages into a popup
   * window as part of your Qooxdoo UI.
   *
   * While it's quick and easy to add logging calls to code as and when you need it,
   * it is often convenient to control which logging calls output messages at runtime
   * rather than having to edit code. @see qx.log.Logger#addFilter
   *
   * @require(qx.dev.StackTrace)
   */
  qx.Bootstrap.define("qx.log.Logger", {
    statics: {
      /*
      ---------------------------------------------------------------------------
        CONFIGURATION
      ---------------------------------------------------------------------------
      */
      __P_58_0: "debug",

      /**
       * Configures the minimum log level required for new messages.
       *
       * @param value {String} One of "debug", "info", "warn" or "error".
       */
      setLevel: function (value) {
        this.__P_58_0 = value;
      },

      /**
       * Returns the currently configured minimum log level required for new
       * messages.
       *
       * @return {Integer} Debug level
       */
      getLevel: function () {
        return this.__P_58_0;
      },

      /**
       * Configures the number of messages to be kept in the buffer.
       *
       * @param value {Integer} Any positive integer
       */
      setTreshold: function (value) {
        this.__P_58_1.setMaxMessages(value);
      },

      /**
       * Returns the currently configured number of messages to be kept in the
       * buffer.
       *
       * @return {Integer} Treshold value
       */
      getTreshold: function () {
        return this.__P_58_1.getMaxMessages();
      },

      /*
      ---------------------------------------------------------------------------
        APPENDER MANAGEMENT
      ---------------------------------------------------------------------------
      */

      /** @type {Map} Map of all known appenders by ID */
      __P_58_2: [],

      /** @type {Map} Map of all known appenders by name */
      __P_58_3: {},

      /** @type {Array} Array of filters to apply when selecting appenders to append to */
      __P_58_4: [],

      /** @type {Integer} Last free appender ID */
      __P_58_5: 0,

      /**
       * Registers the given appender and inserts the last cached messages.
       * 
       * Note that an appender is named by it's class name, unless it has a property
       * called `appenderName`
       *
       * @param appender {Class} A static appender class supporting at
       *   least a <code>process()</code> method to handle incoming messages.
       */
      register: function (appender) {
        if (appender.$$id) {
          return;
        } // Register appender


        var id = this.__P_58_5++;
        var appenderName = appender.appenderName || appender.classname;
        this.__P_58_2[id] = appender;
        this.__P_58_3[appenderName] = appender;
        appender.$$id = id; // Insert previous messages

        var entries = this.__P_58_1.getAllLogEvents();

        for (var i = 0, l = entries.length; i < l; i++) {
          var entry = entries[i];

          var appenders = this.__P_58_6(entry.loggerName, entry.level);

          if (appenders[appenderName]) {
            appender.process(entry);
          }
        }
      },

      /**
       * Unregisters the given appender
       *
       * @param appender {Class} A static appender class
       */
      unregister: function (appender) {
        var id = appender.$$id;

        if (id == null) {
          return;
        }

        var appenderName = appender.appenderName || appender.classname;
        delete this.__P_58_3[appenderName];
        delete this.__P_58_2[id];
        delete appender.$$id;
      },

      /**
       * Adds a filter that specifies the appenders to use for a given logger name (classname).
       *
       * By default, every log entry is output to all appenders but you can change this
       * behaviour by calling qx.log.Logger.addFilter; every log message is associated
       * with a class and a logging level (ie debug, warn, info, error, etc) and you can
       * apply a filter on either one.
       *
       * For example, to restrict the output to only allow qx.ui.* classes to output debug
       * logging information you would use this:
       *
       *  <pre class="javascript">
       *    qx.log.Logger.addFilter(/^qx\.ui/, null, "debug");
       *  </pre>
       *
       * Note that while the default is to log everything, as soon as you apply one filter
       * you are specifying an exhaustive list of classes; so if you use the above example,
       * the ONLY classes that will be able to log is qx.ui.*.  If you want to use multiple
       * classes to the output, just add more addFilter calls.
       *
       * The logging level (eg "debug", "error", etc) is greater than or equal to - so in
       * the above example, debug, error, warn, and info will be output but trace will not.
       *
       * The second parameter to addFilter is the classname of the appender to use; this
       * allows you to specify that log messages only go to one destination; for example:
       *
       *  <pre class="javascript">
       *    qx.log.Logger.addFilter(/^qx\.ui/, "qx.log.appender.Console", "warn");
       *    qx.log.Logger.addFilter(/^qx\.io/, "qx.log.appender.Native", "debug");
       *    qx.log.Logger.addFilter(/^qx\.io/, "qx.log.appender.Console", "error");
       *  </pre>
       *
       * In this example, qx.ui.* will only go to the Console appender and only if a warning
       * is issued; qx.io.* will go to Native for debug, error, warn, and info and to
       * Console for error, warn, and info
       *
       * Note that an appender is named by it's class name, unless it has a property
       * called `appenderName`.
       * 
       * @param logger {String|RegExp} the pattern to match in the logger name
       * @param appenderName {String?} the name of the appender class, if undefined then all appenders
       * @param level {String?} the minimum logging level to use the appender, if undefined the default level is used
       */
      addFilter: function (logger, appenderName, level) {
        if (typeof logger == "string") {
          logger = new RegExp(logger);
        }

        this.__P_58_4.push({
          loggerMatch: logger,
          level: level || this.__P_58_0,
          appenderName: appenderName
        });
      },

      /**
       * Reset all filters
       */
      resetFilters: function () {
        this.__P_58_4 = [];
      },

      /*
      ---------------------------------------------------------------------------
        USER METHODS
      ---------------------------------------------------------------------------
      */

      /**
       * Sending a message at level "debug" to the logger.
       *
       * @param object {Object} Contextual object (either instance or static class)
       * @param message {var} Any number of arguments supported. An argument may
       *   have any JavaScript data type. All data is serialized immediately and
       *   does not keep references to other objects.
       */
      debug: function (object, message) {
        qx.log.Logger.__P_58_7("debug", arguments);
      },

      /**
       * Sending a message at level "info" to the logger.
       *
       * @param object {Object} Contextual object (either instance or static class)
       * @param message {var} Any number of arguments supported. An argument may
       *   have any JavaScript data type. All data is serialized immediately and
       *   does not keep references to other objects.
       */
      info: function (object, message) {
        qx.log.Logger.__P_58_7("info", arguments);
      },

      /**
       * Sending a message at level "warn" to the logger.
       *
       * @param object {Object} Contextual object (either instance or static class)
       * @param message {var} Any number of arguments supported. An argument may
       *   have any JavaScript data type. All data is serialized immediately and
       *   does not keep references to other objects.
       */
      warn: function (object, message) {
        qx.log.Logger.__P_58_7("warn", arguments);
      },

      /**
       * Sending a message at level "error" to the logger.
       *
       * @param object {Object} Contextual object (either instance or static class)
       * @param message {var} Any number of arguments supported. An argument may
       *   have any JavaScript data type. All data is serialized immediately and
       *   does not keep references to other objects.
       */
      error: function (object, message) {
        qx.log.Logger.__P_58_7("error", arguments);
      },

      /**
       * Prints the current stack trace at level "info"
       *
       * @param object {Object?} Contextual object (either instance or static class)
       * @param message {var} Any number of arguments supported. An argument may
       *   have any JavaScript data type. All data is serialized immediately and
       *   does not keep references to other objects.
       */
      trace: function (object, message) {
        if (qx.log.Logger.isLoggerEnabled("trace", object)) {
          var trace = qx.dev.StackTrace.getStackTrace();
          var args = qx.lang.Array.fromArguments(arguments);
          args.push(trace.join("\n"));

          qx.log.Logger.__P_58_7("trace", args);
        }
      },

      /**
       * Prints a method deprecation warning and a stack trace if the setting
       * <code>qx.debug</code> is set to <code>true</code>.
       *
       * @param fcn {Function} reference to the deprecated function. This is
       *     arguments.callee if the calling method is to be deprecated.
       * @param msg {String?} Optional message to be printed.
       */
      deprecatedMethodWarning: function (fcn, msg) {},

      /**
       * Prints a class deprecation warning and a stack trace if the setting
       * <code>qx.debug</code> is set to <code>true</code>.
       *
       * @param clazz {Class} reference to the deprecated class.
       * @param msg {String?} Optional message to be printed.
       */
      deprecatedClassWarning: function (clazz, msg) {},

      /**
       * Prints an event deprecation warning and a stack trace if the setting
       * <code>qx.debug</code> is set to <code>true</code>.
       *
       * @param clazz {Class} reference to the deprecated class.
       * @param event {String} deprecated event name.
       * @param msg {String?} Optional message to be printed.
       */
      deprecatedEventWarning: function (clazz, event, msg) {},

      /**
       * Prints a mixin deprecation warning and a stack trace if the setting
       * <code>qx.debug</code> is set to <code>true</code>.
       *
       * @param clazz {Class} reference to the deprecated mixin.
       * @param msg {String?} Optional message to be printed.
       */
      deprecatedMixinWarning: function (clazz, msg) {},

      /**
       * Prints a constant deprecation warning and a stacktrace if the setting
       * <code>qx.debug</code> is set to <code>true</code> AND the browser supports
       * __defineGetter__!
       *
       * @param clazz {Class} The class the constant is attached to.
       * @param constant {String} The name of the constant as string.
       * @param msg {String} Optional message to be printed.
       */
      deprecatedConstantWarning: function (clazz, constant, msg) {},

      /**
       * Prints a deprecation warning and a stacktrace when a subclass overrides
       * the passed method name. The deprecation is only printed if the setting
       * <code>qx.debug</code> is set to <code>true</code>.
       *
       *
       * @param object {qx.core.Object} Instance to check for overriding.
       * @param baseclass {Class} The baseclass as starting point.
       * @param methodName {String} The method name which is deprecated for overriding.
       * @param msg {String?} Optional message to be printed.
       */
      deprecateMethodOverriding: function (object, baseclass, methodName, msg) {},

      /**
       * Deletes the current buffer. Does not influence message handling of the
       * connected appenders.
       *
       */
      clear: function () {
        this.__P_58_1.clearHistory();
      },

      /*
      ---------------------------------------------------------------------------
        INTERNAL LOGGING IMPLEMENTATION
      ---------------------------------------------------------------------------
      */

      /** @type {qx.log.appender.RingBuffer} Message buffer of previously fired messages. */
      __P_58_1: new qx.log.appender.RingBuffer(50),

      /** @type {Map} Numeric translation of log levels */
      __P_58_8: {
        trace: 0,
        debug: 1,
        info: 2,
        warn: 3,
        error: 4
      },

      /** @type {Map} cache of appenders for a given logger and level */
      __P_58_9: {},

      /**
       * Detects the name of the logger to use for an object
       *
       * @param object {Object} Contextual object (either instance or static class)
       * @return {String} Logger name
       */
      __P_58_10: function (object) {
        if (object) {
          if (object.classname) {
            return object.classname;
          }

          if (typeof object == "string") {
            return object;
          }
        }

        return "[default]";
      },

      /**
       * Detects whether a logger level is enabled for an object
       *
       * @param level {String} One of "trace", "debug", "info", "warn" or "error"
       * @param object {Object} Contextual object (either instance or static class)
       * @return {Boolean} True if the logger is enabled
       */
      isLoggerEnabled: function (level, object) {
        var loggerName = this.__P_58_10(object);

        var appenders = this.__P_58_6(loggerName, level);

        return !!Object.keys(appenders).length;
      },

      /**
       * Internal logging main routine.
       *
       * @param level {String} One of "trace", "debug", "info", "warn" or "error"
       * @param args {Array} List of other arguments, where the first is
       *   taken as the context object.
       */
      __P_58_7: function (level, args) {
        // Get object and determine appenders
        var object = args.length < 2 ? null : args[0];

        var loggerName = this.__P_58_10(object);

        var appenders = this.__P_58_6(loggerName, level);

        if (!Object.keys(appenders).length) {
          return;
        } // Serialize and cache


        var start = object ? 1 : 0;
        var items = [];

        for (var i = start, l = args.length; i < l; i++) {
          items.push(this.__P_58_11(args[i], true));
        } // Build entry


        var time = new Date();
        var entry = {
          time: time,
          offset: time - qx.Bootstrap.LOADSTART,
          level: level,
          loggerName: loggerName,
          items: items,
          // store window to allow cross frame logging
          win: window
        }; // Add relation fields

        if (object) {
          if (qx.Bootstrap.isQxCoreObject(object)) {
            entry.object = object.toHashCode();
          }

          if (object.$$type) {
            entry.clazz = object;
          } else if (object.constructor) {
            entry.clazz = object.constructor;
          }
        }

        this.__P_58_1.process(entry); // Send to appenders


        for (var classname in appenders) {
          appenders[classname].process(entry);
        }
      },

      /**
       * Finds the appenders for a given classname
       *
       * @param className {String} Name of the class
       * @param level {String} the minimum logging level to use the appender
       * @return {Array} list of appenders
       */
      __P_58_6: function (className, level) {
        var levels = this.__P_58_8; // If no filters, then all appenders apply

        if (!this.__P_58_4.length) {
          // Check the default level
          if (levels[level] < levels[this.__P_58_0]) {
            return [];
          }

          return this.__P_58_3;
        } // Check the cache


        var cacheId = className + "|" + level;
        var appenders = this.__P_58_9[cacheId];

        if (appenders !== undefined) {
          return appenders;
        }

        var appenders = {};

        for (var i = 0; i < this.__P_58_4.length; i++) {
          var filter = this.__P_58_4[i]; // Filters only apply to certain levels

          if (levels[level] < levels[filter.level]) {
            continue;
          } // No duplicates


          if (filter.appenderName && appenders[filter.appenderName]) {
            continue;
          } // Test


          if (!filter.loggerMatch || filter.loggerMatch.test(className)) {
            if (filter.appenderName) {
              appenders[filter.appenderName] = this.__P_58_3[filter.appenderName];
            } else {
              return this.__P_58_9[cacheId] = this.__P_58_3;
            }
          }
        }

        return this.__P_58_9[cacheId] = appenders;
      },

      /**
       * Detects the type of the variable given.
       *
       * @param value {var} Incoming value
       * @return {String} Type of the incoming value. Possible values:
       *   "undefined", "null", "boolean", "number", "string",
       *   "function", "array", "error", "map",
       *   "class", "instance", "node", "stringify", "unknown"
       */
      __P_58_12: function (value) {
        if (value === undefined) {
          return "undefined";
        } else if (value === null) {
          return "null";
        }

        if (value.$$type) {
          return "class";
        }

        var type = typeof value;

        if (type === "function" || type == "string" || type === "number" || type === "boolean") {
          return type;
        } else if (type === "object") {
          if (value.nodeType) {
            return "node"; // In Gecko, DOMException doesn't inherit from Error
          } else if (value instanceof Error || value.name && value.message) {
            return "error";
          } else if (value.classname) {
            return "instance";
          } else if (value instanceof Array) {
            return "array";
          } else if (value instanceof Date) {
            return "date";
          } else {
            return "map";
          }
        }

        if (value.toString) {
          return "stringify";
        }

        return "unknown";
      },

      /**
       * Serializes the incoming value. If it is a singular value, the result is
       * a simple string. For an array or a map the result can also be a
       * serialized string of a limited number of individual items.
       *
       * @param value {var} Incoming value
       * @param deep {Boolean?false} Whether arrays and maps should be
       *    serialized for a limited number of items
       * @return {Map} Contains the keys <code>type</code>, <code>text</code> and
       * <code>trace</code>.
       */
      __P_58_11: function (value, deep) {
        var type = this.__P_58_12(value);

        var text = "unknown";
        var trace = [];

        switch (type) {
          case "null":
          case "undefined":
            text = type;
            break;

          case "string":
          case "number":
          case "boolean":
          case "date":
            text = value;
            break;

          case "node":
            if (value.nodeType === 9) {
              text = "document";
            } else if (value.nodeType === 3) {
              text = "text[" + value.nodeValue + "]";
            } else if (value.nodeType === 1) {
              text = value.nodeName.toLowerCase();

              if (value.id) {
                text += "#" + value.id;
              }
            } else {
              text = "node";
            }

            break;

          case "function":
            text = qx.lang.Function.getName(value) || type;
            break;

          case "instance":
          case "class":
          case "stringify":
            text = value.toString();
            break;

          case "error":
            trace = qx.dev.StackTrace.getStackTraceFromError(value);
            text = (value.basename ? value.basename + ": " : "") + value.toString();
            break;

          case "array":
            if (deep) {
              text = [];

              for (var i = 0, l = value.length; i < l; i++) {
                if (text.length > 20) {
                  text.push("...(+" + (l - i) + ")");
                  break;
                }

                text.push(this.__P_58_11(value[i], false));
              }
            } else {
              text = "[...(" + value.length + ")]";
            }

            break;

          case "map":
            if (deep) {
              var temp; // Produce sorted key list

              var sorted = [];

              for (var key in value) {
                sorted.push(key);
              }

              sorted.sort(); // Temporary text list

              text = [];

              for (var i = 0, l = sorted.length; i < l; i++) {
                if (text.length > 20) {
                  text.push("...(+" + (l - i) + ")");
                  break;
                } // Additional storage of hash-key


                key = sorted[i];
                temp = this.__P_58_11(value[key], false);
                temp.key = key;
                text.push(temp);
              }
            } else {
              var number = 0;

              for (var key in value) {
                number++;
              }

              text = "{...(" + number + ")}";
            }

            break;
        }

        return {
          type: type,
          text: text,
          trace: trace
        };
      }
    },
    defer: function (statics) {
      var logs = qx.Bootstrap.$$logs;

      for (var i = 0; i < logs.length; i++) {
        statics.__P_58_7(logs[i][0], logs[i][1]);
      }

      qx.Bootstrap.debug = statics.debug;
      qx.Bootstrap.info = statics.info;
      qx.Bootstrap.warn = statics.warn;
      qx.Bootstrap.error = statics.error;
      qx.Bootstrap.trace = statics.trace;
    }
  });
  qx.log.Logger.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Mixin": {
        "usage": "dynamic",
        "require": true
      },
      "qx.log.Logger": {
        "require": true
      },
      "qx.lang.Array": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * This mixin offers the basic logging features offered by {@link qx.log.Logger}.
   */
  qx.Mixin.define("qx.core.MLogging", {
    members: {
      /** @type {Class} Pointer to the regular logger class */
      __P_77_0: qx.log.Logger,

      /**
       * Logs a debug message.
       *
       * @param varargs {var} The item(s) to log. Any number of arguments is
       * supported. If an argument is not a string, the object dump will be
       * logged.
       */
      debug: function (varargs) {
        this.__P_77_1("debug", arguments);
      },

      /**
       * Logs an info message.
       *
       * @param varargs {var} The item(s) to log. Any number of arguments is
       * supported. If an argument is not a string, the object dump will be
       * logged.
       */
      info: function (varargs) {
        this.__P_77_1("info", arguments);
      },

      /**
       * Logs a warning message.
       *
       * @param varargs {var} The item(s) to log. Any number of arguments is
       * supported. If an argument is not a string, the object dump will be
       * logged.
       */
      warn: function (varargs) {
        this.__P_77_1("warn", arguments);
      },

      /**
       * Logs an error message.
       *
       * @param varargs {var} The item(s) to log. Any number of arguments is
       * supported. If an argument is not a string, the object dump will be
       * logged.
       */
      error: function (varargs) {
        this.__P_77_1("error", arguments);
      },

      /**
       * Logs an error message with the current stack trace
       *
       * @param varargs {var} The item(s) to log. Any number of arguments is
       * supported. If an argument is not a string, the object dump will be
       * logged.
       */
      trace: function (varargs) {
        this.__P_77_1("trace", arguments);
      },

      /**
       * Helper that calls the appropriate logger function with the current object
       * and any number of items.
       *
       * @param level {String} The log level of the message
       * @param varargs {arguments} Arguments list to be logged
       */
      __P_77_1: function (level, varargs) {
        var argumentsArray = qx.lang.Array.fromArguments(varargs);
        argumentsArray.unshift(this);

        this.__P_77_0[level].apply(this.__P_77_0, argumentsArray);
      }
    }
  });
  qx.core.MLogging.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.bom.client.Engine": {},
      "qx.bom.Event": {},
      "qx.core.Environment": {
        "defer": "runtime"
      }
    },
    "environment": {
      "provided": ["event.touch", "event.mouseevent", "event.mousecreateevent", "event.dispatchevent", "event.customevent", "event.mspointer", "event.help", "event.hashchange", "event.mousewheel", "event.auxclick", "event.passive"],
      "required": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
     qooxdoo - the new era of web development
     http://qooxdoo.org
     Copyright:
      2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
     License:
      MIT: https://opensource.org/licenses/MIT
      See the LICENSE file in the project's top-level directory for details.
     Authors:
      * Martin Wittemann (martinwittemann)
  ************************************************************************ */

  /**
   * Internal class which contains the checks used by {@link qx.core.Environment}.
   * All checks in here are marked as internal which means you should never use
   * them directly.
   *
   * This class should contain all checks about events.
   *
   * @internal
   */
  qx.Bootstrap.define("qx.bom.client.Event", {
    statics: {
      /**
       * Checks if touch events are supported.
       *
       * @internal
       * @return {Boolean} <code>true</code> if touch events are supported.
       */
      getTouch: function () {
        return "ontouchstart" in window;
      },

      /**
       * Checks if MSPointer events are available.
       *
       * @internal
       * @return {Boolean} <code>true</code> if pointer events are supported.
       */
      getMsPointer: function () {
        // Fixes issue #9182: new unified pointer input model since Chrome 55
        // see https://github.com/qooxdoo/qooxdoo/issues/9182
        if ("PointerEvent" in window) {
          return true;
        }

        if ("pointerEnabled" in window.navigator) {
          return window.navigator.pointerEnabled;
        } else if ("msPointerEnabled" in window.navigator) {
          return window.navigator.msPointerEnabled;
        }

        return false;
      },

      /**
       * Checks if the proprietary <code>help</code> event is available.
       *
       * @internal
       * @return {Boolean} <code>true</code> if the "help" event is supported.
       */
      getHelp: function () {
        return "onhelp" in document;
      },

      /**
       * Checks if the <code>hashchange</code> event is available
       *
       * @internal
       * @return {Boolean} <code>true</code> if the "hashchange" event is supported.
       */
      getHashChange: function () {
        // avoid false positive in IE7
        var engine = qx.bom.client.Engine.getName();
        var hashchange = ("onhashchange" in window);
        return engine !== "mshtml" && hashchange || engine === "mshtml" && "documentMode" in document && document.documentMode >= 8 && hashchange;
      },

      /**
       * Checks if the DOM2 dispatchEvent method is available
       * @return {Boolean} <code>true</code> if dispatchEvent is supported.
       */
      getDispatchEvent: function () {
        return typeof document.dispatchEvent == "function";
      },

      /**
       * Checks if the CustomEvent constructor is available and supports
       * custom event types.
       *
       * @return {Boolean} <code>true</code> if Custom Events are available
       */
      getCustomEvent: function () {
        if (!window.CustomEvent) {
          return false;
        }

        try {
          new window.CustomEvent("foo");
          return true;
        } catch (ex) {
          return false;
        }
      },

      /**
       * Checks if the MouseEvent constructor is available and supports
       * custom event types.
       *
       * @return {Boolean} <code>true</code> if Mouse Events are available
       */
      getMouseEvent: function () {
        if (!window.MouseEvent) {
          return false;
        }

        try {
          new window.MouseEvent("foo");
          return true;
        } catch (ex) {
          return false;
        }
      },

      /**
       * Returns the event type used in pointer layer to create mouse events.
       *
       * @return {String} Either <code>MouseEvents</code> or <code>UIEvents</code>
       */
      getMouseCreateEvent: function () {
        /* For instance, in IE9, the pageX property of synthetic MouseEvents is
        always 0 and cannot be overridden, so plain UIEvents have to be used with
        mouse event properties added accordingly. */
        try {
          var e = document.createEvent("MouseEvents");
          var orig = e.pageX;
          e.initMouseEvent("click", false, false, window, 0, 0, 0, orig + 1, 0, false, false, false, false, 0, null);

          if (e.pageX !== orig) {
            return "MouseEvents";
          }

          return "UIEvents";
        } catch (ex) {
          return "UIEvents";
        }
      },

      /**
       * Checks if the MouseWheel event is available and on which target.
       *
       * @param win {Window ? null} An optional window instance to check.
       * @return {Map} A map containing two values: type and target.
       */
      getMouseWheel: function (win) {
        if (!win) {
          win = window;
        } // Fix for bug #3234


        var targets = [win, win.document, win.document.body];
        var target = win;
        var type = "DOMMouseScroll"; // for FF < 17

        for (var i = 0; i < targets.length; i++) {
          // check for the spec event (DOM-L3)
          if (qx.bom.Event.supportsEvent(targets[i], "wheel")) {
            type = "wheel";
            target = targets[i];
            break;
          } // check for the non spec event


          if (qx.bom.Event.supportsEvent(targets[i], "mousewheel")) {
            type = "mousewheel";
            target = targets[i];
            break;
          }
        }

        ;
        return {
          type: type,
          target: target
        };
      },

      /**
       * Detects if the engine/browser supports auxclick events
       * 
       * See https://github.com/qooxdoo/qooxdoo/issues/9268 
       *
       * @return {Boolean} <code>true</code> if auxclick events are supported.
       */
      getAuxclickEvent: function () {
        var hasAuxclick = false;

        try {
          hasAuxclick = "onauxclick" in document.documentElement;
        } catch (ex) {}

        ;
        return hasAuxclick ? true : false;
      },

      /**
       * Checks whether the browser supports passive event handlers.
       */
      getPassive: function () {
        var passiveSupported = false;

        try {
          var options = Object.defineProperties({}, {
            passive: {
              get: function () {
                // this function will be called when the browser
                // attempts to access the passive property.
                passiveSupported = true;
              }
            }
          });
          window.addEventListener("test", options, options);
          window.removeEventListener("test", options, options);
        } catch (err) {
          passiveSupported = false;
        }

        return passiveSupported;
      }
    },
    defer: function (statics) {
      qx.core.Environment.add("event.touch", statics.getTouch);
      qx.core.Environment.add("event.mouseevent", statics.getMouseEvent);
      qx.core.Environment.add("event.mousecreateevent", statics.getMouseCreateEvent);
      qx.core.Environment.add("event.dispatchevent", statics.getDispatchEvent);
      qx.core.Environment.add("event.customevent", statics.getCustomEvent);
      qx.core.Environment.add("event.mspointer", statics.getMsPointer);
      qx.core.Environment.add("event.help", statics.getHelp);
      qx.core.Environment.add("event.hashchange", statics.getHashChange);
      qx.core.Environment.add("event.mousewheel", statics.getMouseWheel);
      qx.core.Environment.add("event.auxclick", statics.getAuxclickEvent);
      qx.core.Environment.add("event.passive", statics.getPassive);
    }
  });
  qx.bom.client.Event.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Environment": {
        "defer": "runtime"
      }
    },
    "environment": {
      "provided": ["engine.version", "engine.name"],
      "required": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * This class comes with all relevant information regarding
   * the client's engine.
   *
   * This class is used by {@link qx.core.Environment} and should not be used
   * directly. Please check its class comment for details how to use it.
   *
   * @internal
   */
  qx.Bootstrap.define("qx.bom.client.Engine", {
    // General: http://en.wikipedia.org/wiki/Browser_timeline
    // Webkit: https://developer.apple.com/internet/safari/uamatrix.html
    // Firefox: http://en.wikipedia.org/wiki/History_of_Mozilla_Firefox
    statics: {
      /**
       * Returns the version of the engine.
       *
       * @return {String} The version number of the current engine.
       * @internal
       */
      getVersion: function () {
        var agent = window.navigator.userAgent;
        var version = "";

        if (qx.bom.client.Engine.__P_57_0()) {
          var isTrident = /Trident\/([^\);]+)(\)|;)/.test(agent);

          if (/MSIE\s+([^\);]+)(\)|;)/.test(agent)) {
            version = RegExp.$1; // If the IE8 or IE9 is running in the compatibility mode, the MSIE value
            // is set to an older version, but we need the correct version. The only
            // way is to compare the trident version.

            if (version < 8 && isTrident) {
              if (RegExp.$1 == "4.0") {
                version = "8.0";
              } else if (RegExp.$1 == "5.0") {
                version = "9.0";
              }
            }
          } else if (isTrident) {
            // IE 11 dropped the "MSIE" string
            var match = /\brv\:(\d+?\.\d+?)\b/.exec(agent);

            if (match) {
              version = match[1];
            }
          }
        } else if (qx.bom.client.Engine.__P_57_1()) {
          // Opera has a special versioning scheme, where the second part is combined
          // e.g. 8.54 which should be handled like 8.5.4 to be compatible to the
          // common versioning system used by other browsers
          if (/Opera[\s\/]([0-9]+)\.([0-9])([0-9]*)/.test(agent)) {
            // opera >= 10 has as a first version 9.80 and adds the proper version
            // in a separate "Version/" postfix
            // http://my.opera.com/chooseopera/blog/2009/05/29/changes-in-operas-user-agent-string-format
            if (agent.indexOf("Version/") != -1) {
              var match = agent.match(/Version\/(\d+)\.(\d+)/); // ignore the first match, its the whole version string

              version = match[1] + "." + match[2].charAt(0) + "." + match[2].substring(1, match[2].length);
            } else {
              version = RegExp.$1 + "." + RegExp.$2;

              if (RegExp.$3 != "") {
                version += "." + RegExp.$3;
              }
            }
          }
        } else if (qx.bom.client.Engine.__P_57_2()) {
          if (/AppleWebKit\/([^ ]+)/.test(agent)) {
            version = RegExp.$1; // We need to filter these invalid characters

            var invalidCharacter = RegExp("[^\\.0-9]").exec(version);

            if (invalidCharacter) {
              version = version.slice(0, invalidCharacter.index);
            }
          }
        } else if (qx.bom.client.Engine.__P_57_3()) {
          // Parse "rv" section in user agent string
          if (/rv\:([^\);]+)(\)|;)/.test(agent)) {
            version = RegExp.$1;
          }
        } else {
          var failFunction = window.qxFail;

          if (failFunction && typeof failFunction === "function") {
            version = failFunction().FULLVERSION;
          } else {
            version = "1.9.0.0";
            qx.Bootstrap.warn("Unsupported client: " + agent + "! Assumed gecko version 1.9.0.0 (Firefox 3.0).");
          }
        }

        return version;
      },

      /**
       * Returns the name of the engine.
       *
       * @return {String} The name of the current engine.
       * @internal
       */
      getName: function () {
        var name;

        if (qx.bom.client.Engine.__P_57_0()) {
          name = "mshtml";
        } else if (qx.bom.client.Engine.__P_57_1()) {
          name = "opera";
        } else if (qx.bom.client.Engine.__P_57_2()) {
          name = "webkit";
        } else if (qx.bom.client.Engine.__P_57_3()) {
          name = "gecko";
        } else {
          // check for the fallback
          var failFunction = window.qxFail;

          if (failFunction && typeof failFunction === "function") {
            name = failFunction().NAME;
          } else {
            name = "gecko";
            qx.Bootstrap.warn("Unsupported client: " + window.navigator.userAgent + "! Assumed gecko version 1.9.0.0 (Firefox 3.0).");
          }
        }

        return name;
      },

      /**
       * Internal helper for checking for opera (presto powered).
       *
       * Note that with opera >= 15 their engine switched to blink, so
       * things like "window.opera" don't work anymore or changed (e.g. user agent).
       *
       * @return {Boolean} true, if its opera (presto powered).
       */
      __P_57_1: function () {
        return window.opera && Object.prototype.toString.call(window.opera) == "[object Opera]";
      },

      /**
       * Internal helper for checking for webkit.
       * @return {Boolean} true, if its webkit.
       */
      __P_57_2: function () {
        return window.navigator.userAgent.indexOf("AppleWebKit/") != -1;
      },

      /**
       * Internal helper for checking for gecko.
       *
       * Note:
       *  "window.controllers" is gone/hidden with Firefox 30+
       *  "window.navigator.mozApps" is supported since Firefox 11+ and is gone/hidden with Firefox 47 beta
       *  "window.navigator.buildID" is supported since Firefox 2+
       *  "window.navigator.product" is actually useless cause the HTML5 spec
       *    states it should be the constant "Gecko".
       *
       *  - https://developer.mozilla.org/en-US/docs/Web/API/Window.controllers
       *  - https://developer.mozilla.org/en-US/docs/Web/API/Navigator.mozApps
       *  - https://developer.mozilla.org/en-US/docs/Web/API/Navigator/buildID
       *  - http://www.w3.org/html/wg/drafts/html/master/webappapis.html#navigatorid
       *
       * @return {Boolean} true, if its gecko.
       */
      __P_57_3: function () {
        return (window.navigator.mozApps || window.navigator.buildID) && window.navigator.product === "Gecko" && window.navigator.userAgent.indexOf("Trident") == -1;
      },

      /**
       * Internal helper to check for MSHTML.
       * @return {Boolean} true, if its MSHTML.
       */
      __P_57_0: function () {
        if (window.navigator.cpuClass && (/MSIE\s+([^\);]+)(\)|;)/.test(window.navigator.userAgent) || /Trident\/\d+?\.\d+?/.test(window.navigator.userAgent))) {
          return true;
        }

        if (qx.bom.client.Engine.__P_57_4()) {
          return true;
        }

        return false;
      },

      /**
       * Internal helper to check for Windows phone.
       * @return {Boolean} true, if its Windows phone.
       */
      __P_57_4: function () {
        return window.navigator.userAgent.indexOf("Windows Phone") > -1;
      }
    },
    defer: function (statics) {
      qx.core.Environment.add("engine.version", statics.getVersion);
      qx.core.Environment.add("engine.name", statics.getName);
    }
  });
  qx.bom.client.Engine.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.bom.client.Engine": {
        "usage": "dynamic",
        "require": true
      },
      "qx.bom.client.OperatingSystem": {},
      "qx.core.Environment": {
        "defer": "runtime"
      }
    },
    "environment": {
      "provided": ["browser.name", "browser.version", "browser.documentmode", "browser.quirksmode"],
      "required": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Hagendorn (chris_schmidt)
       * Martin Wittemann (martinwittemann)
  
     ======================================================================
  
     This class contains code from:
  
     * Unify Project
  
       Homepage:
         http://unify-project.org
  
       Copyright:
         2009-2010 Deutsche Telekom AG, Germany, http://telekom.com
  
       License:
         MIT: http://www.opensource.org/licenses/mit-license.php
  
       Authors:
         * Sebastian Werner (wpbasti)
  
  ************************************************************************ */

  /**
   * Basic browser detection for qooxdoo.
   *
   * This class is used by {@link qx.core.Environment} and should not be used
   * directly. Please check its class comment for details how to use it.
   *
   * @require(qx.bom.client.OperatingSystem#getVersion)
   * @internal
   */
  qx.Bootstrap.define("qx.bom.client.Browser", {
    statics: {
      /**
       * Checks for the name of the browser and returns it.
       * @return {String} The name of the current browser.
       * @internal
       */
      getName: function () {
        var agent = navigator.userAgent;
        var reg = new RegExp("(" + qx.bom.client.Browser.__P_74_0 + ")(/|)?([0-9]+\.[0-9])?");
        var match = agent.match(reg);

        if (!match) {
          return "";
        }

        var name = match[1].toLowerCase();
        var engine = qx.bom.client.Engine.getName();

        if (engine === "webkit") {
          if (agent.match(/Edge\/\d+\.\d+/)) {
            name = "edge";
          } else if (name === "android") {
            // Fix Chrome name (for instance wrongly defined in user agent on Android 1.6)
            name = "mobile chrome";
          } else if (agent.indexOf("Mobile Safari") !== -1 || agent.indexOf("Mobile/") !== -1) {
            // Fix Safari name
            name = "mobile safari";
          } else if (agent.indexOf(" OPR/") != -1) {
            name = "opera";
          }
        } else if (engine === "mshtml") {
          // IE 11's ua string no longer contains "MSIE" or even "IE"
          if (name === "msie" || name === "trident") {
            name = "ie"; // Fix IE mobile before Microsoft added IEMobile string

            if (qx.bom.client.OperatingSystem.getVersion() === "ce") {
              name = "iemobile";
            }

            var reg = new RegExp("IEMobile");

            if (agent.match(reg)) {
              name = "iemobile";
            }
          }
        } else if (engine === "opera") {
          if (name === "opera mobi") {
            name = "operamobile";
          } else if (name === "opera mini") {
            name = "operamini";
          }
        }

        return name;
      },

      /**
       * Determines the version of the current browser.
       * @return {String} The name of the current browser.
       * @internal
       */
      getVersion: function () {
        var agent = navigator.userAgent;
        var reg = new RegExp("(" + qx.bom.client.Browser.__P_74_0 + ")(/| )([0-9]+\.[0-9])");
        var match = agent.match(reg);

        if (!match) {
          return "";
        }

        var name = match[1].toLowerCase();
        var version = match[3]; // Support new style version string used by Opera and Safari

        if (agent.match(/Version(\/| )([0-9]+\.[0-9])/)) {
          version = RegExp.$2;
        }

        if (qx.bom.client.Engine.getName() == "mshtml") {
          // Use the Engine version, because IE8 and higher change the user agent
          // string to an older version in compatibility mode
          version = qx.bom.client.Engine.getVersion();

          if (name === "msie" && qx.bom.client.OperatingSystem.getVersion() == "ce") {
            // Fix IE mobile before Microsoft added IEMobile string
            version = "5.0";
          }
        }

        if (qx.bom.client.Engine.getName() == "webkit" || qx.bom.client.Browser.getName() == "opera") {
          if (agent.match(/OPR(\/| )([0-9]+\.[0-9])/)) {
            version = RegExp.$2;
          }

          if (agent.match(/Edge\/([\d+\.*]+)/)) {
            version = RegExp.$1;
          }
        }

        return version;
      },

      /**
       * Returns in which document mode the current document is (only for IE).
       *
       * @internal
       * @return {Number} The mode in which the browser is.
       */
      getDocumentMode: function () {
        if (document.documentMode) {
          return document.documentMode;
        }

        return 0;
      },

      /**
       * Check if in quirks mode.
       *
       * @internal
       * @return {Boolean} <code>true</code>, if the environment is in quirks mode
       */
      getQuirksMode: function () {
        if (qx.bom.client.Engine.getName() == "mshtml" && parseFloat(qx.bom.client.Engine.getVersion()) >= 8) {
          return qx.bom.client.Engine.DOCUMENT_MODE === 5;
        } else {
          return document.compatMode !== "CSS1Compat";
        }
      },

      /**
       * Internal helper map for picking the right browser names to check.
       */
      __P_74_0: {
        // Safari should be the last one to check, because some other Webkit-based browsers
        // use this identifier together with their own one.
        // "Version" is used in Safari 4 to define the Safari version. After "Safari" they place the
        // Webkit version instead. Silly.
        // Palm Pre uses both Safari (contains Webkit version) and "Version" contains the "Pre" version. But
        // as "Version" is not Safari here, we better detect this as the Pre-Browser version. So place
        // "Pre" in front of both "Version" and "Safari".
        "webkit": "AdobeAIR|Titanium|Fluid|Chrome|Android|Epiphany|Konqueror|iCab|iPad|iPhone|OmniWeb|Maxthon|Pre|PhantomJS|Mobile Safari|Safari",
        // Better security by keeping Firefox the last one to match
        "gecko": "prism|Fennec|Camino|Kmeleon|Galeon|Netscape|SeaMonkey|Namoroka|Firefox",
        // No idea what other browsers based on IE's engine
        "mshtml": "IEMobile|Maxthon|MSIE|Trident",
        // Keep "Opera" the last one to correctly prefer/match the mobile clients
        "opera": "Opera Mini|Opera Mobi|Opera"
      }[qx.bom.client.Engine.getName()]
    },
    defer: function (statics) {
      qx.core.Environment.add("browser.name", statics.getName);
      qx.core.Environment.add("browser.version", statics.getVersion);
      qx.core.Environment.add("browser.documentmode", statics.getDocumentMode);
      qx.core.Environment.add("browser.quirksmode", statics.getQuirksMode);
    }
  });
  qx.bom.client.Browser.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.bom.Style": {},
      "qx.bom.Event": {},
      "qx.core.Environment": {
        "defer": "runtime"
      }
    },
    "environment": {
      "provided": ["css.transition"],
      "required": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2013 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Daniel Wagner (danielwagner)
  
  ************************************************************************ */

  /**
   * CSS Transition support checks.
   *
   * Spec: http://www.w3.org/TR/css3-transitions/
   *
   * @internal
   */
  qx.Bootstrap.define("qx.bom.client.CssTransition", {
    statics: {
      /**
       * Returns the (possibly vendor-prefixed) name of the CSS transition property
       * @return {String|null} transition property name or <code>null</code> if
       * not supported
       * @internal
       */
      getTransitionName: function () {
        return qx.bom.Style.getPropertyName("transition");
      },

      /**
       * Main check method which returns an object if CSS transitions are
       * supported. The object contains the following keys:
       * <ul>
       *  <li><code>name</code> The name of the CSS transition property</li>
       *  <li><code>end-event</code> The name of the end event</li>
       * </ul>
       *
       * @internal
       * @return {Object|null} The described object or <code>null</code> if
       * transitions are not supported.
       */
      getSupport: function () {
        var name = qx.bom.client.CssTransition.getTransitionName();

        if (!name) {
          return null;
        }

        var eventName = qx.bom.Event.getEventName(window, "transitionEnd");
        eventName = eventName == "transitionEnd" ? eventName.toLowerCase() : eventName; // Detecting the end event's name is not possible in some browsers,
        // so we deduce it from the property name instead.

        if (!eventName) {
          eventName = name + (name.indexOf("Trans") > 0 ? "E" : "e") + "nd";
        }

        return {
          name: name,
          "end-event": eventName
        };
      }
    },
    defer: function (statics) {
      qx.core.Environment.add("css.transition", statics.getSupport);
    }
  });
  qx.bom.client.CssTransition.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.bom.client.Event": {
        "require": true
      },
      "qx.bom.client.Engine": {
        "require": true
      },
      "qx.bom.client.Browser": {
        "require": true
      },
      "qx.bom.client.CssTransition": {
        "require": true
      },
      "qx.bom.Style": {},
      "qx.lang.String": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "event.passive": {
          "className": "qx.bom.client.Event"
        },
        "engine.name": {
          "className": "qx.bom.client.Engine"
        },
        "browser.name": {
          "className": "qx.bom.client.Browser"
        },
        "browser.documentmode": {
          "className": "qx.bom.client.Browser"
        },
        "css.transition": {
          "className": "qx.bom.client.CssTransition"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
       * Sebastian Werner (wpbasti)
       * Alexander Steitz (aback)
       * Christian Hagendorn (chris_schmidt)
       * Tobias Oberrauch (toberrauch) <tobias.oberrauch@1und1.de>
  
     ======================================================================
  
     This class contains code based on the following work:
  
     * Juriy Zaytsev
       http://thinkweb2.com/projects/prototype/detecting-event-support-without-browser-sniffing/
  
       Copyright (c) 2009 Juriy Zaytsev
  
       License:
         BSD: http://github.com/kangax/iseventsupported/blob/master/LICENSE
  
       ----------------------------------------------------------------------
  
       http://github.com/kangax/iseventsupported/blob/master/LICENSE
  
       Copyright (c) 2009 Juriy Zaytsev
  
       Permission is hereby granted, free of charge, to any person
       obtaining a copy of this software and associated documentation
       files (the "Software"), to deal in the Software without
       restriction, including without limitation the rights to use,
       copy, modify, merge, publish, distribute, sublicense, and/or sell
       copies of the Software, and to permit persons to whom the
       Software is furnished to do so, subject to the following
       conditions:
  
       The above copyright notice and this permission notice shall be
       included in all copies or substantial portions of the Software.
  
       THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
       EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
       OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
       NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
       HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
       WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
       FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
       OTHER DEALINGS IN THE SOFTWARE.
  
  ************************************************************************ */

  /**
   * Wrapper around native event management capabilities of the browser.
   * This class should not be used directly normally. It's better
   * to use {@link qx.event.Registration} instead.
   */
  qx.Bootstrap.define("qx.bom.Event", {
    statics: {
      /**
       * Use the low level browser functionality to attach event listeners
       * to DOM nodes.
       *
       * Use this with caution. This is only thought for event handlers and
       * qualified developers. These are not mem-leak protected!
       *
       * @param target {Object} Any valid native event target
       * @param type {String} Name of the event
       * @param listener {Function} The pointer to the function to assign
       * @param useCapture {Boolean ? false} A Boolean value that specifies the event phase to add
       *    the event handler for the capturing phase or the bubbling phase.
       * @param passive {Boolean ? false} Specifies whether to set the passive option to true or false if supported.
       */
      addNativeListener: function (target, type, listener, useCapture, passive) {
        if (target.addEventListener) {
          if (passive === undefined || !qx.core.Environment.get("event.passive")) {
            target.addEventListener(type, listener, !!useCapture);
          } else {
            target.addEventListener(type, listener, {
              capture: !!useCapture,
              passive: !!passive
            });
          }
        } else if (target.attachEvent) {
          target.attachEvent("on" + type, listener);
        } else if (typeof target["on" + type] != "undefined") {
          target["on" + type] = listener;
        } else {}
      },

      /**
       * Use the low level browser functionality to remove event listeners
       * from DOM nodes.
       *
       * @param target {Object} Any valid native event target
       * @param type {String} Name of the event
       * @param listener {Function} The pointer to the function to assign
       * @param useCapture {Boolean ? false} A Boolean value that specifies the event phase to remove
       *    the event handler for the capturing phase or the bubbling phase.
       */
      removeNativeListener: function (target, type, listener, useCapture) {
        if (target.removeEventListener) {
          target.removeEventListener(type, listener, !!useCapture);
        } else if (target.detachEvent) {
          try {
            target.detachEvent("on" + type, listener);
          } catch (e) {
            // IE7 sometimes dispatches "unload" events on protected windows
            // Ignore the "permission denied" errors.
            if (e.number !== -2146828218) {
              throw e;
            }

            ;
          }
        } else if (typeof target["on" + type] != "undefined") {
          target["on" + type] = null;
        } else {}
      },

      /**
       * Returns the target of the event.
       *
       * @param e {Event} Native event object
       * @return {Object} Any valid native event target
       */
      getTarget: function (e) {
        return e.target || e.srcElement;
      },

      /**
       * Computes the related target from the native DOM event
       *
       * @param e {Event} Native DOM event object
       * @return {Element} The related target
       */
      getRelatedTarget: function (e) {
        if (e.relatedTarget !== undefined) {
          // In Firefox the related target of mouse events is sometimes an
          // anonymous div inside of a text area, which raises an exception if
          // the nodeType is read. This is why the try/catch block is needed.
          if (qx.core.Environment.get("engine.name") == "gecko") {
            try {
              e.relatedTarget && e.relatedTarget.nodeType;
            } catch (ex) {
              return null;
            }
          }

          return e.relatedTarget;
        } else if (e.fromElement !== undefined && (e.type === "mouseover" || e.type === "pointerover")) {
          return e.fromElement;
        } else if (e.toElement !== undefined) {
          return e.toElement;
        } else {
          return null;
        }
      },

      /**
       * Prevent the native default of the event to be processed.
       *
       * This is useful to stop native keybindings, native selection
       * and other native functionality behind events.
       *
       * @param e {Event} Native event object
       */
      preventDefault: function (e) {
        if (e.preventDefault) {
          e.preventDefault();
        } else {
          try {
            // this allows us to prevent some key press events in IE.
            // See bug #1049
            e.keyCode = 0;
          } catch (ex) {}

          e.returnValue = false;
        }
      },

      /**
       * Stops the propagation of the given event to the parent element.
       *
       * Only useful for events which bubble e.g. mousedown.
       *
       * @param e {Event} Native event object
       */
      stopPropagation: function (e) {
        if (e.stopPropagation) {
          e.stopPropagation();
        } else {
          e.cancelBubble = true;
        }
      },

      /**
       * Fires a synthetic native event on the given element.
       *
       * @param target {Element} DOM element to fire event on
       * @param type {String} Name of the event to fire
       * @return {Boolean} A value that indicates whether any of the event handlers called {@link #preventDefault}.
       *  <code>true</code> The default action is permitted, <code>false</code> the caller should prevent the default action.
       */
      fire: function (target, type) {
        // dispatch for standard first
        if (document.createEvent) {
          var evt = document.createEvent("HTMLEvents");
          evt.initEvent(type, true, true);
          return !target.dispatchEvent(evt);
        } // dispatch for IE
        else {
            var evt = document.createEventObject();
            return target.fireEvent("on" + type, evt);
          }
      },

      /**
       * Whether the given target supports the given event type.
       *
       * Useful for testing for support of new features like
       * touch events, gesture events, orientation change, on/offline, etc.
       *
       * *NOTE:* This check is *case-insensitive*.
       * <code>supportsEvent(window, "cLicK")</code> will return <code>true</code>
       * but <code>window.addEventListener("cLicK", callback)</code> will fail
       * silently!
       *
       * @param target {var} Any valid target e.g. window, dom node, etc.
       * @param type {String} Type of the event e.g. click, mousedown
       * @return {Boolean} Whether the given event is supported
       */
      supportsEvent: function (target, type) {
        var browserName = qx.core.Environment.get("browser.name");
        var engineName = qx.core.Environment.get("engine.name"); // transitionEnd support can not be detected generically for Internet Explorer 10+ [BUG #7875]

        if (type.toLowerCase().indexOf("transitionend") != -1 && engineName === "mshtml" && qx.core.Environment.get("browser.documentmode") > 9) {
          return true;
        }
        /**
         * add exception for safari mobile ()
         * @see http://bugzilla.qooxdoo.org/show_bug.cgi?id=8244
         */


        var safariBrowserNames = ["mobile safari", "safari"];

        if (engineName === "webkit" && safariBrowserNames.indexOf(browserName) > -1) {
          var supportedEvents = ['loadeddata', 'progress', 'timeupdate', 'seeked', 'canplay', 'play', 'playing', 'pause', 'loadedmetadata', 'ended', 'volumechange'];

          if (supportedEvents.indexOf(type.toLowerCase()) > -1) {
            return true;
          }
        } // The 'transitionend' event can only be detected on window objects,
        // not DOM elements [BUG #7249]


        if (target != window && type.toLowerCase().indexOf("transitionend") != -1) {
          var transitionSupport = qx.core.Environment.get("css.transition");
          return transitionSupport && transitionSupport["end-event"] == type;
        } // Using the lowercase representation is important for the
        // detection of events like 'MSPointer*'. They have to detected
        // using the lower case name of the event.


        var eventName = "on" + type.toLowerCase();
        var supportsEvent = (eventName in target);

        if (!supportsEvent) {
          supportsEvent = typeof target[eventName] == "function";

          if (!supportsEvent && target.setAttribute) {
            target.setAttribute(eventName, "return;");
            supportsEvent = typeof target[eventName] == "function";
            target.removeAttribute(eventName);
          }
        }

        return supportsEvent;
      },

      /**
       * Returns the (possibly vendor-prefixed) name of the given event type.
       * *NOTE:* Incorrect capitalization of type names will *not* be corrected. See
       * {@link #supportsEvent} for details.
       *
       * @param target {var} Any valid target e.g. window, dom node, etc.
       * @param type {String} Type of the event e.g. click, mousedown
       * @return {String|null} Event name or <code>null</code> if the event is not
       * supported.
       */
      getEventName: function (target, type) {
        var pref = [""].concat(qx.bom.Style.VENDOR_PREFIXES);

        for (var i = 0, l = pref.length; i < l; i++) {
          var prefix = pref[i].toLowerCase();

          if (qx.bom.Event.supportsEvent(target, prefix + type)) {
            return prefix ? prefix + qx.lang.String.firstUp(type) : type;
          }
        }

        return null;
      }
    }
  });
  qx.bom.Event.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Interface": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2016 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * John Spackman (john.spackman@zenesis.com)
  
  ************************************************************************ */

  /**
   * Classes which implement this interface are required to be disposed when they are
   * no longer needed, by calling .dispose(); they are also registered with qx.core.ObjectRegistry
   * so that qx.core.ObjectRegistry.fromHashCode() will work.
   * 
   * Note that classes do not have to implement this interface in order to provide a dispose
   * method and/or a destructor. 
   */
  qx.Interface.define("qx.core.IDisposable", {
    members: {
      /**
       * Dispose this object
       *
       */
      dispose: function () {}
    }
  });
  qx.core.IDisposable.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Bootstrap": {
        "usage": "dynamic",
        "defer": "runtime",
        "require": true
      },
      "qx.core.WindowError": {},
      "qx.core.GlobalError": {}
    },
    "environment": {
      "provided": ["qx.globalErrorHandling"],
      "required": {
        "qx.globalErrorHandling": {
          "className": "qx.event.GlobalError"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * The GlobalError class stores a reference to a global error handler function.
   *
   *  This function is called for each uncatched JavaScript exception. To enable
   *  global error handling the setting <code>qx.globalErrorHandling</code> must
   *  be enabled and an error handler must be registered.
   *  Further each JavaScript "entry point" must be wrapped with a call to
   *  {@link qx.event.GlobalError#observeMethod}.
   *
   * @ignore(qx.core, qx.core.Environment)
   */
  qx.Bootstrap.define("qx.event.GlobalError", {
    statics: {
      __P_75_0: null,
      __P_75_1: null,
      __P_75_2: null,

      /**
       * Little helper to check if the global error handling is enabled.
       * @return {Boolean} <code>true</code>, if it is enabled.
       */
      __P_75_3: function () {
        if (qx.core && qx.core.Environment) {
          return qx.core.Environment.get("qx.globalErrorHandling");
        } else {
          return !!qx.Bootstrap.getEnvironmentSetting("qx.globalErrorHandling");
        }
      },

      /**
       * Set the global fallback error handler
       *
       * @param callback {Function?null} The error handler. The first argument is the
       *    exception, which caused the error
       * @param context {Object?window} The "this" context of the callback function
       */
      setErrorHandler: function (callback, context) {
        this.__P_75_0 = callback || null;
        this.__P_75_2 = context || window;

        if (this.__P_75_3()) {
          // wrap the original onerror
          if (callback && window.onerror) {
            var wrappedHandler = qx.Bootstrap.bind(this.__P_75_4, this);

            if (this.__P_75_1 == null) {
              this.__P_75_1 = window.onerror;
            }

            var self = this;

            window.onerror = function (msg, uri, lineNumber) {
              self.__P_75_1(msg, uri, lineNumber);

              wrappedHandler(msg, uri, lineNumber);
            };
          }

          if (callback && !window.onerror) {
            window.onerror = qx.Bootstrap.bind(this.__P_75_4, this);
          } // reset


          if (this.__P_75_0 == null) {
            if (this.__P_75_1 != null) {
              window.onerror = this.__P_75_1;
              this.__P_75_1 = null;
            } else {
              window.onerror = null;
            }
          }
        }
      },

      /**
       * Catches all errors of the <code>window.onerror</code> handler
       * and passes an {@link qx.core.WindowError} object to the error
       * handling.
       *
       * @param msg {String} browser error message
       * @param uri {String} uri to erroneous script
       * @param lineNumber {Integer} line number of error
       * @param columnNumber {Integer} column number of error
       * @param exception {Error} orginal error
       */
      __P_75_4: function (msg, uri, lineNumber, columnNumber, exception) {
        if (this.__P_75_0) {
          this.handleError(new qx.core.WindowError(msg, uri, lineNumber, columnNumber, exception));
        }
      },

      /**
       * Wraps a method with error handling code. Only methods, which are called
       * directly by the browser (e.g. event handler) should be wrapped.
       *
       * @param method {Function} method to wrap
       * @return {Function} The function wrapped with error handling code
       */
      observeMethod: function (method) {
        if (this.__P_75_3()) {
          var self = this;
          return function () {
            if (!self.__P_75_0) {
              return method.apply(this, arguments);
            }

            try {
              return method.apply(this, arguments);
            } catch (ex) {
              self.handleError(new qx.core.GlobalError(ex, arguments));
            }
          };
        } else {
          return method;
        }
      },

      /**
       * Delegates every given exception to the registered error handler
       *
       * @param ex {qx.core.WindowError|Error} Exception to delegate
       */
      handleError: function (ex) {
        if (this.__P_75_0) {
          this.__P_75_0.call(this.__P_75_2, ex);
        }
      }
    },
    defer: function (statics) {
      // only use the environment class if already loaded
      if (qx.core && qx.core.Environment) {
        qx.core.Environment.add("qx.globalErrorHandling", true);
      } else {
        qx.Bootstrap.setEnvironmentSetting("qx.globalErrorHandling", true);
      }

      statics.setErrorHandler(null, null);
    }
  });
  qx.event.GlobalError.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.bom.Event": {
        "require": true,
        "construct": true
      },
      "qx.core.Environment": {
        "defer": "load",
        "construct": true,
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.IDisposable": {
        "require": true
      },
      "qx.core.ObjectRegistry": {
        "construct": true
      },
      "qx.event.GlobalError": {
        "construct": true,
        "require": true
      },
      "qx.util.DeferredCall": {
        "construct": true
      },
      "qx.core.Assert": {},
      "qx.lang.Array": {},
      "qx.event.IEventHandler": {},
      "qx.log.Logger": {},
      "qx.event.Pool": {},
      "qx.event.Utils": {},
      "qx.util.DisposeUtil": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "qx.globalErrorHandling": {
          "construct": true,
          "className": "qx.event.GlobalError"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
       * Sebastian Werner (wpbasti)
       * John Spackman (johnspackman)
       * Christian Boulanger (cboulanger)
  
  ************************************************************************ */

  /**
   * Wrapper for browser DOM event handling for each browser window/frame.
   *
   * @require(qx.bom.Event)
   */
  qx.Class.define("qx.event.Manager", {
    extend: Object,
    implement: [qx.core.IDisposable],

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * Creates a new instance of the event handler.
     *
     * @param win {Window} The DOM window this manager handles the events for
     * @param registration {qx.event.Registration} The event registration to use
     */
    construct: function (win, registration) {
      // Assign window object
      this.__P_88_0 = win;
      this.__P_88_1 = qx.core.ObjectRegistry.toHashCode(win);
      this.__P_88_2 = registration; // Register to the page unload event.
      // Only for iframes and other secondary documents.

      if (win.qx !== qx) {
        var self = this;

        var method = function () {
          qx.bom.Event.removeNativeListener(win, "unload", method);
          self.dispose();
        };

        if (qx.core.Environment.get("qx.globalErrorHandling")) {
          qx.bom.Event.addNativeListener(win, "unload", qx.event.GlobalError.observeMethod(method));
        } else {
          qx.bom.Event.addNativeListener(win, "unload", method);
        }
      } // Registry for event listeners


      this.__P_88_3 = {}; // The handler and dispatcher instances

      this.__P_88_4 = {};
      this.__P_88_5 = {};
      this.__P_88_6 = {};
      this.__P_88_7 = new qx.util.DeferredCall(function () {
        this.__P_88_8 = null;
      }, this);
      this.__P_88_7.$$blackListCleaner = true;
    },

    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics: {
      /** @type {Integer} Last used ID for an event */
      __P_88_9: 0,

      /**
       * Returns an unique ID which may be used in combination with a target and
       * a type to identify an event entry.
       *
       * @return {String} The next free identifier (auto-incremented)
       */
      getNextUniqueId: function () {
        return this.__P_88_9++ + "";
      },

      /**
       * @type {Array} private list of global event monitor functions
       */
      __P_88_10: [],

      /**
       * Adds a global event monitor function which is called for each event fired
       * anywhere in the application. The function is called with the signature
       * (target: {@link qx.core.Object}, event: {@link qx.event.type.Event}).
       * Since for performance reasons, the original event object is passed,
       * the monitor function must not change this event in any way.
       *
       * @param fn {Function} Monitor function
       * @param context {Object?} Optional execution context of the function
       */
      addGlobalEventMonitor: function (fn, context) {
        qx.core.Assert.assertFunction(fn);
        fn.$$context = context;

        this.__P_88_10.push(fn);
      },

      /**
       * Removes a global event monitor function that had
       * previously been added.
       * @param fn {Function} The global monitor function
       */
      removeGlobalEventMonitor: function (fn) {
        qx.core.Assert.assertFunction(fn);
        qx.lang.Array.remove(this.__P_88_10, fn);
      },

      /**
       * Remove all registered event monitors
       */
      resetGlobalEventMonitors: function () {
        qx.event.Manager.__P_88_10 = [];
      },

      /**
       * Returns the global event monitor. Not compatible with the {@link
       * qx.event.Manager.addGlobalEventMonitor} API. Will be removed in v7.0.0
       *
       * @deprecated {6.0}
       * @return {Function?} the global monitor function
       */
      getGlobalEventMonitor: function () {
        return this.__P_88_10[0];
      },

      /**
       * Sets the global event monitor. Not compatible with the {@link
       * qx.event.Manager.addGlobalEventMonitor} API. Will be removed in
       * v7.0.0. Use {@link qx.event.Manager.addGlobalEventMonitor} instead.
       *
       * @deprecated {6.0}
       * @param fn {Function?} the global monitor function
       */
      setGlobalEventMonitor: function (fn) {
        qx.core.Assert.assertFunction(fn);
        this.__P_88_10[0] = fn;
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __P_88_2: null,
      __P_88_3: null,
      __P_88_5: null,
      __P_88_11: null,
      __P_88_4: null,
      __P_88_6: null,
      __P_88_0: null,
      __P_88_1: null,
      __P_88_8: null,
      __P_88_7: null,

      /*
      ---------------------------------------------------------------------------
        HELPERS
      ---------------------------------------------------------------------------
      */

      /**
       * Get the window instance the event manager is responsible for
       *
       * @return {Window} DOM window instance
       */
      getWindow: function () {
        return this.__P_88_0;
      },

      /**
       * Get the hashcode of the manager's window
       *
       * @return {String} The window's hashcode
       */
      getWindowId: function () {
        return this.__P_88_1;
      },

      /**
       * Returns an instance of the given handler class for this manager(window).
       *
       * @param clazz {Class} Any class which implements {@link qx.event.IEventHandler}
       * @return {Object} The instance used by this manager
       */
      getHandler: function (clazz) {
        var handler = this.__P_88_4[clazz.classname];

        if (handler) {
          return handler;
        }

        return this.__P_88_4[clazz.classname] = new clazz(this);
      },

      /**
       * Returns an instance of the given dispatcher class for this manager(window).
       *
       * @param clazz {Class} Any class which implements {@link qx.event.IEventHandler}
       * @return {Object} The instance used by this manager
       */
      getDispatcher: function (clazz) {
        var dispatcher = this.__P_88_5[clazz.classname];

        if (dispatcher) {
          return dispatcher;
        }

        return this.__P_88_5[clazz.classname] = new clazz(this, this.__P_88_2);
      },

      /*
      ---------------------------------------------------------------------------
        EVENT LISTENER MANAGEMENT
      ---------------------------------------------------------------------------
      */

      /**
       * Get a copy of all event listeners for the given combination
       * of target, event type and phase.
       *
       * This method is especially useful and for event handlers to
       * to query the listeners registered in the manager.
       *
       * @param target {Object} Any valid event target
       * @param type {String} Event type
       * @param capture {Boolean ? false} Whether the listener is for the
       *       capturing phase of the bubbling phase.
       * @return {Array | null} Array of registered event handlers. May return
       *       null when no listener were found.
       */
      getListeners: function (target, type, capture) {
        var targetKey = target.$$hash || qx.core.ObjectRegistry.toHashCode(target);
        var targetMap = this.__P_88_3[targetKey];

        if (!targetMap) {
          return null;
        }

        var entryKey = type + (capture ? "|capture" : "|bubble");
        var entryList = targetMap[entryKey];
        return entryList ? entryList.concat() : null;
      },

      /**
       * Returns all registered listeners.
       *
       * @internal
       *
       * @return {Map} All registered listeners. The key is the hash code form an object.
       */
      getAllListeners: function () {
        return this.__P_88_3;
      },

      /**
       * Returns a serialized array of all events attached on the given target.
       *
       * @param target {Object} Any valid event target
       * @return {Map[]} Array of maps where everyone contains the keys:
       *   <code>handler</code>, <code>self</code>, <code>type</code> and <code>capture</code>.
       */
      serializeListeners: function (target) {
        var targetKey = target.$$hash || qx.core.ObjectRegistry.toHashCode(target);
        var targetMap = this.__P_88_3[targetKey];
        var result = [];

        if (targetMap) {
          var indexOf, type, capture, entryList, entry;

          for (var entryKey in targetMap) {
            indexOf = entryKey.indexOf("|");
            type = entryKey.substring(0, indexOf);
            capture = entryKey.charAt(indexOf + 1) == "c";
            entryList = targetMap[entryKey];

            for (var i = 0, l = entryList.length; i < l; i++) {
              entry = entryList[i];
              result.push({
                self: entry.context,
                handler: entry.handler,
                type: type,
                capture: capture
              });
            }
          }
        }

        return result;
      },

      /**
       * This method might be used to temporally remove all events
       * directly attached to the given target. This do not work
       * have any effect on bubbling events normally.
       *
       * This is mainly thought for detaching events in IE, before
       * cloning them. It also removes all leak scenarios
       * when unloading a document and may be used here as well.
       *
       * @internal
       * @param target {Object} Any valid event target
       * @param enable {Boolean} Whether to enable or disable the events
       */
      toggleAttachedEvents: function (target, enable) {
        var targetKey = target.$$hash || qx.core.ObjectRegistry.toHashCode(target);
        var targetMap = this.__P_88_3[targetKey];

        if (targetMap) {
          var indexOf, type, capture, entryList;

          for (var entryKey in targetMap) {
            indexOf = entryKey.indexOf("|");
            type = entryKey.substring(0, indexOf);
            capture = entryKey.charCodeAt(indexOf + 1) === 99; // checking for character "c".

            entryList = targetMap[entryKey];

            if (enable) {
              this.__P_88_12(target, type, capture);
            } else {
              this.__P_88_13(target, type, capture);
            }
          }
        }
      },

      /**
       * Check whether there are one or more listeners for an event type
       * registered at the target.
       *
       * @param target {Object} Any valid event target
       * @param type {String} The event type
       * @param capture {Boolean ? false} Whether to check for listeners of
       *         the bubbling or of the capturing phase.
       * @return {Boolean} Whether the target has event listeners of the given type.
       */
      hasListener: function (target, type, capture) {
        var targetKey = target.$$hash || qx.core.ObjectRegistry.toHashCode(target);
        var targetMap = this.__P_88_3[targetKey];

        if (!targetMap) {
          return false;
        }

        var entryKey = type + (capture ? "|capture" : "|bubble");
        var entryList = targetMap[entryKey];
        return !!(entryList && entryList.length > 0);
      },

      /**
       * Imports a list of event listeners at once. This only
       * works for newly created elements as it replaces
       * all existing data structures.
       *
       * Works with a map of data. Each entry in this map should be a
       * map again with the keys <code>type</code>, <code>listener</code>,
       * <code>self</code>, <code>capture</code> and an optional <code>unique</code>.
       *
       * The values are identical to the parameters of {@link #addListener}.
       * For details please have a look there.
       *
       * @param target {Object} Any valid event target
       * @param list {Map} A map where every listener has an unique key.
       */
      importListeners: function (target, list) {
        var targetKey = target.$$hash || qx.core.ObjectRegistry.toHashCode(target);
        var targetMap = this.__P_88_3[targetKey] = {};
        var clazz = qx.event.Manager;

        for (var listKey in list) {
          var item = list[listKey];
          var entryKey = item.type + (item.capture ? "|capture" : "|bubble");
          var entryList = targetMap[entryKey];

          if (!entryList) {
            entryList = targetMap[entryKey] = []; // This is the first event listener for this type and target
            // Inform the event handler about the new event
            // they perform the event registration at DOM level if needed

            this.__P_88_12(target, item.type, item.capture);
          } // Append listener to list


          entryList.push({
            handler: item.listener,
            context: item.self,
            unique: item.unique || clazz.__P_88_9++ + ""
          });
        }
      },

      /**
       * Add an event listener to any valid target. The event listener is passed an
       * instance of {@link qx.event.type.Event} containing all relevant information
       * about the event as parameter.
       *
       * @param target {Object} Any valid event target
       * @param type {String} Name of the event e.g. "click", "keydown", ...
       * @param listener {Function} Event listener function
       * @param self {Object ? null} Reference to the 'this' variable inside
       *         the event listener. When not given, the corresponding dispatcher
       *         usually falls back to a default, which is the target
       *         by convention. Note this is not a strict requirement, i.e.
       *         custom dispatchers can follow a different strategy.
       * @param capture {Boolean ? false} Whether to attach the event to the
       *         capturing phase or the bubbling phase of the event. The default is
       *         to attach the event handler to the bubbling phase.
       * @return {String} An opaque ID, which can be used to remove the event listener
       *         using the {@link #removeListenerById} method.
       * @throws {Error} if the parameters are wrong
       */
      addListener: function (target, type, listener, self, capture) {
        var targetKey = target.$$hash || qx.core.ObjectRegistry.toHashCode(target);
        var targetMap = this.__P_88_3[targetKey];

        if (!targetMap) {
          targetMap = this.__P_88_3[targetKey] = {};
        }

        var entryKey = type + (capture ? "|capture" : "|bubble");
        var entryList = targetMap[entryKey];

        if (!entryList) {
          entryList = targetMap[entryKey] = [];
        } // This is the first event listener for this type and target
        // Inform the event handler about the new event
        // they perform the event registration at DOM level if needed


        if (entryList.length === 0) {
          this.__P_88_12(target, type, capture);
        } // Append listener to list


        var unique = qx.event.Manager.__P_88_9++ + "";
        var entry = {
          handler: listener,
          context: self,
          unique: unique
        };
        entryList.push(entry);
        return entryKey + "|" + unique;
      },

      /**
       * Get the event handler class matching the given event target and type
       *
       * @param target {var} The event target
       * @param type {String} The event type
       * @return {qx.event.IEventHandler|null} The best matching event handler or
       *     <code>null</code>.
       */
      findHandler: function (target, type) {
        var isDomNode = false,
            isWindow = false,
            isObject = false,
            isDocument = false;
        var key;

        if (target.nodeType === 1) {
          isDomNode = true;
          key = "DOM_" + target.tagName.toLowerCase() + "_" + type;
        } else if (target.nodeType === 9) {
          isDocument = true;
          key = "DOCUMENT_" + type;
        } // Please note:
        // Identical operator does not work in IE (as of version 7) because
        // document.parentWindow is not identical to window. Crazy stuff.
        else if (target == this.__P_88_0) {
            isWindow = true;
            key = "WIN_" + type;
          } else if (target.classname) {
            isObject = true;
            key = "QX_" + target.classname + "_" + type;
          } else {
            key = "UNKNOWN_" + target + "_" + type;
          }

        var cache = this.__P_88_6;

        if (cache[key]) {
          return cache[key];
        }

        var classes = this.__P_88_2.getHandlers();

        var IEventHandler = qx.event.IEventHandler;
        var clazz, instance, supportedTypes, targetCheck;

        for (var i = 0, l = classes.length; i < l; i++) {
          clazz = classes[i]; // shortcut type check

          supportedTypes = clazz.SUPPORTED_TYPES;

          if (supportedTypes && !supportedTypes[type]) {
            continue;
          } // shortcut target check


          targetCheck = clazz.TARGET_CHECK;

          if (targetCheck) {
            // use bitwise & to compare for the bitmask!
            var found = false;

            if (isDomNode && (targetCheck & IEventHandler.TARGET_DOMNODE) != 0) {
              found = true;
            } else if (isWindow && (targetCheck & IEventHandler.TARGET_WINDOW) != 0) {
              found = true;
            } else if (isObject && (targetCheck & IEventHandler.TARGET_OBJECT) != 0) {
              found = true;
            } else if (isDocument && (targetCheck & IEventHandler.TARGET_DOCUMENT) != 0) {
              found = true;
            }

            if (!found) {
              continue;
            }
          }

          instance = this.getHandler(classes[i]);

          if (clazz.IGNORE_CAN_HANDLE || instance.canHandleEvent(target, type)) {
            cache[key] = instance;
            return instance;
          }
        }

        return null;
      },

      /**
       * This method is called each time an event listener for one of the
       * supported events is added using {qx.event.Manager#addListener}.
       *
       * @param target {Object} Any valid event target
       * @param type {String} event type
       * @param capture {Boolean} Whether to attach the event to the
       *         capturing phase or the bubbling phase of the event.
       * @throws {Error} if there is no handler for the event
       */
      __P_88_12: function (target, type, capture) {
        var handler = this.findHandler(target, type);

        if (handler) {
          handler.registerEvent(target, type, capture);
          return;
        }
      },

      /**
       * Remove an event listener from an event target.
       *
       * @param target {Object} Any valid event target
       * @param type {String} Name of the event
       * @param listener {Function} The pointer to the event listener
       * @param self {Object ? null} Reference to the 'this' variable inside
       *         the event listener.
       * @param capture {Boolean ? false} Whether to remove the event listener of
       *         the bubbling or of the capturing phase.
       * @return {Boolean} Whether the event was removed successfully (was existant)
       * @throws {Error} if the parameters are wrong
       */
      removeListener: function (target, type, listener, self, capture) {
        var targetKey = target.$$hash || qx.core.ObjectRegistry.toHashCode(target);
        var targetMap = this.__P_88_3[targetKey];

        if (!targetMap) {
          return false;
        }

        var entryKey = type + (capture ? "|capture" : "|bubble");
        var entryList = targetMap[entryKey];

        if (!entryList) {
          return false;
        }

        var entry;

        for (var i = 0, l = entryList.length; i < l; i++) {
          entry = entryList[i];

          if (entry.handler === listener && entry.context === self) {
            qx.lang.Array.removeAt(entryList, i);

            this.__P_88_14(entry.unique);

            if (entryList.length == 0) {
              this.__P_88_13(target, type, capture);
            }

            return true;
          }
        }

        return false;
      },

      /**
       * Removes an event listener from an event target by an ID returned by
       * {@link #addListener}.
       *
       * @param target {Object} The event target
       * @param id {String} The ID returned by {@link #addListener}
       * @return {Boolean} <code>true</code> if the handler was removed
       */
      removeListenerById: function (target, id) {
        var split = id.split("|");
        var type = split[0];
        var capture = split[1].charCodeAt(0) == 99; // detect leading "c"

        var unique = split[2];
        var targetKey = target.$$hash || qx.core.ObjectRegistry.toHashCode(target);
        var targetMap = this.__P_88_3[targetKey];

        if (!targetMap) {
          return false;
        }

        var entryKey = type + (capture ? "|capture" : "|bubble");
        var entryList = targetMap[entryKey];

        if (!entryList) {
          return false;
        }

        var entry;

        for (var i = 0, l = entryList.length; i < l; i++) {
          entry = entryList[i];

          if (entry.unique === unique) {
            qx.lang.Array.removeAt(entryList, i);

            this.__P_88_14(entry.unique);

            if (entryList.length == 0) {
              this.__P_88_13(target, type, capture);
            }

            return true;
          }
        }

        return false;
      },

      /**
       * Remove all event listeners, which are attached to the given event target.
       *
       * @param target {Object} The event target to remove all event listeners from.
       * @return {Boolean} Whether the events were existant and were removed successfully.
       */
      removeAllListeners: function (target) {
        var targetKey = target.$$hash || qx.core.ObjectRegistry.toHashCode(target);
        var targetMap = this.__P_88_3[targetKey];

        if (!targetMap) {
          return false;
        } // Deregister from event handlers


        var split, type, capture;

        for (var entryKey in targetMap) {
          if (targetMap[entryKey].length > 0) {
            // This is quite expensive, see bug #1283
            split = entryKey.split("|");
            targetMap[entryKey].forEach(function (entry) {
              this.__P_88_14(entry.unique);
            }, this);
            type = split[0];
            capture = split[1] === "capture";

            this.__P_88_13(target, type, capture);
          }
        }

        delete this.__P_88_3[targetKey];
        return true;
      },

      /**
       * Internal helper for deleting the internal listener  data structure for
       * the given targetKey.
       *
       * @param targetKey {String} Hash code for the object to delete its
       *   listeners.
       *
       * @internal
       */
      deleteAllListeners: function (targetKey) {
        delete this.__P_88_3[targetKey];
      },

      /**
       * This method is called each time the an event listener for one of the
       * supported events is removed by using {qx.event.Manager#removeListener}
       * and no other event listener is listening on this type.
       *
       * @param target {Object} Any valid event target
       * @param type {String} event type
       * @param capture {Boolean} Whether to attach the event to the
       *         capturing phase or the bubbling phase of the event.
       * @throws {Error} if there is no handler for the event
       */
      __P_88_13: function (target, type, capture) {
        var handler = this.findHandler(target, type);

        if (handler) {
          handler.unregisterEvent(target, type, capture);
          return;
        }
      },

      /*
      ---------------------------------------------------------------------------
        EVENT DISPATCH
      ---------------------------------------------------------------------------
      */

      /**
       * Dispatches an event object using the qooxdoo event handler system. The
       * event will only be visible in event listeners attached using
       * {@link #addListener}. After dispatching the event object will be pooled
       * for later reuse or disposed.
       *
       * @param target {Object} Any valid event target
       * @param event {qx.event.type.Event} The event object to dispatch. The event
       *     object must be obtained using {@link qx.event.Registration#createEvent}
       *     and initialized using {@link qx.event.type.Event#init}.
       * @return {Boolean|qx.Promise} whether the event default was prevented or not.
       *     Returns true, when the event was NOT prevented.
       * @throws {Error} if there is no dispatcher for the event
       */
      dispatchEvent: function (target, event) {
        // Show the decentrally fired events to one or more global monitor functions
        var monitors = qx.event.Manager.__P_88_10;

        if (monitors.length) {
          for (var i = 0; i < monitors.length; i++) {
            var preventDefault = event.getDefaultPrevented();

            try {
              monitors[i].call(monitors[i].$$context, target, event);
            } catch (ex) {
              qx.log.Logger.error("Error in global event monitor function " + monitors[i].toString().slice(0, 50) + "..."); // since 6.0.0-beta-2020051X: throw a real error to stop execution instead of just a warning

              throw ex;
            }

            if (preventDefault != event.getDefaultPrevented()) {
              // since 6.0.0-beta-2020051X: throw a real error to stop execution instead of just a warning
              throw new Error("Unexpected change by global event monitor function, modifications to event " + event.getType() + " is not allowed.");
            }
          }
        } // Preparations


        var type = event.getType();

        if (!event.getBubbles() && !this.hasListener(target, type)) {
          qx.event.Pool.getInstance().poolObject(event);
          return true;
        }

        if (!event.getTarget()) {
          event.setTarget(target);
        } // Interacion data


        var classes = this.__P_88_2.getDispatchers();

        var instance; // Loop through the dispatchers

        var dispatched = false;
        var tracker = {};

        for (var i = 0, l = classes.length; i < l; i++) {
          instance = this.getDispatcher(classes[i]); // Ask if the dispatcher can handle this event

          if (instance.canDispatchEvent(target, event, type)) {
            qx.event.Utils.track(tracker, instance.dispatchEvent(target, event, type));
            dispatched = true;
            break;
          }
        }

        if (!dispatched) {
          return true;
        }

        return qx.event.Utils.then(tracker, function () {
          // check whether "preventDefault" has been called
          var preventDefault = event.getDefaultPrevented(); // Release the event instance to the event pool

          qx.event.Pool.getInstance().poolObject(event);
          return !preventDefault;
        });
      },

      /**
       * Dispose the event manager
       */
      dispose: function () {
        // Remove from manager list
        this.__P_88_2.removeManager(this);

        qx.util.DisposeUtil.disposeMap(this, "__P_88_4");
        qx.util.DisposeUtil.disposeMap(this, "__P_88_5"); // Dispose data fields

        this.__P_88_3 = this.__P_88_0 = this.__P_88_11 = null;
        this.__P_88_2 = this.__P_88_6 = null;
      },

      /**
       * Add event to blacklist.
       *
       * @param uid {number} unique event id
       */
      __P_88_14: function (uid) {
        if (this.__P_88_8 === null) {
          this.__P_88_8 = {};

          this.__P_88_7.schedule();
        }

        this.__P_88_8[uid] = true;
      },

      /**
       * Check if the event with the given id has been removed and is therefore blacklisted for event handling
       *
       * @param uid {number} unique event id
       * @return {boolean}
       */
      isBlacklisted: function (uid) {
        return this.__P_88_8 !== null && this.__P_88_8[uid] === true;
      }
    }
  });
  qx.event.Manager.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
  
  ************************************************************************ */

  /**
   * Basic node creation and type detection
   */
  qx.Bootstrap.define("qx.dom.Node", {
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics: {
      /*
      ---------------------------------------------------------------------------
        NODE TYPES
      ---------------------------------------------------------------------------
      */

      /**
       * @type {Map} Node type:
       *
       * * ELEMENT
       * * ATTRIBUTE
       * * TEXT
       * * CDATA_SECTION
       * * ENTITY_REFERENCE
       * * ENTITY
       * * PROCESSING_INSTRUCTION
       * * COMMENT
       * * DOCUMENT
       * * DOCUMENT_TYPE
       * * DOCUMENT_FRAGMENT
       * * NOTATION
       */
      ELEMENT: 1,
      ATTRIBUTE: 2,
      TEXT: 3,
      CDATA_SECTION: 4,
      ENTITY_REFERENCE: 5,
      ENTITY: 6,
      PROCESSING_INSTRUCTION: 7,
      COMMENT: 8,
      DOCUMENT: 9,
      DOCUMENT_TYPE: 10,
      DOCUMENT_FRAGMENT: 11,
      NOTATION: 12,

      /*
      ---------------------------------------------------------------------------
        DOCUMENT ACCESS
      ---------------------------------------------------------------------------
      */

      /**
       * Returns the owner document of the given node
       *
       * @param node {Node|Document|Window} the node which should be tested
       * @return {Document|null} The document of the given DOM node
       */
      getDocument: function (node) {
        return node.nodeType === this.DOCUMENT ? node : // is document already
        node.ownerDocument || // is DOM node
        node.document; // is window
      },

      /**
       * Returns the DOM2 <code>defaultView</code> (window).
       *
       * @param node {Node|Document|Window} node to inspect
       * @return {Window} the <code>defaultView</code> of the given node
       */
      getWindow: function (node) {
        // is a window already
        if (node.nodeType == null) {
          return node;
        } // jump to document


        if (node.nodeType !== this.DOCUMENT) {
          node = node.ownerDocument;
        } // jump to window


        return node.defaultView || node.parentWindow;
      },

      /**
       * Returns the document element. (Logical root node)
       *
       * This is a convenience attribute that allows direct access to the child
       * node that is the root element of the document. For HTML documents,
       * this is the element with the tagName "HTML".
       *
       * @param node {Node|Document|Window} node to inspect
       * @return {Element} document element of the given node
       */
      getDocumentElement: function (node) {
        return this.getDocument(node).documentElement;
      },

      /**
       * Returns the body element. (Visual root node)
       *
       * This normally only makes sense for HTML documents. It returns
       * the content area of the HTML document.
       *
       * @param node {Node|Document|Window} node to inspect
       * @return {Element} document body of the given node
       */
      getBodyElement: function (node) {
        return this.getDocument(node).body;
      },

      /*
      ---------------------------------------------------------------------------
        TYPE TESTS
      ---------------------------------------------------------------------------
      */

      /**
       * Whether the given object is a DOM node
       *
       * @param node {Node} the node which should be tested
       * @return {Boolean} true if the node is a DOM node
       */
      isNode: function (node) {
        return !!(node && node.nodeType != null);
      },

      /**
       * Whether the given object is a DOM element node
       *
       * @param node {Node} the node which should be tested
       * @return {Boolean} true if the node is a DOM element
       */
      isElement: function (node) {
        return !!(node && node.nodeType === this.ELEMENT);
      },

      /**
       * Whether the given object is a DOM document node
       *
       * @param node {Node} the node which should be tested
       * @return {Boolean} true when the node is a DOM document
       */
      isDocument: function (node) {
        return !!(node && node.nodeType === this.DOCUMENT);
      },

      /**
       * Whether the given object is a DOM document fragment node
       *
       * @param node {Node} the node which should be tested
       * @return {Boolean} true when the node is a DOM document fragment
       */
      isDocumentFragment: function (node) {
        return !!(node && node.nodeType === this.DOCUMENT_FRAGMENT);
      },

      /**
       * Whether the given object is a DOM text node
       *
       * @param node {Node} the node which should be tested
       * @return {Boolean} true if the node is a DOM text node
       */
      isText: function (node) {
        return !!(node && node.nodeType === this.TEXT);
      },

      /**
       * Check whether the given object is a browser window object.
       *
       * @param obj {Object} the object which should be tested
       * @return {Boolean} true if the object is a window object
       */
      isWindow: function (obj) {
        return !!(obj && obj.history && obj.location && obj.document);
      },

      /**
       * Whether the node has the given node name
       *
       * @param node {Node} the node
       * @param nodeName {String} the node name to check for
       * @return {Boolean} Whether the node has the given node name
       */
      isNodeName: function (node, nodeName) {
        if (!nodeName || !node || !node.nodeName) {
          return false;
        }

        return nodeName.toLowerCase() == qx.dom.Node.getName(node);
      },

      /*
      ---------------------------------------------------------------------------
        UTILITIES
      ---------------------------------------------------------------------------
      */

      /**
       * Get the node name as lower case string
       *
       * @param node {Node} the node
       * @return {String} the node name
       */
      getName: function (node) {
        if (!node || !node.nodeName) {
          return null;
        }

        return node.nodeName.toLowerCase();
      },

      /**
       * Returns the text content of an node where the node may be of node type
       * NODE_ELEMENT, NODE_ATTRIBUTE, NODE_TEXT or NODE_CDATA
       *
       * @param node {Node} the node from where the search should start.
       *     If the node has subnodes the text contents are recursively retreived and joined.
       * @return {String} the joined text content of the given node or null if not appropriate.
       * @signature function(node)
       */
      getText: function (node) {
        if (!node || !node.nodeType) {
          return null;
        }

        switch (node.nodeType) {
          case 1:
            // NODE_ELEMENT
            var i,
                a = [],
                nodes = node.childNodes,
                length = nodes.length;

            for (i = 0; i < length; i++) {
              a[i] = this.getText(nodes[i]);
            }

            return a.join("");

          case 2: // NODE_ATTRIBUTE

          case 3: // NODE_TEXT

          case 4:
            // CDATA
            return node.nodeValue;
        }

        return null;
      },

      /**
       * Checks if the given node is a block node
       *
       * @param node {Node} Node
       * @return {Boolean} whether it is a block node
       */
      isBlockNode: function (node) {
        if (!qx.dom.Node.isElement(node)) {
          return false;
        }

        node = qx.dom.Node.getName(node);
        return /^(body|form|textarea|fieldset|ul|ol|dl|dt|dd|li|div|hr|p|h[1-6]|quote|pre|table|thead|tbody|tfoot|tr|td|th|iframe|address|blockquote)$/.test(node);
      }
    }
  });
  qx.dom.Node.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.lang.normalize.Date": {
        "require": true
      },
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.bom.client.Engine": {
        "require": true
      },
      "qx.data.Array": {},
      "qx.lang.Type": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "engine.name": {
          "className": "qx.bom.client.Engine"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
  
     ======================================================================
  
     This class contains code based on the following work:
  
     * jQuery
       http://jquery.com
       Version 1.3.1
  
       Copyright:
         2009 John Resig
  
       License:
         MIT: http://www.opensource.org/licenses/mit-license.php
  
     * Underscore.js
       http://underscorejs.org
  
       Copyright:
         2009-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
  
       License:
         MIT: http://www.opensource.org/licenses/mit-license.php
  
  ************************************************************************ */

  /**
   * Static helper functions for arrays with a lot of often used convenience
   * methods like <code>remove</code> or <code>contains</code>.
   *
   * The native JavaScript Array is not modified by this class. However,
   * there are modifications to the native Array in {@link qx.lang.normalize.Array} for
   * browsers that do not support certain JavaScript features natively .
   *
   * @ignore(qx.data)
   * @ignore(qx.data.IListData)
   * @ignore(qx.Class.*)
   * @require(qx.lang.normalize.Date)
   */
  qx.Bootstrap.define("qx.lang.Array", {
    statics: {
      /**
       * Converts an array like object to any other array like
       * object.
       *
       * Attention: The returned array may be same
       * instance as the incoming one if the constructor is identical!
       *
       * @param object {var} any array-like object
       * @param constructor {Function} constructor of the new instance
       * @param offset {Integer?0} position to start from
       * @return {Array} the converted array
       */
      cast: function (object, constructor, offset) {
        if (object.constructor === constructor) {
          return object;
        }

        if (qx.data && qx.data.IListData) {
          if (qx.Class && qx.Class.hasInterface(object, qx.data.IListData)) {
            var object = object.toArray();
          }
        } // Create from given constructor


        var ret = new constructor(); // Some collections in mshtml are not able to be sliced.
        // These lines are a special workaround for this client.

        if (qx.core.Environment.get("engine.name") == "mshtml") {
          if (object.item) {
            for (var i = offset || 0, l = object.length; i < l; i++) {
              ret.push(object[i]);
            }

            return ret;
          }
        } // Copy over items


        if (Object.prototype.toString.call(object) === "[object Array]" && offset == null) {
          ret.push.apply(ret, object);
        } else {
          ret.push.apply(ret, Array.prototype.slice.call(object, offset || 0));
        }

        return ret;
      },

      /**
       * Convert an arguments object into an array.
       *
       * @param args {arguments} arguments object
       * @param offset {Integer?0} position to start from
       * @return {Array} a newly created array (copy) with the content of the arguments object.
       */
      fromArguments: function (args, offset) {
        return Array.prototype.slice.call(args, offset || 0);
      },

      /**
       * Convert a (node) collection into an array
       *
       * @param coll {var} node collection
       * @return {Array} a newly created array (copy) with the content of the node collection.
       */
      fromCollection: function (coll) {
        // The native Array.slice cannot be used with some Array-like objects
        // including NodeLists in older IEs
        if (qx.core.Environment.get("engine.name") == "mshtml") {
          if (coll.item) {
            var arr = [];

            for (var i = 0, l = coll.length; i < l; i++) {
              arr[i] = coll[i];
            }

            return arr;
          }
        }

        return Array.prototype.slice.call(coll, 0);
      },

      /**
       * Expand shorthand definition to a four element list.
       * This is an utility function for padding/margin and all other shorthand handling.
       *
       * @param input {Array} arr with one to four elements
       * @return {Array} an arr with four elements
       */
      fromShortHand: function (input) {
        var len = input.length;
        var result = qx.lang.Array.clone(input); // Copy Values (according to the length)

        switch (len) {
          case 1:
            result[1] = result[2] = result[3] = result[0];
            break;

          case 2:
            result[2] = result[0];
          // no break here

          case 3:
            result[3] = result[1];
        } // Return list with 4 items


        return result;
      },

      /**
       * Return a copy of the given array
       *
       * @param arr {Array} the array to copy
       * @return {Array} copy of the array
       */
      clone: function (arr) {
        return arr.concat();
      },

      /**
       * Insert an element at a given position into the array
       *
       * @param arr {Array} the array
       * @param obj {var} the element to insert
       * @param i {Integer} position where to insert the element into the array
       * @return {Array} the array
       */
      insertAt: function (arr, obj, i) {
        arr.splice(i, 0, obj);
        return arr;
      },

      /**
       * Insert an element into the array before a given second element.
       *
       * @param arr {Array} the array
       * @param obj {var} object to be inserted
       * @param obj2 {var} insert obj1 before this object
       * @return {Array} the array
       */
      insertBefore: function (arr, obj, obj2) {
        var i = arr.indexOf(obj2);

        if (i == -1) {
          arr.push(obj);
        } else {
          arr.splice(i, 0, obj);
        }

        return arr;
      },

      /**
       * Insert an element into the array after a given second element.
       *
       * @param arr {Array} the array
       * @param obj {var} object to be inserted
       * @param obj2 {var} insert obj1 after this object
       * @return {Array} the array
       */
      insertAfter: function (arr, obj, obj2) {
        var i = arr.indexOf(obj2);

        if (i == -1 || i == arr.length - 1) {
          arr.push(obj);
        } else {
          arr.splice(i + 1, 0, obj);
        }

        return arr;
      },

      /**
       * Remove an element from the array at the given index
       *
       * @param arr {Array} the array
       * @param i {Integer} index of the element to be removed
       * @return {var} The removed element.
       */
      removeAt: function (arr, i) {
        return arr.splice(i, 1)[0];
      },

      /**
       * Remove all elements from the array
       *
       * @param arr {Array} the array
       * @return {Array} empty array
       */
      removeAll: function (arr) {
        arr.length = 0;
        return this;
      },

      /**
       * Append the elements of an array to the array
       *
       * @param arr1 {Array} the array
       * @param arr2 {Array} the elements of this array will be appended to other one
       * @return {Array} The modified array.
       * @throws {Error} if one of the arguments is not an array
       */
      append: function (arr1, arr2) {
        if (arr1 instanceof qx.data.Array) {
          return arr1.append(arr2);
        }

        if (arr2 instanceof qx.data.Array) {
          arr2 = arr2.toArray();
        } // this check is important because opera throws an uncatchable error if apply is called without
        // an arr as second argument.


        Array.prototype.push.apply(arr1, arr2);
        return arr1;
      },

      /**
       * Modifies the first array as it removes all elements
       * which are listed in the second array as well.
       *
       * @param arr1 {Array} the array
       * @param arr2 {Array} the elements of this array will be excluded from the other one
       * @return {Array} The modified array.
       * @throws {Error} if one of the arguments is not an array
       */
      exclude: function (arr1, arr2) {
        if (arr1 instanceof qx.data.Array) {
          return arr1.exclude(arr2);
        } // this check is important because opera throws an uncatchable error if apply is called without
        // an arr as second argument.


        arr2.forEach(function (item) {
          var index = arr1.indexOf(item);

          if (index != -1) {
            arr1.splice(index, 1);
          }
        });
        return arr1;
      },

      /**
       * Remove an element from the array.
       *
       * @param arr {Array} the array
       * @param obj {var} element to be removed from the array
       * @return {var} the removed element
       */
      remove: function (arr, obj) {
        if (arr instanceof qx.data.Array) {
          return arr.remove(obj);
        }

        var i = arr.indexOf(obj);

        if (i != -1) {
          arr.splice(i, 1);
          return obj;
        }
      },

      /**
       * Whether the array contains the given element
       *
       * @deprecated {6.0} Please use Array instance include method instead
       *
       * @param arr {Array} the array
       * @param obj {var} object to look for
       * @return {Boolean} whether the arr contains the element
       */
      contains: function (arr, obj) {
        return arr.includes(obj);
      },

      /**
       * Check whether the two arrays have the same content. Checks only the
       * equality of the arrays' content.
       *
       * @param arr1 {Array} first array
       * @param arr2 {Array} second array
       * @return {Boolean} Whether the two arrays are equal
       */
      equals: function (arr1, arr2) {
        if (arr1 instanceof qx.data.Array) {
          return arr1.equals(arr2);
        }

        arr2 = qx.lang.Array.toNativeArray(arr2);
        var length = arr1.length;

        if (length !== arr2.length) {
          return false;
        }

        for (var i = 0; i < length; i++) {
          if (arr1[i] !== arr2[i]) {
            return false;
          }
        }

        return true;
      },

      /**
       * Returns the sum of all values in the given array. Supports
       * numeric values only.
       *
       * @param arr {Number[]} Array to process
       * @return {Number} The sum of all values.
       */
      sum: function (arr) {
        var result = 0;

        for (var i = 0, l = arr.length; i < l; i++) {
          if (arr[i] != undefined) {
            result += arr[i];
          }
        }

        return result;
      },

      /**
       * Returns the highest value in the given array. Supports
       * numeric values only.
       *
       * @param arr {Number[]} Array to process
       * @return {Number | null} The highest of all values or undefined if array is empty.
       */
      max: function (arr) {
        var i,
            len = arr.length,
            result = arr[0];

        for (i = 1; i < len; i++) {
          if (arr[i] > result) {
            result = arr[i];
          }
        }

        return result === undefined ? null : result;
      },

      /**
       * Returns the lowest value in the given array. Supports
       * numeric values only.
       *
       * @param arr {Number[]} Array to process
       * @return {Number | null} The lowest of all values or undefined if array is empty.
       */
      min: function (arr) {
        var i,
            len = arr.length,
            result = arr[0];

        for (i = 1; i < len; i++) {
          if (arr[i] < result) {
            result = arr[i];
          }
        }

        return result === undefined ? null : result;
      },

      /**
       * Recreates an array which is free of all duplicate elements from the original.
       *
       * This method does not modify the original array!
       *
       * Keep in mind that this methods deletes undefined indexes.
       *
       * @param arr {Array} Incoming array
       * @return {Array} Returns a copy with no duplicates
       */
      unique: function (arr) {
        var ret = [],
            doneStrings = {},
            doneNumbers = {},
            doneObjects = {};
        var value,
            count = 0;
        var key = "qx" + Date.now();
        var hasNull = false,
            hasFalse = false,
            hasTrue = false; // Rebuild array and omit duplicates

        for (var i = 0, len = arr.length; i < len; i++) {
          value = arr[i]; // Differ between null, primitives and reference types

          if (value === null) {
            if (!hasNull) {
              hasNull = true;
              ret.push(value);
            }
          } else if (value === undefined) {// pass
          } else if (value === false) {
            if (!hasFalse) {
              hasFalse = true;
              ret.push(value);
            }
          } else if (value === true) {
            if (!hasTrue) {
              hasTrue = true;
              ret.push(value);
            }
          } else if (typeof value === "string") {
            if (!doneStrings[value]) {
              doneStrings[value] = 1;
              ret.push(value);
            }
          } else if (typeof value === "number") {
            if (!doneNumbers[value]) {
              doneNumbers[value] = 1;
              ret.push(value);
            }
          } else {
            var hash = value[key];

            if (hash == null) {
              hash = value[key] = count++;
            }

            if (!doneObjects[hash]) {
              doneObjects[hash] = value;
              ret.push(value);
            }
          }
        } // Clear object hashs


        for (var hash in doneObjects) {
          try {
            delete doneObjects[hash][key];
          } catch (ex) {
            try {
              doneObjects[hash][key] = null;
            } catch (ex1) {
              throw new Error("Cannot clean-up map entry doneObjects[" + hash + "][" + key + "]");
            }
          }
        }

        return ret;
      },

      /**
       * Returns a new array with integers from start to stop incremented or decremented by step.
       *
       * @param start {Integer} start of the new array, defaults to 0
       * @param stop {Integer} stop of the new array
       * @param step {Integer} increment / decrement - depends whether you use positive or negative values
       * @return {Array} Returns a new array with integers
       */
      range: function (start, stop, step) {
        if (arguments.length <= 1) {
          stop = start || 0;
          start = 0;
        }

        step = arguments[2] || 1;
        var length = Math.max(Math.ceil((stop - start) / step), 0);
        var idx = 0;
        var range = Array(length);

        while (idx < length) {
          range[idx++] = start;
          start += step;
        }

        return range;
      },

      /**
       * Replaces the contents of the array `dest`
       * 
       * @param dest {Array|qx.data.Array} the array to edit (if null then a new array is created)
       * @param src {Array|qx.data.Array} the array to copy from, or null
       * @return {Array} the edited array (or the new array, if dest is null)
       */
      replace: function (dest, src) {
        if (dest instanceof qx.data.Array) {
          return dest.replace(src);
        }

        if (src === null) {
          if (dest === null) {
            return null;
          } else {
            return [];
          }
        }

        src = qx.lang.Array.toNativeArray(src);

        if (dest === null) {
          dest = src.slice(0);
        } else {
          var args = [0, dest.length];
          src.forEach(function (item) {
            args.push(item);
          });
          dest.splice.apply(dest, args);
        }

        return dest;
      },

      /**
       * Returns a native array from src where possible; qx.data.Array is converted to its native array,
       * in which case unless `clone` parameter is set to true the rules of qx.data.Array.toArray should 
       * be followed, ie that the array should not be manipulated directly.
       * 
       * @param src {qx.data.Array|Array} the object to return as an array
       * @param clone{Boolean?} whether to make the returned array a clone, ie editable by the calling code
       * @return {Array}
       */
      toNativeArray: function (src, clone) {
        if (src === undefined || src === null) {
          return src;
        }

        if (src instanceof qx.data.Array) {
          if (clone) {
            return src.toArray().slice(0);
          }

          return src.toArray();
        }

        if (qx.lang.Type.isArray(src)) {
          if (clone) {
            return src.slice(0);
          }

          return src;
        }

        return [src];
      }
    }
  });
  qx.lang.Array.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.lang.Array": {
        "require": true
      },
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.event.GlobalError": {
        "require": true
      }
    },
    "environment": {
      "provided": [],
      "required": {
        "qx.globalErrorHandling": {
          "className": "qx.event.GlobalError"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
  
     ======================================================================
  
     This class contains code based on the following work:
  
     * Mootools
       http://mootools.net
       Version 1.1.1
  
       Copyright:
         2007 Valerio Proietti
  
       License:
         MIT: http://www.opensource.org/licenses/mit-license.php
  
  ************************************************************************ */

  /**
   * Collection of helper methods operating on functions.
   *
   * @ignore(qx.core.Object)
   * @require(qx.lang.Array)
   */
  qx.Bootstrap.define("qx.lang.Function", {
    statics: {
      /**
       * Extract the caller of a function from the arguments variable.
       * This will not work in Opera < 9.6.
       *
       * @param args {arguments} The local arguments variable
       * @return {Function} A reference to the calling function or "undefined" if caller is not supported.
       */
      getCaller: function (args) {
        return args.caller ? args.caller.callee : args.callee.caller;
      },

      /**
       * Try to get a sensible textual description of a function object.
       * This may be the class/mixin and method name of a function
       * or at least the signature of the function.
       *
       * @param fcn {Function} function the get the name for.
       * @return {String} Name of the function.
       */
      getName: function (fcn) {
        if (fcn.displayName) {
          return fcn.displayName;
        }

        if (fcn.$$original || fcn.wrapper || fcn.classname) {
          return fcn.classname + ".constructor()";
        }

        if (fcn.$$mixin) {
          //members
          for (var key in fcn.$$mixin.$$members) {
            if (fcn.$$mixin.$$members[key] == fcn) {
              return fcn.$$mixin.name + ".prototype." + key + "()";
            }
          } // statics


          for (var key in fcn.$$mixin) {
            if (fcn.$$mixin[key] == fcn) {
              return fcn.$$mixin.name + "." + key + "()";
            }
          }
        }

        if (fcn.self) {
          var clazz = fcn.self.constructor;

          if (clazz) {
            // members
            for (var key in clazz.prototype) {
              if (clazz.prototype[key] == fcn) {
                return clazz.classname + ".prototype." + key + "()";
              }
            } // statics


            for (var key in clazz) {
              if (clazz[key] == fcn) {
                return clazz.classname + "." + key + "()";
              }
            }
          }
        }

        var fcnReResult = fcn.toString().match(/function\s*(\w*)\s*\(.*/);

        if (fcnReResult && fcnReResult.length >= 1 && fcnReResult[1]) {
          return fcnReResult[1] + "()";
        }

        return 'anonymous()';
      },

      /**
       * Evaluates JavaScript code globally
       *
       * @lint ignoreDeprecated(eval)
       *
       * @param data {String} JavaScript commands
       * @return {var} Result of the execution
       */
      globalEval: function (data) {
        if (window.execScript) {
          return window.execScript(data);
        } else {
          return eval.call(window, data);
        }
      },

      /**
       * Base function for creating functional closures which is used by most other methods here.
       *
       * *Syntax*
       *
       * <pre class='javascript'>var createdFunction = qx.lang.Function.create(myFunction, [options]);</pre>
       *
       * @param func {Function} Original function to wrap
       * @param options {Map?} Map of options
       * <ul>
       * <li><strong>self</strong>: The object that the "this" of the function will refer to. Default is the same as the wrapper function is called.</li>
       * <li><strong>args</strong>: An array of arguments that will be passed as arguments to the function when called.
       *     Default is no custom arguments; the function will receive the standard arguments when called.</li>
       * <li><strong>delay</strong>: If set, the returned function will delay the actual execution by this amount of milliseconds and return a timer handle when called.
       *     Default is no delay.</li>
       * <li><strong>periodical</strong>: If set the returned function will periodically perform the actual execution with this specified interval
       *      and return a timer handle when called. Default is no periodical execution.</li>
       * <li><strong>attempt</strong>: If set to true, the returned function will try to execute and return either the results or false on error. Default is false.</li>
       * </ul>
       *
       * @return {Function} Wrapped function
       */
      create: function (func, options) {
        // Nothing to be done when there are no options.
        if (!options) {
          return func;
        } // Check for at least one attribute.


        if (!(options.self || options.args || options.delay != null || options.periodical != null || options.attempt)) {
          return func;
        }

        return function (event) {
          // Convert (and copy) incoming arguments
          var args = qx.lang.Array.fromArguments(arguments); // Prepend static arguments

          if (options.args) {
            args = options.args.concat(args);
          }

          if (options.delay || options.periodical) {
            var returns = function () {
              return func.apply(options.self || this, args);
            };

            if (qx.core.Environment.get("qx.globalErrorHandling")) {
              returns = qx.event.GlobalError.observeMethod(returns);
            }

            if (options.delay) {
              return window.setTimeout(returns, options.delay);
            }

            if (options.periodical) {
              return window.setInterval(returns, options.periodical);
            }
          } else if (options.attempt) {
            var ret = false;

            try {
              ret = func.apply(options.self || this, args);
            } catch (ex) {}

            return ret;
          } else {
            return func.apply(options.self || this, args);
          }
        };
      },

      /**
       * Returns a function whose "this" is altered.
       *
       *
       * *Native way*
       *
       * This is also a feature of JavaScript 1.8.5 and will be supplied
       * by modern browsers. Including {@link qx.lang.normalize.Function}
       * will supply a cross browser normalization of the native
       * implementation. We like to encourage you to use the native function!
       *
       *
       * *Syntax*
       *
       * <pre class='javascript'>qx.lang.Function.bind(myFunction, [self, [varargs...]]);</pre>
       *
       * *Example*
       *
       * <pre class='javascript'>
       * function myFunction()
       * {
       *   this.setStyle('color', 'red');
       *   // note that 'this' here refers to myFunction, not an element
       *   // we'll need to bind this function to the element we want to alter
       * };
       *
       * var myBoundFunction = qx.lang.Function.bind(myFunction, myElement);
       * myBoundFunction(); // this will make the element myElement red.
       * </pre>
       *
       * If you find yourself using this static method a lot, you may be
       * interested in the bindTo() method in the mixin qx.core.MBindTo.
       *
       * @see qx.core.MBindTo
       *
       * @param func {Function} Original function to wrap
       * @param self {Object ? null} The object that the "this" of the function will refer to.
       * @param varargs {arguments ? null} The arguments to pass to the function.
       * @return {Function} The bound function.
       */
      bind: function (func, self, varargs) {
        return this.create(func, {
          self: self,
          args: arguments.length > 2 ? qx.lang.Array.fromArguments(arguments, 2) : null
        });
      },

      /**
       * Returns a function whose arguments are pre-configured.
       *
       * *Syntax*
       *
       * <pre class='javascript'>qx.lang.Function.curry(myFunction, [varargs...]);</pre>
       *
       * *Example*
       *
       * <pre class='javascript'>
       * function myFunction(elem) {
       *   elem.setStyle('color', 'red');
       * };
       *
       * var myBoundFunction = qx.lang.Function.curry(myFunction, myElement);
       * myBoundFunction(); // this will make the element myElement red.
       * </pre>
       *
       * @param func {Function} Original function to wrap
       * @param varargs {arguments} The arguments to pass to the function.
       * @return {var} The pre-configured function.
       */
      curry: function (func, varargs) {
        return this.create(func, {
          args: arguments.length > 1 ? qx.lang.Array.fromArguments(arguments, 1) : null
        });
      },

      /**
       * Returns a function which could be used as a listener for a native event callback.
       *
       * *Syntax*
       *
       * <pre class='javascript'>qx.lang.Function.listener(myFunction, [self, [varargs...]]);</pre>
       *
       * @param func {Function} Original function to wrap
       * @param self {Object ? null} The object that the "this" of the function will refer to.
       * @param varargs {arguments ? null} The arguments to pass to the function.
       * @return {var} The bound function.
       */
      listener: function (func, self, varargs) {
        if (arguments.length < 3) {
          return function (event) {
            // Directly execute, but force first parameter to be the event object.
            return func.call(self || this, event || window.event);
          };
        } else {
          var optargs = qx.lang.Array.fromArguments(arguments, 2);
          return function (event) {
            var args = [event || window.event]; // Append static arguments

            args.push.apply(args, optargs); // Finally execute original method

            func.apply(self || this, args);
          };
        }
      },

      /**
       * Tries to execute the function.
       *
       * *Syntax*
       *
       * <pre class='javascript'>var result = qx.lang.Function.attempt(myFunction, [self, [varargs...]]);</pre>
       *
       * *Example*
       *
       * <pre class='javascript'>
       * var myObject = {
       *   'cow': 'moo!'
       * };
       *
       * var myFunction = function()
       * {
       *   for(var i = 0; i < arguments.length; i++) {
       *     if(!this[arguments[i]]) throw('doh!');
       *   }
       * };
       *
       * var result = qx.lang.Function.attempt(myFunction, myObject, 'pig', 'cow'); // false
       * </pre>
       *
       * @param func {Function} Original function to wrap
       * @param self {Object ? null} The object that the "this" of the function will refer to.
       * @param varargs {arguments ? null} The arguments to pass to the function.
       * @return {Boolean|var} <code>false</code> if an exception is thrown, else the function's return.
       */
      attempt: function (func, self, varargs) {
        return this.create(func, {
          self: self,
          attempt: true,
          args: arguments.length > 2 ? qx.lang.Array.fromArguments(arguments, 2) : null
        })();
      },

      /**
       * Delays the execution of a function by a specified duration.
       *
       * *Syntax*
       *
       * <pre class='javascript'>var timeoutID = qx.lang.Function.delay(myFunction, [delay, [self, [varargs...]]]);</pre>
       *
       * *Example*
       *
       * <pre class='javascript'>
       * var myFunction = function(){ alert('moo! Element id is: ' + this.id); };
       * //wait 50 milliseconds, then call myFunction and bind myElement to it
       * qx.lang.Function.delay(myFunction, 50, myElement); // alerts: 'moo! Element id is: ... '
       *
       * // An anonymous function, example
       * qx.lang.Function.delay(function(){ alert('one second later...'); }, 1000); //wait a second and alert
       * </pre>
       *
       * @param func {Function} Original function to wrap
       * @param delay {Integer} The duration to wait (in milliseconds).
       * @param self {Object ? null} The object that the "this" of the function will refer to.
       * @param varargs {arguments ? null} The arguments to pass to the function.
       * @return {Integer} The JavaScript Timeout ID (useful for clearing delays).
       */
      delay: function (func, delay, self, varargs) {
        return this.create(func, {
          delay: delay,
          self: self,
          args: arguments.length > 3 ? qx.lang.Array.fromArguments(arguments, 3) : null
        })();
      },

      /**
       * Executes a function in the specified intervals of time
       *
       * *Syntax*
       *
       * <pre class='javascript'>var intervalID = qx.lang.Function.periodical(myFunction, [period, [self, [varargs...]]]);</pre>
       *
       * *Example*
       *
       * <pre class='javascript'>
       * var Site = { counter: 0 };
       * var addCount = function(){ this.counter++; };
       * qx.lang.Function.periodical(addCount, 1000, Site); // will add the number of seconds at the Site
       * </pre>
       *
       * @param func {Function} Original function to wrap
       * @param interval {Integer} The duration of the intervals between executions.
       * @param self {Object ? null} The object that the "this" of the function will refer to.
       * @param varargs {arguments ? null} The arguments to pass to the function.
       * @return {Integer} The Interval ID (useful for clearing a periodical).
       */
      periodical: function (func, interval, self, varargs) {
        return this.create(func, {
          periodical: interval,
          self: self,
          args: arguments.length > 3 ? qx.lang.Array.fromArguments(arguments, 3) : null
        })();
      }
    }
  });
  qx.lang.Function.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.event.Manager": {
        "require": true
      },
      "qx.dom.Node": {
        "require": true
      },
      "qx.lang.Function": {
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.ObjectRegistry": {},
      "qx.event.type.Event": {},
      "qx.event.Pool": {},
      "qx.event.Utils": {},
      "qx.Promise": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
       * Sebastian Werner (wpbasti)
  
  ************************************************************************ */

  /**
   * Wrapper for browser generic event handling.
   *
   * Supported events differ from target to target. Generally the handlers
   * in {@link qx.event.handler} defines the available features.
   *
   * @require(qx.event.Manager)
   * @require(qx.dom.Node)
   * @require(qx.lang.Function)
   */
  qx.Class.define("qx.event.Registration", {
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics: {
      /**
       * Static list of all instantiated event managers. The key is the qooxdoo
       * hash value of the corresponding window
       */
      __P_73_0: {},

      /**
       * Get an instance of the event manager, which can handle events for the
       * given target.
       *
       * @param target {Object} Any valid event target
       * @return {qx.event.Manager} The event manger for the target.
       */
      getManager: function (target) {
        if (target == null) {
          target = window;
        } else if (target.nodeType) {
          target = qx.dom.Node.getWindow(target);
        } else if (!qx.dom.Node.isWindow(target)) {
          target = window;
        }

        var hash = target.$$hash || qx.core.ObjectRegistry.toHashCode(target);
        var manager = this.__P_73_0[hash];

        if (!manager) {
          manager = new qx.event.Manager(target, this);
          this.__P_73_0[hash] = manager;
        }

        return manager;
      },

      /**
       * Removes a manager for a specific window from the list.
       *
       * Normally only used when the manager gets disposed through
       * an unload event of the attached window.
       *
       * @param mgr {qx.event.Manager} The manager to remove
       */
      removeManager: function (mgr) {
        var id = mgr.getWindowId();
        delete this.__P_73_0[id];
      },

      /**
       * Add an event listener to a DOM target. The event listener is passed an
       * instance of {@link qx.event.type.Event} containing all relevant information
       * about the event as parameter.
       *
       * @param target {Object} Any valid event target
       * @param type {String} Name of the event e.g. "click", "keydown", ...
       * @param listener {Function} Event listener function
       * @param self {Object ? null} Reference to the 'this' variable inside
       *         the event listener. When not given, the corresponding dispatcher
       *         usually falls back to a default, which is the target
       *         by convention. Note this is not a strict requirement, i.e.
       *         custom dispatchers can follow a different strategy.
       * @param capture {Boolean} Whether to attach the event to the
       *         capturing phase or the bubbling phase of the event. The default is
       *         to attach the event handler to the bubbling phase.
       * @return {var} An opaque id, which can be used to remove the event listener
       *         using the {@link #removeListenerById} method.
       */
      addListener: function (target, type, listener, self, capture) {
        return this.getManager(target).addListener(target, type, listener, self, capture);
      },

      /**
       * Remove an event listener from an event target.
       *
       * Note: All registered event listeners will automatically at page unload
       *   so it is not necessary to detach events in the destructor.
       *
       * @param target {Object} The event target
       * @param type {String} Name of the event
       * @param listener {Function} The pointer to the event listener
       * @param self {Object ? null} Reference to the 'this' variable inside
       *         the event listener.
       * @param capture {Boolean} Whether to remove the event listener of
       *    the bubbling or of the capturing phase.
       * @return {Boolean} Whether the event was removed. Return <code>false</code> if
       *    the event was already removed before.
       */
      removeListener: function (target, type, listener, self, capture) {
        return this.getManager(target).removeListener(target, type, listener, self, capture);
      },

      /**
       * Removes an event listener from an event target by an id returned by
       * {@link #addListener}
       *
       * @param target {Object} The event target
       * @param id {var} The id returned by {@link #addListener}
       * @return {Boolean} Whether the event was removed. Return <code>false</code> if
       *    the event was already removed before.
       */
      removeListenerById: function (target, id) {
        return this.getManager(target).removeListenerById(target, id);
      },

      /**
       * Remove all event listeners, which are attached to the given event target.
       *
       * @param target {Object} The event target to remove all event listeners from.
       * @return {Boolean} Whether the events were existant and were removed successfully.
       */
      removeAllListeners: function (target) {
        return this.getManager(target).removeAllListeners(target);
      },

      /**
       * Internal helper for deleting the listeners map used during shutdown.
       *
       * @param target {Object} The event target to delete the internal map for
       *    all event listeners.
       *
       * @internal
       */
      deleteAllListeners: function (target) {
        var targetKey = target.$$hash;

        if (targetKey) {
          this.getManager(target).deleteAllListeners(targetKey);
        }
      },

      /**
       * Check whether there are one or more listeners for an event type
       * registered at the target.
       *
       * @param target {Object} Any valid event target
       * @param type {String} The event type
       * @param capture {Boolean ? false} Whether to check for listeners of
       *         the bubbling or of the capturing phase.
       * @return {Boolean} Whether the target has event listeners of the given type.
       */
      hasListener: function (target, type, capture) {
        return this.getManager(target).hasListener(target, type, capture);
      },

      /**
       * Returns a serialized array of all events attached on the given target.
       *
       * @param target {Object} Any valid event target
       * @return {Map[]} Array of maps where everyone contains the keys:
       *   <code>handler</code>, <code>self</code>, <code>type</code> and <code>capture</code>.
       */
      serializeListeners: function (target) {
        return this.getManager(target).serializeListeners(target);
      },

      /**
       * Get an event instance of the given class, which can be dispatched using
       * an event manager. The created events must be initialized using
       * {@link qx.event.type.Event#init}.
       *
       * @param type {String} The type of the event to create
       * @param clazz {Object?qx.event.type.Event} The event class to use
       * @param args {Array?null} Array which will be passed to
       *       the event's init method.
       * @return {qx.event.type.Event} An instance of the given class.
       */
      createEvent: function (type, clazz, args) {
        // Fallback to default
        if (clazz == null) {
          clazz = qx.event.type.Event;
        }

        var obj = qx.event.Pool.getInstance().getObject(clazz); // Initialize with given arguments

        args ? obj.init.apply(obj, args) : obj.init(); // Setup the type
        // Note: Native event may setup this later or using init() above
        // using the native information.

        if (type) {
          obj.setType(type);
        }

        return obj;
      },

      /**
       * Dispatch an event object on the given target.
       *
       * It is normally better to use {@link #fireEvent} because it uses
       * the event pooling and is quite handy otherwise as well. After dispatching
       * the event object will be pooled for later reuse or disposed.
       *
       * @param target {Object} Any valid event target
       * @param event {qx.event.type.Event} The event object to dispatch. The event
       *       object must be obtained using {@link #createEvent} and initialized
       *       using {@link qx.event.type.Event#init}.
       * @return {Boolean|qx.Promise} whether the event default was prevented or not.
       *     Returns true, when the event was NOT prevented.
       */
      dispatchEvent: function (target, event) {
        return this.getManager(target).dispatchEvent(target, event);
      },

      /**
       * Create an event object and dispatch it on the given target.
       *
       * @param target {Object} Any valid event target
       * @param type {String} Event type to fire
       * @param clazz {Class?qx.event.type.Event} The event class
       * @param args {Array?null} Arguments, which will be passed to
       *       the event's init method.
       * @return {Event} the event
       * @see #createEvent
       */
      __P_73_1: function (target, type, clazz, args) {
        var evt = this.createEvent(type, clazz || null, args);
        this.getManager(target).dispatchEvent(target, evt);
        return evt;
      },

      /**
       * Create an event object and dispatch it on the given target.
       *
       * Note about Promises in v6.0: this method has changed to return either a boolean (true if the
       * event was prevented) or a promise which will evaluate to the same thing; this is
       * because events are now asynchronous and preventDefault is inherently synchronous.
       * However, although this changing in the return type is conspicuous it does not necessarily
       * introduce a backwards compatibility issue because the "truthy" nature of the return
       * is preserved.  Code which needs to take care of asynchronous issues will need to change,
       * but that was necessary anyway, and it is rare to use the return value of this method (only
       * one class in Qooxdoo used it).
       *
       * @param target {Object} Any valid event target
       * @param type {String} Event type to fire
       * @param clazz {Class?qx.event.type.Event} The event class
       * @param args {Array?null} Arguments, which will be passed to
       *       the event's init method.
       * @return {Boolean|qx.Promise} whether the event default was prevented or not.
       *     Returns true, when the event was NOT prevented.
       * @see #createEvent
       */
      fireEvent: function (target, type, clazz, args) {
        var evt = this.createEvent(type, clazz || null, args);
        var tracker = {};
        var self = this;
        qx.event.Utils.then(tracker, function () {
          return self.getManager(target).dispatchEvent(target, evt);
        });
        return qx.event.Utils.then(tracker, function () {
          return !evt.getDefaultPrevented();
        });
      },

      /**
       * Create an event object and dispatch it on the given target; equivalent to fireEvent, except that it
       * always returns a promise
       *
       * @param target {Object} Any valid event target
       * @param type {String} Event type to fire
       * @param clazz {Class?qx.event.type.Event} The event class
       * @param args {Array?null} Arguments, which will be passed to
       *       the event's init method.
       * @return {qx.Promise} a promise aggregated from the event handlers;
       * 	if the default was prevented, the promise is rejected
       * @see #createEvent
       */
      fireEventAsync: function (target, type, clazz, args) {
        {
          return qx.Promise.resolve(this.fireEvent(target, type, clazz, args));
        }
      },

      /**
       * Create an event object and dispatch it on the given target.
       * The event dispatched with this method does never bubble! Use only if you
       * are sure that bubbling is not required.
       *
       * @param target {Object} Any valid event target
       * @param type {String} Event type to fire
       * @param clazz {Class?qx.event.type.Event} The event class
       * @param args {Array?null} Arguments, which will be passed to
       *       the event's init method.
       * @return {Event} the event
       * @see #createEvent
       */
      __P_73_2: function (target, type, clazz, args) {
        var mgr = this.getManager(target);

        if (!mgr.hasListener(target, type, false)) {
          return null;
        }

        var evt = this.createEvent(type, clazz || null, args);
        mgr.dispatchEvent(target, evt);
        return evt;
      },

      /**
       * Create an event object and dispatch it on the given target.
       * The event dispatched with this method does never bubble! Use only if you
       * are sure that bubbling is not required.
       *
       * @param target {Object} Any valid event target
       * @param type {String} Event type to fire
       * @param clazz {Class?qx.event.type.Event} The event class
       * @param args {Array?null} Arguments, which will be passed to
       *       the event's init method.
       * @return {Boolean} whether the event default was prevented or not.
       *     Returns true, when the event was NOT prevented.
       * @see #createEvent
       */
      fireNonBubblingEvent: function (target, type, clazz, args) {
        var evt = this.__P_73_2.apply(this, arguments);

        if (evt === null) {
          return true;
        }

        return !evt.getDefaultPrevented();
      },

      /**
       * Create an event object and dispatch it on the given target.
       * The event dispatched with this method does never bubble! Use only if you
       * are sure that bubbling is not required.
       *
       * @param target {Object} Any valid event target
       * @param type {String} Event type to fire
       * @param clazz {Class?qx.event.type.Event} The event class
       * @param args {Array?null} Arguments, which will be passed to
       *       the event's init method.
       * @return {qx.Promise} a promise aggregated from the event handlers;
       * 	if the default was prevented, the promise is rejected
       * @see #createEvent
       */
      fireNonBubblingEventAsync: function (target, type, clazz, args) {
        var evt = this.__P_73_2.apply(this, arguments);

        if (evt === null) {
          return qx.Promise.resolve(true);
        }

        return evt.promise();
      },

      /*
      ---------------------------------------------------------------------------
        EVENT HANDLER/DISPATCHER PRIORITY
      ---------------------------------------------------------------------------
      */

      /** @type {Integer} Highest priority. Used by handlers and dispatchers. */
      PRIORITY_FIRST: -32000,

      /** @type {Integer} Default priority. Used by handlers and dispatchers. */
      PRIORITY_NORMAL: 0,

      /** @type {Integer} Lowest priority. Used by handlers and dispatchers. */
      PRIORITY_LAST: 32000,

      /*
      ---------------------------------------------------------------------------
        EVENT HANDLER REGISTRATION
      ---------------------------------------------------------------------------
      */

      /** @type {Array} Contains all known event handlers */
      __P_73_3: [],

      /**
       * Register an event handler.
       *
       * @param handler {qx.event.IEventHandler} Event handler to add
       * @throws {Error} if the handler does not have the IEventHandler interface.
       */
      addHandler: function (handler) {
        // Append to list
        this.__P_73_3.push(handler); // Re-sort list


        this.__P_73_3.sort(function (a, b) {
          return a.PRIORITY - b.PRIORITY;
        });
      },

      /**
       * Get a list of registered event handlers.
       *
       * @return {qx.event.IEventHandler[]} registered event handlers
       */
      getHandlers: function () {
        return this.__P_73_3;
      },

      /*
      ---------------------------------------------------------------------------
        EVENT DISPATCHER REGISTRATION
      ---------------------------------------------------------------------------
      */

      /** @type {Array} Contains all known event dispatchers */
      __P_73_4: [],

      /**
       * Register an event dispatcher.
       *
       * @param dispatcher {qx.event.IEventDispatcher} Event dispatcher to add
       * @param priority {Integer} One of
       * {@link qx.event.Registration#PRIORITY_FIRST},
       * {@link qx.event.Registration#PRIORITY_NORMAL}
       *       or {@link qx.event.Registration#PRIORITY_LAST}.
       * @throws {Error} if the dispatcher does not have the IEventHandler interface.
       */
      addDispatcher: function (dispatcher, priority) {
        // Append to list
        this.__P_73_4.push(dispatcher); // Re-sort list


        this.__P_73_4.sort(function (a, b) {
          return a.PRIORITY - b.PRIORITY;
        });
      },

      /**
       * Get a list of registered event dispatchers.
       *
       * @return {qx.event.IEventDispatcher[]} all registered event dispatcher
       */
      getDispatchers: function () {
        return this.__P_73_4;
      }
    }
  });
  qx.event.Registration.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.event.dispatch.Direct": {},
      "qx.event.handler.Object": {},
      "qx.Mixin": {
        "usage": "dynamic",
        "require": true
      },
      "qx.event.Registration": {
        "require": true
      },
      "qx.Promise": {},
      "qx.event.type.Data": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * This mixin offers basic event handling capabilities. It includes the
   * commonly known methods for managing event listeners and firing events.
   *
   * @use(qx.event.dispatch.Direct)
   * @use(qx.event.handler.Object)
   */
  qx.Mixin.define("qx.core.MEvent", {
    members: {
      /** @type {Class} Pointer to the regular event registration class */
      __P_78_0: qx.event.Registration,

      /**
       * Add event listener to this object.
       *
       * @param type {String} name of the event type
       * @param listener {Function} event callback function
       * @param self {Object ? null} Reference to the 'this' variable inside
       *         the event listener. When not given, the corresponding dispatcher
       *         usually falls back to a default, which is the target
       *         by convention. Note this is not a strict requirement, i.e.
       *         custom dispatchers can follow a different strategy.
       * @param capture {Boolean ? false} Whether to attach the event to the
       *         capturing phase or the bubbling phase of the event. The default is
       *         to attach the event handler to the bubbling phase.
       * @return {String} An opaque id, which can be used to remove the event listener
       *         using the {@link #removeListenerById} method.
       */
      addListener: function (type, listener, self, capture) {
        if (!this.$$disposed) {
          return this.__P_78_0.addListener(this, type, listener, self, capture);
        }

        return null;
      },

      /**
       * Add event listener to this object, which is only called once. After the
       * listener is called the event listener gets removed.
       *
       * @param type {String} name of the event type
       * @param listener {Function} event callback function
       * @param context {Object ? window} reference to the 'this' variable inside the callback
       * @param capture {Boolean ? false} Whether to attach the event to the
       *         capturing phase or the bubbling phase of the event. The default is
       *         to attach the event handler to the bubbling phase.
       * @return {String} An opaque id, which can be used to remove the event listener
       *         using the {@link #removeListenerById} method.
       */
      addListenerOnce: function (type, listener, context, capture) {
        var self = this; // self is needed to remove the listener inside the callback

        if (!context) {
          context = this;
        }

        var id; // store id in closure context

        var callback = function (e) {
          self.removeListenerById(id);
          listener.call(context, e);
        }; // check for wrapped callback storage


        if (!listener.$$wrapped_callback) {
          listener.$$wrapped_callback = {};
        } // store the call for each type in case the listener is
        // used for more than one type [BUG #8038]


        listener.$$wrapped_callback[type + this.toHashCode()] = callback;
        id = this.addListener(type, callback, context, capture);
        return id;
      },

      /**
       * Remove event listener from this object
       *
       * @param type {String} name of the event type
       * @param listener {Function} event callback function
       * @param self {Object ? null} reference to the 'this' variable inside the callback
       * @param capture {Boolean} Whether to remove the event listener of
       *   the bubbling or of the capturing phase.
       * @return {Boolean} Whether the event was removed successfully (has existed)
       */
      removeListener: function (type, listener, self, capture) {
        if (!this.$$disposed) {
          // special handling for wrapped once listener
          if (listener.$$wrapped_callback && listener.$$wrapped_callback[type + this.$$hash]) {
            var callback = listener.$$wrapped_callback[type + this.$$hash];
            delete listener.$$wrapped_callback[type + this.$$hash];
            listener = callback;
          }

          return this.__P_78_0.removeListener(this, type, listener, self, capture);
        }

        return false;
      },

      /**
       * Removes an event listener from an event target by an id returned by
       * {@link #addListener}
       *
       * @param id {String} The id returned by {@link #addListener}
       * @return {Boolean} Whether the event was removed successfully (has existed)
       */
      removeListenerById: function (id) {
        if (!this.$$disposed) {
          return this.__P_78_0.removeListenerById(this, id);
        }

        return false;
      },

      /**
       * Check if there are one or more listeners for an event type.
       *
       * @param type {String} name of the event type
       * @param capture {Boolean ? false} Whether to check for listeners of
       *         the bubbling or of the capturing phase.
       * @return {Boolean} Whether the object has a listener of the given type.
       */
      hasListener: function (type, capture) {
        return this.__P_78_0.hasListener(this, type, capture);
      },

      /**
       * Dispatch an event on this object
       *
       * @param evt {qx.event.type.Event} event to dispatch
       * @return {Boolean} Whether the event default was prevented or not.
       *     Returns true, when the event was NOT prevented.
       */
      dispatchEvent: function (evt) {
        if (!this.$$disposed) {
          return this.__P_78_0.dispatchEvent(this, evt);
        }

        return true;
      },

      /**
       * Creates and dispatches an event on this object.
       *
       * @param type {String} Event type to fire
       * @param clazz {Class?qx.event.type.Event} The event class
       * @param args {Array?null} Arguments, which will be passed to
       *       the event's init method.
       * @return {Boolean|qx.Promise} whether the event default was prevented or not.
       *     Returns true, when the event was NOT prevented.
       */
      fireEvent: function (type, clazz, args) {
        if (!this.$$disposed) {
          return this.__P_78_0.fireEvent(this, type, clazz, args);
        }

        return true;
      },

      /**
       * Creates and dispatches an event on this object; equivalent to fireEvent, except that it
       * always returns a promise
       *
       * @param type {String} Event type to fire
       * @param clazz {Class?qx.event.type.Event} The event class
       * @param args {Array?null} Arguments, which will be passed to
       *       the event's init method.
       * @return {qx.Promise} a promise aggregated from the event handlers;
       *  if the default was prevented, the promise is rejected
       */
      fireEventAsync: function (type, clazz, args) {
        if (!this.$$disposed) {
          return this.__P_78_0.fireEventAsync(this, type, clazz, args);
        }

        return qx.Promise.resolve(true);
      },

      /**
       * Create an event object and dispatch it on this object.
       * The event dispatched with this method does never bubble! Use only if you
       * are sure that bubbling is not required.
       *
       * @param type {String} Event type to fire
       * @param clazz {Class?qx.event.type.Event} The event class
       * @param args {Array?null} Arguments, which will be passed to
       *       the event's init method.
       * @return {Boolean} Whether the event default was prevented or not.
       *     Returns true, when the event was NOT prevented.
       */
      fireNonBubblingEvent: function (type, clazz, args) {
        if (!this.$$disposed) {
          return this.__P_78_0.fireNonBubblingEvent(this, type, clazz, args);
        }

        return true;
      },

      /**
       * Create an event object and dispatch it on this object; equivalent to fireNonBubblingEvent, 
       * except that it always returns a promise.
       * 
       * The event dispatched with this method does never bubble! Use only if you
       * are sure that bubbling is not required.
       *
       * @param type {String} Event type to fire
       * @param clazz {Class?qx.event.type.Event} The event class
       * @param args {Array?null} Arguments, which will be passed to
       *       the event's init method.
       * @return {qx.Promise} a promise aggregated from the event handlers;
       *  if the default was prevented, the promise is rejected
       */
      fireNonBubblingEventAsync: function (type, clazz, args) {
        if (!this.$$disposed) {
          return this.__P_78_0.fireNonBubblingEventAsync(this, type, clazz, args);
        }

        return qx.Promise.resolve(true);
      },

      /**
       * Creates and dispatches an non-bubbling data event on this object.
       *
       * @param type {String} Event type to fire
       * @param data {var} User defined data attached to the event object
       * @param oldData {var?null} The event's old data (optional)
       * @param cancelable {Boolean?false} Whether or not an event can have its default
       *     action prevented. The default action can either be the browser's
       *     default action of a native event (e.g. open the context menu on a
       *     right click) or the default action of a qooxdoo class (e.g. close
       *     the window widget). The default action can be prevented by calling
       *     {@link qx.event.type.Event#preventDefault}
       * @return {Boolean|qx.Promise} whether the event default was prevented or not.
       *     Returns true, when the event was NOT prevented.
       */
      fireDataEvent: function (type, data, oldData, cancelable) {
        if (!this.$$disposed) {
          if (oldData === undefined) {
            oldData = null;
          }

          return this.__P_78_0.fireEvent(this, type, qx.event.type.Data, [data, oldData, !!cancelable]);
        }

        return true;
      },

      /**
       * Creates and dispatches an non-bubbling data event on this object; equivalent to 
       * fireEvent, except that it always returns a promise.
       *
       * @param type {String} Event type to fire
       * @param data {var} User defined data attached to the event object
       * @param oldData {var?null} The event's old data (optional)
       * @param cancelable {Boolean?false} Whether or not an event can have its default
       *     action prevented. The default action can either be the browser's
       *     default action of a native event (e.g. open the context menu on a
       *     right click) or the default action of a qooxdoo class (e.g. close
       *     the window widget). The default action can be prevented by calling
       *     {@link qx.event.type.Event#preventDefault}
       * @return {qx.Promise} a promise aggregated from the event handlers;
       *  if the default was prevented, the promise is rejected
       */
      fireDataEventAsync: function (type, data, oldData, cancelable) {
        if (!this.$$disposed) {
          if (oldData === undefined) {
            oldData = null;
          }

          return this.__P_78_0.fireEventAsync(this, type, qx.event.type.Data, [data, oldData, !!cancelable]);
        }

        return qx.Promise.resolve(true);
      }
    }
  });
  qx.core.MEvent.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Mixin": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Property": {},
      "qx.Bootstrap": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * This mixin offers the basic property features which include generic
   * setter, getter and resetter.
   */
  qx.Mixin.define("qx.core.MProperty", {
    members: {
      /**
       * Sets multiple properties at once by using a property list or
       * sets one property and its value by the first and second argument.
       * As a fallback, if no generated property setter could be found, a
       * handwritten setter will be searched and invoked if available.
       *
       * @param data {Map | String} a map of property values. The key is the name of the property.
       * @param value {var?} the value, only used when <code>data</code> is a string.
       * @return {Object} Returns this instance if <code>data</code> is a map
       *   or a non-generated setter is called; otherwise returns <code>value</code>.
       * @throws {Error} if a property defined does not exist
       */
      set: function (data, value) {
        var setter = qx.core.Property.$$method.set;

        if (qx.Bootstrap.isString(data)) {
          if (!this[setter[data]]) {
            if (this["set" + qx.Bootstrap.firstUp(data)] != undefined) {
              this["set" + qx.Bootstrap.firstUp(data)](value);
              return this;
            }

            throw new Error("No such property: " + data);
          }

          return this[setter[data]](value);
        } else {
          for (var prop in data) {
            if (!this[setter[prop]]) {
              if (this["set" + qx.Bootstrap.firstUp(prop)] != undefined) {
                this["set" + qx.Bootstrap.firstUp(prop)](data[prop]);
                continue;
              }

              throw new Error("No such property: " + prop);
            }

            this[setter[prop]](data[prop]);
          }

          return this;
        }
      },

      /**
       * Returns the value of the given property. If no generated getter could be
       * found, a fallback tries to access a handwritten getter.
       *
       * @param prop {String} Name of the property.
       * @return {var} The value of the value
       * @throws {Error} if a property defined does not exist
       */
      get: function (prop) {
        var getter = qx.core.Property.$$method.get;

        if (!this[getter[prop]]) {
          if (this["get" + qx.Bootstrap.firstUp(prop)] != undefined) {
            return this["get" + qx.Bootstrap.firstUp(prop)]();
          }

          throw new Error("No such property: " + prop);
        }

        return this[getter[prop]]();
      },

      /**
       * Resets the value of the given property. If no generated resetter could be
       * found, a handwritten resetter will be invoked, if available.
       *
       * @param prop {String} Name of the property.
       * @throws {Error} if a property defined does not exist
       */
      reset: function (prop) {
        var resetter = qx.core.Property.$$method.reset;

        if (!this[resetter[prop]]) {
          if (this["reset" + qx.Bootstrap.firstUp(prop)] != undefined) {
            this["reset" + qx.Bootstrap.firstUp(prop)]();
            return;
          }

          throw new Error("No such property: " + prop);
        }

        this[resetter[prop]]();
      },

      /**
       * Checks if the property is initialized, i.e. has a defined init value or
       * has got a value by a setter method.
       *
       * @param prop {String} Name of the property
       * @return {Boolean} If the property is initialized
       * @throws {Error} If the property defined does not exist
       */
      isPropertyInitialized: function (prop) {
        return this["$$user_" + prop] !== undefined || this["$$init_" + prop] !== undefined;
      }
    }
  });
  qx.core.MProperty.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Mixin": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2017 Zenesis Limited, http://www.zenesis.com
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * John Spackman (john.spackman@zenesis.com, @johnspackman)
  
  ************************************************************************ */

  /**
   * A mixin providing objects by ID and owners.
   * 
   * The typical use of IDs is to override the `_createQxObjectImpl` method and create
   * new instances on demand; all code should access these instances by calling
   * `getQxObject`.
   */
  qx.Mixin.define("qx.core.MObjectId", {
    /*
     * ****************************************************************************
     * PROPERTIES
     * ****************************************************************************
     */
    properties: {
      /** The owning object */
      qxOwner: {
        init: null,
        check: "qx.core.Object",
        nullable: true,
        apply: "_applyQxOwner"
      },

      /** {String} The ID of the object.  */
      qxObjectId: {
        init: null,
        check: function (value) {
          return value === null || typeof value == "string" && value.indexOf('/') < 0;
        },
        nullable: true,
        apply: "_applyQxObjectId"
      }
    },

    /*
     * ****************************************************************************
     * MEMBERS
     * ****************************************************************************
     */
    members: {
      __P_79_0: null,
      __P_79_1: false,

      /**
       * Apply owner
       */
      _applyQxOwner: function (value, oldValue) {
        if (!this.__P_79_1) {
          throw new Error("Please use API methods to change owner, not the property");
        }
      },

      /**
       * Apply objectId
       */
      _applyQxObjectId: function (value, oldValue) {
        if (!this.__P_79_1) {
          var owner = this.getQxOwner();

          if (owner) {
            owner.__P_79_2(this, value, oldValue);
          }

          this._cascadeQxObjectIdChanges();
        }
      },

      /**
       * Called when a child's objectId changes
       */
      __P_79_2: function (obj, newId, oldId) {
        delete this.__P_79_0[oldId];
        this.__P_79_0[newId] = obj;
      },

      /**
       * Reflect changes to IDs or owners
       */
      _cascadeQxObjectIdChanges: function () {
        if (typeof this.getContentElement == "function") {
          var contentElement = this.getContentElement();

          if (contentElement) {
            contentElement.updateObjectId();
          }
        }

        if (this.__P_79_0) {
          for (var name in this.__P_79_0) {
            var obj = this.__P_79_0[name];

            if (obj instanceof qx.core.Object) {
              obj._cascadeQxObjectIdChanges();
            }
          }
        }
      },

      /**
       * Returns the object with the specified ID
       * 
       * @param id
       *          {String} ID of the object
       * @return {qx.core.Object?} the found object
       */
      getQxObject: function (id) {
        if (this.__P_79_0) {
          var obj = this.__P_79_0[id];

          if (obj !== undefined) {
            return obj;
          }
        } // Separate out the child control ID


        var controlId = null;
        var pos = id.indexOf('#');

        if (pos > -1) {
          controlId = id.substring(pos + 1);
          id = id.substring(0, pos);
        }

        var result = undefined; // Handle paths

        if (id.indexOf('/') > -1) {
          var segs = id.split('/');
          var target = this;
          var found = segs.every(function (seg) {
            if (!seg.length) {
              return true;
            }

            if (!target) {
              return false;
            }

            var tmp = target.getQxObject(seg);

            if (tmp !== undefined) {
              target = tmp;
              return true;
            }
          });

          if (found) {
            result = target;
          }
        } else {
          // No object, creating the object
          result = this._createQxObject(id);
        }

        if (result && controlId) {
          var childControl = result.getChildControl(controlId);
          return childControl;
        }

        return result;
      },

      /**
       * Creates the object and adds it to a list; most classes are expected to
       * override `_createQxObjectImpl` NOT this method.
       * 
       * @param id {String} ID of the object
       * @return {qx.core.Object?} the created object
       */
      _createQxObject: function (id) {
        var result = this._createQxObjectImpl(id);

        if (result !== undefined) {
          this.addOwnedQxObject(result, id);
        }

        return result;
      },

      /**
       * Creates the object, intended to be overridden. Null is a valid return
       * value and will be cached by `getQxObject`, however `undefined` is NOT a
       * valid value and so will not be cached meaning that `_createQxObjectImpl`
       * will be called multiple times until a valid value is returned.
       * 
       * @param id {String} ID of the object
       * @return {qx.core.Object?} the created object
       */
      _createQxObjectImpl: function (id) {
        return undefined;
      },

      /**
       * Adds an object as owned by this object
       * 
       * @param obj {qx.core.Object} the object to register
       * @param id {String?} the id to set when registering the object
       */
      addOwnedQxObject: function (obj, id) {
        if (!this.__P_79_0) {
          this.__P_79_0 = {};
        }

        if (!(obj instanceof qx.core.Object)) {
          if (!id) {
            throw new Error("Cannot register an object that has no ID, obj=" + obj);
          }

          if (this.__P_79_0[id]) {
            throw new Error("Cannot register an object with ID '" + id + "' because that ID is already in use, this=" + this + ", obj=" + obj);
          }

          this.__P_79_0[id] = obj;
          return;
        }

        var thatOwner = obj.getQxOwner();

        if (thatOwner === this) {
          return;
        }

        obj.__P_79_1 = true;

        try {
          if (thatOwner) {
            thatOwner.__P_79_3(obj);
          }

          if (id === undefined) {
            id = obj.getQxObjectId();
          }

          if (!id) {
            throw new Error("Cannot register an object that has no ID, obj=" + obj);
          }

          if (this.__P_79_0[id]) {
            throw new Error("Cannot register an object with ID '" + id + "' because that ID is already in use, this=" + this + ", obj=" + obj);
          }

          if (obj.getQxOwner() != null) {
            throw new Error("Cannot register an object with ID '" + id + "' because it is already owned by another object this=" + this + ", obj=" + obj);
          }

          obj.setQxOwner(this);
          obj.setQxObjectId(id);

          obj._cascadeQxObjectIdChanges();
        } finally {
          obj.__P_79_1 = false;
        }

        this.__P_79_0[id] = obj;
      },

      /**
       * Discards an object from the list of owned objects; note that this does
       * not dispose of the object, simply forgets it if it exists.
       * 
       * @param args {String|Object} the ID of the object to discard, or the object itself
       */
      removeOwnedQxObject: function (args) {
        if (!this.__P_79_0) {
          throw new Error("Cannot discard object because it is not owned by this, this=" + this + ", object=" + obj);
        }

        var id;
        var obj;

        if (typeof args === "string") {
          if (args.indexOf('/') > -1) {
            throw new Error("Cannot discard owned objects based on a path");
          }

          id = args;
          obj = this.__P_79_0[id];

          if (obj === undefined) {
            return;
          }
        } else {
          obj = args;

          if (!(obj instanceof qx.core.Object)) {
            throw new Error("Cannot discard object by reference because it is not a Qooxdoo object, please remove it using the original ID; object=" + obj);
          }

          id = obj.getQxObjectId();

          if (this.__P_79_0[id] !== obj) {
            throw new Error("Cannot discard object because it is not owned by this, this=" + this + ", object=" + obj);
          }
        }

        if (obj !== null) {
          if (!(obj instanceof qx.core.Object)) {
            this.__P_79_3(obj);

            delete this.__P_79_0[id];
          } else {
            obj.__P_79_1 = true;

            try {
              this.__P_79_3(obj);

              obj._cascadeQxObjectIdChanges();
            } finally {
              obj.__P_79_1 = false;
            }
          }
        }
      },

      /**
       * Removes an owned object
       * 
       * @param obj {qx.core.Object} the object
       */
      __P_79_3: function (obj) {
        if (obj !== null) {
          var id = obj.getQxObjectId();
          obj.setQxOwner(null);
          delete this.__P_79_0[id];
        }
      },

      /**
       * Returns an array of objects that are owned by this object, or an empty
       * array if none exists.
       * 
       * @return {Array}
       */
      getOwnedQxObjects: function () {
        return this.__P_79_0 ? Object.values(this.__P_79_0) : [];
      }
    }
  });
  qx.core.MObjectId.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * Utility class with type check for all native JavaScript data types.
   *
   */
  qx.Bootstrap.define("qx.lang.Type", {
    statics: {
      /**
       * Get the internal class of the value. See
       * http://perfectionkills.com/instanceof-considered-harmful-or-how-to-write-a-robust-isarray/
       * for details.
       *
       * @signature function(value)
       * @param value {var} value to get the class for
       * @return {String} the internal class of the value
       */
      getClass: qx.Bootstrap.getClass,

      /**
       * Whether the value is a string.
       *
       * @signature function(value)
       * @param value {var} Value to check.
       * @return {Boolean} Whether the value is a string.
       */
      isString: qx.Bootstrap.isString,

      /**
       * Whether the value is an array.
       *
       * @signature function(value)
       * @param value {var} Value to check.
       * @return {Boolean} Whether the value is an array.
       */
      isArray: qx.Bootstrap.isArray,

      /**
       * Whether the value is an object. Note that built-in types like Window are
       * not reported to be objects.
       *
       * @signature function(value)
       * @param value {var} Value to check.
       * @return {Boolean} Whether the value is an object.
       */
      isObject: qx.Bootstrap.isObject,

      /**
       * Whether the value is a function.
       *
       * @signature function(value)
       * @param value {var} Value to check.
       * @return {Boolean} Whether the value is a function.
       */
      isFunction: qx.Bootstrap.isFunction,

      /**
       * Whether the value is a function or an async function.
       *
       * @signature function(value)
       * @param value {var} Value to check.
       * @return {Boolean} Whether the value is a function or an async function.
       */
      isFunctionOrAsyncFunction: qx.Bootstrap.isFunctionOrAsyncFunction,

      /**
      * Whether the value is a regular expression.
      *
      * @param value {var} Value to check.
      * @return {Boolean} Whether the value is a regular expression.
      */
      isRegExp: function (value) {
        return this.getClass(value) === "RegExp";
      },

      /**
      * Whether the value is a number.
      *
      * This function checks if the _type_ of the value is Number.
      * Global properties *NaN*, *-Infinity*, *+Infinity*,
      * *Number.POSITIVE_INFINITY* and *Number.NEGATIVE_INFINITY*
      * return true.
      *
      * @param value {var} Value to check.
      * @return {Boolean} Whether the value is a number.
      */
      isNumber: function (value) {
        // Added "value !== null" because IE throws an exception "Object expected"
        // by executing "value instanceof Number" if value is a DOM element that
        // doesn't exist. It seems that there is an internal different between a
        // JavaScript null and a null returned from calling DOM.
        // e.q. by document.getElementById("ReturnedNull").
        return value !== null && (this.getClass(value) === "Number" || value instanceof Number);
      },

      /**
      * Whether the value is a boolean.
      *
      * @param value {var} Value to check.
      * @return {Boolean} Whether the value is a boolean.
      */
      isBoolean: function (value) {
        // Added "value !== null" because IE throws an exception "Object expected"
        // by executing "value instanceof Boolean" if value is a DOM element that
        // doesn't exist. It seems that there is an internal different between a
        // JavaScript null and a null returned from calling DOM.
        // e.q. by document.getElementById("ReturnedNull").
        return value !== null && (this.getClass(value) === "Boolean" || value instanceof Boolean);
      },

      /**
       * Whether the value is a date.
       *
       * @param value {var} Value to check.
       * @return {Boolean} Whether the value is a date.
       */
      isDate: function (value) {
        // Added "value !== null" because IE throws an exception "Object expected"
        // by executing "value instanceof Date" if value is a DOM element that
        // doesn't exist. It seems that there is an internal different between a
        // JavaScript null and a null returned from calling DOM.
        // e.q. by document.getElementById("ReturnedNull").
        return value !== null && (this.getClass(value) === "Date" || value instanceof Date);
      },

      /**
       * Whether the value is a Error.
       *
       * @param value {var} Value to check.
       * @return {Boolean} Whether the value is a Error.
       */
      isError: function (value) {
        // Added "value !== null" because IE throws an exception "Object expected"
        // by executing "value instanceof Error" if value is a DOM element that
        // doesn't exist. It seems that there is an internal different between a
        // JavaScript null and a null returned from calling DOM.
        // e.q. by document.getElementById("ReturnedNull").
        return value !== null && (this.getClass(value) === "Error" || value instanceof Error);
      },

      /**
       * Whether the value is a Promise.
       *
       * checks if value exists and has a function 'then'
       *
       * @param value {var} Value to check.
       * @return {Boolean} Whether the value is a Promise.
       *
       */
      isPromise: function (value) {
        return value != null && this.isFunction(value.then);
      }
    }
  });
  qx.lang.Type.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.lang.Type": {
        "require": true
      },
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.AssertionError": {},
      "qx.lang.Json": {},
      "qx.lang.Number": {},
      "qx.lang.String": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * A collection of assertions.
   *
   * These methods can be used to assert incoming parameters, return values, ...
   * If an assertion fails an {@link AssertionError} is thrown.
   *
   * Assertions are used in unit tests as well.
   *
   * @require(qx.lang.Type)
   * @ignore(qx.Class.*)
   */
  qx.Bootstrap.define("qx.core.Assert", {
    statics: {
      __P_67_0: true,

      /**
       * Assert that the condition evaluates to <code>true</code>. An
       * {@link AssertionError} is thrown if otherwise.
       *
       * @param comment {String} Message to be shown if the assertion fails. This
       *    message is provided by the user.
       * @param msgvarargs {var} any number of parts of a message to show if assertion
       *                         triggers. Each will be converted to a string and all
       *                         parts will be concatenated. E. g. instead of
       *                         "Got invalid value " + this.__toString(val) + "!!!!!"
       *                         use
       *                         "Got invalid value ", val, "!!!!!"
       *                         (much better performance)
       *
       */
      __P_67_1: function (comment, msgvarargs) {
        // Build up message from message varargs. It's not really important
        // how long this takes as it is done only when assertion is triggered
        var msg = "";

        for (var i = 1, l = arguments.length; i < l; i++) {
          msg = msg + this.__P_67_2(arguments[i] === undefined ? "'undefined'" : arguments[i]);
        }

        var fullComment = "";

        if (msg) {
          fullComment = comment + ": " + msg;
        } else {
          fullComment = comment;
        }

        var errorMsg = "Assertion error! " + fullComment;

        if (qx.Class && qx.Class.isDefined("qx.core.AssertionError")) {
          var err = new qx.core.AssertionError(comment, msg);

          if (this.__P_67_0) {
            qx.Bootstrap.error(errorMsg + "\n Stack trace: \n" + err.getStackTrace());
          }

          throw err;
        } else {
          if (this.__P_67_0) {
            qx.Bootstrap.error(errorMsg);
          }

          throw new Error(errorMsg);
        }
      },

      /**
       * Convert an unknown value to a string to display in error messages
       *
       * @param value {var} any value
       * @return {String} a string representation of the value
       */
      __P_67_2: function (value) {
        var stringValue;

        if (value === null) {
          stringValue = "null";
        } else if (qx.lang.Type.isArray(value) && value.length > 10) {
          stringValue = "Array[" + value.length + "]";
        } else if (value instanceof Object && value.toString == null) {
          stringValue = qx.lang.Json.stringify(value, null, 2);
        } else {
          try {
            stringValue = value.toString();
          } catch (e) {
            stringValue = "";
          }
        }

        return stringValue;
      },

      /**
       * Assert that the condition evaluates to <code>true</code>.
       *
       * @param condition {var} Condition to check for. Must evaluate to
       *    <code>true</code>.
       * @param msg {String?} Message to be shown if the assertion fails.
       */
      assert: function (condition, msg) {
        condition == true || this.__P_67_1(msg || "", "Called assert with 'false'");
      },

      /**
       * Raise an {@link AssertionError}.
       *
       * @param msg {String} Message to be shown if the assertion fails.
       * @param compact {Boolean?false} Show less verbose message. Default: false.
       */
      fail: function (msg, compact) {
        var msgvarargs = compact ? "" : "Called fail().";

        this.__P_67_1(msg || "", msgvarargs);
      },

      /**
       * Assert that the value is <code>true</code> (Identity check).
       *
       * @param value {Boolean} Condition to check for. Must be identical to
       *    <code>true</code>.
       * @param msg {String?} Message to be shown if the assertion fails.
       */
      assertTrue: function (value, msg) {
        value === true || this.__P_67_1(msg || "", "Called assertTrue with '", value, "'");
      },

      /**
       * Assert that the value is <code>false</code> (Identity check).
       *
       * @param value {Boolean} Condition to check for. Must be identical to
       *    <code>false</code>.
       * @param msg {String?} Message to be shown if the assertion fails.
       */
      assertFalse: function (value, msg) {
        value === false || this.__P_67_1(msg || "", "Called assertFalse with '", value, "'");
      },

      /**
       * Assert that both values are equal. (Uses the equality operator
       * <code>==</code>.)
       *
       * @param expected {var} Reference value
       * @param found {var} found value
       * @param msg {String?} Message to be shown if the assertion fails.
       */
      assertEquals: function (expected, found, msg) {
        expected == found || this.__P_67_1(msg || "", "Expected '", expected, "' but found '", found, "'!");
      },

      /**
       * Assert that both values are not equal. (Uses the not equality operator
       * <code>!=</code>.)
       *
       * @param expected {var} Reference value
       * @param found {var} found value
       * @param msg {String?} Message to be shown if the assertion fails.
       */
      assertNotEquals: function (expected, found, msg) {
        expected != found || this.__P_67_1(msg || "", "Expected '", expected, "' to be not equal with '", found, "'!");
      },

      /**
       * Assert that both float values are equal. This might be needed because
       * of the natural floating point inaccuracy of computers.
       *
       * @param expected {Float} Reference value
       * @param found {Float} Found value
       * @param msg {String?} Message to be shown if the assertion fails.
       */
      assertEqualsFloat: function (expected, found, msg) {
        this.assertNumber(expected);
        this.assertNumber(found);
        qx.lang.Number.equals(expected, found) || this.__P_67_1(msg || "", "Expected '", expected, "' to be equal with '", found, "'!");
      },

      /**
       * Assert that both float values are not equal. This might be needed
       * because of the natural floating point inaccuracy of computers.
       *
       * @param expected {Float} Reference value
       * @param found {Float} Found value
       * @param msg {String?} Message to be shown if the assertion fails.
       */
      assertNotEqualsFloat: function (expected, found, msg) {
        this.assertNumber(expected);
        this.assertNumber(found);
        !qx.lang.Number.equals(expected, found) || this.__P_67_1(msg || "", "Expected '", expected, "' to be not equal with '", found, "'!");
      },

      /**
       * Assert that both values are identical. (Uses the identity operator
       * <code>===</code>.)
       *
       * @param expected {var} Reference value
       * @param found {var} found value
       * @param msg {String?} Message to be shown if the assertion fails.
       */
      assertIdentical: function (expected, found, msg) {
        expected === found || this.__P_67_1(msg || "", "Expected '", expected, "' (identical) but found '", found, "'!");
      },

      /**
       * Assert that both values are not identical. (Uses the not identity operator
       * <code>!==</code>.)
       *
       * @param expected {var} Reference value
       * @param found {var} found value
       * @param msg {String?} Message to be shown if the assertion fails.
       */
      assertNotIdentical: function (expected, found, msg) {
        expected !== found || this.__P_67_1(msg || "", "Expected '", expected, "' to be not identical with '", found, "'!");
      },

      /**
       * Assert that the value is not <code>undefined</code>.
       *
       * @param value {var} Value to check
       * @param msg {String?} Message to be shown if the assertion fails.
       */
      assertNotUndefined: function (value, msg) {
        value !== undefined || this.__P_67_1(msg || "", "Expected value not to be undefined but found undefined!");
      },

      /**
       * Assert that the value is <code>undefined</code>.
       *
       * @param value {var} Value to check
       * @param msg {String?} Message to be shown if the assertion fails.
       */
      assertUndefined: function (value, msg) {
        value === undefined || this.__P_67_1(msg || "", "Expected value to be undefined but found ", value, "!");
      },

      /**
       * Assert that the value is not <code>null</code>.
       *
       * @param value {var} Value to check
       * @param msg {String?} Message to be shown if the assertion fails.
       */
      assertNotNull: function (value, msg) {
        value !== null || this.__P_67_1(msg || "", "Expected value not to be null but found null!");
      },

      /**
       * Assert that the value is <code>null</code>.
       *
       * @param value {var} Value to check
       * @param msg {String?} Message to be shown if the assertion fails.
       */
      assertNull: function (value, msg) {
        value === null || this.__P_67_1(msg || "", "Expected value to be null but found ", value, "!");
      },

      /**
       * Assert that the first two arguments are equal, when serialized into
       * JSON.
       *
       * @param expected {var} The the expected value
       * @param found {var} The found value
       * @param msg {String?} Message to be shown if the assertion fails.
       */
      assertJsonEquals: function (expected, found, msg) {
        this.assertEquals(qx.lang.Json.stringify(expected), qx.lang.Json.stringify(found), msg);
      },

      /**
       * Assert that the given string matches the regular expression
       *
       * @param str {String} String, which should match the regular expression
       * @param re {String|RegExp} Regular expression to match
       * @param msg {String?} Message to be shown if the assertion fails.
       */
      assertMatch: function (str, re, msg) {
        this.assertString(str);
        this.assert(qx.lang.Type.isRegExp(re) || qx.lang.Type.isString(re), "The parameter 're' must be a string or a regular expression.");
        str.search(re) >= 0 || this.__P_67_1(msg || "", "The String '", str, "' does not match the regular expression '", re.toString(), "'!");
      },

      /**
       * Assert that the number of arguments is within the given range
       *
       * @param args {arguments} The <code>arguments<code> variable of a function
       * @param minCount {Integer} Minimal number of arguments
       * @param maxCount {Integer} Maximum number of arguments
       * @param msg {String?} Message to be shown if the assertion fails.
       */
      assertArgumentsCount: function (args, minCount, maxCount, msg) {
        var argCount = args.length;
        argCount >= minCount && argCount <= maxCount || this.__P_67_1(msg || "", "Wrong number of arguments given. Expected '", minCount, "' to '", maxCount, "' arguments but found '", argCount, "' arguments.");
      },

      /**
       * Assert that an event is fired.
       *
       * @param obj {Object} The object on which the event should be fired.
       * @param event {String} The event which should be fired.
       * @param invokeFunc {Function} The function which will be invoked and which
       *   fires the event.
       * @param listenerFunc {Function?null} The function which will be invoked in the
       *   listener. The function receives one parameter which is the event.
       * @param msg {String?""} Message to be shows if the assertion fails.
       */
      assertEventFired: function (obj, event, invokeFunc, listenerFunc, msg) {
        var called = false;

        var listener = function (e) {
          if (listenerFunc) {
            listenerFunc.call(obj, e);
          }

          called = true;
        };

        var id;

        try {
          id = obj.addListener(event, listener, obj);
          invokeFunc.call(obj);
        } catch (ex) {
          throw ex;
        } finally {
          try {
            obj.removeListenerById(id);
          } catch (ex) {
            /* ignore */
          }
        }

        called === true || this.__P_67_1(msg || "", "Event (", event, ") not fired.");
      },

      /**
       * Assert that an event is not fired.
       *
       * @param obj {Object} The object on which the event should be fired.
       * @param event {String} The event which should be fired.
       * @param invokeFunc {Function} The function which will be invoked and which
       *   should not fire the event.
       * @param msg {String?} Message to be shows if the assertion fails.
       */
      assertEventNotFired: function (obj, event, invokeFunc, msg) {
        var called = false;

        var listener = function (e) {
          called = true;
        };

        var id = obj.addListener(event, listener, obj);
        invokeFunc.call();
        called === false || this.__P_67_1(msg || "", "Event (", event, ") was fired.");
        obj.removeListenerById(id);
      },

      /**
       * Asserts that the callback raises a matching exception.
       *
       * @param callback {Function} function to check
       * @param exception {Error?Error} Expected constructor of the exception.
       *   The assertion fails if the raised exception is not an instance of the
       *   parameter.
       * @param re {String|RegExp} The assertion fails if the error message does
       *   not match this parameter
       * @param msg {String?} Message to be shown if the assertion fails.
       */
      assertException: function (callback, exception, re, msg) {
        var exception = exception || Error;
        var error;

        try {
          this.__P_67_0 = false;
          callback();
        } catch (ex) {
          error = ex;
        } finally {
          this.__P_67_0 = true;
        }

        if (error == null) {
          this.__P_67_1(msg || "", "The function did not raise an exception!");
        }

        error instanceof exception || this.__P_67_1(msg || "", "The raised exception does not have the expected type! ", exception, " != ", error);

        if (re) {
          this.assertMatch(error.toString(), re, msg);
        }
      },

      /**
       * Assert that the value is an item in the given array.
       *
       * @param value {var} Value to check
       * @param array {Array} List of valid values
       * @param msg {String?} Message to be shown if the assertion fails.
       */
      assertInArray: function (value, array, msg) {
        array.indexOf(value) !== -1 || this.__P_67_1(msg || "", "The value '", value, "' must have any of the values defined in the array '", array, "'");
      },

      /**
       * Assert that the value is NOT an item in the given array
       *
       * @param value {var} Value to check
       * @param array {Array} List of values
       * @param msg {String?} Message to be shown if the assertion fails
       */
      assertNotInArray: function (value, array, msg) {
        array.indexOf(value) === -1 || this.__P_67_1(msg || "", qx.lang.String.format("The value '%1' must not have any of the values defined in the array '%2'", [value, array]));
      },

      /**
       * Assert that both array have identical array items.
       *
       * @param expected {Array} The expected array
       * @param found {Array} The found array
       * @param msg {String?} Message to be shown if the assertion fails.
       */
      assertArrayEquals: function (expected, found, msg) {
        this.assertArray(expected, msg);
        this.assertArray(found, msg);
        msg = msg || "Expected [" + expected.join(", ") + "], but found [" + found.join(", ") + "]";

        if (expected.length !== found.length) {
          this.fail(msg, true);
        }

        for (var i = 0; i < expected.length; i++) {
          if (expected[i] !== found[i]) {
            this.fail(msg, true);
          }
        }
      },

      /**
       * Assert that the value is a key in the given map.
       *
       * @param value {var} Value to check
       * @param map {Map} Map, where the keys represent the valid values
       * @param msg {String?} Message to be shown if the assertion fails.
       */
      assertKeyInMap: function (value, map, msg) {
        map[value] !== undefined || this.__P_67_1(msg || "", "The value '", value, "' must must be a key of the map '", map, "'");
      },

      /**
       * Assert that the value is a function.
       *
       * @param value {var} Value to check
       * @param msg {String?} Message to be shown if the assertion fails.
       */
      assertFunction: function (value, msg) {
        qx.lang.Type.isFunction(value) || this.__P_67_1(msg || "", "Expected value to be typeof function but found ", value, "!");
      },

      /**
       * Assert that the value is a function or an async function.
       *
       * @param value {var} Value to check
       * @param msg {String?} Message to be shown if the assertion fails.
       */
      assertFunctionOrAsyncFunction: function (value, msg) {
        qx.lang.Type.isFunctionOrAsyncFunction(value) || this.__P_67_1(msg || "", "Expected value to be typeof function or typeof async function but found ", value, "!");
      },

      /**
       * Assert that the value is a string.
       *
       * @param value {var} Value to check
       * @param msg {String?} Message to be shown if the assertion fails.
       */
      assertString: function (value, msg) {
        qx.lang.Type.isString(value) || this.__P_67_1(msg || "", "Expected value to be a string but found ", value, "!");
      },

      /**
       * Assert that the value is a boolean.
       *
       * @param value {var} Value to check
       * @param msg {String?} Message to be shown if the assertion fails.
       */
      assertBoolean: function (value, msg) {
        qx.lang.Type.isBoolean(value) || this.__P_67_1(msg || "", "Expected value to be a boolean but found ", value, "!");
      },

      /**
       * Assert that the value is a number.
       *
       * @param value {var} Value to check
       * @param msg {String?} Message to be shown if the assertion fails.
       */
      assertNumber: function (value, msg) {
        qx.lang.Type.isNumber(value) && isFinite(value) || this.__P_67_1(msg || "", "Expected value to be a number but found ", value, "!");
      },

      /**
       * Assert that the value is a number >= 0.
       *
       * @param value {var} Value to check
       * @param msg {String?} Message to be shown if the assertion fails.
       */
      assertPositiveNumber: function (value, msg) {
        qx.lang.Type.isNumber(value) && isFinite(value) && value >= 0 || this.__P_67_1(msg || "", "Expected value to be a number >= 0 but found ", value, "!");
      },

      /**
       * Assert that the value is an integer.
       *
       * @param value {var} Value to check
       * @param msg {String?} Message to be shown if the assertion fails.
       */
      assertInteger: function (value, msg) {
        qx.lang.Type.isNumber(value) && isFinite(value) && value % 1 === 0 || this.__P_67_1(msg || "", "Expected value to be an integer but found ", value, "!");
      },

      /**
       * Assert that the value is an integer >= 0.
       *
       * @param value {var} Value to check
       * @param msg {String?} Message to be shown if the assertion fails.
       */
      assertPositiveInteger: function (value, msg) {
        var condition = qx.lang.Type.isNumber(value) && isFinite(value) && value % 1 === 0 && value >= 0;
        condition || this.__P_67_1(msg || "", "Expected value to be an integer >= 0 but found ", value, "!");
      },

      /**
       * Assert that the value is inside the given range.
       *
       * @param value {var} Value to check
       * @param min {Number} lower bound
       * @param max {Number} upper bound
       * @param msg {String?} Message to be shown if the assertion fails.
       */
      assertInRange: function (value, min, max, msg) {
        value >= min && value <= max || this.__P_67_1(msg || "", qx.lang.String.format("Expected value '%1' to be in the range '%2'..'%3'!", [value, min, max]));
      },

      /**
       * Assert that the value is an object.
       *
       * @param value {var} Value to check
       * @param msg {String?} Message to be shown if the assertion fails.
       */
      assertObject: function (value, msg) {
        var condition = value !== null && (qx.lang.Type.isObject(value) || typeof value === "object");
        condition || this.__P_67_1(msg || "", "Expected value to be typeof object but found ", value, "!");
      },

      /**
       * Assert that the value is an array.
       *
       * @param value {var} Value to check
       * @param msg {String?} Message to be shown if the assertion fails.
       */
      assertArray: function (value, msg) {
        qx.lang.Type.isArray(value) || this.__P_67_1(msg || "", "Expected value to be an array but found ", value, "!");
      },

      /**
       * Assert that the value is a map either created using <code>new Object</code>
       * or by using the object literal notation <code>{ ... }</code>.
       *
       * @param value {var} Value to check
       * @param msg {String?} Message to be shown if the assertion fails.
       */
      assertMap: function (value, msg) {
        qx.lang.Type.isObject(value) || this.__P_67_1(msg || "", "Expected value to be a map but found ", value, "!");
      },

      /**
      * Assert that the value is a regular expression.
      *
      * @param value {var} Value to check
      * @param msg {String?} Message to be shown if the assertion fails.
      */
      assertRegExp: function (value, msg) {
        qx.lang.Type.isRegExp(value) || this.__P_67_1(msg || "", "Expected value to be a regular expression but found ", value, "!");
      },

      /**
       * Assert that the value has the given type using the <code>typeof</code>
       * operator. Because the type is not always what it is supposed to be it is
       * better to use more explicit checks like {@link #assertString} or
       * {@link #assertArray}.
       *
       * @param value {var} Value to check
       * @param type {String} expected type of the value
       * @param msg {String?} Message to be shown if the assertion fails.
       */
      assertType: function (value, type, msg) {
        this.assertString(type, "Invalid argument 'type'");
        typeof value === type || this.__P_67_1(msg || "", "Expected value to be typeof '", type, "' but found ", value, "!");
      },

      /**
       * Assert that the value is an instance of the given class.
       *
       * @param value {var} Value to check
       * @param clazz {Class} The value must be an instance of this class
       * @param msg {String?} Message to be shown if the assertion fails.
       */
      assertInstance: function (value, clazz, msg) {
        var className = clazz.classname || clazz + "";
        value instanceof clazz || this.__P_67_1(msg || "", "Expected value to be instanceof '", className, "' but found ", value, "!");
      },

      /**
       * Assert that the value implements the given interface.
       *
       * @param value {var} Value to check
       * @param iface {Class} The value must implement this interface
       * @param msg {String?} Message to be shown if the assertion fails.
       */
      assertInterface: function (value, iface, msg) {
        qx.Class && qx.Class.implementsInterface(value, iface) || this.__P_67_1(msg || "", "Expected object '", value, "' to implement the interface '", iface, "'!");
      },

      /**
       * Assert that the value represents the given CSS color value. This method
       * parses the color strings and compares the RGB values. It is able to
       * parse values supported by {@link qx.util.ColorUtil#stringToRgb}.
       *
       *  @param expected {String} The expected color
       *  @param value {String} The value to check
       *  @param msg {String?} Message to be shown if the assertion fails.
       */
      assertCssColor: function (expected, value, msg) {
        var ColorUtil = qx.Class ? qx.Class.getByName("qx.util.ColorUtil") : null;

        if (!ColorUtil) {
          throw new Error("qx.util.ColorUtil not available! Your code must have a dependency on 'qx.util.ColorUtil'");
        }

        var expectedRgb = ColorUtil.stringToRgb(expected);

        try {
          var valueRgb = ColorUtil.stringToRgb(value);
        } catch (ex) {
          this.__P_67_1(msg || "", "Expected value to be the CSS color '", expected, "' (rgb(", expectedRgb.join(","), ")), but found value '", value, "', which cannot be converted to a CSS color!");
        }

        var condition = expectedRgb[0] == valueRgb[0] && expectedRgb[1] == valueRgb[1] && expectedRgb[2] == valueRgb[2];
        condition || this.__P_67_1(msg || "", "Expected value to be the CSS color '", expectedRgb, "' (rgb(", expectedRgb.join(","), ")), but found value '", value, "' (rgb(", valueRgb.join(","), "))!");
      },

      /**
       * Assert that the value is a DOM element.
       *
       * @param value {var} Value to check
       * @param msg {String?} Message to be shown if the assertion fails.
       */
      assertElement: function (value, msg) {
        // see qx.dom.Node.isElement
        !!(value && value.nodeType === 1) || this.__P_67_1(msg || "", "Expected value to be a DOM element but found  '", value, "'!");
      },

      /**
       * Assert that the value is an instance of {@link qx.core.Object}.
       *
       * @param value {var} Value to check
       * @param msg {String?} Message to be shown if the assertion fails.
       */
      assertQxObject: function (value, msg) {
        this.__P_67_3(value, "qx.core.Object") || this.__P_67_1(msg || "", "Expected value to be a qooxdoo object but found ", value, "!");
      },

      /**
       * Assert that the value is an instance of {@link qx.ui.core.Widget}.
       *
       * @param value {var} Value to check
       * @param msg {String?} Message to be shown if the assertion fails.
       */
      assertQxWidget: function (value, msg) {
        this.__P_67_3(value, "qx.ui.core.Widget") || this.__P_67_1(msg || "", "Expected value to be a qooxdoo widget but found ", value, "!");
      },

      /**
       * Internal helper for checking the instance of a qooxdoo object using the
       * classname.
       *
       * @param object {var} The object to check.
       * @param classname {String} The classname of the class as string.
       * @return {Boolean} <code>true</code> if the object is an instance of the
       * class
       */
      __P_67_3: function (object, classname) {
        if (!object) {
          return false;
        }

        var clazz = object.constructor;

        while (clazz) {
          if (clazz.classname === classname) {
            return true;
          }

          clazz = clazz.superclass;
        }

        return false;
      }
    }
  });
  qx.core.Assert.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Assert": {
        "require": true
      },
      "qx.Mixin": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * This mixin includes all assertions from {@link qx.core.Assert} to conveniently
   * call assertions. It is included into {@link qx.core.Object} if debugging code
   * is enabled. It is further included into all unit tests
   * {@link qx.dev.unit.TestCase}.
   *
   * @require(qx.core.Assert)
   */
  qx.Mixin.define("qx.core.MAssert", {
    members: {
      /**
       * Assert that the condition evaluates to <code>true</code>.
       *
       * @param condition {var} Condition to check for. Must evaluate to
       *    <code>true</code>.
       * @param msg {String?} Message to be shown if the assertion fails.
       */
      assert: function (condition, msg) {
        qx.core.Assert.assert(condition, msg);
      },

      /**
       * Raise an {@link AssertionError}
       *
       * @param msg {String} Message to be shown if the assertion fails.
       * @param compact {Boolean?false} Show less verbose message. Default: false.
       */
      fail: function (msg, compact) {
        qx.core.Assert.fail(msg, compact);
      },

      /**
       * Assert that the value is <code>true</code> (Identity check).
       *
       * @param value {Boolean} Condition to check for. Must be identical to
       *    <code>true</code>.
       * @param msg {String?} Message to be shown if the assertion fails.
       */
      assertTrue: function (value, msg) {
        qx.core.Assert.assertTrue(value, msg);
      },

      /**
       * Assert that the value is <code>false</code> (Identity check).
       *
       * @param value {Boolean} Condition to check for. Must be identical to
       *    <code>false</code>.
       * @param msg {String?} Message to be shown if the assertion fails.
       */
      assertFalse: function (value, msg) {
        qx.core.Assert.assertFalse(value, msg);
      },

      /**
       * Assert that both values are equal. (Uses the equality operator
       * <code>==</code>.)
       *
       * @param expected {var} Reference value
       * @param found {var} found value
       * @param msg {String?} Message to be shown if the assertion fails.
       */
      assertEquals: function (expected, found, msg) {
        qx.core.Assert.assertEquals(expected, found, msg);
      },

      /**
       * Assert that both values are not equal. (Uses the not equality operator
       * <code>!=</code>.)
       *
       * @param expected {var} Reference value
       * @param found {var} found value
       * @param msg {String?} Message to be shown if the assertion fails.
       */
      assertNotEquals: function (expected, found, msg) {
        qx.core.Assert.assertNotEquals(expected, found, msg);
      },

      /**
       * Assert that both float values are equal. This might be needed because
       * of the natural floating point inaccuracy of computers.
       *
       * @param expected {Float} Reference value
       * @param found {Float} Found value
       * @param msg {String?} Message to be shown if the assertion fails.
       */
      assertEqualsFloat: function (expected, found, msg) {
        qx.core.Assert.assertEqualsFloat(expected, found, msg);
      },

      /**
       * Assert that both float values are not equal. This might be needed
       * because of the natural floating point inaccuracy of computers.
       *
       * @param expected {Float} Reference value
       * @param found {Float} Found value
       * @param msg {String?} Message to be shown if the assertion fails.
       */
      assertNotEqualsFloat: function (expected, found, msg) {
        qx.core.Assert.assertNotEqualsFloat(expected, found, msg);
      },

      /**
       * Assert that both values are identical. (Uses the identity operator
       * <code>===</code>.)
       *
       * @param expected {var} Reference value
       * @param found {var} found value
       * @param msg {String?} Message to be shown if the assertion fails.
       */
      assertIdentical: function (expected, found, msg) {
        qx.core.Assert.assertIdentical(expected, found, msg);
      },

      /**
       * Assert that both values are not identical. (Uses the not identity operator
       * <code>!==</code>.)
       *
       * @param expected {var} Reference value
       * @param found {var} found value
       * @param msg {String?} Message to be shown if the assertion fails.
       */
      assertNotIdentical: function (expected, found, msg) {
        qx.core.Assert.assertNotIdentical(expected, found, msg);
      },

      /**
       * Assert that the value is not <code>undefined</code>.
       *
       * @param value {var} Value to check
       * @param msg {String?} Message to be shown if the assertion fails.
       */
      assertNotUndefined: function (value, msg) {
        qx.core.Assert.assertNotUndefined(value, msg);
      },

      /**
       * Assert that the value is <code>undefined</code>.
       *
       * @param value {var} Value to check
       * @param msg {String?} Message to be shown if the assertion fails.
       */
      assertUndefined: function (value, msg) {
        qx.core.Assert.assertUndefined(value, msg);
      },

      /**
       * Assert that the value is not <code>null</code>.
       *
       * @param value {var} Value to check
       * @param msg {String?} Message to be shown if the assertion fails.
       */
      assertNotNull: function (value, msg) {
        qx.core.Assert.assertNotNull(value, msg);
      },

      /**
       * Assert that the value is <code>null</code>.
       *
       * @param value {var} Value to check
       * @param msg {String?} Message to be shown if the assertion fails.
       */
      assertNull: function (value, msg) {
        qx.core.Assert.assertNull(value, msg);
      },

      /**
       * Assert that the first two arguments are equal, when serialized into
       * JSON.
       *
       * @param expected {var} The expected value
       * @param found {var} The found value
       * @param msg {String?} Message to be shown if the assertion fails.
       */
      assertJsonEquals: function (expected, found, msg) {
        qx.core.Assert.assertJsonEquals(expected, found, msg);
      },

      /**
       * Assert that the given string matches the regular expression
       *
       * @param str {String} String, which should match the regular expression
       * @param re {RegExp} Regular expression to match
       * @param msg {String?} Message to be shown if the assertion fails.
       */
      assertMatch: function (str, re, msg) {
        qx.core.Assert.assertMatch(str, re, msg);
      },

      /**
       * Assert that the number of arguments is within the given range
       *
       * @param args {arguments} The <code>arguments<code> variable of a function
       * @param minCount {Integer} Minimal number of arguments
       * @param maxCount {Integer} Maximum number of arguments
       * @param msg {String?} Message to be shown if the assertion fails.
       */
      assertArgumentsCount: function (args, minCount, maxCount, msg) {
        qx.core.Assert.assertArgumentsCount(args, minCount, maxCount, msg);
      },

      /**
       * Assert that an event is fired.
       *
       * @param obj {Object} The object on which the event should be fired.
       * @param event {String} The event which should be fired.
       * @param invokeFunc {Function} The function which will be invoked and which
       *   fires the event.
       * @param listener {Function?null} The function which will be invoked in the
       *   listener. The function has one parameter called e which is the event.
       * @param msg {String?""} Message to be shows if the assertion fails.
       */
      assertEventFired: function (obj, event, invokeFunc, listener, msg) {
        qx.core.Assert.assertEventFired(obj, event, invokeFunc, listener, msg);
      },

      /**
       * Assert that an event is not fired.
       *
       * @param obj {Object} The object on which the event should be fired.
       * @param event {String} The event which should be fired.
       * @param invokeFunc {Function} The function which will be invoked and which
       *   should not fire the event.
       * @param msg {String?} Message to be shows if the assertion fails.
       */
      assertEventNotFired: function (obj, event, invokeFunc, msg) {
        qx.core.Assert.assertEventNotFired(obj, event, invokeFunc, msg);
      },

      /**
       * Asserts that the callback raises a matching exception.
       *
       * @param callback {Function} function to check
       * @param exception {Error?Error} Expected constructor of the exception.
       *   The assertion fails if the raised exception is not an instance of the
       *   parameter.
       * @param re {String|RegExp} The assertion fails if the error message does
       *   not match this parameter
       * @param msg {String?} Message to be shown if the assertion fails.
       */
      assertException: function (callback, exception, re, msg) {
        qx.core.Assert.assertException(callback, exception, re, msg);
      },

      /**
       * Assert that the value is an item in the given array.
       *
       * @param value {var} Value to check
       * @param array {Array} List of valid values
       * @param msg {String?} Message to be shown if the assertion fails.
       */
      assertInArray: function (value, array, msg) {
        qx.core.Assert.assertInArray(value, array, msg);
      },

      /**
       * Assert that the value is NOT an item in the given array
       *
       * @param value {var} Value to check
       * @param array {Array} List of values
       * @param msg {String?} Message to be shown if the assertion fails
       */
      assertNotInArray: function (value, array, msg) {
        qx.core.Assert.assertNotInArray(value, array, msg);
      },

      /**
       * Assert that both array have identical array items.
       *
       * @param expected {Array} The expected array
       * @param found {Array} The found array
       * @param msg {String?} Message to be shown if the assertion fails.
       */
      assertArrayEquals: function (expected, found, msg) {
        qx.core.Assert.assertArrayEquals(expected, found, msg);
      },

      /**
       * Assert that the value is a key in the given map.
       *
       * @param value {var} Value to check
       * @param map {Map} Map, where the keys represent the valid values
       * @param msg {String?} Message to be shown if the assertion fails.
       */
      assertKeyInMap: function (value, map, msg) {
        qx.core.Assert.assertKeyInMap(value, map, msg);
      },

      /**
       * Assert that the value is a function.
       *
       * @param value {var} Value to check
       * @param msg {String?} Message to be shown if the assertion fails.
       */
      assertFunction: function (value, msg) {
        qx.core.Assert.assertFunction(value, msg);
      },

      /**
       * Assert that the value is a string.
       *
       * @param value {var} Value to check
       * @param msg {String?} Message to be shown if the assertion fails.
       */
      assertString: function (value, msg) {
        qx.core.Assert.assertString(value, msg);
      },

      /**
       * Assert that the value is a boolean.
       *
       * @param value {var} Value to check
       * @param msg {String?} Message to be shown if the assertion fails.
       */
      assertBoolean: function (value, msg) {
        qx.core.Assert.assertBoolean(value, msg);
      },

      /**
       * Assert that the value is a number.
       *
       * @param value {var} Value to check
       * @param msg {String?} Message to be shown if the assertion fails.
       */
      assertNumber: function (value, msg) {
        qx.core.Assert.assertNumber(value, msg);
      },

      /**
       * Assert that the value is a number >= 0.
       *
       * @param value {var} Value to check
       * @param msg {String?} Message to be shown if the assertion fails.
       */
      assertPositiveNumber: function (value, msg) {
        qx.core.Assert.assertPositiveNumber(value, msg);
      },

      /**
       * Assert that the value is an integer.
       *
       * @param value {var} Value to check
       * @param msg {String?} Message to be shown if the assertion fails.
       */
      assertInteger: function (value, msg) {
        qx.core.Assert.assertInteger(value, msg);
      },

      /**
       * Assert that the value is an integer >= 0.
       *
       * @param value {var} Value to check
       * @param msg {String?} Message to be shown if the assertion fails.
       */
      assertPositiveInteger: function (value, msg) {
        qx.core.Assert.assertPositiveInteger(value, msg);
      },

      /**
       * Assert that the value is inside the given range.
       *
       * @param value {var} Value to check
       * @param min {Number} lower bound
       * @param max {Number} upper bound
       * @param msg {String?} Message to be shown if the assertion fails.
       */
      assertInRange: function (value, min, max, msg) {
        qx.core.Assert.assertInRange(value, min, max, msg);
      },

      /**
       * Assert that the value is an object.
       *
       * @param value {var} Value to check
       * @param msg {String?} Message to be shown if the assertion fails.
       */
      assertObject: function (value, msg) {
        qx.core.Assert.assertObject(value, msg);
      },

      /**
       * Assert that the value is an array.
       *
       * @param value {var} Value to check
       * @param msg {String?} Message to be shown if the assertion fails.
       */
      assertArray: function (value, msg) {
        qx.core.Assert.assertArray(value, msg);
      },

      /**
       * Assert that the value is a map either created using <code>new Object</code>
       * or by using the object literal notation <code>{ ... }</code>.
       *
       * @param value {var} Value to check
       * @param msg {String?} Message to be shown if the assertion fails.
       */
      assertMap: function (value, msg) {
        qx.core.Assert.assertMap(value, msg);
      },

      /**
       * Assert that the value is a regular expression.
       *
       * @param value {var} Value to check
       * @param msg {String?} Message to be shown if the assertion fails.
       */
      assertRegExp: function (value, msg) {
        qx.core.Assert.assertRegExp(value, msg);
      },

      /**
       * Assert that the value has the given type using the <code>typeof</code>
       * operator. Because the type is not always what it is supposed to be it is
       * better to use more explicit checks like {@link #assertString} or
       * {@link #assertArray}.
       *
       * @param value {var} Value to check
       * @param type {String} expected type of the value
       * @param msg {String?} Message to be shown if the assertion fails.
       */
      assertType: function (value, type, msg) {
        qx.core.Assert.assertType(value, type, msg);
      },

      /**
       * Assert that the value is an instance of the given class.
       *
       * @param value {var} Value to check
       * @param clazz {Class} The value must be an instance of this class
       * @param msg {String?} Message to be shown if the assertion fails.
       */
      assertInstance: function (value, clazz, msg) {
        qx.core.Assert.assertInstance(value, clazz, msg);
      },

      /**
       * Assert that the value implements the given interface.
       *
       * @param value {var} Value to check
       * @param iface {Class} The value must implement this interface
       * @param msg {String?} Message to be shown if the assertion fails.
       */
      assertInterface: function (value, iface, msg) {
        qx.core.Assert.assertInterface(value, iface, msg);
      },

      /**
       * Assert that the value represents the given CSS color value. This method
       * parses the color strings and compares the RGB values. It is able to
       * parse values supported by {@link qx.util.ColorUtil#stringToRgb}.
       *
       *  @param expected {String} The expected color
       *  @param value {String} The value to check
       *  @param msg {String?} Message to be shown if the assertion fails.
       */
      assertCssColor: function (expected, value, msg) {
        qx.core.Assert.assertCssColor(expected, value, msg);
      },

      /**
       * Assert that the value is a DOM element.
       *
       * @param value {var} Value to check
       * @param msg {String?} Message to be shown if the assertion fails.
       */
      assertElement: function (value, msg) {
        qx.core.Assert.assertElement(value, msg);
      },

      /**
       * Assert that the value is an instance of {@link qx.core.Object}.
       *
       * @param value {var} Value to check
       * @param msg {String?} Message to be shown if the assertion fails.
       */
      assertQxObject: function (value, msg) {
        qx.core.Assert.assertQxObject(value, msg);
      },

      /**
       * Assert that the value is an instance of {@link qx.ui.core.Widget}.
       *
       * @param value {var} Value to check
       * @param msg {String?} Message to be shown if the assertion fails.
       */
      assertQxWidget: function (value, msg) {
        qx.core.Assert.assertQxWidget(value, msg);
      }
    }
  });
  qx.core.MAssert.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.ObjectRegistry": {
        "require": true
      },
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.data.MBinding": {
        "require": true
      },
      "qx.core.MLogging": {
        "require": true
      },
      "qx.core.MEvent": {
        "require": true
      },
      "qx.core.MProperty": {
        "require": true
      },
      "qx.core.MObjectId": {
        "require": true
      },
      "qx.core.MAssert": {
        "require": true
      },
      "qx.core.Property": {
        "require": true
      },
      "qx.core.IDisposable": {},
      "qx.util.Uuid": {},
      "qx.util.DisposeUtil": {},
      "qx.event.Registration": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * The qooxdoo root class. All other classes are direct or indirect subclasses of this one.
   *
   * This class contains methods for:
   *
   * * object management (creation and destruction)
   * * interfaces for event system
   * * generic setter/getter support
   * * interfaces for logging console
   * * user friendly OO interfaces like {@link #self} or {@link #base}
   *
   * @require(qx.core.ObjectRegistry)
   */
  qx.Class.define("qx.core.Object", {
    extend: Object,
    include: qx.core.Environment.filter({
      "module.databinding": qx.data.MBinding,
      "module.logger": qx.core.MLogging,
      "module.events": qx.core.MEvent,
      "module.property": qx.core.MProperty,
      "module.objectid": qx.core.MObjectId,
      "qx.debug": qx.core.MAssert
    }),

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * Create a new instance
     */
    construct: function () {},

    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics: {
      /** Internal type */
      $$type: "Object"
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __P_62_0: true ? qx.core.Property : null,

      /*
      ---------------------------------------------------------------------------
        BASICS
      ---------------------------------------------------------------------------
      */

      /**
       * Return unique hash code of object
       *
       * @return {String} unique hash code of the object
       */
      toHashCode: function () {
        if (!this.$$hash && !this.$$disposed) {
          if (false || qx.Class.hasInterface(this.constructor, qx.core.IDisposable)) {
            qx.core.ObjectRegistry.register(this);
          } else {
            qx.core.ObjectRegistry.toHashCode(this);
          }
        }

        return this.$$hash;
      },

      /**
       * Returns a UUID for this object
       * 
       * @return {String} a UUID
       */
      toUuid: function () {
        if (!this.$$uuid) {
          this.$$uuid = qx.util.Uuid.createUuidV4();
        }

        return this.$$uuid;
      },

      /**
       * Sets a UUID; normally set automatically, you would only set this manually
       * if you have a very special reason to do so - for example, you are using UUIDs which are
       * synchronized from a special source, eg remote server.
       * 
       * This can only be called once, and only if it has not been automatically allocated.  If
       * you really do need to call this, call it as soon after construction as possible to avoid
       * an exception.  
       * 
       * @param uuid {String} an ID which is unique across the whole application
       */
      setExplicitUuid: function (uuid) {
        if (Boolean(this.$$uuid)) {
          throw new Error("Cannot change the UUID of an object once set");
        }

        this.$$uuid = uuid;
      },

      /**
       * Returns a string representation of the qooxdoo object.
       *
       * @return {String} string representation of the object
       */
      toString: function () {
        return this.classname + "[" + this.toHashCode() + "]";
      },

      /**
       * Call the same method of the super class.
       *
       * @param args {IArguments} the arguments variable of the calling method
       * @param varargs {var?} variable number of arguments passed to the overwritten function
       * @return {var} the return value of the method of the base class.
       */
      base: function (args, varargs) {
        if (arguments.length === 1) {
          return args.callee.base.call(this);
        } else {
          return args.callee.base.apply(this, Array.prototype.slice.call(arguments, 1));
        }
      },

      /**
       * Returns the static class (to access static members of this class)
       *
       * @param args {arguments} the arguments variable of the calling method
       * @return {var} the return value of the method of the base class.
       */
      self: function (args) {
        return args.callee.self;
      },

      /*
      ---------------------------------------------------------------------------
        CLONE SUPPORT
      ---------------------------------------------------------------------------
      */

      /**
       *
       * Returns a clone of this object. Copies over all user configured
       * property values. Do not configure a parent nor apply the appearance
       * styles directly.
       *
       * @return {qx.core.Object} The clone
       */
      clone: function () {
        var clazz = this.constructor;
        var clone = new clazz();
        var props = qx.Class.getProperties(clazz);
        var user = this.__P_62_0.$$store.user;
        var setter = this.__P_62_0.$$method.set;
        var name; // Iterate through properties

        for (var i = 0, l = props.length; i < l; i++) {
          name = props[i];

          if (this.hasOwnProperty(user[name])) {
            clone[setter[name]](this[user[name]]);
          }
        } // Return clone


        return clone;
      },

      /*
      ---------------------------------------------------------------------------
        USER DATA
      ---------------------------------------------------------------------------
      */

      /** @type {Map} stored user data */
      __P_62_1: null,

      /**
       * Store user defined data inside the object.
       *
       * @param key {String} the key
       * @param value {Object} the value of the user data
       */
      setUserData: function (key, value) {
        if (!this.__P_62_1) {
          this.__P_62_1 = {};
        }

        this.__P_62_1[key] = value;
      },

      /**
       * Load user defined data from the object
       *
       * @param key {String} the key
       * @return {Object} the user data
       */
      getUserData: function (key) {
        if (!this.__P_62_1) {
          return null;
        }

        var data = this.__P_62_1[key];
        return data === undefined ? null : data;
      },

      /**
       * Clears all user defined data from the object.
       */
      resetUserData: function () {
        this.__P_62_1 = null;
      },

      /*
      ---------------------------------------------------------------------------
        DISPOSER
      ---------------------------------------------------------------------------
      */

      /**
       * Returns true if the object is disposed.
       *
       * @return {Boolean} Whether the object has been disposed
       */
      isDisposed: function () {
        return this.$$disposed || false;
      },

      /**
       * Returns true if the object is being disposed, ie this.dispose() has started but 
       * not finished
       *
       * @return {Boolean} Whether the object is being disposed
       */
      isDisposing: function () {
        return this.$$disposing || false;
      },

      /**
       * Dispose this object
       *
       */
      dispose: function () {
        // Check first
        if (this.$$disposed) {
          return;
        } // Mark as disposed (directly, not at end, to omit recursions)


        this.$$disposed = true;
        this.$$disposing = true;
        this.$$instance = null;
        this.$$allowconstruct = null; // Debug output

        // Deconstructor support for classes
        var clazz = this.constructor;
        var mixins;

        while (clazz.superclass) {
          // Processing this class...
          if (clazz.$$destructor) {
            clazz.$$destructor.call(this);
          } // Destructor support for mixins


          if (clazz.$$includes) {
            mixins = clazz.$$flatIncludes;

            for (var i = 0, l = mixins.length; i < l; i++) {
              if (mixins[i].$$destructor) {
                mixins[i].$$destructor.call(this);
              }
            }
          } // Jump up to next super class


          clazz = clazz.superclass;
        }

        this.$$disposing = false; // Additional checks
      },

      /*
      ---------------------------------------------------------------------------
        DISPOSER UTILITIES
      ---------------------------------------------------------------------------
      */

      /**
       * Disconnects and disposes given objects from instance.
       * Only works with qx.core.Object based objects e.g. Widgets.
       *
       * @param varargs {arguments} Names of fields (which store objects) to dispose
       */
      _disposeObjects: function (varargs) {
        qx.util.DisposeUtil.disposeObjects(this, arguments);
      },

      /**
       * Disconnects and disposes given singleton objects from instance.
       * Only works with qx.core.Object based objects e.g. Widgets.
       *
       * @param varargs {arguments} Names of fields (which store objects) to dispose
       */
      _disposeSingletonObjects: function (varargs) {
        qx.util.DisposeUtil.disposeObjects(this, arguments, true);
      },

      /**
       * Disposes all members of the given array and deletes
       * the field which refers to the array afterwards.
       *
       * @param field {String} Name of the field which refers to the array
       */
      _disposeArray: function (field) {
        qx.util.DisposeUtil.disposeArray(this, field);
      },

      /**
       * Disposes all members of the given map and deletes
       * the field which refers to the map afterwards.
       *
       * @param field {String} Name of the field which refers to the map
       */
      _disposeMap: function (field) {
        qx.util.DisposeUtil.disposeMap(this, field);
      }
    },

    /*
    *****************************************************************************
       ENVIRONMENT SETTINGS
    *****************************************************************************
    */
    environment: {
      "qx.debug.dispose.level": 0
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function () {
      {
        if (!qx.core.ObjectRegistry.inShutDown) {
          // Cleanup event listeners
          qx.event.Registration.removeAllListeners(this);
        } else {
          // on shutdown, just clear the internal listener map
          qx.event.Registration.deleteAllListeners(this);
        }
      } // Cleanup object registry

      qx.core.ObjectRegistry.unregister(this); // Cleanup user data

      this.__P_62_1 = null; // only of properties are available

      {
        // Cleanup properties
        var clazz = this.constructor;
        var properties;
        var store = this.__P_62_0.$$store;
        var storeUser = store.user;
        var storeTheme = store.theme;
        var storeInherit = store.inherit;
        var storeUseinit = store.useinit;
        var storeInit = store.init;

        while (clazz) {
          properties = clazz.$$properties;

          if (properties) {
            for (var name in properties) {
              if (properties[name].dereference) {
                this[storeUser[name]] = this[storeTheme[name]] = this[storeInherit[name]] = this[storeUseinit[name]] = this[storeInit[name]] = undefined;
              }
            }
          }

          clazz = clazz.superclass;
        }
      }
    }
  });
  qx.core.Object.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Interface": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * This interface defines a data structure compatible with the data binding
   * controllers.
   * It defines a minimum of functionality which the controller need to work.
   */
  qx.Interface.define("qx.data.IListData", {
    events: {
      /**
       * The change event which will be fired if there is a change in the data structure.
       * The data contains a map with three key value pairs:
       * <li>start: The start index of the change.</li>
       * <li>end: The end index of the change.</li>
       * <li>type: The type of the change as a String. This can be 'add',
       * 'remove', 'order' or 'add/remove'</li>
       * <li>added: The items which has been added (as a JavaScript array)</li>
       * <li>removed: The items which has been removed (as a JavaScript array)</li>
       */
      "change": "qx.event.type.Data",

      /**
       * The changeLength event will be fired every time the length of the
       * data structure changes.
       */
      "changeLength": "qx.event.type.Event"
    },
    members: {
      /**
       * Returns the item at the given index
       *
       * @param index {Number} The index requested of the data element.
       *
       * @return {var} The element at the given index.
       */
      getItem: function (index) {},

      /**
       * Sets the given item at the given position in the data structure. A
       * change event has to be fired.
       *
       * @param index {Number} The index of the data element.
       * @param item {var} The new item to set.
       */
      setItem: function (index, item) {},

      /**
       * Method to remove and add new element to the data. For every remove or
       * add a change event should be fired.
       *
       * @param startIndex {Integer} The index where the splice should start
       * @param amount {Integer} Defines number of element which will be removed
       *   at the given position.
       * @param varargs {var} All following parameters will be added at the given
       *   position to the array.
       * @return {qx.data.Array} An array containing the removed elements.
       */
      splice: function (startIndex, amount, varargs) {},

      /**
       * Check if the given item is in the current data structure.
       *
       * @param item {var} The item which is possibly in the data structure.
       * @return {Boolean} true, if the array contains the given item.
       */
      contains: function (item) {},

      /**
       * Returns the current length of the data structure.
       *
       * @return {Number} The current length of the data structure.
       */
      getLength: function () {},

      /**
       * Returns the list data as native array.
       *
       * @return {Array} The native array.
       */
      toArray: function () {}
    }
  });
  qx.data.IListData.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.event.Registration": {},
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "require": true
      },
      "qx.event.Pool": {},
      "qx.Promise": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * Basic event object.
   *
   * Please note:
   * Event objects are only valid during the event dispatch. After the dispatch
   * event objects are pooled or disposed. If you want to safe a reference to an
   * event instance use the {@link #clone} method.
   *
   * The interface is modeled after the DOM level 2 event interface:
   * http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-interface
   *
   * @use(qx.event.Registration)
   */
  qx.Class.define("qx.event.type.Event", {
    extend: qx.core.Object,

    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics: {
      /** The current event phase is the capturing phase. */
      CAPTURING_PHASE: 1,

      /** The event is currently being evaluated at the target */
      AT_TARGET: 2,

      /** The current event phase is the bubbling phase. */
      BUBBLING_PHASE: 3
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /** {qx.Promise[]} promises returned by event handlers */
      _promises: null,

      /**
       * Initialize the fields of the event. The event must be initialized before
       * it can be dispatched.
       *
       * @param canBubble {Boolean?false} Whether or not the event is a bubbling event.
       *     If the event is bubbling, the bubbling can be stopped using
       *     {@link #stopPropagation}
       * @param cancelable {Boolean?false} Whether or not an event can have its default
       *     action prevented. The default action can either be the browser's
       *     default action of a native event (e.g. open the context menu on a
       *     right click) or the default action of a qooxdoo class (e.g. close
       *     the window widget). The default action can be prevented by calling
       *     {@link #preventDefault}
       * @return {qx.event.type.Event} The initialized event instance
       */
      init: function (canBubble, cancelable) {
        this._type = null;
        this._target = null;
        this._currentTarget = null;
        this._relatedTarget = null;
        this._originalTarget = null;
        this._stopPropagation = false;
        this._preventDefault = false;
        this._bubbles = !!canBubble;
        this._cancelable = !!cancelable;
        this._timeStamp = new Date().getTime();
        this._eventPhase = null;
        this._promises = null;
        return this;
      },

      /**
       * Create a clone of the event object, which is not automatically disposed
       * or pooled after an event dispatch.
       *
       * @param embryo {qx.event.type.Event?null} Optional event class, which will
       *     be configured using the data of this event instance. The event must be
       *     an instance of this event class. If the value is <code>null</code>,
       *     a new pooled instance is created.
       * @return {qx.event.type.Event} a clone of this class.
       */
      clone: function (embryo) {
        if (embryo) {
          var clone = embryo;
        } else {
          var clone = qx.event.Pool.getInstance().getObject(this.constructor);
        }

        clone._type = this._type;
        clone._target = this._target;
        clone._currentTarget = this._currentTarget;
        clone._relatedTarget = this._relatedTarget;
        clone._originalTarget = this._originalTarget;
        clone._stopPropagation = this._stopPropagation;
        clone._bubbles = this._bubbles;
        clone._preventDefault = this._preventDefault;
        clone._cancelable = this._cancelable;
        clone._promises = this._promises;
        return clone;
      },

      /**
       * Stops event from all further processing. Execute this when the
       * current handler should have "exclusive rights" to the event
       * and no further reaction by anyone else should happen.
       */
      stop: function () {
        if (this._bubbles) {
          this.stopPropagation();
        }

        if (this._cancelable) {
          this.preventDefault();
        }
      },

      /**
       * This method is used to prevent further propagation of an event during event
       * flow. If this method is called by any event listener the event will cease
       * propagating through the tree. The event will complete dispatch to all listeners
       * on the current event target before event flow stops.
       *
       */
      stopPropagation: function () {
        this._stopPropagation = true;
      },

      /**
       * Get whether further event propagation has been stopped.
       *
       * @return {Boolean} Whether further propagation has been stopped.
       */
      getPropagationStopped: function () {
        return !!this._stopPropagation;
      },

      /**
       * Prevent the default action of cancelable events, e.g. opening the context
       * menu, ...
       *
       */
      preventDefault: function () {
        this._preventDefault = true;
      },

      /**
       * Adds a promise to the list of promises returned by event handlers
       * @param promise {qx.Promise} the promise to add
       */
      addPromise: function (promise) {
        if (this._promises === null) {
          this._promises = [promise];
        } else {
          this._promises.push(promise);
        }
      },

      /**
       * Returns the array of promises, or null if there are no promises
       * @return {qx.Promise[]?}
       */
      getPromises: function () {
        return this._promises;
      },

      /**
       * Returns a promise for this event; if the event is defaultPrevented, the promise
       * is a rejected promise, otherwise it is fulfilled.  The promise returned will only
       * be fulfilled when the promises added via {@link addPromise} are also fulfilled
       */
      promise: function () {
        if (this.getDefaultPrevented()) {
          return qx.Promise.reject();
        }

        if (this._promises === null) {
          return qx.Promise.resolve(true);
        }

        return qx.Promise.all(this._promises);
      },

      /**
       * Get whether the default action has been prevented
       *
       * @return {Boolean} Whether the default action has been prevented
       */
      getDefaultPrevented: function () {
        return !!this._preventDefault;
      },

      /**
       * The name of the event
       *
       * @return {String} name of the event
       */
      getType: function () {
        return this._type;
      },

      /**
       * Override the event type
       *
       * @param type {String} new event type
       */
      setType: function (type) {
        this._type = type;
      },

      /**
       * Used to indicate which phase of event flow is currently being evaluated.
       *
       * @return {Integer} The current event phase. Possible values are
       *         {@link #CAPTURING_PHASE}, {@link #AT_TARGET} and {@link #BUBBLING_PHASE}.
       */
      getEventPhase: function () {
        return this._eventPhase;
      },

      /**
       * Override the event phase
       *
       * @param eventPhase {Integer} new event phase
       */
      setEventPhase: function (eventPhase) {
        this._eventPhase = eventPhase;
      },

      /**
       * The time (in milliseconds relative to the epoch) at which the event was created.
       *
       * @return {Integer} the timestamp the event was created.
       */
      getTimeStamp: function () {
        return this._timeStamp;
      },

      /**
       * Returns the event target to which the event was originally
       * dispatched.
       *
       * @return {Element} target to which the event was originally
       *       dispatched.
       */
      getTarget: function () {
        return this._target;
      },

      /**
       * Override event target.
       *
       * @param target {Element} new event target
       */
      setTarget: function (target) {
        this._target = target;
      },

      /**
       * Get the event target node whose event listeners are currently being
       * processed. This is particularly useful during event capturing and
       * bubbling.
       *
       * @return {Element} The target the event listener is currently
       *       dispatched on.
       */
      getCurrentTarget: function () {
        return this._currentTarget || this._target;
      },

      /**
       * Override current target.
       *
       * @param currentTarget {Element} new current target
       */
      setCurrentTarget: function (currentTarget) {
        this._currentTarget = currentTarget;
      },

      /**
       * Get the related event target. This is only configured for
       * events which also had an influences on another element e.g.
       * mouseover/mouseout, focus/blur, ...
       *
       * @return {Element} The related target
       */
      getRelatedTarget: function () {
        return this._relatedTarget;
      },

      /**
       * Override related target.
       *
       * @param relatedTarget {Element} new related target
       */
      setRelatedTarget: function (relatedTarget) {
        this._relatedTarget = relatedTarget;
      },

      /**
       * Get the original event target. This is only configured
       * for events which are fired by another event (often when
       * the target should be reconfigured for another view) e.g.
       * low-level DOM event to widget event.
       *
       * @return {Element} The original target
       */
      getOriginalTarget: function () {
        return this._originalTarget;
      },

      /**
       * Override original target.
       *
       * @param originalTarget {Element} new original target
       */
      setOriginalTarget: function (originalTarget) {
        this._originalTarget = originalTarget;
      },

      /**
       * Check whether or not the event is a bubbling event. If the event can
       * bubble the value is true, else the value is false.
       *
       * @return {Boolean} Whether the event bubbles
       */
      getBubbles: function () {
        return this._bubbles;
      },

      /**
       * Set whether the event bubbles.
       *
       * @param bubbles {Boolean} Whether the event bubbles
       */
      setBubbles: function (bubbles) {
        this._bubbles = bubbles;
      },

      /**
       * Get whether the event is cancelable
       *
       * @return {Boolean} Whether the event is cancelable
       */
      isCancelable: function () {
        return this._cancelable;
      },

      /**
       * Set whether the event is cancelable
       *
       * @param cancelable {Boolean} Whether the event is cancelable
       */
      setCancelable: function (cancelable) {
        this._cancelable = cancelable;
      }
    }
  });
  qx.event.type.Event.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.event.type.Event": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
  
  ************************************************************************ */

  /**
   * Event object for data holding event or data changes.
   */
  qx.Class.define("qx.event.type.Data", {
    extend: qx.event.type.Event,

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __P_86_0: null,
      __P_86_1: null,

      /**
       * Initializes an event object.
       *
       * @param data {var} The event's new data
       * @param old {var?null} The event's old data (optional)
       * @param cancelable {Boolean?false} Whether or not an event can have its default
       *     action prevented. The default action can either be the browser's
       *     default action of a native event (e.g. open the context menu on a
       *     right click) or the default action of a qooxdoo class (e.g. close
       *     the window widget). The default action can be prevented by calling
       *     {@link qx.event.type.Event#preventDefault}
       * @return {qx.event.type.Data} the initialized instance.
       */
      init: function (data, old, cancelable) {
        qx.event.type.Data.prototype.init.base.call(this, false, cancelable);
        this.__P_86_0 = data;
        this.__P_86_1 = old;
        return this;
      },

      /**
       * Get a copy of this object
       *
       * @param embryo {qx.event.type.Data?null} Optional event class, which will
       *     be configured using the data of this event instance. The event must be
       *     an instance of this event class. If the data is <code>null</code>,
       *     a new pooled instance is created.
       * @return {qx.event.type.Data} a copy of this object
       */
      clone: function (embryo) {
        var clone = qx.event.type.Data.prototype.clone.base.call(this, embryo);
        clone.__P_86_0 = this.__P_86_0;
        clone.__P_86_1 = this.__P_86_1;
        return clone;
      },

      /**
       * The new data of the event sending this data event.
       * The return data type is the same as the event data type.
       *
       * @return {var} The new data of the event
       */
      getData: function () {
        return this.__P_86_0;
      },

      /**
       * The old data of the event sending this data event.
       * The return data type is the same as the event data type.
       *
       * @return {var} The old data of the event
       */
      getOldData: function () {
        return this.__P_86_1;
      }
    }
  });
  qx.event.type.Data.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Interface": {
        "usage": "dynamic",
        "require": true
      },
      "qx.event.type.Event": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * All event dispatchers must implement this interface. Event dispatchers must
   * register themselves at the event Manager using
   * {@link qx.event.Registration#addDispatcher}.
   */
  qx.Interface.define("qx.event.IEventDispatcher", {
    members: {
      /**
       * Whether the dispatcher is responsible for the this event.
       *
       * @param target {Element|Event} The event dispatch target
       * @param event {qx.event.type.Event} The event object
       * @param type {String} the event type
       * @return {Boolean} Whether the event dispatcher is responsible for the this event
       */
      canDispatchEvent: function (target, event, type) {
        this.assertInstance(event, qx.event.type.Event);
        this.assertString(type);
      },

      /**
       * This function dispatches the event to the event listeners.
       *
       * @param target {Element|Event} The event dispatch target
       * @param event {qx.event.type.Event} event object to dispatch
       * @param type {String} the event type
       * @return {qx.Promise?} a promise, if one or more of the event handlers returned a promise
       */
      dispatchEvent: function (target, event, type) {
        this.assertInstance(event, qx.event.type.Event);
        this.assertString(type);
      }
    }
  });
  qx.event.IEventDispatcher.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "require": true
      },
      "qx.event.IEventDispatcher": {
        "require": true
      },
      "qx.event.Registration": {
        "defer": "runtime",
        "require": true
      },
      "qx.event.type.Event": {},
      "qx.event.Utils": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * Dispatches events directly on the event target (no bubbling nor capturing).
   */
  qx.Class.define("qx.event.dispatch.Direct", {
    extend: qx.core.Object,
    implement: qx.event.IEventDispatcher,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * Create a new instance
     *
     * @param manager {qx.event.Manager} Event manager for the window to use
     */
    construct: function (manager) {
      this._manager = manager;
    },

    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics: {
      /** @type {Integer} Priority of this dispatcher */
      PRIORITY: qx.event.Registration.PRIORITY_LAST
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /*
      ---------------------------------------------------------------------------
        EVENT DISPATCHER INTERFACE
      ---------------------------------------------------------------------------
      */
      // interface implementation
      canDispatchEvent: function (target, event, type) {
        return !event.getBubbles();
      },
      // interface implementation
      dispatchEvent: function (target, event, type) {
        event.setEventPhase(qx.event.type.Event.AT_TARGET);
        var tracker = {};
        var self = this;

        var listeners = this._manager.getListeners(target, type, false);

        if (listeners) {
          listeners.forEach(function (listener) {
            if (self._manager.isBlacklisted(listener.unique)) {
              return;
            }

            var context = listener.context || target;
            qx.event.Utils.then(tracker, function () {
              return listener.handler.call(context, event);
            });
          });
        }

        return tracker.promise;
      }
    },

    /*
    *****************************************************************************
       DEFER
    *****************************************************************************
    */
    defer: function (statics) {
      qx.event.Registration.addDispatcher(statics);
    }
  });
  qx.event.dispatch.Direct.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.core.Assert": {
        "construct": true
      },
      "qx.data.Array": {},
      "qx.lang.Array": {},
      "qx.log.Logger": {},
      "qx.bom.Event": {},
      "qx.event.GlobalError": {},
      "qx.core.Environment": {
        "defer": "runtime"
      }
    },
    "environment": {
      "provided": ["qx.promise.warnings", "qx.promise.longStackTraces"],
      "required": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2016 Zenesis Limited, http://www.zenesis.com
       BluebirdJS Copyright (c) 2013-2016 Petka Antonov http://bluebirdjs.com/
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
   * John Spackman (john.spackman@zenesis.com)
  
   ************************************************************************ */

  /**
   * This class adds Promise/A+ support to Qooxdoo, as specified at 
   * https://github.com/promises-aplus/promises-spec and using the Bluebird Promise
   * library (http://bluebirdjs.com/) to implement it.  The official Promise/A+ API) 
   * is mirrored exactly, and a number of extension methods are added with the BluebirdJS 
   * API for inspiration (many/most of the extension functions are taken verbatim).
   * 
   * There are two ways to bind a 'this' value to callbacks - the first is to
   * append a context method to methods like then(), and the second is to specify
   * the context as the second parameter to the constructor and all callbacks will
   * be bound to that value.
   * 
   * For example:
   * 
   * <pre class="javascript">
   *   var promise = new qx.Promise(myAsyncFunction, this);
   *   promise.then(function() {
   *     // 'this' is preserved from the outer scope
   *   });
   *   
   *   // ... is the same as: ...
   *   var promise = new qx.Promise(myAsyncFunction);
   *   promise.then(function() {
   *     // 'this' is preserved from the outer scope
   *   }, this);
   * </pre>
   * 
   * If you have an existing qx.Promise and want to bind all callbacks, use the
   * bind() method - but note that it returns a new promise:
   * 
   *  <pre class="javascript">
   *    var promise = someMethodThatReturnsAPromise();
   *    var boundPromise = promise.bind(this);
   *    boundPromise.then(function() {
   *      // 'this' is preserved from the outer scope
   *    }, this);
   *  </pre>
   * 
   */

  /* 
   @ignore(process.*)
   @ignore(global.*)
   @ignore(Symbol.*)
   @ignore(chrome.*)
   
  */
  qx.Class.define("qx.Promise", {
    extend: qx.core.Object,

    /**
     * Constructor.
     * 
     * The promise function is called with two parameters, functions which are to be called
     * when the promise is fulfilled or rejected respectively.  If you do not provide any
     * parameters, the promise can be externally resolved or rejected by calling the
     * <code>resolve()</code> or <code>reject()</code> methods.
     * 
     * @param fn {Function} the promise function called with <code>(resolve, reject)</code>
     * @param context {Object?} optional context for all callbacks
     */
    construct: function (fn, context) {
      qx.core.Object.constructor.call(this);

      qx.Promise.__P_64_0();

      if (fn instanceof qx.Promise.Bluebird) {
        this.__P_64_1 = fn;
      } else if (fn) {
        if (context !== undefined && context !== null) {
          fn = fn.bind(context);
        }

        this.__P_64_1 = new qx.Promise.Bluebird(fn);
      } else {
        this.__P_64_1 = new qx.Promise.Bluebird(this.__P_64_2.bind(this));
      }

      qx.core.Assert.assertTrue(!this.__P_64_1.$$qxPromise);
      this.__P_64_1.$$qxPromise = this;

      if (context !== undefined && context !== null) {
        this.__P_64_1 = this.__P_64_1.bind(context);
      }
    },

    /**
     * Destructor
     */
    destruct: function () {
      delete this.__P_64_1.$$qxPromise;
      delete this.__P_64_1;
    },
    members: {
      /** The Promise */
      __P_64_1: null,

      /** Stores data for completing the promise externally */
      __P_64_3: null,

      /* *********************************************************************************
       * 
       * Promise API methods
       * 
       */

      /**
       * Returns a promise which is determined by the functions <code>onFulfilled</code>
       * and <code>onRejected</code>.
       * 
       * @param onFulfilled {Function} called when the Promise is fulfilled. This function 
       *  has one argument, the fulfillment value.
       * @param onRejected {Function?} called when the Promise is rejected. This function 
       *  has one argument, the rejection reason.
       * @return {qx.Promise}
       */
      then: function (onFulfilled, onRejected) {
        return this._callMethod('then', arguments);
      },

      /**
       * Appends a rejection handler callback to the promise, and returns a new promise 
       * resolving to the return value of the callback if it is called, or to its original 
       * fulfillment value if the promise is instead fulfilled.
       * 
       * @param onRejected {Function?} called when the Promise is rejected. This function 
       *  has one argument, the rejection reason.
       * @return {qx.Promise} a qx.Promise is rejected if onRejected throws an error or 
       *  returns a Promise which is itself rejected; otherwise, it is resolved.
       */
      "catch": function (onRejected) {
        return this._callMethod('catch', arguments);
      },

      /* *********************************************************************************
       * 
       * Extension Promise methods
       * 
       */

      /**
       * Creates a new qx.Promise with the 'this' set to a different context
       * 
       * @param context {Object} the 'this' context for the new Promise
       * @return {qx.Promise} the new promise
       */
      bind: function (context) {
        return qx.Promise.__P_64_4(this.__P_64_1.bind(context));
      },

      /**
       * Like calling <code>.then</code>, but the fulfillment value must be an array, which is flattened 
       * to the formal parameters of the fulfillment handler.
       * 
       * For example:
       * <pre>
       * qx.Promise.all([
       *   fs.readFileAsync("file1.txt"),
       *   fs.readFileAsync("file2.txt")
       * ]).spread(function(file1text, file2text) {
       *   if (file1text === file2text) {
       *     console.log("files are equal");
       *   }
       *   else {
       *     console.log("files are not equal");
       *   }
       * });
       * </pre>
       * 
       * @param fulfilledHandler {Function} called when the Promises are fulfilled.
       * @return {qx.Promise}
       */
      spread: function (fulfilledHandler) {
        return this._callMethod('spread', arguments);
      },

      /**
       * Appends a handler that will be called regardless of this promise's fate. The handler
       * is not allowed to modify the value of the promise
       * 
       * @param handler {Function?} called when the Promise is fulfilled or rejected. This function 
       *  has no arguments, but can return a promise
       * @return {qx.Promise} a qx.Promise chained from this promise
       */
      "finally": function (onRejected) {
        return this._callMethod('finally', arguments);
      },

      /**
       * Cancel this promise. Will not do anything if this promise is already settled.
       */
      cancel: function () {
        return this._callMethod('cancel', arguments);
      },

      /**
       * Same as {@link qx.Promise.all} except that it iterates over the value of this promise, when
       * it is fulfilled; for example, if this Promise resolves to an Iterable (eg an Array), 
       * <code>.all</code> will return a Promise that waits for all promises in that Iterable to be 
       * fullfilled.  The Iterable can be a mix of values and Promises
       * 
       * @return {qx.Promise}
       */
      all: function () {
        return this._callIterableMethod('all', arguments);
      },

      /**
       * Same as {@link qx.Promise.race} except that it iterates over the value of this promise, when
       * it is fulfilled; for example, if this Promise resolves to an Iterable (eg an Array), 
       * <code>.race</code> will return a Promise that waits until the first promise in that Iterable 
       * has been fullfilled.  The Iterable can be a mix of values and Promises
       * 
       * @return {qx.Promise}
       */
      race: function (iterable) {
        return this._callIterableMethod('race', arguments);
      },

      /**
       * Same as {@link qx.Promise.some} except that it iterates over the value of this promise, when
       * it is fulfilled.  Like <code>some</code>, with 1 as count. However, if the promise fulfills, 
       * the fulfillment value is not an array of 1 but the value directly.
       * 
       * @return {qx.Promise}
       */
      any: function (iterable) {
        return this._callIterableMethod('any', arguments);
      },

      /**
       * Same as {@link qx.Promise.some} except that it iterates over the value of this promise, when
       * it is fulfilled; return a promise that is fulfilled as soon as count promises are fulfilled 
       * in the array. The fulfillment value is an array with count values in the order they were fulfilled.
       * 
       * @param iterable {Iterable} An iterable object, such as an Array
       * @param count {Integer}
       * @return {qx.Promise}
       */
      some: function (iterable, count) {
        return this._callIterableMethod('some', arguments);
      },

      /**
       * Same as {@link qx.Promise.forEach} except that it iterates over the value of this promise, when
       * it is fulfilled; iterates over the values with the given <code>iterator</code> function with the signature 
       * <code>(value, index, length)</code> where <code>value</code> is the resolved value. Iteration happens 
       * serially. If any promise is rejected the returned promise is rejected as well.
       * 
       * Resolves to the original array unmodified, this method is meant to be used for side effects. If the iterator 
       * function returns a promise or a thenable, then the result of the promise is awaited, before continuing with 
       * next iteration.
       * 
       * @param iterable {Iterable} An iterable object, such as an Array
       * @param iterator {Function} the callback, with <code>(value, index, length)</code>
       * @return {qx.Promise}
       */
      forEach: function (iterable, iterator) {
        return this._callIterableMethod('each', arguments);
      },

      /**
       * Same as {@link qx.Promise.filter} except that it iterates over the value of this promise, when it is fulfilled; 
       * iterates over all the values into an array and filter the array to another using the given filterer function.
       * 
       * @param iterable {Iterable} An iterable object, such as an Array
       * @param iterator {Function} the callback, with <code>(value, index, length)</code>
       * @param options {Object?} options; can be:
       *  <code>concurrency</code> max nuber of simultaneous filters, default is <code>Infinity</code>
       * @return {qx.Promise}
       */
      filter: function (iterable, iterator, options) {
        return this._callIterableMethod('filter', arguments);
      },

      /**
       * Same as {@link qx.Promise.map} except that it iterates over the value of this promise, when it is fulfilled; 
       * iterates over all the values into an array and map the array to another using the given mapper function.
       * 
       * Promises returned by the mapper function are awaited for and the returned promise doesn't fulfill 
       * until all mapped promises have fulfilled as well. If any promise in the array is rejected, or 
       * any promise returned by the mapper function is rejected, the returned promise is rejected as well.
       * 
       * The mapper function for a given item is called as soon as possible, that is, when the promise 
       * for that item's index in the input array is fulfilled. This doesn't mean that the result array 
       * has items in random order, it means that .map can be used for concurrency coordination unlike 
       * .all.
       * 
       * @param iterable {Iterable} An iterable object, such as an Array
       * @param iterator {Function} the callback, with <code>(value, index, length)</code>
       * @param options {Object?} options; can be:
       *  <code>concurrency</code> max nuber of simultaneous filters, default is <code>Infinity</code>
       * @return {qx.Promise}
       */
      map: function (iterable, iterator, options) {
        return this._callIterableMethod('map', arguments);
      },

      /**
       * Same as {@link qx.Promise.mapSeries} except that it iterates over the value of this promise, when
       * it is fulfilled; iterates over all the values into an array and iterate over the array serially, 
       * in-order.
       * 
       * Returns a promise for an array that contains the values returned by the iterator function in their 
       * respective positions. The iterator won't be called for an item until its previous item, and the 
       * promise returned by the iterator for that item are fulfilled. This results in a mapSeries kind of 
       * utility but it can also be used simply as a side effect iterator similar to Array#forEach.
       * 
       * If any promise in the input array is rejected or any promise returned by the iterator function is 
       * rejected, the result will be rejected as well.
       * 
       * @param iterable {Iterable} An iterable object, such as an Array
       * @param iterator {Function} the callback, with <code>(value, index, length)</code>
       * @return {qx.Promise}
       */
      mapSeries: function (iterable, iterator) {
        return this._callIterableMethod('mapSeries', arguments);
      },

      /**
       * Same as {@link qx.Promise.reduce} except that it iterates over the value of this promise, when
       * it is fulfilled; iterates over all the values in the <code>Iterable</code> into an array and 
       * reduce the array to a value using the given reducer function.
       * 
       * If the reducer function returns a promise, then the result of the promise is awaited, before 
       * continuing with next iteration. If any promise in the array is rejected or a promise returned 
       * by the reducer function is rejected, the result is rejected as well.
       * 
       * If initialValue is undefined (or a promise that resolves to undefined) and the iterable contains 
       * only 1 item, the callback will not be called and the iterable's single item is returned. If the 
       * iterable is empty, the callback will not be called and initialValue is returned (which may be 
       * undefined).
       * 
       * qx.Promise.reduce will start calling the reducer as soon as possible, this is why you might want to 
       * use it over qx.Promise.all (which awaits for the entire array before you can call Array#reduce on it).
       * 
       * @param iterable {Iterable} An iterable object, such as an Array
       * @param reducer {Function} the callback, with <code>(value, index, length)</code>
       * @param initialValue {Object?} optional initial value
       * @return {qx.Promise}
       */
      reduce: function (iterable, reducer, initialValue) {
        return this._callIterableMethod('reduce', arguments);
      },

      /**
       * External promise handler
       */
      __P_64_2: function (resolve, reject) {
        this.__P_64_3 = {
          resolve: resolve,
          reject: reject,
          complete: false
        };
      },

      /**
       * Returns the data stored by __externalPromise, throws an exception once processed
       */
      __P_64_5: function () {
        if (!this.__P_64_3) {
          throw new Error("Promise cannot be resolved externally");
        }

        if (this.__P_64_3.complete) {
          throw new Error("Promise has already been resolved or rejected");
        }

        this.__P_64_3.complete = true;
        return this.__P_64_3;
      },

      /**
       * Resolves an external promise
       */
      resolve: function (value) {
        this.__P_64_5().resolve(value);
      },

      /**
       * Rejects an external promise
       */
      reject: function (reason) {
        this.__P_64_5().reject(reason);
      },

      /* *********************************************************************************
       * 
       * Utility methods
       * 
       */

      /**
       * Helper method used to call Promise methods which iterate over an array
       */
      _callIterableMethod: function (methodName, args) {
        args = qx.Promise.__P_64_6(args);
        return qx.Promise.__P_64_4(this.__P_64_1.then(function (value) {
          var newP = qx.Promise.Bluebird.resolve(value instanceof qx.data.Array ? value.toArray() : value);
          return qx.Promise.__P_64_4(newP[methodName].apply(newP, args));
        }));
      },

      /**
       * Helper method used to call a Promise method
       */
      _callMethod: function (methodName, args) {
        args = qx.Promise.__P_64_6(args);
        return qx.Promise.__P_64_4(this.__P_64_1[methodName].apply(this.__P_64_1, args));
      },

      /**
       * Returns the actual Promise implementation.
       * 
       * Note that Bluebird is the current implementation, and may change without 
       * notice in the future; if you use this API you accept that this is a private 
       * implementation detail exposed for debugging or diagnosis purposes only.  For
       * this reason, the toPromise() method is listed as deprecated starting from the
       * first release  
       * @deprecated {6.0} this API method is subject to change
       */
      toPromise: function () {
        return this.__P_64_1;
      }
    },
    statics: {
      /** Bluebird Promise library; always available */
      Bluebird: null,

      /** Native Promise library; only available if the browser supports it */
      Native: null,

      /** Promise library, either the Native one or a Polyfill; reliable choice for native Promises */
      Promise: null,

      /** This is used to suppress warnings about rejections without an Error object, only used if
       * the reason is undefined
       */
      __P_64_7: new Error("Default Error"),

      /* *********************************************************************************
       * 
       * Promise API methods
       * 
       */

      /**
       * Returns a Promise object that is resolved with the given value. If the value is a thenable (i.e. 
       * has a then method), the returned promise will "follow" that thenable, adopting its eventual 
       * state; otherwise the returned promise will be fulfilled with the value. Generally, if you 
       * don't know if a value is a promise or not, Promise.resolve(value) it instead and work with 
       * the return value as a promise.
       * 
       * @param value {Object}
       * @param context {Object?} optional context for callbacks to be bound to
       * @return {qx.Promise}
       */
      resolve: function (value, context) {
        var promise;

        if (value instanceof qx.Promise) {
          promise = value;
        } else {
          promise = qx.Promise.__P_64_4(qx.Promise.Bluebird.resolve(value));
        }

        if (context !== undefined) {
          promise = promise.bind(context);
        }

        return promise;
      },

      /**
       * Returns a Promise object that is rejected with the given reason.
       * @param reason {Object?} Reason why this Promise rejected. A warning is generated if not instanceof Error. If undefined, a default Error is used.
       * @param context {Object?} optional context for callbacks to be bound to
       * @return {qx.Promise}
       */
      reject: function (reason, context) {
        var args = qx.lang.Array.fromArguments(arguments);

        if (reason === undefined) {
          args.shift();
          args.unshift(qx.Promise.__P_64_7);
        } else if (!(reason instanceof Error)) {
          qx.log.Logger.warn("Rejecting a promise with a non-Error value");
        }

        var promise = qx.Promise.__P_64_8('reject', args, 0);

        if (context !== undefined) {
          promise = promise.bind(context);
        }

        return promise;
      },

      /**
       * Returns a promise that resolves when all of the promises in the object properties have resolved, 
       * or rejects with the reason of the first passed promise that rejects.  The result of each property
       * is placed back in the object, replacing the promise.  Note that non-promise values are untouched.
       * 
       * @param value {var} An object
       * @return {qx.Promise}
       */
      allOf: function (value) {
        function action(value) {
          var arr = [];
          var names = [];

          for (var name in value) {
            if (value.hasOwnProperty(name) && value[name] instanceof qx.Promise) {
              arr.push(value[name]);
              names.push(name);
            }
          }

          return qx.Promise.all(arr).then(function (arr) {
            arr.forEach(function (item, index) {
              value[names[index]] = item;
            });
            return value;
          });
        }

        return value instanceof qx.Promise ? value.then(action) : action(value);
      },

      /**
       * Returns a promise that resolves when all of the promises in the iterable argument have resolved, 
       * or rejects with the reason of the first passed promise that rejects.  Note that non-promise values 
       * are untouched.
       * 
       * @param iterable {Iterable} An iterable object, such as an Array
       * @return {qx.Promise}
       */
      all: function (iterable) {
        return qx.Promise.__P_64_8('all', arguments);
      },

      /**
       * Returns a promise that resolves or rejects as soon as one of the promises in the iterable resolves 
       * or rejects, with the value or reason from that promise.
       * @param iterable {Iterable} An iterable object, such as an Array
       * @return {qx.Promise}
       */
      race: function (iterable) {
        return qx.Promise.__P_64_8('race', arguments);
      },

      /* *********************************************************************************
       * 
       * Extension API methods
       * 
       */

      /**
       * Like Promise.some, with 1 as count. However, if the promise fulfills, the fulfillment value is not an 
       * array of 1 but the value directly.
       * 
       * @param iterable {Iterable} An iterable object, such as an Array
       * @return {qx.Promise}
       */
      any: function (iterable) {
        return qx.Promise.__P_64_8('any', arguments);
      },

      /**
       * Given an Iterable (arrays are Iterable), or a promise of an Iterable, which produces promises (or a mix 
       * of promises and values), iterate over all the values in the Iterable into an array and return a promise 
       * that is fulfilled as soon as count promises are fulfilled in the array. The fulfillment value is an 
       * array with count values in the order they were fulfilled.
       * 
       * @param iterable {Iterable} An iterable object, such as an Array
       * @param count {Integer}
       * @return {qx.Promise}
       */
      some: function (iterable, count) {
        return qx.Promise.__P_64_8('some', arguments);
      },

      /**
       * Iterate over an array, or a promise of an array, which contains promises (or a mix of promises and values) 
       * with the given <code>iterator</code> function with the signature <code>(value, index, length)</code> where 
       * <code>value</code> is the resolved value of a respective promise in the input array. Iteration happens 
       * serially. If any promise in the input array is rejected the returned promise is rejected as well.
       * 
       * Resolves to the original array unmodified, this method is meant to be used for side effects. If the iterator 
       * function returns a promise or a thenable, then the result of the promise is awaited, before continuing with 
       * next iteration.
       * 
       * @param iterable {Iterable} An iterable object, such as an Array
       * @param iterator {Function} the callback, with <code>(value, index, length)</code>
       * @return {qx.Promise}
       */
      forEach: function (iterable, iterator) {
        return qx.Promise.__P_64_8('each', arguments);
      },

      /**
       * Given an Iterable(arrays are Iterable), or a promise of an Iterable, which produces promises (or a mix of 
       * promises and values), iterate over all the values in the Iterable into an array and filter the array to 
       * another using the given filterer function.
       * 
       * It is essentially an efficient shortcut for doing a .map and then Array#filter:
       * <pre>
       *   qx.Promise.map(valuesToBeFiltered, function(value, index, length) {
       *       return Promise.all([filterer(value, index, length), value]);
       *   }).then(function(values) {
       *       return values.filter(function(stuff) {
       *           return stuff[0] == true
       *       }).map(function(stuff) {
       *           return stuff[1];
       *       });
       *   });
       * </pre>
       * 
       * @param iterable {Iterable} An iterable object, such as an Array
       * @param iterator {Function} the callback, with <code>(value, index, length)</code>
       * @param options {Object?} options; can be:
       *  <code>concurrency</code> max nuber of simultaneous filters, default is <code>Infinity</code>
       * @return {qx.Promise}
       */
      filter: function (iterable, iterator, options) {
        return qx.Promise.__P_64_8('filter', arguments);
      },

      /**
       * Given an <code>Iterable</code> (arrays are <code>Iterable</code>), or a promise of an 
       * <code>Iterable</code>, which produces promises (or a mix of promises and values), iterate over 
       * all the values in the <code>Iterable</code> into an array and map the array to another using 
       * the given mapper function.
       * 
       * Promises returned by the mapper function are awaited for and the returned promise doesn't fulfill 
       * until all mapped promises have fulfilled as well. If any promise in the array is rejected, or 
       * any promise returned by the mapper function is rejected, the returned promise is rejected as well.
       * 
       * The mapper function for a given item is called as soon as possible, that is, when the promise 
       * for that item's index in the input array is fulfilled. This doesn't mean that the result array 
       * has items in random order, it means that .map can be used for concurrency coordination unlike 
       * .all.
       * 
       * A common use of Promise.map is to replace the .push+Promise.all boilerplate:
       * 
       * <pre>
       *   var promises = [];
       *   for (var i = 0; i < fileNames.length; ++i) {
       *       promises.push(fs.readFileAsync(fileNames[i]));
       *   }
       *   qx.Promise.all(promises).then(function() {
       *       console.log("done");
       *   });
       *   
       *   // Using Promise.map:
       *   qx.Promise.map(fileNames, function(fileName) {
       *       // Promise.map awaits for returned promises as well.
       *       return fs.readFileAsync(fileName);
       *   }).then(function() {
       *       console.log("done");
       *   });
       * </pre>
       * 
       * @param iterable {Iterable} An iterable object, such as an Array
       * @param iterator {Function} the callback, with <code>(value, index, length)</code>
       * @param options {Object?} options; can be:
       *  <code>concurrency</code> max nuber of simultaneous filters, default is <code>Infinity</code>
       * @return {qx.Promise}
       */
      map: function (iterable, iterator, options) {
        return qx.Promise.__P_64_8('map', arguments);
      },

      /**
       * Given an <code>Iterable</code>(arrays are <code>Iterable</code>), or a promise of an 
       * <code>Iterable</code>, which produces promises (or a mix of promises and values), iterate over 
       * all the values in the <code>Iterable</code> into an array and iterate over the array serially, 
       * in-order.
       * 
       * Returns a promise for an array that contains the values returned by the iterator function in their 
       * respective positions. The iterator won't be called for an item until its previous item, and the 
       * promise returned by the iterator for that item are fulfilled. This results in a mapSeries kind of 
       * utility but it can also be used simply as a side effect iterator similar to Array#forEach.
       * 
       * If any promise in the input array is rejected or any promise returned by the iterator function is 
       * rejected, the result will be rejected as well.
       * 
       * Example where .mapSeries(the instance method) is used for iterating with side effects:
       * 
       * <pre>
       * // Source: http://jakearchibald.com/2014/es7-async-functions/
       * function loadStory() {
       *   return getJSON('story.json')
       *     .then(function(story) {
       *       addHtmlToPage(story.heading);
       *       return story.chapterURLs.map(getJSON);
       *     })
       *     .mapSeries(function(chapter) { addHtmlToPage(chapter.html); })
       *     .then(function() { addTextToPage("All done"); })
       *     .catch(function(err) { addTextToPage("Argh, broken: " + err.message); })
       *     .then(function() { document.querySelector('.spinner').style.display = 'none'; });
       * }
       * </pre>
       * 
       * @param iterable {Iterable} An iterable object, such as an Array
       * @param iterator {Function} the callback, with <code>(value, index, length)</code>
       * @return {qx.Promise}
       */
      mapSeries: function (iterable, iterator) {
        return qx.Promise.__P_64_8('mapSeries', arguments);
      },

      /**
       * Given an <code>Iterable</code> (arrays are <code>Iterable</code>), or a promise of an 
       * <code>Iterable</code>, which produces promises (or a mix of promises and values), iterate 
       * over all the values in the <code>Iterable</code> into an array and reduce the array to a 
       * value using the given reducer function.
       * 
       * If the reducer function returns a promise, then the result of the promise is awaited, before 
       * continuing with next iteration. If any promise in the array is rejected or a promise returned 
       * by the reducer function is rejected, the result is rejected as well.
       * 
       * Read given files sequentially while summing their contents as an integer. Each file contains 
       * just the text 10.
       * 
       * <pre>
       *   qx.Promise.reduce(["file1.txt", "file2.txt", "file3.txt"], function(total, fileName) {
       *       return fs.readFileAsync(fileName, "utf8").then(function(contents) {
       *           return total + parseInt(contents, 10);
       *       });
       *   }, 0).then(function(total) {
       *       //Total is 30
       *   });
       * </pre>
       * 
       * If initialValue is undefined (or a promise that resolves to undefined) and the iterable contains 
       * only 1 item, the callback will not be called and the iterable's single item is returned. If the 
       * iterable is empty, the callback will not be called and initialValue is returned (which may be 
       * undefined).
       * 
       * Promise.reduce will start calling the reducer as soon as possible, this is why you might want to 
       * use it over Promise.all (which awaits for the entire array before you can call Array#reduce on it).
       * 
       * @param iterable {Iterable} An iterable object, such as an Array
       * @param reducer {Function} the callback, with <code>(value, index, length)</code>
       * @param initialValue {Object?} optional initial value
       * @return {qx.Promise}
       */
      reduce: function (iterable, reducer, initialValue) {
        return qx.Promise.__P_64_8('reduce', arguments);
      },

      /**
       * Returns a new function that wraps the given function fn. The new function will always return a promise that is 
       * fulfilled with the original functions return values or rejected with thrown exceptions from the original function.
       * @param cb {Function}
       * @return {Function}
       */
      method: function (cb) {
        var wrappedCb = qx.Promise.Bluebird.method(cb);
        return function () {
          return qx.Promise.__P_64_4(wrappedCb.apply(this, arguments));
        };
      },

      /**
       * Like .all but for object properties or Maps* entries instead of iterated values. Returns a promise that 
       * is fulfilled when all the properties of the object or the Map's' values** are fulfilled. The promise's 
       * fulfillment value is an object or a Map with fulfillment values at respective keys to the original object 
       * or a Map. If any promise in the object or Map rejects, the returned promise is rejected with the rejection 
       * reason.
       * 
       * If object is a trusted Promise, then it will be treated as a promise for object rather than for its 
       * properties. All other objects (except Maps) are treated for their properties as is returned by 
       * Object.keys - the object's own enumerable properties.
       * 
       * @param input {Object} An Object
       * @return {qx.Promise}
       */
      props: function (input) {
        return qx.Promise.__P_64_8('props', arguments);
      },

      /**
       * Returns a new function that wraps a function that is in node.js
       * style. The resulting function returns a promise instead of taking a
       * callback function as an argument. The promise is resolved or rejected
       * by the action of the callback function. The provided function must
       * accept a callback as its last argument, and that callback function must
       * expect its first argument to be an error if non-null. If the first
       * argument is null, the second argument (optional) will be the success
       * value.
       *
       * Example:
       *
       * Assume there is a member method in myApp.Application such as the
       * following:
       * <pre><code>
       *   issueRpc : function(method, params, callback)
       *   {
       *     ...
       *   }
       * </code></pre>
       *
       * where the signature of <code>callback</code> is:
       * <pre><code>
       *   function callback(e, result)
       * </code></pre>
       *
       * The <code>issueRpc</code>method could be converted to be called using
       * promises instead of callbacks, as shown here:
       * <pre><code>
       *   var app = qx.core.Init.getApplication();
       *   var rpc = qx.Promise.promisify(app.issueRpc, { context : app });
       *   rpc("ping", [ "hello world" ])
       *     .then(
       *       function(pongValue)
       *       {
       *         // handle result
       *       })
       *     .catch(
       *       function(e)
       *       {
       *         throw e;
       *       });
       * </code></pre>
       *
       * @param f {Function} The node.js-style function to be promisified
       *
       * @param options {Map?}
       *   The sole user option in this map is <code>context</code>, which may
       *   be specified to arrange for the provided callback function to be
       *   called in the specified context.
       *   
       * @return {qx.Promise}
       */
      promisify: function (f, options) {
        return qx.Promise.__P_64_8('promisify', arguments);
      },

      /* *********************************************************************************
       * 
       * Internal API methods
       * 
       */

      /**
       * Called when the Bluebird Promise class is loaded
       * @param Promise {Class} the Promise class
       */
      __P_64_9: function (Promise) {
        qx.Promise.Bluebird = Promise;
        Promise.config({
          warnings: true,
          longStackTraces: true,
          cancellation: true
        });
      },

      /** Whether one-time initialisaton has happened */
      __P_64_10: false,

      /**
       * One-time initializer
       */
      __P_64_0: function () {
        if (qx.Promise.__P_64_10) {
          return;
        }

        qx.Promise.__P_64_10 = true;
        qx.bom.Event.addNativeListener(window, "unhandledrejection", qx.Promise.__P_64_11.bind(this));
      },

      /**
       * Handles unhandled errors and passes them through to Qooxdoo's global error handler
       * @param e {NativeEvent}
       */
      __P_64_11: function (e) {
        e.preventDefault();
        var reason = null;

        if (e instanceof Error) {
          reason = e;
        } else if (e.reason instanceof Error) {
          reason = e.reason;
        } else if (e.detail && e.detail.reason instanceof Error) {
          reason = e.detail.reason;
        }

        qx.log.Logger.error(this, "Unhandled promise rejection: " + (reason ? reason.stack : "(not from exception)"));
        qx.event.GlobalError.handleError(reason);
      },

      /**
       * Wraps values, converting Promise into qx.Promise
       * @param value {Object}
       * @return {Object}
       */
      __P_64_4: function (value) {
        if (value instanceof qx.Promise.Bluebird) {
          if (value.$$qxPromise) {
            value = value.$$qxPromise;
          } else {
            value = new qx.Promise(value);
          }
        }

        return value;
      },

      /**
       * Binds all functions in the array to the context at the end of the array;
       * the last value must be a qx.core.Object to distinguish itself from configuration
       * objects passed to some methods.
       * @param args {arguments}
       * @param minArgs {Integer?} minimum number of arguments expected for the method call;
       * 	this is used to determine whether the last value is for binding (default is 1)
       * @return {Array} array of new arguments with functions bound as necessary
       */
      __P_64_6: function (args, minArgs) {
        args = qx.lang.Array.fromArguments(args);

        if (minArgs === undefined) {
          minArgs = 1;
        }

        if (args.length > minArgs) {
          var context = args[args.length - 1];

          if (context instanceof qx.core.Object || qx.Class.isClass(context)) {
            args.pop();

            for (var i = 0; i < args.length; i++) {
              if (typeof args[i] == "function") {
                args[i] = args[i].bind(context);
              }
            }
          }
        }

        return args;
      },

      /**
       * Helper method used to call a Bluebird Promise method
       * @param methodName {String} method name to call
       * @param args {Array} arguments to pass
       * @param minArgs {Integer?} {@see __bindArgs}
       * @return {Object?}
       */
      __P_64_8: function (methodName, args, minArgs) {
        args = qx.Promise.__P_64_6(args, minArgs);
        return qx.Promise.__P_64_4(qx.Promise.Bluebird[methodName].apply(qx.Promise.Bluebird, qx.Promise.__P_64_12(args)));
      },

      /**
       * Maps all arguments ready for passing to a Bluebird function; qx.data.Array are
       * translated to native arrays and qx.Promise to Promise.  This is not recursive.
       */
      __P_64_12: function (args) {
        var dest = [];
        args.forEach(function (arg) {
          if (arg instanceof qx.data.Array) {
            dest.push(arg.toArray());
          } else if (arg instanceof qx.Promise) {
            dest.push(arg.toPromise());
          } else {
            dest.push(arg);
          }
        });
        return dest;
      }
    },
    defer: function (statics, members) {
      statics.Promise = statics.Native = window.Promise;
      var debug = false;
      qx.core.Environment.add("qx.promise.warnings", debug);
      qx.core.Environment.add("qx.promise.longStackTraces", false);
    }
  });
  /**
   * @lint ignoreUnused(exports)
   * @lint ignoreUnused(module)
   * @lint ignoreUnused(define)
   * @lint ignoreUnused(CapturedTrace)
   * @lint ignoreUnused(bitField)
   * @lint ignoreUnused(isArray)
   * @lint ignoreDeprecated(eval)
   * @lint ignoreNoLoopBlock()
   * @ignore(Map)
   * @ignore(MutationObserver)
   * @ignore(Symbol)
   * @ignore(Symbol.iterator)
   * @ignore(_dereq_)
   * @ignore(chrome)
   * @ignore(chrome.loadTimes)
   * @ignore(CustomEvent)
   * @ignore(define)
   * @ignore(define.amd)
   * @ignore(enumeration)
   * @ignore(Event)
   * @ignore(exports)
   * @ignore(global)
   * @ignore(global.setImmediate)
   * @ignore(module)
   * @ignore(module.exports)
   * @ignore(MutationObserver)
   * @ignore(obj)
   * @ignore(obj.toPromise)
   * @ignore(predicateLoop)
   * @ignore(process)
   * @ignore(process.domain)
   * @ignore(process.emit.apply)
   * @ignore(process.env)
   * @ignore(process.exit)
   * @ignore(process.nextTick)
   * @ignore(process.stderr.isTTY)
   * @ignore(process.stderr.write)
   * @ignore(process.versions.node.split)
   * @ignore(promise)
   * @ignore(Promise)
   * @ignore(self) 
   * @ignore(setImmediate)
   */

  (function () {
    /* @preserve
     * The MIT License (MIT)
     * 
     * Copyright (c) 2013-2015 Petka Antonov
     * 
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     * 
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     * 
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     * 
     */

    /**
     * bluebird build version 3.4.5
     * Features enabled: core, race, call_get, generators, map, nodeify, promisify, props, reduce, settle, some, using, timers, filter, any, each
     */
    !function (e) {
      qx.Promise.__P_64_9(e());
    }(function () {
      var define, module, exports;
      return function e(t, n, r) {
        function s(o, u) {
          if (!n[o]) {
            if (!t[o]) {
              var a = typeof _dereq_ == "function" && _dereq_;
              if (!u && a) return a(o, true);
              if (i) return i(o, true);
              var f = new Error("Cannot find module '" + o + "'");
              throw f.code = "MODULE_NOT_FOUND", f;
            }

            var l = n[o] = {
              exports: {}
            };
            t[o][0].call(l.exports, function (e) {
              var n = t[o][1][e];
              return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
          }

          return n[o].exports;
        }

        var i = typeof _dereq_ == "function" && _dereq_;

        for (var o = 0; o < r.length; o++) s(r[o]);

        return s;
      }({
        1: [function (_dereq_, module, exports) {
          "use strict";

          module.exports = function (Promise) {
            var SomePromiseArray = Promise._SomePromiseArray;

            function any(promises) {
              var ret = new SomePromiseArray(promises);
              var promise = ret.promise();
              ret.setHowMany(1);
              ret.setUnwrap();
              ret.init();
              return promise;
            }

            Promise.any = function (promises) {
              return any(promises);
            };

            Promise.prototype.any = function () {
              return any(this);
            };
          };
        }, {}],
        2: [function (_dereq_, module, exports) {
          "use strict";

          var firstLineError;

          try {
            throw new Error();
          } catch (e) {
            firstLineError = e;
          }

          var schedule = _dereq_("./schedule");

          var Queue = _dereq_("./queue");

          var util = _dereq_("./util");

          function Async() {
            this._customScheduler = false;
            this._isTickUsed = false;
            this._lateQueue = new Queue(16);
            this._normalQueue = new Queue(16);
            this._haveDrainedQueues = false;
            this._trampolineEnabled = true;
            var self = this;

            this.drainQueues = function () {
              self._drainQueues();
            };

            this._schedule = schedule;
          }

          Async.prototype.setScheduler = function (fn) {
            var prev = this._schedule;
            this._schedule = fn;
            this._customScheduler = true;
            return prev;
          };

          Async.prototype.hasCustomScheduler = function () {
            return this._customScheduler;
          };

          Async.prototype.enableTrampoline = function () {
            this._trampolineEnabled = true;
          };

          Async.prototype.disableTrampolineIfNecessary = function () {
            if (util.hasDevTools) {
              this._trampolineEnabled = false;
            }
          };

          Async.prototype.haveItemsQueued = function () {
            return this._isTickUsed || this._haveDrainedQueues;
          };

          Async.prototype.fatalError = function (e, isNode) {
            if (isNode) {
              process.stderr.write("Fatal " + (e instanceof Error ? e.stack : e) + "\n");
              process.exit(2);
            } else {
              this.throwLater(e);
            }
          };

          Async.prototype.throwLater = function (fn, arg) {
            if (arguments.length === 1) {
              arg = fn;

              fn = function () {
                throw arg;
              };
            }

            if (typeof setTimeout !== "undefined") {
              setTimeout(function () {
                fn(arg);
              }, 0);
            } else try {
              this._schedule(function () {
                fn(arg);
              });
            } catch (e) {
              throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
            }
          };

          function AsyncInvokeLater(fn, receiver, arg) {
            this._lateQueue.push(fn, receiver, arg);

            this._queueTick();
          }

          function AsyncInvoke(fn, receiver, arg) {
            this._normalQueue.push(fn, receiver, arg);

            this._queueTick();
          }

          function AsyncSettlePromises(promise) {
            this._normalQueue._pushOne(promise);

            this._queueTick();
          }

          if (!util.hasDevTools) {
            Async.prototype.invokeLater = AsyncInvokeLater;
            Async.prototype.invoke = AsyncInvoke;
            Async.prototype.settlePromises = AsyncSettlePromises;
          } else {
            Async.prototype.invokeLater = function (fn, receiver, arg) {
              if (this._trampolineEnabled) {
                AsyncInvokeLater.call(this, fn, receiver, arg);
              } else {
                this._schedule(function () {
                  setTimeout(function () {
                    fn.call(receiver, arg);
                  }, 100);
                });
              }
            };

            Async.prototype.invoke = function (fn, receiver, arg) {
              if (this._trampolineEnabled) {
                AsyncInvoke.call(this, fn, receiver, arg);
              } else {
                this._schedule(function () {
                  fn.call(receiver, arg);
                });
              }
            };

            Async.prototype.settlePromises = function (promise) {
              if (this._trampolineEnabled) {
                AsyncSettlePromises.call(this, promise);
              } else {
                this._schedule(function () {
                  promise._settlePromises();
                });
              }
            };
          }

          Async.prototype.invokeFirst = function (fn, receiver, arg) {
            this._normalQueue.unshift(fn, receiver, arg);

            this._queueTick();
          };

          Async.prototype._drainQueue = function (queue) {
            while (queue.length() > 0) {
              var fn = queue.shift();

              if (typeof fn !== "function") {
                fn._settlePromises();

                continue;
              }

              var receiver = queue.shift();
              var arg = queue.shift();
              fn.call(receiver, arg);
            }
          };

          Async.prototype._drainQueues = function () {
            this._drainQueue(this._normalQueue);

            this._reset();

            this._haveDrainedQueues = true;

            this._drainQueue(this._lateQueue);
          };

          Async.prototype._queueTick = function () {
            if (!this._isTickUsed) {
              this._isTickUsed = true;

              this._schedule(this.drainQueues);
            }
          };

          Async.prototype._reset = function () {
            this._isTickUsed = false;
          };

          module.exports = Async;
          module.exports.firstLineError = firstLineError;
        }, {
          "./queue": 26,
          "./schedule": 29,
          "./util": 36
        }],
        3: [function (_dereq_, module, exports) {
          "use strict";

          module.exports = function (Promise, INTERNAL, tryConvertToPromise, debug) {
            var calledBind = false;

            var rejectThis = function (_, e) {
              this._reject(e);
            };

            var targetRejected = function (e, context) {
              context.promiseRejectionQueued = true;

              context.bindingPromise._then(rejectThis, rejectThis, null, this, e);
            };

            var bindingResolved = function (thisArg, context) {
              if ((this._bitField & 50397184) === 0) {
                this._resolveCallback(context.target);
              }
            };

            var bindingRejected = function (e, context) {
              if (!context.promiseRejectionQueued) this._reject(e);
            };

            Promise.prototype.bind = function (thisArg) {
              if (!calledBind) {
                calledBind = true;
                Promise.prototype._propagateFrom = debug.propagateFromFunction();
                Promise.prototype._boundValue = debug.boundValueFunction();
              }

              var maybePromise = tryConvertToPromise(thisArg);
              var ret = new Promise(INTERNAL);

              ret._propagateFrom(this, 1);

              var target = this._target();

              ret._setBoundTo(maybePromise);

              if (maybePromise instanceof Promise) {
                var context = {
                  promiseRejectionQueued: false,
                  promise: ret,
                  target: target,
                  bindingPromise: maybePromise
                };

                target._then(INTERNAL, targetRejected, undefined, ret, context);

                maybePromise._then(bindingResolved, bindingRejected, undefined, ret, context);

                ret._setOnCancel(maybePromise);
              } else {
                ret._resolveCallback(target);
              }

              return ret;
            };

            Promise.prototype._setBoundTo = function (obj) {
              if (obj !== undefined) {
                this._bitField = this._bitField | 2097152;
                this._boundTo = obj;
              } else {
                this._bitField = this._bitField & ~2097152;
              }
            };

            Promise.prototype._isBound = function () {
              return (this._bitField & 2097152) === 2097152;
            };

            Promise.bind = function (thisArg, value) {
              return Promise.resolve(value).bind(thisArg);
            };
          };
        }, {}],
        4: [function (_dereq_, module, exports) {
          "use strict";

          var old;
          if (typeof Promise !== "undefined") old = Promise;

          function noConflict() {
            try {
              if (Promise === bluebird) Promise = old;
            } catch (e) {}

            return bluebird;
          }

          var bluebird = _dereq_("./promise")();

          bluebird.noConflict = noConflict;
          module.exports = bluebird;
        }, {
          "./promise": 22
        }],
        5: [function (_dereq_, module, exports) {
          "use strict";

          var cr = Object.create;

          if (cr) {
            var callerCache = cr(null);
            var getterCache = cr(null);
            callerCache[" size"] = getterCache[" size"] = 0;
          }

          module.exports = function (Promise) {
            var util = _dereq_("./util");

            var canEvaluate = util.canEvaluate;
            var isIdentifier = util.isIdentifier;
            var getMethodCaller;
            var getGetter;

            function ensureMethod(obj, methodName) {
              var fn;
              if (obj != null) fn = obj[methodName];

              if (typeof fn !== "function") {
                var message = "Object " + util.classString(obj) + " has no method '" + util.toString(methodName) + "'";
                throw new Promise.TypeError(message);
              }

              return fn;
            }

            function caller(obj) {
              var methodName = this.pop();
              var fn = ensureMethod(obj, methodName);
              return fn.apply(obj, this);
            }

            Promise.prototype.call = function (methodName) {
              var args = [].slice.call(arguments, 1);
              ;
              args.push(methodName);
              return this._then(caller, undefined, undefined, args, undefined);
            };

            function namedGetter(obj) {
              return obj[this];
            }

            function indexedGetter(obj) {
              var index = +this;
              if (index < 0) index = Math.max(0, index + obj.length);
              return obj[index];
            }

            Promise.prototype.get = function (propertyName) {
              var isIndex = typeof propertyName === "number";
              var getter;

              if (!isIndex) {
                if (canEvaluate) {
                  var maybeGetter = getGetter(propertyName);
                  getter = maybeGetter !== null ? maybeGetter : namedGetter;
                } else {
                  getter = namedGetter;
                }
              } else {
                getter = indexedGetter;
              }

              return this._then(getter, undefined, undefined, propertyName, undefined);
            };
          };
        }, {
          "./util": 36
        }],
        6: [function (_dereq_, module, exports) {
          "use strict";

          module.exports = function (Promise, PromiseArray, apiRejection, debug) {
            var util = _dereq_("./util");

            var tryCatch = util.tryCatch;
            var errorObj = util.errorObj;
            var async = Promise._async;

            Promise.prototype["break"] = Promise.prototype.cancel = function () {
              if (!debug.cancellation()) return this._warn("cancellation is disabled");
              var promise = this;
              var child = promise;

              while (promise._isCancellable()) {
                if (!promise._cancelBy(child)) {
                  if (child._isFollowing()) {
                    child._followee().cancel();
                  } else {
                    child._cancelBranched();
                  }

                  break;
                }

                var parent = promise._cancellationParent;

                if (parent == null || !parent._isCancellable()) {
                  if (promise._isFollowing()) {
                    promise._followee().cancel();
                  } else {
                    promise._cancelBranched();
                  }

                  break;
                } else {
                  if (promise._isFollowing()) promise._followee().cancel();

                  promise._setWillBeCancelled();

                  child = promise;
                  promise = parent;
                }
              }
            };

            Promise.prototype._branchHasCancelled = function () {
              this._branchesRemainingToCancel--;
            };

            Promise.prototype._enoughBranchesHaveCancelled = function () {
              return this._branchesRemainingToCancel === undefined || this._branchesRemainingToCancel <= 0;
            };

            Promise.prototype._cancelBy = function (canceller) {
              if (canceller === this) {
                this._branchesRemainingToCancel = 0;

                this._invokeOnCancel();

                return true;
              } else {
                this._branchHasCancelled();

                if (this._enoughBranchesHaveCancelled()) {
                  this._invokeOnCancel();

                  return true;
                }
              }

              return false;
            };

            Promise.prototype._cancelBranched = function () {
              if (this._enoughBranchesHaveCancelled()) {
                this._cancel();
              }
            };

            Promise.prototype._cancel = function () {
              if (!this._isCancellable()) return;

              this._setCancelled();

              async.invoke(this._cancelPromises, this, undefined);
            };

            Promise.prototype._cancelPromises = function () {
              if (this._length() > 0) this._settlePromises();
            };

            Promise.prototype._unsetOnCancel = function () {
              this._onCancelField = undefined;
            };

            Promise.prototype._isCancellable = function () {
              return this.isPending() && !this._isCancelled();
            };

            Promise.prototype.isCancellable = function () {
              return this.isPending() && !this.isCancelled();
            };

            Promise.prototype._doInvokeOnCancel = function (onCancelCallback, internalOnly) {
              if (util.isArray(onCancelCallback)) {
                for (var i = 0; i < onCancelCallback.length; ++i) {
                  this._doInvokeOnCancel(onCancelCallback[i], internalOnly);
                }
              } else if (onCancelCallback !== undefined) {
                if (typeof onCancelCallback === "function") {
                  if (!internalOnly) {
                    var e = tryCatch(onCancelCallback).call(this._boundValue());

                    if (e === errorObj) {
                      this._attachExtraTrace(e.e);

                      async.throwLater(e.e);
                    }
                  }
                } else {
                  onCancelCallback._resultCancelled(this);
                }
              }
            };

            Promise.prototype._invokeOnCancel = function () {
              var onCancelCallback = this._onCancel();

              this._unsetOnCancel();

              async.invoke(this._doInvokeOnCancel, this, onCancelCallback);
            };

            Promise.prototype._invokeInternalOnCancel = function () {
              if (this._isCancellable()) {
                this._doInvokeOnCancel(this._onCancel(), true);

                this._unsetOnCancel();
              }
            };

            Promise.prototype._resultCancelled = function () {
              this.cancel();
            };
          };
        }, {
          "./util": 36
        }],
        7: [function (_dereq_, module, exports) {
          "use strict";

          module.exports = function (NEXT_FILTER) {
            var util = _dereq_("./util");

            var getKeys = _dereq_("./es5").keys;

            var tryCatch = util.tryCatch;
            var errorObj = util.errorObj;

            function catchFilter(instances, cb, promise) {
              return function (e) {
                var boundTo = promise._boundValue();

                predicateLoop: for (var i = 0; i < instances.length; ++i) {
                  var item = instances[i];

                  if (item === Error || item != null && item.prototype instanceof Error) {
                    if (e instanceof item) {
                      return tryCatch(cb).call(boundTo, e);
                    }
                  } else if (typeof item === "function") {
                    var matchesPredicate = tryCatch(item).call(boundTo, e);

                    if (matchesPredicate === errorObj) {
                      return matchesPredicate;
                    } else if (matchesPredicate) {
                      return tryCatch(cb).call(boundTo, e);
                    }
                  } else if (util.isObject(e)) {
                    var keys = getKeys(item);

                    for (var j = 0; j < keys.length; ++j) {
                      var key = keys[j];

                      if (item[key] != e[key]) {
                        continue predicateLoop;
                      }
                    }

                    return tryCatch(cb).call(boundTo, e);
                  }
                }

                return NEXT_FILTER;
              };
            }

            return catchFilter;
          };
        }, {
          "./es5": 13,
          "./util": 36
        }],
        8: [function (_dereq_, module, exports) {
          "use strict";

          module.exports = function (Promise) {
            var longStackTraces = false;
            var contextStack = [];

            Promise.prototype._promiseCreated = function () {};

            Promise.prototype._pushContext = function () {};

            Promise.prototype._popContext = function () {
              return null;
            };

            Promise._peekContext = Promise.prototype._peekContext = function () {};

            function Context() {
              this._trace = new Context.CapturedTrace(peekContext());
            }

            Context.prototype._pushContext = function () {
              if (this._trace !== undefined) {
                this._trace._promiseCreated = null;
                contextStack.push(this._trace);
              }
            };

            Context.prototype._popContext = function () {
              if (this._trace !== undefined) {
                var trace = contextStack.pop();
                var ret = trace._promiseCreated;
                trace._promiseCreated = null;
                return ret;
              }

              return null;
            };

            function createContext() {
              if (longStackTraces) return new Context();
            }

            function peekContext() {
              var lastIndex = contextStack.length - 1;

              if (lastIndex >= 0) {
                return contextStack[lastIndex];
              }

              return undefined;
            }

            Context.CapturedTrace = null;
            Context.create = createContext;

            Context.deactivateLongStackTraces = function () {};

            Context.activateLongStackTraces = function () {
              var Promise_pushContext = Promise.prototype._pushContext;
              var Promise_popContext = Promise.prototype._popContext;
              var Promise_PeekContext = Promise._peekContext;
              var Promise_peekContext = Promise.prototype._peekContext;
              var Promise_promiseCreated = Promise.prototype._promiseCreated;

              Context.deactivateLongStackTraces = function () {
                Promise.prototype._pushContext = Promise_pushContext;
                Promise.prototype._popContext = Promise_popContext;
                Promise._peekContext = Promise_PeekContext;
                Promise.prototype._peekContext = Promise_peekContext;
                Promise.prototype._promiseCreated = Promise_promiseCreated;
                longStackTraces = false;
              };

              longStackTraces = true;
              Promise.prototype._pushContext = Context.prototype._pushContext;
              Promise.prototype._popContext = Context.prototype._popContext;
              Promise._peekContext = Promise.prototype._peekContext = peekContext;

              Promise.prototype._promiseCreated = function () {
                var ctx = this._peekContext();

                if (ctx && ctx._promiseCreated == null) ctx._promiseCreated = this;
              };
            };

            return Context;
          };
        }, {}],
        9: [function (_dereq_, module, exports) {
          "use strict";

          module.exports = function (Promise, Context) {
            var getDomain = Promise._getDomain;
            var async = Promise._async;

            var Warning = _dereq_("./errors").Warning;

            var util = _dereq_("./util");

            var canAttachTrace = util.canAttachTrace;
            var unhandledRejectionHandled;
            var possiblyUnhandledRejection;
            var bluebirdFramePattern = /[\\\/]bluebird[\\\/]js[\\\/](release|debug|instrumented)/;
            var nodeFramePattern = /\((?:timers\.js):\d+:\d+\)/;
            var parseLinePattern = /[\/<\(](.+?):(\d+):(\d+)\)?\s*$/;
            var stackFramePattern = null;
            var formatStack = null;
            var indentStackFrames = false;
            var printWarning;
            var debugging = !!(util.env("BLUEBIRD_DEBUG") != 0 && (true || util.env("BLUEBIRD_DEBUG") || util.env("NODE_ENV") === "development"));
            var warnings = !!(util.env("BLUEBIRD_WARNINGS") != 0 && (debugging || util.env("BLUEBIRD_WARNINGS")));
            var longStackTraces = !!(util.env("BLUEBIRD_LONG_STACK_TRACES") != 0 && (debugging || util.env("BLUEBIRD_LONG_STACK_TRACES")));
            var wForgottenReturn = util.env("BLUEBIRD_W_FORGOTTEN_RETURN") != 0 && (warnings || !!util.env("BLUEBIRD_W_FORGOTTEN_RETURN"));

            Promise.prototype.suppressUnhandledRejections = function () {
              var target = this._target();

              target._bitField = target._bitField & ~1048576 | 524288;
            };

            Promise.prototype._ensurePossibleRejectionHandled = function () {
              if ((this._bitField & 524288) !== 0) return;

              this._setRejectionIsUnhandled();

              async.invokeLater(this._notifyUnhandledRejection, this, undefined);
            };

            Promise.prototype._notifyUnhandledRejectionIsHandled = function () {
              fireRejectionEvent("rejectionHandled", unhandledRejectionHandled, undefined, this);
            };

            Promise.prototype._setReturnedNonUndefined = function () {
              this._bitField = this._bitField | 268435456;
            };

            Promise.prototype._returnedNonUndefined = function () {
              return (this._bitField & 268435456) !== 0;
            };

            Promise.prototype._notifyUnhandledRejection = function () {
              if (this._isRejectionUnhandled()) {
                var reason = this._settledValue();

                this._setUnhandledRejectionIsNotified();

                fireRejectionEvent("unhandledRejection", possiblyUnhandledRejection, reason, this);
              }
            };

            Promise.prototype._setUnhandledRejectionIsNotified = function () {
              this._bitField = this._bitField | 262144;
            };

            Promise.prototype._unsetUnhandledRejectionIsNotified = function () {
              this._bitField = this._bitField & ~262144;
            };

            Promise.prototype._isUnhandledRejectionNotified = function () {
              return (this._bitField & 262144) > 0;
            };

            Promise.prototype._setRejectionIsUnhandled = function () {
              this._bitField = this._bitField | 1048576;
            };

            Promise.prototype._unsetRejectionIsUnhandled = function () {
              this._bitField = this._bitField & ~1048576;

              if (this._isUnhandledRejectionNotified()) {
                this._unsetUnhandledRejectionIsNotified();

                this._notifyUnhandledRejectionIsHandled();
              }
            };

            Promise.prototype._isRejectionUnhandled = function () {
              return (this._bitField & 1048576) > 0;
            };

            Promise.prototype._warn = function (message, shouldUseOwnTrace, promise) {
              return warn(message, shouldUseOwnTrace, promise || this);
            };

            Promise.onPossiblyUnhandledRejection = function (fn) {
              var domain = getDomain();
              possiblyUnhandledRejection = typeof fn === "function" ? domain === null ? fn : util.domainBind(domain, fn) : undefined;
            };

            Promise.onUnhandledRejectionHandled = function (fn) {
              var domain = getDomain();
              unhandledRejectionHandled = typeof fn === "function" ? domain === null ? fn : util.domainBind(domain, fn) : undefined;
            };

            var disableLongStackTraces = function () {};

            Promise.longStackTraces = function () {
              if (async.haveItemsQueued() && !config.longStackTraces) {
                throw new Error("cannot enable long stack traces after promises have been created\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
              }

              if (!config.longStackTraces && longStackTracesIsSupported()) {
                var Promise_captureStackTrace = Promise.prototype._captureStackTrace;
                var Promise_attachExtraTrace = Promise.prototype._attachExtraTrace;
                config.longStackTraces = true;

                disableLongStackTraces = function () {
                  if (async.haveItemsQueued() && !config.longStackTraces) {
                    throw new Error("cannot enable long stack traces after promises have been created\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
                  }

                  Promise.prototype._captureStackTrace = Promise_captureStackTrace;
                  Promise.prototype._attachExtraTrace = Promise_attachExtraTrace;
                  Context.deactivateLongStackTraces();
                  async.enableTrampoline();
                  config.longStackTraces = false;
                };

                Promise.prototype._captureStackTrace = longStackTracesCaptureStackTrace;
                Promise.prototype._attachExtraTrace = longStackTracesAttachExtraTrace;
                Context.activateLongStackTraces();
                async.disableTrampolineIfNecessary();
              }
            };

            Promise.hasLongStackTraces = function () {
              return config.longStackTraces && longStackTracesIsSupported();
            };

            var fireDomEvent = function () {
              try {
                if (typeof CustomEvent === "function") {
                  var event = new CustomEvent("CustomEvent");
                  util.global.dispatchEvent(event);
                  return function (name, event) {
                    var domEvent = new CustomEvent(name.toLowerCase(), {
                      detail: event,
                      cancelable: true
                    });
                    return !util.global.dispatchEvent(domEvent);
                  };
                } else if (typeof Event === "function") {
                  var event = new Event("CustomEvent");
                  util.global.dispatchEvent(event);
                  return function (name, event) {
                    var domEvent = new Event(name.toLowerCase(), {
                      cancelable: true
                    });
                    domEvent.detail = event;
                    return !util.global.dispatchEvent(domEvent);
                  };
                } else {
                  var event = document.createEvent("CustomEvent");
                  event.initCustomEvent("testingtheevent", false, true, {});
                  util.global.dispatchEvent(event);
                  return function (name, event) {
                    var domEvent = document.createEvent("CustomEvent");
                    domEvent.initCustomEvent(name.toLowerCase(), false, true, event);
                    return !util.global.dispatchEvent(domEvent);
                  };
                }
              } catch (e) {}

              return function () {
                return false;
              };
            }();

            var fireGlobalEvent = function () {
              if (util.isNode) {
                return function () {
                  return process.emit.apply(process, arguments);
                };
              } else {
                if (!util.global) {
                  return function () {
                    return false;
                  };
                }

                return function (name) {
                  var methodName = "on" + name.toLowerCase();
                  var method = util.global[methodName];
                  if (!method) return false;
                  method.apply(util.global, [].slice.call(arguments, 1));
                  return true;
                };
              }
            }();

            function generatePromiseLifecycleEventObject(name, promise) {
              return {
                promise: promise
              };
            }

            var eventToObjectGenerator = {
              promiseCreated: generatePromiseLifecycleEventObject,
              promiseFulfilled: generatePromiseLifecycleEventObject,
              promiseRejected: generatePromiseLifecycleEventObject,
              promiseResolved: generatePromiseLifecycleEventObject,
              promiseCancelled: generatePromiseLifecycleEventObject,
              promiseChained: function (name, promise, child) {
                return {
                  promise: promise,
                  child: child
                };
              },
              warning: function (name, warning) {
                return {
                  warning: warning
                };
              },
              unhandledRejection: function (name, reason, promise) {
                return {
                  reason: reason,
                  promise: promise
                };
              },
              rejectionHandled: generatePromiseLifecycleEventObject
            };

            var activeFireEvent = function (name) {
              var globalEventFired = false;

              try {
                globalEventFired = fireGlobalEvent.apply(null, arguments);
              } catch (e) {
                async.throwLater(e);
                globalEventFired = true;
              }

              var domEventFired = false;

              try {
                domEventFired = fireDomEvent(name, eventToObjectGenerator[name].apply(null, arguments));
              } catch (e) {
                async.throwLater(e);
                domEventFired = true;
              }

              return domEventFired || globalEventFired;
            };

            Promise.config = function (opts) {
              opts = Object(opts);

              if ("longStackTraces" in opts) {
                if (opts.longStackTraces) {
                  Promise.longStackTraces();
                } else if (!opts.longStackTraces && Promise.hasLongStackTraces()) {
                  disableLongStackTraces();
                }
              }

              if ("warnings" in opts) {
                var warningsOption = opts.warnings;
                config.warnings = !!warningsOption;
                wForgottenReturn = config.warnings;

                if (util.isObject(warningsOption)) {
                  if ("wForgottenReturn" in warningsOption) {
                    wForgottenReturn = !!warningsOption.wForgottenReturn;
                  }
                }
              }

              if ("cancellation" in opts && opts.cancellation && !config.cancellation) {
                if (async.haveItemsQueued()) {
                  throw new Error("cannot enable cancellation after promises are in use");
                }

                Promise.prototype._clearCancellationData = cancellationClearCancellationData;
                Promise.prototype._propagateFrom = cancellationPropagateFrom;
                Promise.prototype._onCancel = cancellationOnCancel;
                Promise.prototype._setOnCancel = cancellationSetOnCancel;
                Promise.prototype._attachCancellationCallback = cancellationAttachCancellationCallback;
                Promise.prototype._execute = cancellationExecute;
                propagateFromFunction = cancellationPropagateFrom;
                config.cancellation = true;
              }

              if ("monitoring" in opts) {
                if (opts.monitoring && !config.monitoring) {
                  config.monitoring = true;
                  Promise.prototype._fireEvent = activeFireEvent;
                } else if (!opts.monitoring && config.monitoring) {
                  config.monitoring = false;
                  Promise.prototype._fireEvent = defaultFireEvent;
                }
              }
            };

            function defaultFireEvent() {
              return false;
            }

            Promise.prototype._fireEvent = defaultFireEvent;

            Promise.prototype._execute = function (executor, resolve, reject) {
              try {
                executor(resolve, reject);
              } catch (e) {
                return e;
              }
            };

            Promise.prototype._onCancel = function () {};

            Promise.prototype._setOnCancel = function (handler) {
              ;
            };

            Promise.prototype._attachCancellationCallback = function (onCancel) {
              ;
            };

            Promise.prototype._captureStackTrace = function () {};

            Promise.prototype._attachExtraTrace = function () {};

            Promise.prototype._clearCancellationData = function () {};

            Promise.prototype._propagateFrom = function (parent, flags) {
              ;
              ;
            };

            function cancellationExecute(executor, resolve, reject) {
              var promise = this;

              try {
                executor(resolve, reject, function (onCancel) {
                  if (typeof onCancel !== "function") {
                    throw new TypeError("onCancel must be a function, got: " + util.toString(onCancel));
                  }

                  promise._attachCancellationCallback(onCancel);
                });
              } catch (e) {
                return e;
              }
            }

            function cancellationAttachCancellationCallback(onCancel) {
              if (!this._isCancellable()) return this;

              var previousOnCancel = this._onCancel();

              if (previousOnCancel !== undefined) {
                if (util.isArray(previousOnCancel)) {
                  previousOnCancel.push(onCancel);
                } else {
                  this._setOnCancel([previousOnCancel, onCancel]);
                }
              } else {
                this._setOnCancel(onCancel);
              }
            }

            function cancellationOnCancel() {
              return this._onCancelField;
            }

            function cancellationSetOnCancel(onCancel) {
              this._onCancelField = onCancel;
            }

            function cancellationClearCancellationData() {
              this._cancellationParent = undefined;
              this._onCancelField = undefined;
            }

            function cancellationPropagateFrom(parent, flags) {
              if ((flags & 1) !== 0) {
                this._cancellationParent = parent;
                var branchesRemainingToCancel = parent._branchesRemainingToCancel;

                if (branchesRemainingToCancel === undefined) {
                  branchesRemainingToCancel = 0;
                }

                parent._branchesRemainingToCancel = branchesRemainingToCancel + 1;
              }

              if ((flags & 2) !== 0 && parent._isBound()) {
                this._setBoundTo(parent._boundTo);
              }
            }

            function bindingPropagateFrom(parent, flags) {
              if ((flags & 2) !== 0 && parent._isBound()) {
                this._setBoundTo(parent._boundTo);
              }
            }

            var propagateFromFunction = bindingPropagateFrom;

            function boundValueFunction() {
              var ret = this._boundTo;

              if (ret !== undefined) {
                if (ret instanceof Promise) {
                  if (ret.isFulfilled()) {
                    return ret.value();
                  } else {
                    return undefined;
                  }
                }
              }

              return ret;
            }

            function longStackTracesCaptureStackTrace() {
              this._trace = new CapturedTrace(this._peekContext());
            }

            function longStackTracesAttachExtraTrace(error, ignoreSelf) {
              if (canAttachTrace(error)) {
                var trace = this._trace;

                if (trace !== undefined) {
                  if (ignoreSelf) trace = trace._parent;
                }

                if (trace !== undefined) {
                  trace.attachExtraTrace(error);
                } else if (!error.__P_64_13) {
                  var parsed = parseStackAndMessage(error);
                  util.notEnumerableProp(error, "stack", parsed.message + "\n" + parsed.stack.join("\n"));
                  util.notEnumerableProp(error, "__P_64_13", true);
                }
              }
            }

            function checkForgottenReturns(returnValue, promiseCreated, name, promise, parent) {
              if (returnValue === undefined && promiseCreated !== null && wForgottenReturn) {
                if (parent !== undefined && parent._returnedNonUndefined()) return;
                if ((promise._bitField & 65535) === 0) return;
                if (name) name = name + " ";
                var handlerLine = "";
                var creatorLine = "";

                if (promiseCreated._trace) {
                  var traceLines = promiseCreated._trace.stack.split("\n");

                  var stack = cleanStack(traceLines);

                  for (var i = stack.length - 1; i >= 0; --i) {
                    var line = stack[i];

                    if (!nodeFramePattern.test(line)) {
                      var lineMatches = line.match(parseLinePattern);

                      if (lineMatches) {
                        handlerLine = "at " + lineMatches[1] + ":" + lineMatches[2] + ":" + lineMatches[3] + " ";
                      }

                      break;
                    }
                  }

                  if (stack.length > 0) {
                    var firstUserLine = stack[0];

                    for (var i = 0; i < traceLines.length; ++i) {
                      if (traceLines[i] === firstUserLine) {
                        if (i > 0) {
                          creatorLine = "\n" + traceLines[i - 1];
                        }

                        break;
                      }
                    }
                  }
                }

                var msg = "a promise was created in a " + name + "handler " + handlerLine + "but was not returned from it, " + "see http://goo.gl/rRqMUw" + creatorLine;

                promise._warn(msg, true, promiseCreated);
              }
            }

            function deprecated(name, replacement) {
              var message = name + " is deprecated and will be removed in a future version.";
              if (replacement) message += " Use " + replacement + " instead.";
              return warn(message);
            }

            function warn(message, shouldUseOwnTrace, promise) {
              if (!config.warnings) return;
              var warning = new Warning(message);
              var ctx;

              if (shouldUseOwnTrace) {
                promise._attachExtraTrace(warning);
              } else if (config.longStackTraces && (ctx = Promise._peekContext())) {
                ctx.attachExtraTrace(warning);
              } else {
                var parsed = parseStackAndMessage(warning);
                warning.stack = parsed.message + "\n" + parsed.stack.join("\n");
              }

              if (!activeFireEvent("warning", warning)) {
                formatAndLogError(warning, "", true);
              }
            }

            function reconstructStack(message, stacks) {
              for (var i = 0; i < stacks.length - 1; ++i) {
                stacks[i].push("From previous event:");
                stacks[i] = stacks[i].join("\n");
              }

              if (i < stacks.length) {
                stacks[i] = stacks[i].join("\n");
              }

              return message + "\n" + stacks.join("\n");
            }

            function removeDuplicateOrEmptyJumps(stacks) {
              for (var i = 0; i < stacks.length; ++i) {
                if (stacks[i].length === 0 || i + 1 < stacks.length && stacks[i][0] === stacks[i + 1][0]) {
                  stacks.splice(i, 1);
                  i--;
                }
              }
            }

            function removeCommonRoots(stacks) {
              var current = stacks[0];

              for (var i = 1; i < stacks.length; ++i) {
                var prev = stacks[i];
                var currentLastIndex = current.length - 1;
                var currentLastLine = current[currentLastIndex];
                var commonRootMeetPoint = -1;

                for (var j = prev.length - 1; j >= 0; --j) {
                  if (prev[j] === currentLastLine) {
                    commonRootMeetPoint = j;
                    break;
                  }
                }

                for (var j = commonRootMeetPoint; j >= 0; --j) {
                  var line = prev[j];

                  if (current[currentLastIndex] === line) {
                    current.pop();
                    currentLastIndex--;
                  } else {
                    break;
                  }
                }

                current = prev;
              }
            }

            function cleanStack(stack) {
              var ret = [];

              for (var i = 0; i < stack.length; ++i) {
                var line = stack[i];
                var isTraceLine = "    (No stack trace)" === line || stackFramePattern.test(line);
                var isInternalFrame = isTraceLine && shouldIgnore(line);

                if (isTraceLine && !isInternalFrame) {
                  if (indentStackFrames && line.charAt(0) !== " ") {
                    line = "    " + line;
                  }

                  ret.push(line);
                }
              }

              return ret;
            }

            function stackFramesAsArray(error) {
              var stack = error.stack.replace(/\s+$/g, "").split("\n");

              for (var i = 0; i < stack.length; ++i) {
                var line = stack[i];

                if ("    (No stack trace)" === line || stackFramePattern.test(line)) {
                  break;
                }
              }

              if (i > 0) {
                stack = stack.slice(i);
              }

              return stack;
            }

            function parseStackAndMessage(error) {
              var stack = error.stack;
              var message = error.toString();
              stack = typeof stack === "string" && stack.length > 0 ? stackFramesAsArray(error) : ["    (No stack trace)"];
              return {
                message: message,
                stack: cleanStack(stack)
              };
            }

            function formatAndLogError(error, title, isSoft) {
              if (typeof console !== "undefined") {
                var message;

                if (util.isObject(error)) {
                  var stack = error.stack;
                  message = title + formatStack(stack, error);
                } else {
                  message = title + String(error);
                }

                if (typeof printWarning === "function") {
                  printWarning(message, isSoft);
                } else if (typeof console.log === "function" || typeof console.log === "object") {
                  console.log(message);
                }
              }
            }

            function fireRejectionEvent(name, localHandler, reason, promise) {
              var localEventFired = false;

              try {
                if (typeof localHandler === "function") {
                  localEventFired = true;

                  if (name === "rejectionHandled") {
                    localHandler(promise);
                  } else {
                    localHandler(reason, promise);
                  }
                }
              } catch (e) {
                async.throwLater(e);
              }

              if (name === "unhandledRejection") {
                if (!activeFireEvent(name, reason, promise) && !localEventFired) {
                  formatAndLogError(reason, "Unhandled rejection ");
                }
              } else {
                activeFireEvent(name, promise);
              }
            }

            function formatNonError(obj) {
              var str;

              if (typeof obj === "function") {
                str = "[function " + (obj.name || "anonymous") + "]";
              } else {
                str = obj && typeof obj.toString === "function" ? obj.toString() : util.toString(obj);
                var ruselessToString = /\[object [a-zA-Z0-9$_]+\]/;

                if (ruselessToString.test(str)) {
                  try {
                    var newStr = JSON.stringify(obj);
                    str = newStr;
                  } catch (e) {}
                }

                if (str.length === 0) {
                  str = "(empty array)";
                }
              }

              return "(<" + snip(str) + ">, no stack trace)";
            }

            function snip(str) {
              var maxChars = 41;

              if (str.length < maxChars) {
                return str;
              }

              return str.substr(0, maxChars - 3) + "...";
            }

            function longStackTracesIsSupported() {
              return typeof captureStackTrace === "function";
            }

            var shouldIgnore = function () {
              return false;
            };

            var parseLineInfoRegex = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;

            function parseLineInfo(line) {
              var matches = line.match(parseLineInfoRegex);

              if (matches) {
                return {
                  fileName: matches[1],
                  line: parseInt(matches[2], 10)
                };
              }
            }

            function setBounds(firstLineError, lastLineError) {
              if (!longStackTracesIsSupported()) return;
              var firstStackLines = firstLineError.stack.split("\n");
              var lastStackLines = lastLineError.stack.split("\n");
              var firstIndex = -1;
              var lastIndex = -1;
              var firstFileName;
              var lastFileName;

              for (var i = 0; i < firstStackLines.length; ++i) {
                var result = parseLineInfo(firstStackLines[i]);

                if (result) {
                  firstFileName = result.fileName;
                  firstIndex = result.line;
                  break;
                }
              }

              for (var i = 0; i < lastStackLines.length; ++i) {
                var result = parseLineInfo(lastStackLines[i]);

                if (result) {
                  lastFileName = result.fileName;
                  lastIndex = result.line;
                  break;
                }
              }

              if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName || firstFileName !== lastFileName || firstIndex >= lastIndex) {
                return;
              }

              shouldIgnore = function (line) {
                if (bluebirdFramePattern.test(line)) return true;
                var info = parseLineInfo(line);

                if (info) {
                  if (info.fileName === firstFileName && firstIndex <= info.line && info.line <= lastIndex) {
                    return true;
                  }
                }

                return false;
              };
            }

            function CapturedTrace(parent) {
              this._parent = parent;
              this._promisesCreated = 0;
              var length = this._length = 1 + (parent === undefined ? 0 : parent._length);
              captureStackTrace(this, CapturedTrace);
              if (length > 32) this.uncycle();
            }

            util.inherits(CapturedTrace, Error);
            Context.CapturedTrace = CapturedTrace;

            CapturedTrace.prototype.uncycle = function () {
              var length = this._length;
              if (length < 2) return;
              var nodes = [];
              var stackToIndex = {};

              for (var i = 0, node = this; node !== undefined; ++i) {
                nodes.push(node);
                node = node._parent;
              }

              length = this._length = i;

              for (var i = length - 1; i >= 0; --i) {
                var stack = nodes[i].stack;

                if (stackToIndex[stack] === undefined) {
                  stackToIndex[stack] = i;
                }
              }

              for (var i = 0; i < length; ++i) {
                var currentStack = nodes[i].stack;
                var index = stackToIndex[currentStack];

                if (index !== undefined && index !== i) {
                  if (index > 0) {
                    nodes[index - 1]._parent = undefined;
                    nodes[index - 1]._length = 1;
                  }

                  nodes[i]._parent = undefined;
                  nodes[i]._length = 1;
                  var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;

                  if (index < length - 1) {
                    cycleEdgeNode._parent = nodes[index + 1];

                    cycleEdgeNode._parent.uncycle();

                    cycleEdgeNode._length = cycleEdgeNode._parent._length + 1;
                  } else {
                    cycleEdgeNode._parent = undefined;
                    cycleEdgeNode._length = 1;
                  }

                  var currentChildLength = cycleEdgeNode._length + 1;

                  for (var j = i - 2; j >= 0; --j) {
                    nodes[j]._length = currentChildLength;
                    currentChildLength++;
                  }

                  return;
                }
              }
            };

            CapturedTrace.prototype.attachExtraTrace = function (error) {
              if (error.__P_64_13) return;
              this.uncycle();
              var parsed = parseStackAndMessage(error);
              var message = parsed.message;
              var stacks = [parsed.stack];
              var trace = this;

              while (trace !== undefined) {
                stacks.push(cleanStack(trace.stack.split("\n")));
                trace = trace._parent;
              }

              removeCommonRoots(stacks);
              removeDuplicateOrEmptyJumps(stacks);
              util.notEnumerableProp(error, "stack", reconstructStack(message, stacks));
              util.notEnumerableProp(error, "__P_64_13", true);
            };

            var captureStackTrace = function stackDetection() {
              var v8stackFramePattern = /^\s*at\s*/;

              var v8stackFormatter = function (stack, error) {
                if (typeof stack === "string") return stack;

                if (error.name !== undefined && error.message !== undefined) {
                  return error.toString();
                }

                return formatNonError(error);
              };

              if (typeof Error.stackTraceLimit === "number" && typeof Error.captureStackTrace === "function") {
                Error.stackTraceLimit += 6;
                stackFramePattern = v8stackFramePattern;
                formatStack = v8stackFormatter;
                var captureStackTrace = Error.captureStackTrace;

                shouldIgnore = function (line) {
                  return bluebirdFramePattern.test(line);
                };

                return function (receiver, ignoreUntil) {
                  Error.stackTraceLimit += 6;
                  captureStackTrace(receiver, ignoreUntil);
                  Error.stackTraceLimit -= 6;
                };
              }

              var err = new Error();

              if (typeof err.stack === "string" && err.stack.split("\n")[0].indexOf("stackDetection@") >= 0) {
                stackFramePattern = /@/;
                formatStack = v8stackFormatter;
                indentStackFrames = true;
                return function captureStackTrace(o) {
                  o.stack = new Error().stack;
                };
              }

              var hasStackAfterThrow;

              try {
                throw new Error();
              } catch (e) {
                hasStackAfterThrow = "stack" in e;
              }

              if (!("stack" in err) && hasStackAfterThrow && typeof Error.stackTraceLimit === "number") {
                stackFramePattern = v8stackFramePattern;
                formatStack = v8stackFormatter;
                return function captureStackTrace(o) {
                  Error.stackTraceLimit += 6;

                  try {
                    throw new Error();
                  } catch (e) {
                    o.stack = e.stack;
                  }

                  Error.stackTraceLimit -= 6;
                };
              }

              formatStack = function (stack, error) {
                if (typeof stack === "string") return stack;

                if ((typeof error === "object" || typeof error === "function") && error.name !== undefined && error.message !== undefined) {
                  return error.toString();
                }

                return formatNonError(error);
              };

              return null;
            }([]);

            if (typeof console !== "undefined" && typeof console.warn !== "undefined") {
              printWarning = function (message) {
                console.warn(message);
              };

              if (util.isNode && process.stderr.isTTY) {
                printWarning = function (message, isSoft) {
                  var color = isSoft ? "\u001b[33m" : "\u001b[31m";
                  console.warn(color + message + "\u001b[0m\n");
                };
              } else if (!util.isNode && typeof new Error().stack === "string") {
                printWarning = function (message, isSoft) {
                  console.warn("%c" + message, isSoft ? "color: darkorange" : "color: red");
                };
              }
            }

            var config = {
              warnings: warnings,
              longStackTraces: false,
              cancellation: false,
              monitoring: false
            };
            if (longStackTraces) Promise.longStackTraces();
            return {
              longStackTraces: function () {
                return config.longStackTraces;
              },
              warnings: function () {
                return config.warnings;
              },
              cancellation: function () {
                return config.cancellation;
              },
              monitoring: function () {
                return config.monitoring;
              },
              propagateFromFunction: function () {
                return propagateFromFunction;
              },
              boundValueFunction: function () {
                return boundValueFunction;
              },
              checkForgottenReturns: checkForgottenReturns,
              setBounds: setBounds,
              warn: warn,
              deprecated: deprecated,
              CapturedTrace: CapturedTrace,
              fireDomEvent: fireDomEvent,
              fireGlobalEvent: fireGlobalEvent
            };
          };
        }, {
          "./errors": 12,
          "./util": 36
        }],
        10: [function (_dereq_, module, exports) {
          "use strict";

          module.exports = function (Promise) {
            function returner() {
              return this.value;
            }

            function thrower() {
              throw this.reason;
            }

            Promise.prototype["return"] = Promise.prototype.thenReturn = function (value) {
              if (value instanceof Promise) value.suppressUnhandledRejections();
              return this._then(returner, undefined, undefined, {
                value: value
              }, undefined);
            };

            Promise.prototype["throw"] = Promise.prototype.thenThrow = function (reason) {
              return this._then(thrower, undefined, undefined, {
                reason: reason
              }, undefined);
            };

            Promise.prototype.catchThrow = function (reason) {
              if (arguments.length <= 1) {
                return this._then(undefined, thrower, undefined, {
                  reason: reason
                }, undefined);
              } else {
                var _reason = arguments[1];

                var handler = function () {
                  throw _reason;
                };

                return this.caught(reason, handler);
              }
            };

            Promise.prototype.catchReturn = function (value) {
              if (arguments.length <= 1) {
                if (value instanceof Promise) value.suppressUnhandledRejections();
                return this._then(undefined, returner, undefined, {
                  value: value
                }, undefined);
              } else {
                var _value = arguments[1];
                if (_value instanceof Promise) _value.suppressUnhandledRejections();

                var handler = function () {
                  return _value;
                };

                return this.caught(value, handler);
              }
            };
          };
        }, {}],
        11: [function (_dereq_, module, exports) {
          "use strict";

          module.exports = function (Promise, INTERNAL) {
            var PromiseReduce = Promise.reduce;
            var PromiseAll = Promise.all;

            function promiseAllThis() {
              return PromiseAll(this);
            }

            function PromiseMapSeries(promises, fn) {
              return PromiseReduce(promises, fn, INTERNAL, INTERNAL);
            }

            Promise.prototype.each = function (fn) {
              return PromiseReduce(this, fn, INTERNAL, 0)._then(promiseAllThis, undefined, undefined, this, undefined);
            };

            Promise.prototype.mapSeries = function (fn) {
              return PromiseReduce(this, fn, INTERNAL, INTERNAL);
            };

            Promise.each = function (promises, fn) {
              return PromiseReduce(promises, fn, INTERNAL, 0)._then(promiseAllThis, undefined, undefined, promises, undefined);
            };

            Promise.mapSeries = PromiseMapSeries;
          };
        }, {}],
        12: [function (_dereq_, module, exports) {
          "use strict";

          var es5 = _dereq_("./es5");

          var Objectfreeze = es5.freeze;

          var util = _dereq_("./util");

          var inherits = util.inherits;
          var notEnumerableProp = util.notEnumerableProp;

          function subError(nameProperty, defaultMessage) {
            function SubError(message) {
              if (!(this instanceof SubError)) return new SubError(message);
              notEnumerableProp(this, "message", typeof message === "string" ? message : defaultMessage);
              notEnumerableProp(this, "name", nameProperty);

              if (Error.captureStackTrace) {
                Error.captureStackTrace(this, this.constructor);
              } else {
                Error.call(this);
              }
            }

            inherits(SubError, Error);
            return SubError;
          }

          var _TypeError, _RangeError;

          var Warning = subError("Warning", "warning");
          var CancellationError = subError("CancellationError", "cancellation error");
          var TimeoutError = subError("TimeoutError", "timeout error");
          var AggregateError = subError("AggregateError", "aggregate error");

          try {
            _TypeError = TypeError;
            _RangeError = RangeError;
          } catch (e) {
            _TypeError = subError("TypeError", "type error");
            _RangeError = subError("RangeError", "range error");
          }

          var methods = "join pop push shift unshift slice filter forEach some every map indexOf lastIndexOf reduce reduceRight sort reverse".split(" ");

          for (var i = 0; i < methods.length; ++i) {
            if (typeof Array.prototype[methods[i]] === "function") {
              AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];
            }
          }

          es5.defineProperty(AggregateError.prototype, "length", {
            value: 0,
            configurable: false,
            writable: true,
            enumerable: true
          });
          AggregateError.prototype["isOperational"] = true;
          var level = 0;

          AggregateError.prototype.toString = function () {
            var indent = Array(level * 4 + 1).join(" ");
            var ret = "\n" + indent + "AggregateError of:" + "\n";
            level++;
            indent = Array(level * 4 + 1).join(" ");

            for (var i = 0; i < this.length; ++i) {
              var str = this[i] === this ? "[Circular AggregateError]" : this[i] + "";
              var lines = str.split("\n");

              for (var j = 0; j < lines.length; ++j) {
                lines[j] = indent + lines[j];
              }

              str = lines.join("\n");
              ret += str + "\n";
            }

            level--;
            return ret;
          };

          function OperationalError(message) {
            if (!(this instanceof OperationalError)) return new OperationalError(message);
            notEnumerableProp(this, "name", "OperationalError");
            notEnumerableProp(this, "message", message);
            this.cause = message;
            this["isOperational"] = true;

            if (message instanceof Error) {
              notEnumerableProp(this, "message", message.message);
              notEnumerableProp(this, "stack", message.stack);
            } else if (Error.captureStackTrace) {
              Error.captureStackTrace(this, this.constructor);
            }
          }

          inherits(OperationalError, Error);
          var errorTypes = Error["__BluebirdErrorTypes__"];

          if (!errorTypes) {
            errorTypes = Objectfreeze({
              CancellationError: CancellationError,
              TimeoutError: TimeoutError,
              OperationalError: OperationalError,
              RejectionError: OperationalError,
              AggregateError: AggregateError
            });
            es5.defineProperty(Error, "__BluebirdErrorTypes__", {
              value: errorTypes,
              writable: false,
              enumerable: false,
              configurable: false
            });
          }

          module.exports = {
            Error: Error,
            TypeError: _TypeError,
            RangeError: _RangeError,
            CancellationError: errorTypes.CancellationError,
            OperationalError: errorTypes.OperationalError,
            TimeoutError: errorTypes.TimeoutError,
            AggregateError: errorTypes.AggregateError,
            Warning: Warning
          };
        }, {
          "./es5": 13,
          "./util": 36
        }],
        13: [function (_dereq_, module, exports) {
          var isES5 = function () {
            "use strict";

            return this === undefined;
          }();

          if (isES5) {
            module.exports = {
              freeze: Object.freeze,
              defineProperty: Object.defineProperty,
              getDescriptor: Object.getOwnPropertyDescriptor,
              keys: Object.keys,
              names: Object.getOwnPropertyNames,
              getPrototypeOf: Object.getPrototypeOf,
              isArray: Array.isArray,
              isES5: isES5,
              propertyIsWritable: function (obj, prop) {
                var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
                return !!(!descriptor || descriptor.writable || descriptor.set);
              }
            };
          } else {
            var has = {}.hasOwnProperty;
            var str = {}.toString;
            var proto = {}.constructor.prototype;

            var ObjectKeys = function (o) {
              var ret = [];

              for (var key in o) {
                if (has.call(o, key)) {
                  ret.push(key);
                }
              }

              return ret;
            };

            var ObjectGetDescriptor = function (o, key) {
              return {
                value: o[key]
              };
            };

            var ObjectDefineProperty = function (o, key, desc) {
              o[key] = desc.value;
              return o;
            };

            var ObjectFreeze = function (obj) {
              return obj;
            };

            var ObjectGetPrototypeOf = function (obj) {
              try {
                return Object(obj).constructor.prototype;
              } catch (e) {
                return proto;
              }
            };

            var ArrayIsArray = function (obj) {
              try {
                return str.call(obj) === "[object Array]";
              } catch (e) {
                return false;
              }
            };

            module.exports = {
              isArray: ArrayIsArray,
              keys: ObjectKeys,
              names: ObjectKeys,
              defineProperty: ObjectDefineProperty,
              getDescriptor: ObjectGetDescriptor,
              freeze: ObjectFreeze,
              getPrototypeOf: ObjectGetPrototypeOf,
              isES5: isES5,
              propertyIsWritable: function () {
                return true;
              }
            };
          }
        }, {}],
        14: [function (_dereq_, module, exports) {
          "use strict";

          module.exports = function (Promise, INTERNAL) {
            var PromiseMap = Promise.map;

            Promise.prototype.filter = function (fn, options) {
              return PromiseMap(this, fn, options, INTERNAL);
            };

            Promise.filter = function (promises, fn, options) {
              return PromiseMap(promises, fn, options, INTERNAL);
            };
          };
        }, {}],
        15: [function (_dereq_, module, exports) {
          "use strict";

          module.exports = function (Promise, tryConvertToPromise) {
            var util = _dereq_("./util");

            var CancellationError = Promise.CancellationError;
            var errorObj = util.errorObj;

            function PassThroughHandlerContext(promise, type, handler) {
              this.promise = promise;
              this.type = type;
              this.handler = handler;
              this.called = false;
              this.cancelPromise = null;
            }

            PassThroughHandlerContext.prototype.isFinallyHandler = function () {
              return this.type === 0;
            };

            function FinallyHandlerCancelReaction(finallyHandler) {
              this.finallyHandler = finallyHandler;
            }

            FinallyHandlerCancelReaction.prototype._resultCancelled = function () {
              checkCancel(this.finallyHandler);
            };

            function checkCancel(ctx, reason) {
              if (ctx.cancelPromise != null) {
                if (arguments.length > 1) {
                  ctx.cancelPromise._reject(reason);
                } else {
                  ctx.cancelPromise._cancel();
                }

                ctx.cancelPromise = null;
                return true;
              }

              return false;
            }

            function succeed() {
              return finallyHandler.call(this, this.promise._target()._settledValue());
            }

            function fail(reason) {
              if (checkCancel(this, reason)) return;
              errorObj.e = reason;
              return errorObj;
            }

            function finallyHandler(reasonOrValue) {
              var promise = this.promise;
              var handler = this.handler;

              if (!this.called) {
                this.called = true;
                var ret = this.isFinallyHandler() ? handler.call(promise._boundValue()) : handler.call(promise._boundValue(), reasonOrValue);

                if (ret !== undefined) {
                  promise._setReturnedNonUndefined();

                  var maybePromise = tryConvertToPromise(ret, promise);

                  if (maybePromise instanceof Promise) {
                    if (this.cancelPromise != null) {
                      if (maybePromise._isCancelled()) {
                        var reason = new CancellationError("late cancellation observer");

                        promise._attachExtraTrace(reason);

                        errorObj.e = reason;
                        return errorObj;
                      } else if (maybePromise.isPending()) {
                        maybePromise._attachCancellationCallback(new FinallyHandlerCancelReaction(this));
                      }
                    }

                    return maybePromise._then(succeed, fail, undefined, this, undefined);
                  }
                }
              }

              if (promise.isRejected()) {
                checkCancel(this);
                errorObj.e = reasonOrValue;
                return errorObj;
              } else {
                checkCancel(this);
                return reasonOrValue;
              }
            }

            Promise.prototype._passThrough = function (handler, type, success, fail) {
              if (typeof handler !== "function") return this.then();
              return this._then(success, fail, undefined, new PassThroughHandlerContext(this, type, handler), undefined);
            };

            Promise.prototype.lastly = Promise.prototype["finally"] = function (handler) {
              return this._passThrough(handler, 0, finallyHandler, finallyHandler);
            };

            Promise.prototype.tap = function (handler) {
              return this._passThrough(handler, 1, finallyHandler);
            };

            return PassThroughHandlerContext;
          };
        }, {
          "./util": 36
        }],
        16: [function (_dereq_, module, exports) {
          "use strict";

          module.exports = function (Promise, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug) {
            var errors = _dereq_("./errors");

            var TypeError = errors.TypeError;

            var util = _dereq_("./util");

            var errorObj = util.errorObj;
            var tryCatch = util.tryCatch;
            var yieldHandlers = [];

            function promiseFromYieldHandler(value, yieldHandlers, traceParent) {
              for (var i = 0; i < yieldHandlers.length; ++i) {
                traceParent._pushContext();

                var result = tryCatch(yieldHandlers[i])(value);

                traceParent._popContext();

                if (result === errorObj) {
                  traceParent._pushContext();

                  var ret = Promise.reject(errorObj.e);

                  traceParent._popContext();

                  return ret;
                }

                var maybePromise = tryConvertToPromise(result, traceParent);
                if (maybePromise instanceof Promise) return maybePromise;
              }

              return null;
            }

            function PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {
              if (debug.cancellation()) {
                var internal = new Promise(INTERNAL);

                var _finallyPromise = this._finallyPromise = new Promise(INTERNAL);

                this._promise = internal.lastly(function () {
                  return _finallyPromise;
                });

                internal._captureStackTrace();

                internal._setOnCancel(this);
              } else {
                var promise = this._promise = new Promise(INTERNAL);

                promise._captureStackTrace();
              }

              this._stack = stack;
              this._generatorFunction = generatorFunction;
              this._receiver = receiver;
              this._generator = undefined;
              this._yieldHandlers = typeof yieldHandler === "function" ? [yieldHandler].concat(yieldHandlers) : yieldHandlers;
              this._yieldedPromise = null;
              this._cancellationPhase = false;
            }

            util.inherits(PromiseSpawn, Proxyable);

            PromiseSpawn.prototype._isResolved = function () {
              return this._promise === null;
            };

            PromiseSpawn.prototype._cleanup = function () {
              this._promise = this._generator = null;

              if (debug.cancellation() && this._finallyPromise !== null) {
                this._finallyPromise._fulfill();

                this._finallyPromise = null;
              }
            };

            PromiseSpawn.prototype._promiseCancelled = function () {
              if (this._isResolved()) return;
              var implementsReturn = typeof this._generator["return"] !== "undefined";
              var result;

              if (!implementsReturn) {
                var reason = new Promise.CancellationError("generator .return() sentinel");
                Promise.coroutine.returnSentinel = reason;

                this._promise._attachExtraTrace(reason);

                this._promise._pushContext();

                result = tryCatch(this._generator["throw"]).call(this._generator, reason);

                this._promise._popContext();
              } else {
                this._promise._pushContext();

                result = tryCatch(this._generator["return"]).call(this._generator, undefined);

                this._promise._popContext();
              }

              this._cancellationPhase = true;
              this._yieldedPromise = null;

              this._continue(result);
            };

            PromiseSpawn.prototype._promiseFulfilled = function (value) {
              this._yieldedPromise = null;

              this._promise._pushContext();

              var result = tryCatch(this._generator.next).call(this._generator, value);

              this._promise._popContext();

              this._continue(result);
            };

            PromiseSpawn.prototype._promiseRejected = function (reason) {
              this._yieldedPromise = null;

              this._promise._attachExtraTrace(reason);

              this._promise._pushContext();

              var result = tryCatch(this._generator["throw"]).call(this._generator, reason);

              this._promise._popContext();

              this._continue(result);
            };

            PromiseSpawn.prototype._resultCancelled = function () {
              if (this._yieldedPromise instanceof Promise) {
                var promise = this._yieldedPromise;
                this._yieldedPromise = null;
                promise.cancel();
              }
            };

            PromiseSpawn.prototype.promise = function () {
              return this._promise;
            };

            PromiseSpawn.prototype._run = function () {
              this._generator = this._generatorFunction.call(this._receiver);
              this._receiver = this._generatorFunction = undefined;

              this._promiseFulfilled(undefined);
            };

            PromiseSpawn.prototype._continue = function (result) {
              var promise = this._promise;

              if (result === errorObj) {
                this._cleanup();

                if (this._cancellationPhase) {
                  return promise.cancel();
                } else {
                  return promise._rejectCallback(result.e, false);
                }
              }

              var value = result.value;

              if (result.done === true) {
                this._cleanup();

                if (this._cancellationPhase) {
                  return promise.cancel();
                } else {
                  return promise._resolveCallback(value);
                }
              } else {
                var maybePromise = tryConvertToPromise(value, this._promise);

                if (!(maybePromise instanceof Promise)) {
                  maybePromise = promiseFromYieldHandler(maybePromise, this._yieldHandlers, this._promise);

                  if (maybePromise === null) {
                    this._promiseRejected(new TypeError("A value %s was yielded that could not be treated as a promise\u000a\u000a    See http://goo.gl/MqrFmX\u000a\u000a".replace("%s", value) + "From coroutine:\u000a" + this._stack.split("\n").slice(1, -7).join("\n")));

                    return;
                  }
                }

                maybePromise = maybePromise._target();
                var bitField = maybePromise._bitField;
                ;

                if ((bitField & 50397184) === 0) {
                  this._yieldedPromise = maybePromise;

                  maybePromise._proxy(this, null);
                } else if ((bitField & 33554432) !== 0) {
                  Promise._async.invoke(this._promiseFulfilled, this, maybePromise._value());
                } else if ((bitField & 16777216) !== 0) {
                  Promise._async.invoke(this._promiseRejected, this, maybePromise._reason());
                } else {
                  this._promiseCancelled();
                }
              }
            };

            Promise.coroutine = function (generatorFunction, options) {
              if (typeof generatorFunction !== "function") {
                throw new TypeError("generatorFunction must be a function\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
              }

              var yieldHandler = Object(options).yieldHandler;
              var PromiseSpawn$ = PromiseSpawn;
              var stack = new Error().stack;
              return function () {
                var generator = generatorFunction.apply(this, arguments);
                var spawn = new PromiseSpawn$(undefined, undefined, yieldHandler, stack);
                var ret = spawn.promise();
                spawn._generator = generator;

                spawn._promiseFulfilled(undefined);

                return ret;
              };
            };

            Promise.coroutine.addYieldHandler = function (fn) {
              if (typeof fn !== "function") {
                throw new TypeError("expecting a function but got " + util.classString(fn));
              }

              yieldHandlers.push(fn);
            };

            Promise.spawn = function (generatorFunction) {
              debug.deprecated("Promise.spawn()", "Promise.coroutine()");

              if (typeof generatorFunction !== "function") {
                return apiRejection("generatorFunction must be a function\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
              }

              var spawn = new PromiseSpawn(generatorFunction, this);
              var ret = spawn.promise();

              spawn._run(Promise.spawn);

              return ret;
            };
          };
        }, {
          "./errors": 12,
          "./util": 36
        }],
        17: [function (_dereq_, module, exports) {
          "use strict";

          module.exports = function (Promise, PromiseArray, tryConvertToPromise, INTERNAL, async, getDomain) {
            var util = _dereq_("./util");

            var canEvaluate = util.canEvaluate;
            var tryCatch = util.tryCatch;
            var errorObj = util.errorObj;
            var reject;

            Promise.join = function () {
              var last = arguments.length - 1;
              var fn;

              if (last > 0 && typeof arguments[last] === "function") {
                fn = arguments[last];
              }

              var args = [].slice.call(arguments);
              ;
              if (fn) args.pop();
              var ret = new PromiseArray(args).promise();
              return fn !== undefined ? ret.spread(fn) : ret;
            };
          };
        }, {
          "./util": 36
        }],
        18: [function (_dereq_, module, exports) {
          "use strict";

          module.exports = function (Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug) {
            var getDomain = Promise._getDomain;

            var util = _dereq_("./util");

            var tryCatch = util.tryCatch;
            var errorObj = util.errorObj;

            function MappingPromiseArray(promises, fn, limit, _filter) {
              this.constructor$(promises);

              this._promise._captureStackTrace();

              var domain = getDomain();
              this._callback = domain === null ? fn : util.domainBind(domain, fn);
              this._preservedValues = _filter === INTERNAL ? new Array(this.length()) : null;
              this._limit = limit;
              this._inFlight = 0;
              this._queue = [];

              this._init$(undefined, -2);
            }

            util.inherits(MappingPromiseArray, PromiseArray);

            MappingPromiseArray.prototype._init = function () {};

            MappingPromiseArray.prototype._promiseFulfilled = function (value, index) {
              var values = this._values;
              var length = this.length();
              var preservedValues = this._preservedValues;
              var limit = this._limit;

              if (index < 0) {
                index = index * -1 - 1;
                values[index] = value;

                if (limit >= 1) {
                  this._inFlight--;

                  this._drainQueue();

                  if (this._isResolved()) return true;
                }
              } else {
                if (limit >= 1 && this._inFlight >= limit) {
                  values[index] = value;

                  this._queue.push(index);

                  return false;
                }

                if (preservedValues !== null) preservedValues[index] = value;
                var promise = this._promise;
                var callback = this._callback;

                var receiver = promise._boundValue();

                promise._pushContext();

                var ret = tryCatch(callback).call(receiver, value, index, length);

                var promiseCreated = promise._popContext();

                debug.checkForgottenReturns(ret, promiseCreated, preservedValues !== null ? "Promise.filter" : "Promise.map", promise);

                if (ret === errorObj) {
                  this._reject(ret.e);

                  return true;
                }

                var maybePromise = tryConvertToPromise(ret, this._promise);

                if (maybePromise instanceof Promise) {
                  maybePromise = maybePromise._target();
                  var bitField = maybePromise._bitField;
                  ;

                  if ((bitField & 50397184) === 0) {
                    if (limit >= 1) this._inFlight++;
                    values[index] = maybePromise;

                    maybePromise._proxy(this, (index + 1) * -1);

                    return false;
                  } else if ((bitField & 33554432) !== 0) {
                    ret = maybePromise._value();
                  } else if ((bitField & 16777216) !== 0) {
                    this._reject(maybePromise._reason());

                    return true;
                  } else {
                    this._cancel();

                    return true;
                  }
                }

                values[index] = ret;
              }

              var totalResolved = ++this._totalResolved;

              if (totalResolved >= length) {
                if (preservedValues !== null) {
                  this._filter(values, preservedValues);
                } else {
                  this._resolve(values);
                }

                return true;
              }

              return false;
            };

            MappingPromiseArray.prototype._drainQueue = function () {
              var queue = this._queue;
              var limit = this._limit;
              var values = this._values;

              while (queue.length > 0 && this._inFlight < limit) {
                if (this._isResolved()) return;
                var index = queue.pop();

                this._promiseFulfilled(values[index], index);
              }
            };

            MappingPromiseArray.prototype._filter = function (booleans, values) {
              var len = values.length;
              var ret = new Array(len);
              var j = 0;

              for (var i = 0; i < len; ++i) {
                if (booleans[i]) ret[j++] = values[i];
              }

              ret.length = j;

              this._resolve(ret);
            };

            MappingPromiseArray.prototype.preservedValues = function () {
              return this._preservedValues;
            };

            function map(promises, fn, options, _filter) {
              if (typeof fn !== "function") {
                return apiRejection("expecting a function but got " + util.classString(fn));
              }

              var limit = 0;

              if (options !== undefined) {
                if (typeof options === "object" && options !== null) {
                  if (typeof options.concurrency !== "number") {
                    return Promise.reject(new TypeError("'concurrency' must be a number but it is " + util.classString(options.concurrency)));
                  }

                  limit = options.concurrency;
                } else {
                  return Promise.reject(new TypeError("options argument must be an object but it is " + util.classString(options)));
                }
              }

              limit = typeof limit === "number" && isFinite(limit) && limit >= 1 ? limit : 0;
              return new MappingPromiseArray(promises, fn, limit, _filter).promise();
            }

            Promise.prototype.map = function (fn, options) {
              return map(this, fn, options, null);
            };

            Promise.map = function (promises, fn, options, _filter) {
              return map(promises, fn, options, _filter);
            };
          };
        }, {
          "./util": 36
        }],
        19: [function (_dereq_, module, exports) {
          "use strict";

          module.exports = function (Promise, INTERNAL, tryConvertToPromise, apiRejection, debug) {
            var util = _dereq_("./util");

            var tryCatch = util.tryCatch;

            Promise.method = function (fn) {
              if (typeof fn !== "function") {
                throw new Promise.TypeError("expecting a function but got " + util.classString(fn));
              }

              return function () {
                var ret = new Promise(INTERNAL);

                ret._captureStackTrace();

                ret._pushContext();

                var value = tryCatch(fn).apply(this, arguments);

                var promiseCreated = ret._popContext();

                debug.checkForgottenReturns(value, promiseCreated, "Promise.method", ret);

                ret._resolveFromSyncValue(value);

                return ret;
              };
            };

            Promise.attempt = Promise["try"] = function (fn) {
              if (typeof fn !== "function") {
                return apiRejection("expecting a function but got " + util.classString(fn));
              }

              var ret = new Promise(INTERNAL);

              ret._captureStackTrace();

              ret._pushContext();

              var value;

              if (arguments.length > 1) {
                debug.deprecated("calling Promise.try with more than 1 argument");
                var arg = arguments[1];
                var ctx = arguments[2];
                value = util.isArray(arg) ? tryCatch(fn).apply(ctx, arg) : tryCatch(fn).call(ctx, arg);
              } else {
                value = tryCatch(fn)();
              }

              var promiseCreated = ret._popContext();

              debug.checkForgottenReturns(value, promiseCreated, "Promise.try", ret);

              ret._resolveFromSyncValue(value);

              return ret;
            };

            Promise.prototype._resolveFromSyncValue = function (value) {
              if (value === util.errorObj) {
                this._rejectCallback(value.e, false);
              } else {
                this._resolveCallback(value, true);
              }
            };
          };
        }, {
          "./util": 36
        }],
        20: [function (_dereq_, module, exports) {
          "use strict";

          var util = _dereq_("./util");

          var maybeWrapAsError = util.maybeWrapAsError;

          var errors = _dereq_("./errors");

          var OperationalError = errors.OperationalError;

          var es5 = _dereq_("./es5");

          function isUntypedError(obj) {
            return obj instanceof Error && es5.getPrototypeOf(obj) === Error.prototype;
          }

          var rErrorKey = /^(?:name|message|stack|cause)$/;

          function wrapAsOperationalError(obj) {
            var ret;

            if (isUntypedError(obj)) {
              ret = new OperationalError(obj);
              ret.name = obj.name;
              ret.message = obj.message;
              ret.stack = obj.stack;
              var keys = es5.keys(obj);

              for (var i = 0; i < keys.length; ++i) {
                var key = keys[i];

                if (!rErrorKey.test(key)) {
                  ret[key] = obj[key];
                }
              }

              return ret;
            }

            util.markAsOriginatingFromRejection(obj);
            return obj;
          }

          function nodebackForPromise(promise, multiArgs) {
            return function (err, value) {
              if (promise === null) return;

              if (err) {
                var wrapped = wrapAsOperationalError(maybeWrapAsError(err));

                promise._attachExtraTrace(wrapped);

                promise._reject(wrapped);
              } else if (!multiArgs) {
                promise._fulfill(value);
              } else {
                var args = [].slice.call(arguments, 1);
                ;

                promise._fulfill(args);
              }

              promise = null;
            };
          }

          module.exports = nodebackForPromise;
        }, {
          "./errors": 12,
          "./es5": 13,
          "./util": 36
        }],
        21: [function (_dereq_, module, exports) {
          "use strict";

          module.exports = function (Promise) {
            var util = _dereq_("./util");

            var async = Promise._async;
            var tryCatch = util.tryCatch;
            var errorObj = util.errorObj;

            function spreadAdapter(val, nodeback) {
              var promise = this;
              if (!util.isArray(val)) return successAdapter.call(promise, val, nodeback);
              var ret = tryCatch(nodeback).apply(promise._boundValue(), [null].concat(val));

              if (ret === errorObj) {
                async.throwLater(ret.e);
              }
            }

            function successAdapter(val, nodeback) {
              var promise = this;

              var receiver = promise._boundValue();

              var ret = val === undefined ? tryCatch(nodeback).call(receiver, null) : tryCatch(nodeback).call(receiver, null, val);

              if (ret === errorObj) {
                async.throwLater(ret.e);
              }
            }

            function errorAdapter(reason, nodeback) {
              var promise = this;

              if (!reason) {
                var newReason = new Error(reason + "");
                newReason.cause = reason;
                reason = newReason;
              }

              var ret = tryCatch(nodeback).call(promise._boundValue(), reason);

              if (ret === errorObj) {
                async.throwLater(ret.e);
              }
            }

            Promise.prototype.asCallback = Promise.prototype.nodeify = function (nodeback, options) {
              if (typeof nodeback == "function") {
                var adapter = successAdapter;

                if (options !== undefined && Object(options).spread) {
                  adapter = spreadAdapter;
                }

                this._then(adapter, errorAdapter, undefined, this, nodeback);
              }

              return this;
            };
          };
        }, {
          "./util": 36
        }],
        22: [function (_dereq_, module, exports) {
          "use strict";

          module.exports = function () {
            var makeSelfResolutionError = function () {
              return new TypeError("circular promise resolution chain\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
            };

            var reflectHandler = function () {
              return new Promise.PromiseInspection(this._target());
            };

            var apiRejection = function (msg) {
              return Promise.reject(new TypeError(msg));
            };

            function Proxyable() {}

            var UNDEFINED_BINDING = {};

            var util = _dereq_("./util");

            var getDomain;

            if (util.isNode) {
              getDomain = function () {
                var ret = process.domain;
                if (ret === undefined) ret = null;
                return ret;
              };
            } else {
              getDomain = function () {
                return null;
              };
            }

            util.notEnumerableProp(Promise, "_getDomain", getDomain);

            var es5 = _dereq_("./es5");

            var Async = _dereq_("./async");

            var async = new Async();
            es5.defineProperty(Promise, "_async", {
              value: async
            });

            var errors = _dereq_("./errors");

            var TypeError = Promise.TypeError = errors.TypeError;
            Promise.RangeError = errors.RangeError;
            var CancellationError = Promise.CancellationError = errors.CancellationError;
            Promise.TimeoutError = errors.TimeoutError;
            Promise.OperationalError = errors.OperationalError;
            Promise.RejectionError = errors.OperationalError;
            Promise.AggregateError = errors.AggregateError;

            var INTERNAL = function () {};

            var APPLY = {};
            var NEXT_FILTER = {};

            var tryConvertToPromise = _dereq_("./thenables")(Promise, INTERNAL);

            var PromiseArray = _dereq_("./promise_array")(Promise, INTERNAL, tryConvertToPromise, apiRejection, Proxyable);

            var Context = _dereq_("./context")(Promise);
            /*jshint unused:false*/


            var createContext = Context.create;

            var debug = _dereq_("./debuggability")(Promise, Context);

            var CapturedTrace = debug.CapturedTrace;

            var PassThroughHandlerContext = _dereq_("./finally")(Promise, tryConvertToPromise);

            var catchFilter = _dereq_("./catch_filter")(NEXT_FILTER);

            var nodebackForPromise = _dereq_("./nodeback");

            var errorObj = util.errorObj;
            var tryCatch = util.tryCatch;

            function check(self, executor) {
              if (typeof executor !== "function") {
                throw new TypeError("expecting a function but got " + util.classString(executor));
              }

              if (self.constructor !== Promise) {
                throw new TypeError("the promise constructor cannot be invoked directly\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
              }
            }

            function Promise(executor) {
              this._bitField = 0;
              this._fulfillmentHandler0 = undefined;
              this._rejectionHandler0 = undefined;
              this._promise0 = undefined;
              this._receiver0 = undefined;

              if (executor !== INTERNAL) {
                check(this, executor);

                this._resolveFromExecutor(executor);
              }

              this._promiseCreated();

              this._fireEvent("promiseCreated", this);
            }

            Promise.prototype.toString = function () {
              return "[object Promise]";
            };

            Promise.prototype.caught = Promise.prototype["catch"] = function (fn) {
              var len = arguments.length;

              if (len > 1) {
                var catchInstances = new Array(len - 1),
                    j = 0,
                    i;

                for (i = 0; i < len - 1; ++i) {
                  var item = arguments[i];

                  if (util.isObject(item)) {
                    catchInstances[j++] = item;
                  } else {
                    return apiRejection("expecting an object but got A catch statement predicate " + util.classString(item));
                  }
                }

                catchInstances.length = j;
                fn = arguments[i];
                return this.then(undefined, catchFilter(catchInstances, fn, this));
              }

              return this.then(undefined, fn);
            };

            Promise.prototype.reflect = function () {
              return this._then(reflectHandler, reflectHandler, undefined, this, undefined);
            };

            Promise.prototype.then = function (didFulfill, didReject) {
              if (debug.warnings() && arguments.length > 0 && typeof didFulfill !== "function" && typeof didReject !== "function") {
                var msg = ".then() only accepts functions but was passed: " + util.classString(didFulfill);

                if (arguments.length > 1) {
                  msg += ", " + util.classString(didReject);
                }

                this._warn(msg);
              }

              return this._then(didFulfill, didReject, undefined, undefined, undefined);
            };

            Promise.prototype.done = function (didFulfill, didReject) {
              var promise = this._then(didFulfill, didReject, undefined, undefined, undefined);

              promise._setIsFinal();
            };

            Promise.prototype.spread = function (fn) {
              if (typeof fn !== "function") {
                return apiRejection("expecting a function but got " + util.classString(fn));
              }

              return this.all()._then(fn, undefined, undefined, APPLY, undefined);
            };

            Promise.prototype.toJSON = function () {
              var ret = {
                isFulfilled: false,
                isRejected: false,
                fulfillmentValue: undefined,
                rejectionReason: undefined
              };

              if (this.isFulfilled()) {
                ret.fulfillmentValue = this.value();
                ret.isFulfilled = true;
              } else if (this.isRejected()) {
                ret.rejectionReason = this.reason();
                ret.isRejected = true;
              }

              return ret;
            };

            Promise.prototype.all = function () {
              if (arguments.length > 0) {
                this._warn(".all() was passed arguments but it does not take any");
              }

              return new PromiseArray(this).promise();
            };

            Promise.prototype.error = function (fn) {
              return this.caught(util.originatesFromRejection, fn);
            };

            Promise.getNewLibraryCopy = module.exports;

            Promise.is = function (val) {
              return val instanceof Promise;
            };

            Promise.fromNode = Promise.fromCallback = function (fn) {
              var ret = new Promise(INTERNAL);

              ret._captureStackTrace();

              var multiArgs = arguments.length > 1 ? !!Object(arguments[1]).multiArgs : false;
              var result = tryCatch(fn)(nodebackForPromise(ret, multiArgs));

              if (result === errorObj) {
                ret._rejectCallback(result.e, true);
              }

              if (!ret._isFateSealed()) ret._setAsyncGuaranteed();
              return ret;
            };

            Promise.all = function (promises) {
              return new PromiseArray(promises).promise();
            };

            Promise.cast = function (obj) {
              var ret = tryConvertToPromise(obj);

              if (!(ret instanceof Promise)) {
                ret = new Promise(INTERNAL);

                ret._captureStackTrace();

                ret._setFulfilled();

                ret._rejectionHandler0 = obj;
              }

              return ret;
            };

            Promise.resolve = Promise.fulfilled = Promise.cast;

            Promise.reject = Promise.rejected = function (reason) {
              var ret = new Promise(INTERNAL);

              ret._captureStackTrace();

              ret._rejectCallback(reason, true);

              return ret;
            };

            Promise.setScheduler = function (fn) {
              if (typeof fn !== "function") {
                throw new TypeError("expecting a function but got " + util.classString(fn));
              }

              return async.setScheduler(fn);
            };

            Promise.prototype._then = function (didFulfill, didReject, _, receiver, internalData) {
              var haveInternalData = internalData !== undefined;
              var promise = haveInternalData ? internalData : new Promise(INTERNAL);

              var target = this._target();

              var bitField = target._bitField;

              if (!haveInternalData) {
                promise._propagateFrom(this, 3);

                promise._captureStackTrace();

                if (receiver === undefined && (this._bitField & 2097152) !== 0) {
                  if (!((bitField & 50397184) === 0)) {
                    receiver = this._boundValue();
                  } else {
                    receiver = target === this ? undefined : this._boundTo;
                  }
                }

                this._fireEvent("promiseChained", this, promise);
              }

              var domain = getDomain();

              if (!((bitField & 50397184) === 0)) {
                var handler,
                    value,
                    settler = target._settlePromiseCtx;

                if ((bitField & 33554432) !== 0) {
                  value = target._rejectionHandler0;
                  handler = didFulfill;
                } else if ((bitField & 16777216) !== 0) {
                  value = target._fulfillmentHandler0;
                  handler = didReject;

                  target._unsetRejectionIsUnhandled();
                } else {
                  settler = target._settlePromiseLateCancellationObserver;
                  value = new CancellationError("late cancellation observer");

                  target._attachExtraTrace(value);

                  handler = didReject;
                }

                async.invoke(settler, target, {
                  handler: domain === null ? handler : typeof handler === "function" && util.domainBind(domain, handler),
                  promise: promise,
                  receiver: receiver,
                  value: value
                });
              } else {
                target._addCallbacks(didFulfill, didReject, promise, receiver, domain);
              }

              return promise;
            };

            Promise.prototype._length = function () {
              return this._bitField & 65535;
            };

            Promise.prototype._isFateSealed = function () {
              return (this._bitField & 117506048) !== 0;
            };

            Promise.prototype._isFollowing = function () {
              return (this._bitField & 67108864) === 67108864;
            };

            Promise.prototype._setLength = function (len) {
              this._bitField = this._bitField & -65536 | len & 65535;
            };

            Promise.prototype._setFulfilled = function () {
              this._bitField = this._bitField | 33554432;

              this._fireEvent("promiseFulfilled", this);
            };

            Promise.prototype._setRejected = function () {
              this._bitField = this._bitField | 16777216;

              this._fireEvent("promiseRejected", this);
            };

            Promise.prototype._setFollowing = function () {
              this._bitField = this._bitField | 67108864;

              this._fireEvent("promiseResolved", this);
            };

            Promise.prototype._setIsFinal = function () {
              this._bitField = this._bitField | 4194304;
            };

            Promise.prototype._isFinal = function () {
              return (this._bitField & 4194304) > 0;
            };

            Promise.prototype._unsetCancelled = function () {
              this._bitField = this._bitField & ~65536;
            };

            Promise.prototype._setCancelled = function () {
              this._bitField = this._bitField | 65536;

              this._fireEvent("promiseCancelled", this);
            };

            Promise.prototype._setWillBeCancelled = function () {
              this._bitField = this._bitField | 8388608;
            };

            Promise.prototype._setAsyncGuaranteed = function () {
              if (async.hasCustomScheduler()) return;
              this._bitField = this._bitField | 134217728;
            };

            Promise.prototype._receiverAt = function (index) {
              var ret = index === 0 ? this._receiver0 : this[index * 4 - 4 + 3];

              if (ret === UNDEFINED_BINDING) {
                return undefined;
              } else if (ret === undefined && this._isBound()) {
                return this._boundValue();
              }

              return ret;
            };

            Promise.prototype._promiseAt = function (index) {
              return this[index * 4 - 4 + 2];
            };

            Promise.prototype._fulfillmentHandlerAt = function (index) {
              return this[index * 4 - 4 + 0];
            };

            Promise.prototype._rejectionHandlerAt = function (index) {
              return this[index * 4 - 4 + 1];
            };

            Promise.prototype._boundValue = function () {};

            Promise.prototype._migrateCallback0 = function (follower) {
              var bitField = follower._bitField;
              var fulfill = follower._fulfillmentHandler0;
              var reject = follower._rejectionHandler0;
              var promise = follower._promise0;

              var receiver = follower._receiverAt(0);

              if (receiver === undefined) receiver = UNDEFINED_BINDING;

              this._addCallbacks(fulfill, reject, promise, receiver, null);
            };

            Promise.prototype._migrateCallbackAt = function (follower, index) {
              var fulfill = follower._fulfillmentHandlerAt(index);

              var reject = follower._rejectionHandlerAt(index);

              var promise = follower._promiseAt(index);

              var receiver = follower._receiverAt(index);

              if (receiver === undefined) receiver = UNDEFINED_BINDING;

              this._addCallbacks(fulfill, reject, promise, receiver, null);
            };

            Promise.prototype._addCallbacks = function (fulfill, reject, promise, receiver, domain) {
              var index = this._length();

              if (index >= 65531) {
                index = 0;

                this._setLength(0);
              }

              if (index === 0) {
                this._promise0 = promise;
                this._receiver0 = receiver;

                if (typeof fulfill === "function") {
                  this._fulfillmentHandler0 = domain === null ? fulfill : util.domainBind(domain, fulfill);
                }

                if (typeof reject === "function") {
                  this._rejectionHandler0 = domain === null ? reject : util.domainBind(domain, reject);
                }
              } else {
                var base = index * 4 - 4;
                this[base + 2] = promise;
                this[base + 3] = receiver;

                if (typeof fulfill === "function") {
                  this[base + 0] = domain === null ? fulfill : util.domainBind(domain, fulfill);
                }

                if (typeof reject === "function") {
                  this[base + 1] = domain === null ? reject : util.domainBind(domain, reject);
                }
              }

              this._setLength(index + 1);

              return index;
            };

            Promise.prototype._proxy = function (proxyable, arg) {
              this._addCallbacks(undefined, undefined, arg, proxyable, null);
            };

            Promise.prototype._resolveCallback = function (value, shouldBind) {
              if ((this._bitField & 117506048) !== 0) return;
              if (value === this) return this._rejectCallback(makeSelfResolutionError(), false);
              var maybePromise = tryConvertToPromise(value, this);
              if (!(maybePromise instanceof Promise)) return this._fulfill(value);
              if (shouldBind) this._propagateFrom(maybePromise, 2);

              var promise = maybePromise._target();

              if (promise === this) {
                this._reject(makeSelfResolutionError());

                return;
              }

              var bitField = promise._bitField;

              if ((bitField & 50397184) === 0) {
                var len = this._length();

                if (len > 0) promise._migrateCallback0(this);

                for (var i = 1; i < len; ++i) {
                  promise._migrateCallbackAt(this, i);
                }

                this._setFollowing();

                this._setLength(0);

                this._setFollowee(promise);
              } else if ((bitField & 33554432) !== 0) {
                this._fulfill(promise._value());
              } else if ((bitField & 16777216) !== 0) {
                this._reject(promise._reason());
              } else {
                var reason = new CancellationError("late cancellation observer");

                promise._attachExtraTrace(reason);

                this._reject(reason);
              }
            };

            Promise.prototype._rejectCallback = function (reason, synchronous, ignoreNonErrorWarnings) {
              var trace = util.ensureErrorObject(reason);
              var hasStack = trace === reason;

              if (!hasStack && !ignoreNonErrorWarnings && debug.warnings()) {
                var message = "a promise was rejected with a non-error: " + util.classString(reason);

                this._warn(message, true);
              }

              this._attachExtraTrace(trace, synchronous ? hasStack : false);

              this._reject(reason);
            };

            Promise.prototype._resolveFromExecutor = function (executor) {
              var promise = this;

              this._captureStackTrace();

              this._pushContext();

              var synchronous = true;

              var r = this._execute(executor, function (value) {
                promise._resolveCallback(value);
              }, function (reason) {
                promise._rejectCallback(reason, synchronous);
              });

              synchronous = false;

              this._popContext();

              if (r !== undefined) {
                promise._rejectCallback(r, true);
              }
            };

            Promise.prototype._settlePromiseFromHandler = function (handler, receiver, value, promise) {
              var bitField = promise._bitField;
              if ((bitField & 65536) !== 0) return;

              promise._pushContext();

              var x;

              if (receiver === APPLY) {
                if (!value || typeof value.length !== "number") {
                  x = errorObj;
                  x.e = new TypeError("cannot .spread() a non-array: " + util.classString(value));
                } else {
                  x = tryCatch(handler).apply(this._boundValue(), value);
                }
              } else {
                x = tryCatch(handler).call(receiver, value);
              }

              var promiseCreated = promise._popContext();

              bitField = promise._bitField;
              if ((bitField & 65536) !== 0) return;

              if (x === NEXT_FILTER) {
                promise._reject(value);
              } else if (x === errorObj) {
                promise._rejectCallback(x.e, false);
              } else {
                debug.checkForgottenReturns(x, promiseCreated, "", promise, this);

                promise._resolveCallback(x);
              }
            };

            Promise.prototype._target = function () {
              var ret = this;

              while (ret._isFollowing()) ret = ret._followee();

              return ret;
            };

            Promise.prototype._followee = function () {
              return this._rejectionHandler0;
            };

            Promise.prototype._setFollowee = function (promise) {
              this._rejectionHandler0 = promise;
            };

            Promise.prototype._settlePromise = function (promise, handler, receiver, value) {
              var isPromise = promise instanceof Promise;
              var bitField = this._bitField;
              var asyncGuaranteed = (bitField & 134217728) !== 0;

              if ((bitField & 65536) !== 0) {
                if (isPromise) promise._invokeInternalOnCancel();

                if (receiver instanceof PassThroughHandlerContext && receiver.isFinallyHandler()) {
                  receiver.cancelPromise = promise;

                  if (tryCatch(handler).call(receiver, value) === errorObj) {
                    promise._reject(errorObj.e);
                  }
                } else if (handler === reflectHandler) {
                  promise._fulfill(reflectHandler.call(receiver));
                } else if (receiver instanceof Proxyable) {
                  receiver._promiseCancelled(promise);
                } else if (isPromise || promise instanceof PromiseArray) {
                  promise._cancel();
                } else {
                  receiver.cancel();
                }
              } else if (typeof handler === "function") {
                if (!isPromise) {
                  handler.call(receiver, value, promise);
                } else {
                  if (asyncGuaranteed) promise._setAsyncGuaranteed();

                  this._settlePromiseFromHandler(handler, receiver, value, promise);
                }
              } else if (receiver instanceof Proxyable) {
                if (!receiver._isResolved()) {
                  if ((bitField & 33554432) !== 0) {
                    receiver._promiseFulfilled(value, promise);
                  } else {
                    receiver._promiseRejected(value, promise);
                  }
                }
              } else if (isPromise) {
                if (asyncGuaranteed) promise._setAsyncGuaranteed();

                if ((bitField & 33554432) !== 0) {
                  promise._fulfill(value);
                } else {
                  promise._reject(value);
                }
              }
            };

            Promise.prototype._settlePromiseLateCancellationObserver = function (ctx) {
              var handler = ctx.handler;
              var promise = ctx.promise;
              var receiver = ctx.receiver;
              var value = ctx.value;

              if (typeof handler === "function") {
                if (!(promise instanceof Promise)) {
                  handler.call(receiver, value, promise);
                } else {
                  this._settlePromiseFromHandler(handler, receiver, value, promise);
                }
              } else if (promise instanceof Promise) {
                promise._reject(value);
              }
            };

            Promise.prototype._settlePromiseCtx = function (ctx) {
              this._settlePromise(ctx.promise, ctx.handler, ctx.receiver, ctx.value);
            };

            Promise.prototype._settlePromise0 = function (handler, value, bitField) {
              var promise = this._promise0;

              var receiver = this._receiverAt(0);

              this._promise0 = undefined;
              this._receiver0 = undefined;

              this._settlePromise(promise, handler, receiver, value);
            };

            Promise.prototype._clearCallbackDataAtIndex = function (index) {
              var base = index * 4 - 4;
              this[base + 2] = this[base + 3] = this[base + 0] = this[base + 1] = undefined;
            };

            Promise.prototype._fulfill = function (value) {
              var bitField = this._bitField;
              if ((bitField & 117506048) >>> 16) return;

              if (value === this) {
                var err = makeSelfResolutionError();

                this._attachExtraTrace(err);

                return this._reject(err);
              }

              this._setFulfilled();

              this._rejectionHandler0 = value;

              if ((bitField & 65535) > 0) {
                if ((bitField & 134217728) !== 0) {
                  this._settlePromises();
                } else {
                  async.settlePromises(this);
                }
              }
            };

            Promise.prototype._reject = function (reason) {
              var bitField = this._bitField;
              if ((bitField & 117506048) >>> 16) return;

              this._setRejected();

              this._fulfillmentHandler0 = reason;

              if (this._isFinal()) {
                return async.fatalError(reason, util.isNode);
              }

              if ((bitField & 65535) > 0) {
                async.settlePromises(this);
              } else {
                this._ensurePossibleRejectionHandled();
              }
            };

            Promise.prototype._fulfillPromises = function (len, value) {
              for (var i = 1; i < len; i++) {
                var handler = this._fulfillmentHandlerAt(i);

                var promise = this._promiseAt(i);

                var receiver = this._receiverAt(i);

                this._clearCallbackDataAtIndex(i);

                this._settlePromise(promise, handler, receiver, value);
              }
            };

            Promise.prototype._rejectPromises = function (len, reason) {
              for (var i = 1; i < len; i++) {
                var handler = this._rejectionHandlerAt(i);

                var promise = this._promiseAt(i);

                var receiver = this._receiverAt(i);

                this._clearCallbackDataAtIndex(i);

                this._settlePromise(promise, handler, receiver, reason);
              }
            };

            Promise.prototype._settlePromises = function () {
              var bitField = this._bitField;
              var len = bitField & 65535;

              if (len > 0) {
                if ((bitField & 16842752) !== 0) {
                  var reason = this._fulfillmentHandler0;

                  this._settlePromise0(this._rejectionHandler0, reason, bitField);

                  this._rejectPromises(len, reason);
                } else {
                  var value = this._rejectionHandler0;

                  this._settlePromise0(this._fulfillmentHandler0, value, bitField);

                  this._fulfillPromises(len, value);
                }

                this._setLength(0);
              }

              this._clearCancellationData();
            };

            Promise.prototype._settledValue = function () {
              var bitField = this._bitField;

              if ((bitField & 33554432) !== 0) {
                return this._rejectionHandler0;
              } else if ((bitField & 16777216) !== 0) {
                return this._fulfillmentHandler0;
              }
            };

            function deferResolve(v) {
              this.promise._resolveCallback(v);
            }

            function deferReject(v) {
              this.promise._rejectCallback(v, false);
            }

            Promise.defer = Promise.pending = function () {
              debug.deprecated("Promise.defer", "new Promise");
              var promise = new Promise(INTERNAL);
              return {
                promise: promise,
                resolve: deferResolve,
                reject: deferReject
              };
            };

            util.notEnumerableProp(Promise, "_makeSelfResolutionError", makeSelfResolutionError);

            _dereq_("./method")(Promise, INTERNAL, tryConvertToPromise, apiRejection, debug);

            _dereq_("./bind")(Promise, INTERNAL, tryConvertToPromise, debug);

            _dereq_("./cancel")(Promise, PromiseArray, apiRejection, debug);

            _dereq_("./direct_resolve")(Promise);

            _dereq_("./synchronous_inspection")(Promise);

            _dereq_("./join")(Promise, PromiseArray, tryConvertToPromise, INTERNAL, async, getDomain);

            Promise.Promise = Promise;
            Promise.version = "3.4.5";

            _dereq_('./map.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);

            _dereq_('./call_get.js')(Promise);

            _dereq_('./using.js')(Promise, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug);

            _dereq_('./timers.js')(Promise, INTERNAL, debug);

            _dereq_('./generators.js')(Promise, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug);

            _dereq_('./nodeify.js')(Promise);

            _dereq_('./promisify.js')(Promise, INTERNAL);

            _dereq_('./props.js')(Promise, PromiseArray, tryConvertToPromise, apiRejection);

            _dereq_('./race.js')(Promise, INTERNAL, tryConvertToPromise, apiRejection);

            _dereq_('./reduce.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);

            _dereq_('./settle.js')(Promise, PromiseArray, debug);

            _dereq_('./some.js')(Promise, PromiseArray, apiRejection);

            _dereq_('./filter.js')(Promise, INTERNAL);

            _dereq_('./each.js')(Promise, INTERNAL);

            _dereq_('./any.js')(Promise);

            util.toFastProperties(Promise);
            util.toFastProperties(Promise.prototype);

            function fillTypes(value) {
              var p = new Promise(INTERNAL);
              p._fulfillmentHandler0 = value;
              p._rejectionHandler0 = value;
              p._promise0 = value;
              p._receiver0 = value;
            } // Complete slack tracking, opt out of field-type tracking and           
            // stabilize map                                                         


            fillTypes({
              a: 1
            });
            fillTypes({
              b: 2
            });
            fillTypes({
              c: 3
            });
            fillTypes(1);
            fillTypes(function () {});
            fillTypes(undefined);
            fillTypes(false);
            fillTypes(new Promise(INTERNAL));
            debug.setBounds(Async.firstLineError, util.lastLineError);
            return Promise;
          };
        }, {
          "./any.js": 1,
          "./async": 2,
          "./bind": 3,
          "./call_get.js": 5,
          "./cancel": 6,
          "./catch_filter": 7,
          "./context": 8,
          "./debuggability": 9,
          "./direct_resolve": 10,
          "./each.js": 11,
          "./errors": 12,
          "./es5": 13,
          "./filter.js": 14,
          "./finally": 15,
          "./generators.js": 16,
          "./join": 17,
          "./map.js": 18,
          "./method": 19,
          "./nodeback": 20,
          "./nodeify.js": 21,
          "./promise_array": 23,
          "./promisify.js": 24,
          "./props.js": 25,
          "./race.js": 27,
          "./reduce.js": 28,
          "./settle.js": 30,
          "./some.js": 31,
          "./synchronous_inspection": 32,
          "./thenables": 33,
          "./timers.js": 34,
          "./using.js": 35,
          "./util": 36
        }],
        23: [function (_dereq_, module, exports) {
          "use strict";

          module.exports = function (Promise, INTERNAL, tryConvertToPromise, apiRejection, Proxyable) {
            var util = _dereq_("./util");

            var isArray = util.isArray;

            function toResolutionValue(val) {
              switch (val) {
                case -2:
                  return [];

                case -3:
                  return {};
              }
            }

            function PromiseArray(values) {
              var promise = this._promise = new Promise(INTERNAL);

              if (values instanceof Promise) {
                promise._propagateFrom(values, 3);
              }

              promise._setOnCancel(this);

              this._values = values;
              this._length = 0;
              this._totalResolved = 0;

              this._init(undefined, -2);
            }

            util.inherits(PromiseArray, Proxyable);

            PromiseArray.prototype.length = function () {
              return this._length;
            };

            PromiseArray.prototype.promise = function () {
              return this._promise;
            };

            PromiseArray.prototype._init = function init(_, resolveValueIfEmpty) {
              var values = tryConvertToPromise(this._values, this._promise);

              if (values instanceof Promise) {
                values = values._target();
                var bitField = values._bitField;
                ;
                this._values = values;

                if ((bitField & 50397184) === 0) {
                  this._promise._setAsyncGuaranteed();

                  return values._then(init, this._reject, undefined, this, resolveValueIfEmpty);
                } else if ((bitField & 33554432) !== 0) {
                  values = values._value();
                } else if ((bitField & 16777216) !== 0) {
                  return this._reject(values._reason());
                } else {
                  return this._cancel();
                }
              }

              values = util.asArray(values);

              if (values === null) {
                var err = apiRejection("expecting an array or an iterable object but got " + util.classString(values)).reason();

                this._promise._rejectCallback(err, false);

                return;
              }

              if (values.length === 0) {
                if (resolveValueIfEmpty === -5) {
                  this._resolveEmptyArray();
                } else {
                  this._resolve(toResolutionValue(resolveValueIfEmpty));
                }

                return;
              }

              this._iterate(values);
            };

            PromiseArray.prototype._iterate = function (values) {
              var len = this.getActualLength(values.length);
              this._length = len;
              this._values = this.shouldCopyValues() ? new Array(len) : this._values;
              var result = this._promise;
              var isResolved = false;
              var bitField = null;

              for (var i = 0; i < len; ++i) {
                var maybePromise = tryConvertToPromise(values[i], result);

                if (maybePromise instanceof Promise) {
                  maybePromise = maybePromise._target();
                  bitField = maybePromise._bitField;
                } else {
                  bitField = null;
                }

                if (isResolved) {
                  if (bitField !== null) {
                    maybePromise.suppressUnhandledRejections();
                  }
                } else if (bitField !== null) {
                  if ((bitField & 50397184) === 0) {
                    maybePromise._proxy(this, i);

                    this._values[i] = maybePromise;
                  } else if ((bitField & 33554432) !== 0) {
                    isResolved = this._promiseFulfilled(maybePromise._value(), i);
                  } else if ((bitField & 16777216) !== 0) {
                    isResolved = this._promiseRejected(maybePromise._reason(), i);
                  } else {
                    isResolved = this._promiseCancelled(i);
                  }
                } else {
                  isResolved = this._promiseFulfilled(maybePromise, i);
                }
              }

              if (!isResolved) result._setAsyncGuaranteed();
            };

            PromiseArray.prototype._isResolved = function () {
              return this._values === null;
            };

            PromiseArray.prototype._resolve = function (value) {
              this._values = null;

              this._promise._fulfill(value);
            };

            PromiseArray.prototype._cancel = function () {
              if (this._isResolved() || !this._promise._isCancellable()) return;
              this._values = null;

              this._promise._cancel();
            };

            PromiseArray.prototype._reject = function (reason) {
              this._values = null;

              this._promise._rejectCallback(reason, false);
            };

            PromiseArray.prototype._promiseFulfilled = function (value, index) {
              this._values[index] = value;
              var totalResolved = ++this._totalResolved;

              if (totalResolved >= this._length) {
                this._resolve(this._values);

                return true;
              }

              return false;
            };

            PromiseArray.prototype._promiseCancelled = function () {
              this._cancel();

              return true;
            };

            PromiseArray.prototype._promiseRejected = function (reason) {
              this._totalResolved++;

              this._reject(reason);

              return true;
            };

            PromiseArray.prototype._resultCancelled = function () {
              if (this._isResolved()) return;
              var values = this._values;

              this._cancel();

              if (values instanceof Promise) {
                values.cancel();
              } else {
                for (var i = 0; i < values.length; ++i) {
                  if (values[i] instanceof Promise) {
                    values[i].cancel();
                  }
                }
              }
            };

            PromiseArray.prototype.shouldCopyValues = function () {
              return true;
            };

            PromiseArray.prototype.getActualLength = function (len) {
              return len;
            };

            return PromiseArray;
          };
        }, {
          "./util": 36
        }],
        24: [function (_dereq_, module, exports) {
          "use strict";

          module.exports = function (Promise, INTERNAL) {
            var THIS = {};

            var util = _dereq_("./util");

            var nodebackForPromise = _dereq_("./nodeback");

            var withAppended = util.withAppended;
            var maybeWrapAsError = util.maybeWrapAsError;
            var canEvaluate = util.canEvaluate;

            var TypeError = _dereq_("./errors").TypeError;

            var defaultSuffix = "Async";
            var defaultPromisified = {
              __P_64_14: true
            };
            var noCopyProps = ["arity", "length", "name", "arguments", "caller", "callee", "prototype", "__P_64_14"];
            var noCopyPropsPattern = new RegExp("^(?:" + noCopyProps.join("|") + ")$");

            var defaultFilter = function (name) {
              return util.isIdentifier(name) && name.charAt(0) !== "_" && name !== "constructor";
            };

            function propsFilter(key) {
              return !noCopyPropsPattern.test(key);
            }

            function isPromisified(fn) {
              try {
                return fn.__P_64_14 === true;
              } catch (e) {
                return false;
              }
            }

            function hasPromisified(obj, key, suffix) {
              var val = util.getDataPropertyOrDefault(obj, key + suffix, defaultPromisified);
              return val ? isPromisified(val) : false;
            }

            function checkValid(ret, suffix, suffixRegexp) {
              for (var i = 0; i < ret.length; i += 2) {
                var key = ret[i];

                if (suffixRegexp.test(key)) {
                  var keyWithoutAsyncSuffix = key.replace(suffixRegexp, "");

                  for (var j = 0; j < ret.length; j += 2) {
                    if (ret[j] === keyWithoutAsyncSuffix) {
                      throw new TypeError("Cannot promisify an API that has normal methods with '%s'-suffix\u000a\u000a    See http://goo.gl/MqrFmX\u000a".replace("%s", suffix));
                    }
                  }
                }
              }
            }

            function promisifiableMethods(obj, suffix, suffixRegexp, filter) {
              var keys = util.inheritedDataKeys(obj);
              var ret = [];

              for (var i = 0; i < keys.length; ++i) {
                var key = keys[i];
                var value = obj[key];
                var passesDefaultFilter = filter === defaultFilter ? true : defaultFilter(key, value, obj);

                if (typeof value === "function" && !isPromisified(value) && !hasPromisified(obj, key, suffix) && filter(key, value, obj, passesDefaultFilter)) {
                  ret.push(key, value);
                }
              }

              checkValid(ret, suffix, suffixRegexp);
              return ret;
            }

            var escapeIdentRegex = function (str) {
              return str.replace(/([$])/, "\\$");
            };

            var makeNodePromisifiedEval;

            function makeNodePromisifiedClosure(callback, receiver, _, fn, __P_64_15, multiArgs) {
              var defaultThis = function () {
                return this;
              }();

              var method = callback;

              if (typeof method === "string") {
                callback = fn;
              }

              function promisified() {
                var _receiver = receiver;
                if (receiver === THIS) _receiver = this;
                var promise = new Promise(INTERNAL);

                promise._captureStackTrace();

                var cb = typeof method === "string" && this !== defaultThis ? this[method] : callback;
                var fn = nodebackForPromise(promise, multiArgs);

                try {
                  cb.apply(_receiver, withAppended(arguments, fn));
                } catch (e) {
                  promise._rejectCallback(maybeWrapAsError(e), true, true);
                }

                if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
                return promise;
              }

              util.notEnumerableProp(promisified, "__P_64_14", true);
              return promisified;
            }

            var makeNodePromisified = canEvaluate ? makeNodePromisifiedEval : makeNodePromisifiedClosure;

            function promisifyAll(obj, suffix, filter, promisifier, multiArgs) {
              var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + "$");
              var methods = promisifiableMethods(obj, suffix, suffixRegexp, filter);

              for (var i = 0, len = methods.length; i < len; i += 2) {
                var key = methods[i];
                var fn = methods[i + 1];
                var promisifiedKey = key + suffix;

                if (promisifier === makeNodePromisified) {
                  obj[promisifiedKey] = makeNodePromisified(key, THIS, key, fn, suffix, multiArgs);
                } else {
                  var promisified = promisifier(fn, function () {
                    return makeNodePromisified(key, THIS, key, fn, suffix, multiArgs);
                  });
                  util.notEnumerableProp(promisified, "__P_64_14", true);
                  obj[promisifiedKey] = promisified;
                }
              }

              util.toFastProperties(obj);
              return obj;
            }

            function promisify(callback, receiver, multiArgs) {
              return makeNodePromisified(callback, receiver, undefined, callback, null, multiArgs);
            }

            Promise.promisify = function (fn, options) {
              if (typeof fn !== "function") {
                throw new TypeError("expecting a function but got " + util.classString(fn));
              }

              if (isPromisified(fn)) {
                return fn;
              }

              options = Object(options);
              var receiver = options.context === undefined ? THIS : options.context;
              var multiArgs = !!options.multiArgs;
              var ret = promisify(fn, receiver, multiArgs);
              util.copyDescriptors(fn, ret, propsFilter);
              return ret;
            };

            Promise.promisifyAll = function (target, options) {
              if (typeof target !== "function" && typeof target !== "object") {
                throw new TypeError("the target of promisifyAll must be an object or a function\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
              }

              options = Object(options);
              var multiArgs = !!options.multiArgs;
              var suffix = options.suffix;
              if (typeof suffix !== "string") suffix = defaultSuffix;
              var filter = options.filter;
              if (typeof filter !== "function") filter = defaultFilter;
              var promisifier = options.promisifier;
              if (typeof promisifier !== "function") promisifier = makeNodePromisified;

              if (!util.isIdentifier(suffix)) {
                throw new RangeError("suffix must be a valid identifier\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
              }

              var keys = util.inheritedDataKeys(target);

              for (var i = 0; i < keys.length; ++i) {
                var value = target[keys[i]];

                if (keys[i] !== "constructor" && util.isClass(value)) {
                  promisifyAll(value.prototype, suffix, filter, promisifier, multiArgs);
                  promisifyAll(value, suffix, filter, promisifier, multiArgs);
                }
              }

              return promisifyAll(target, suffix, filter, promisifier, multiArgs);
            };
          };
        }, {
          "./errors": 12,
          "./nodeback": 20,
          "./util": 36
        }],
        25: [function (_dereq_, module, exports) {
          "use strict";

          module.exports = function (Promise, PromiseArray, tryConvertToPromise, apiRejection) {
            var util = _dereq_("./util");

            var isObject = util.isObject;

            var es5 = _dereq_("./es5");

            var Es6Map;
            if (typeof Map === "function") Es6Map = Map;

            var mapToEntries = function () {
              var index = 0;
              var size = 0;

              function extractEntry(value, key) {
                this[index] = value;
                this[index + size] = key;
                index++;
              }

              return function mapToEntries(map) {
                size = map.size;
                index = 0;
                var ret = new Array(map.size * 2);
                map.forEach(extractEntry, ret);
                return ret;
              };
            }();

            var entriesToMap = function (entries) {
              var ret = new Es6Map();
              var length = entries.length / 2 | 0;

              for (var i = 0; i < length; ++i) {
                var key = entries[length + i];
                var value = entries[i];
                ret.set(key, value);
              }

              return ret;
            };

            function PropertiesPromiseArray(obj) {
              var isMap = false;
              var entries;

              if (Es6Map !== undefined && obj instanceof Es6Map) {
                entries = mapToEntries(obj);
                isMap = true;
              } else {
                var keys = es5.keys(obj);
                var len = keys.length;
                entries = new Array(len * 2);

                for (var i = 0; i < len; ++i) {
                  var key = keys[i];
                  entries[i] = obj[key];
                  entries[i + len] = key;
                }
              }

              this.constructor$(entries);
              this._isMap = isMap;

              this._init$(undefined, -3);
            }

            util.inherits(PropertiesPromiseArray, PromiseArray);

            PropertiesPromiseArray.prototype._init = function () {};

            PropertiesPromiseArray.prototype._promiseFulfilled = function (value, index) {
              this._values[index] = value;
              var totalResolved = ++this._totalResolved;

              if (totalResolved >= this._length) {
                var val;

                if (this._isMap) {
                  val = entriesToMap(this._values);
                } else {
                  val = {};
                  var keyOffset = this.length();

                  for (var i = 0, len = this.length(); i < len; ++i) {
                    val[this._values[i + keyOffset]] = this._values[i];
                  }
                }

                this._resolve(val);

                return true;
              }

              return false;
            };

            PropertiesPromiseArray.prototype.shouldCopyValues = function () {
              return false;
            };

            PropertiesPromiseArray.prototype.getActualLength = function (len) {
              return len >> 1;
            };

            function props(promises) {
              var ret;
              var castValue = tryConvertToPromise(promises);

              if (!isObject(castValue)) {
                return apiRejection("cannot await properties of a non-object\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
              } else if (castValue instanceof Promise) {
                ret = castValue._then(Promise.props, undefined, undefined, undefined, undefined);
              } else {
                ret = new PropertiesPromiseArray(castValue).promise();
              }

              if (castValue instanceof Promise) {
                ret._propagateFrom(castValue, 2);
              }

              return ret;
            }

            Promise.prototype.props = function () {
              return props(this);
            };

            Promise.props = function (promises) {
              return props(promises);
            };
          };
        }, {
          "./es5": 13,
          "./util": 36
        }],
        26: [function (_dereq_, module, exports) {
          "use strict";

          function arrayMove(src, srcIndex, dst, dstIndex, len) {
            for (var j = 0; j < len; ++j) {
              dst[j + dstIndex] = src[j + srcIndex];
              src[j + srcIndex] = void 0;
            }
          }

          function Queue(capacity) {
            this._capacity = capacity;
            this._length = 0;
            this._front = 0;
          }

          Queue.prototype._willBeOverCapacity = function (size) {
            return this._capacity < size;
          };

          Queue.prototype._pushOne = function (arg) {
            var length = this.length();

            this._checkCapacity(length + 1);

            var i = this._front + length & this._capacity - 1;
            this[i] = arg;
            this._length = length + 1;
          };

          Queue.prototype._unshiftOne = function (value) {
            var capacity = this._capacity;

            this._checkCapacity(this.length() + 1);

            var front = this._front;
            var i = (front - 1 & capacity - 1 ^ capacity) - capacity;
            this[i] = value;
            this._front = i;
            this._length = this.length() + 1;
          };

          Queue.prototype.unshift = function (fn, receiver, arg) {
            this._unshiftOne(arg);

            this._unshiftOne(receiver);

            this._unshiftOne(fn);
          };

          Queue.prototype.push = function (fn, receiver, arg) {
            var length = this.length() + 3;

            if (this._willBeOverCapacity(length)) {
              this._pushOne(fn);

              this._pushOne(receiver);

              this._pushOne(arg);

              return;
            }

            var j = this._front + length - 3;

            this._checkCapacity(length);

            var wrapMask = this._capacity - 1;
            this[j + 0 & wrapMask] = fn;
            this[j + 1 & wrapMask] = receiver;
            this[j + 2 & wrapMask] = arg;
            this._length = length;
          };

          Queue.prototype.shift = function () {
            var front = this._front,
                ret = this[front];
            this[front] = undefined;
            this._front = front + 1 & this._capacity - 1;
            this._length--;
            return ret;
          };

          Queue.prototype.length = function () {
            return this._length;
          };

          Queue.prototype._checkCapacity = function (size) {
            if (this._capacity < size) {
              this._resizeTo(this._capacity << 1);
            }
          };

          Queue.prototype._resizeTo = function (capacity) {
            var oldCapacity = this._capacity;
            this._capacity = capacity;
            var front = this._front;
            var length = this._length;
            var moveItemsCount = front + length & oldCapacity - 1;
            arrayMove(this, 0, this, oldCapacity, moveItemsCount);
          };

          module.exports = Queue;
        }, {}],
        27: [function (_dereq_, module, exports) {
          "use strict";

          module.exports = function (Promise, INTERNAL, tryConvertToPromise, apiRejection) {
            var util = _dereq_("./util");

            var raceLater = function (promise) {
              return promise.then(function (array) {
                return race(array, promise);
              });
            };

            function race(promises, parent) {
              var maybePromise = tryConvertToPromise(promises);

              if (maybePromise instanceof Promise) {
                return raceLater(maybePromise);
              } else {
                promises = util.asArray(promises);
                if (promises === null) return apiRejection("expecting an array or an iterable object but got " + util.classString(promises));
              }

              var ret = new Promise(INTERNAL);

              if (parent !== undefined) {
                ret._propagateFrom(parent, 3);
              }

              var fulfill = ret._fulfill;
              var reject = ret._reject;

              for (var i = 0, len = promises.length; i < len; ++i) {
                var val = promises[i];

                if (val === undefined && !(i in promises)) {
                  continue;
                }

                Promise.cast(val)._then(fulfill, reject, undefined, ret, null);
              }

              return ret;
            }

            Promise.race = function (promises) {
              return race(promises, undefined);
            };

            Promise.prototype.race = function () {
              return race(this, undefined);
            };
          };
        }, {
          "./util": 36
        }],
        28: [function (_dereq_, module, exports) {
          "use strict";

          module.exports = function (Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug) {
            var getDomain = Promise._getDomain;

            var util = _dereq_("./util");

            var tryCatch = util.tryCatch;

            function ReductionPromiseArray(promises, fn, initialValue, _each) {
              this.constructor$(promises);
              var domain = getDomain();
              this._fn = domain === null ? fn : util.domainBind(domain, fn);

              if (initialValue !== undefined) {
                initialValue = Promise.resolve(initialValue);

                initialValue._attachCancellationCallback(this);
              }

              this._initialValue = initialValue;
              this._currentCancellable = null;

              if (_each === INTERNAL) {
                this._eachValues = Array(this._length);
              } else if (_each === 0) {
                this._eachValues = null;
              } else {
                this._eachValues = undefined;
              }

              this._promise._captureStackTrace();

              this._init$(undefined, -5);
            }

            util.inherits(ReductionPromiseArray, PromiseArray);

            ReductionPromiseArray.prototype._gotAccum = function (accum) {
              if (this._eachValues !== undefined && this._eachValues !== null && accum !== INTERNAL) {
                this._eachValues.push(accum);
              }
            };

            ReductionPromiseArray.prototype._eachComplete = function (value) {
              if (this._eachValues !== null) {
                this._eachValues.push(value);
              }

              return this._eachValues;
            };

            ReductionPromiseArray.prototype._init = function () {};

            ReductionPromiseArray.prototype._resolveEmptyArray = function () {
              this._resolve(this._eachValues !== undefined ? this._eachValues : this._initialValue);
            };

            ReductionPromiseArray.prototype.shouldCopyValues = function () {
              return false;
            };

            ReductionPromiseArray.prototype._resolve = function (value) {
              this._promise._resolveCallback(value);

              this._values = null;
            };

            ReductionPromiseArray.prototype._resultCancelled = function (sender) {
              if (sender === this._initialValue) return this._cancel();
              if (this._isResolved()) return;

              this._resultCancelled$();

              if (this._currentCancellable instanceof Promise) {
                this._currentCancellable.cancel();
              }

              if (this._initialValue instanceof Promise) {
                this._initialValue.cancel();
              }
            };

            ReductionPromiseArray.prototype._iterate = function (values) {
              this._values = values;
              var value;
              var i;
              var length = values.length;

              if (this._initialValue !== undefined) {
                value = this._initialValue;
                i = 0;
              } else {
                value = Promise.resolve(values[0]);
                i = 1;
              }

              this._currentCancellable = value;

              if (!value.isRejected()) {
                for (; i < length; ++i) {
                  var ctx = {
                    accum: null,
                    value: values[i],
                    index: i,
                    length: length,
                    array: this
                  };
                  value = value._then(gotAccum, undefined, undefined, ctx, undefined);
                }
              }

              if (this._eachValues !== undefined) {
                value = value._then(this._eachComplete, undefined, undefined, this, undefined);
              }

              value._then(completed, completed, undefined, value, this);
            };

            Promise.prototype.reduce = function (fn, initialValue) {
              return reduce(this, fn, initialValue, null);
            };

            Promise.reduce = function (promises, fn, initialValue, _each) {
              return reduce(promises, fn, initialValue, _each);
            };

            function completed(valueOrReason, array) {
              if (this.isFulfilled()) {
                array._resolve(valueOrReason);
              } else {
                array._reject(valueOrReason);
              }
            }

            function reduce(promises, fn, initialValue, _each) {
              if (typeof fn !== "function") {
                return apiRejection("expecting a function but got " + util.classString(fn));
              }

              var array = new ReductionPromiseArray(promises, fn, initialValue, _each);
              return array.promise();
            }

            function gotAccum(accum) {
              this.accum = accum;

              this.array._gotAccum(accum);

              var value = tryConvertToPromise(this.value, this.array._promise);

              if (value instanceof Promise) {
                this.array._currentCancellable = value;
                return value._then(gotValue, undefined, undefined, this, undefined);
              } else {
                return gotValue.call(this, value);
              }
            }

            function gotValue(value) {
              var array = this.array;
              var promise = array._promise;
              var fn = tryCatch(array._fn);

              promise._pushContext();

              var ret;

              if (array._eachValues !== undefined) {
                ret = fn.call(promise._boundValue(), value, this.index, this.length);
              } else {
                ret = fn.call(promise._boundValue(), this.accum, value, this.index, this.length);
              }

              if (ret instanceof Promise) {
                array._currentCancellable = ret;
              }

              var promiseCreated = promise._popContext();

              debug.checkForgottenReturns(ret, promiseCreated, array._eachValues !== undefined ? "Promise.each" : "Promise.reduce", promise);
              return ret;
            }
          };
        }, {
          "./util": 36
        }],
        29: [function (_dereq_, module, exports) {
          "use strict";

          var util = _dereq_("./util");

          var schedule;

          var noAsyncScheduler = function () {
            throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
          };

          var NativePromise = util.getNativePromise();

          if (util.isNode && typeof MutationObserver === "undefined") {
            var GlobalSetImmediate = global.setImmediate;
            var ProcessNextTick = process.nextTick;
            schedule = util.isRecentNode ? function (fn) {
              GlobalSetImmediate.call(global, fn);
            } : function (fn) {
              ProcessNextTick.call(process, fn);
            };
          } else if (typeof NativePromise === "function" && typeof NativePromise.resolve === "function") {
            var nativePromise = NativePromise.resolve();

            schedule = function (fn) {
              nativePromise.then(fn);
            };
          } else if (typeof MutationObserver !== "undefined" && !(typeof window !== "undefined" && window.navigator && (window.navigator.standalone || window.cordova))) {
            schedule = function () {
              var div = document.createElement("div");
              var opts = {
                attributes: true
              };
              var toggleScheduled = false;
              var div2 = document.createElement("div");
              var o2 = new MutationObserver(function () {
                div.classList.toggle("foo");
                toggleScheduled = false;
              });
              o2.observe(div2, opts);

              var scheduleToggle = function () {
                if (toggleScheduled) return;
                toggleScheduled = true;
                div2.classList.toggle("foo");
              };

              return function schedule(fn) {
                var o = new MutationObserver(function () {
                  o.disconnect();
                  fn();
                });
                o.observe(div, opts);
                scheduleToggle();
              };
            }();
          } else if (typeof setImmediate !== "undefined") {
            schedule = function (fn) {
              setImmediate(fn);
            };
          } else if (typeof setTimeout !== "undefined") {
            schedule = function (fn) {
              setTimeout(fn, 0);
            };
          } else {
            schedule = noAsyncScheduler;
          }

          module.exports = schedule;
        }, {
          "./util": 36
        }],
        30: [function (_dereq_, module, exports) {
          "use strict";

          module.exports = function (Promise, PromiseArray, debug) {
            var PromiseInspection = Promise.PromiseInspection;

            var util = _dereq_("./util");

            function SettledPromiseArray(values) {
              this.constructor$(values);
            }

            util.inherits(SettledPromiseArray, PromiseArray);

            SettledPromiseArray.prototype._promiseResolved = function (index, inspection) {
              this._values[index] = inspection;
              var totalResolved = ++this._totalResolved;

              if (totalResolved >= this._length) {
                this._resolve(this._values);

                return true;
              }

              return false;
            };

            SettledPromiseArray.prototype._promiseFulfilled = function (value, index) {
              var ret = new PromiseInspection();
              ret._bitField = 33554432;
              ret._settledValueField = value;
              return this._promiseResolved(index, ret);
            };

            SettledPromiseArray.prototype._promiseRejected = function (reason, index) {
              var ret = new PromiseInspection();
              ret._bitField = 16777216;
              ret._settledValueField = reason;
              return this._promiseResolved(index, ret);
            };

            Promise.settle = function (promises) {
              debug.deprecated(".settle()", ".reflect()");
              return new SettledPromiseArray(promises).promise();
            };

            Promise.prototype.settle = function () {
              return Promise.settle(this);
            };
          };
        }, {
          "./util": 36
        }],
        31: [function (_dereq_, module, exports) {
          "use strict";

          module.exports = function (Promise, PromiseArray, apiRejection) {
            var util = _dereq_("./util");

            var RangeError = _dereq_("./errors").RangeError;

            var AggregateError = _dereq_("./errors").AggregateError;

            var isArray = util.isArray;
            var CANCELLATION = {};

            function SomePromiseArray(values) {
              this.constructor$(values);
              this._howMany = 0;
              this._unwrap = false;
              this._initialized = false;
            }

            util.inherits(SomePromiseArray, PromiseArray);

            SomePromiseArray.prototype._init = function () {
              if (!this._initialized) {
                return;
              }

              if (this._howMany === 0) {
                this._resolve([]);

                return;
              }

              this._init$(undefined, -5);

              var isArrayResolved = isArray(this._values);

              if (!this._isResolved() && isArrayResolved && this._howMany > this._canPossiblyFulfill()) {
                this._reject(this._getRangeError(this.length()));
              }
            };

            SomePromiseArray.prototype.init = function () {
              this._initialized = true;

              this._init();
            };

            SomePromiseArray.prototype.setUnwrap = function () {
              this._unwrap = true;
            };

            SomePromiseArray.prototype.howMany = function () {
              return this._howMany;
            };

            SomePromiseArray.prototype.setHowMany = function (count) {
              this._howMany = count;
            };

            SomePromiseArray.prototype._promiseFulfilled = function (value) {
              this._addFulfilled(value);

              if (this._fulfilled() === this.howMany()) {
                this._values.length = this.howMany();

                if (this.howMany() === 1 && this._unwrap) {
                  this._resolve(this._values[0]);
                } else {
                  this._resolve(this._values);
                }

                return true;
              }

              return false;
            };

            SomePromiseArray.prototype._promiseRejected = function (reason) {
              this._addRejected(reason);

              return this._checkOutcome();
            };

            SomePromiseArray.prototype._promiseCancelled = function () {
              if (this._values instanceof Promise || this._values == null) {
                return this._cancel();
              }

              this._addRejected(CANCELLATION);

              return this._checkOutcome();
            };

            SomePromiseArray.prototype._checkOutcome = function () {
              if (this.howMany() > this._canPossiblyFulfill()) {
                var e = new AggregateError();

                for (var i = this.length(); i < this._values.length; ++i) {
                  if (this._values[i] !== CANCELLATION) {
                    e.push(this._values[i]);
                  }
                }

                if (e.length > 0) {
                  this._reject(e);
                } else {
                  this._cancel();
                }

                return true;
              }

              return false;
            };

            SomePromiseArray.prototype._fulfilled = function () {
              return this._totalResolved;
            };

            SomePromiseArray.prototype._rejected = function () {
              return this._values.length - this.length();
            };

            SomePromiseArray.prototype._addRejected = function (reason) {
              this._values.push(reason);
            };

            SomePromiseArray.prototype._addFulfilled = function (value) {
              this._values[this._totalResolved++] = value;
            };

            SomePromiseArray.prototype._canPossiblyFulfill = function () {
              return this.length() - this._rejected();
            };

            SomePromiseArray.prototype._getRangeError = function (count) {
              var message = "Input array must contain at least " + this._howMany + " items but contains only " + count + " items";
              return new RangeError(message);
            };

            SomePromiseArray.prototype._resolveEmptyArray = function () {
              this._reject(this._getRangeError(0));
            };

            function some(promises, howMany) {
              if ((howMany | 0) !== howMany || howMany < 0) {
                return apiRejection("expecting a positive integer\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
              }

              var ret = new SomePromiseArray(promises);
              var promise = ret.promise();
              ret.setHowMany(howMany);
              ret.init();
              return promise;
            }

            Promise.some = function (promises, howMany) {
              return some(promises, howMany);
            };

            Promise.prototype.some = function (howMany) {
              return some(this, howMany);
            };

            Promise._SomePromiseArray = SomePromiseArray;
          };
        }, {
          "./errors": 12,
          "./util": 36
        }],
        32: [function (_dereq_, module, exports) {
          "use strict";

          module.exports = function (Promise) {
            function PromiseInspection(promise) {
              if (promise !== undefined) {
                promise = promise._target();
                this._bitField = promise._bitField;
                this._settledValueField = promise._isFateSealed() ? promise._settledValue() : undefined;
              } else {
                this._bitField = 0;
                this._settledValueField = undefined;
              }
            }

            PromiseInspection.prototype._settledValue = function () {
              return this._settledValueField;
            };

            var value = PromiseInspection.prototype.value = function () {
              if (!this.isFulfilled()) {
                throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
              }

              return this._settledValue();
            };

            var reason = PromiseInspection.prototype.error = PromiseInspection.prototype.reason = function () {
              if (!this.isRejected()) {
                throw new TypeError("cannot get rejection reason of a non-rejected promise\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
              }

              return this._settledValue();
            };

            var isFulfilled = PromiseInspection.prototype.isFulfilled = function () {
              return (this._bitField & 33554432) !== 0;
            };

            var isRejected = PromiseInspection.prototype.isRejected = function () {
              return (this._bitField & 16777216) !== 0;
            };

            var isPending = PromiseInspection.prototype.isPending = function () {
              return (this._bitField & 50397184) === 0;
            };

            var isResolved = PromiseInspection.prototype.isResolved = function () {
              return (this._bitField & 50331648) !== 0;
            };

            PromiseInspection.prototype.isCancelled = function () {
              return (this._bitField & 8454144) !== 0;
            };

            Promise.prototype.__P_64_16 = function () {
              return (this._bitField & 65536) === 65536;
            };

            Promise.prototype._isCancelled = function () {
              return this._target().__P_64_16();
            };

            Promise.prototype.isCancelled = function () {
              return (this._target()._bitField & 8454144) !== 0;
            };

            Promise.prototype.isPending = function () {
              return isPending.call(this._target());
            };

            Promise.prototype.isRejected = function () {
              return isRejected.call(this._target());
            };

            Promise.prototype.isFulfilled = function () {
              return isFulfilled.call(this._target());
            };

            Promise.prototype.isResolved = function () {
              return isResolved.call(this._target());
            };

            Promise.prototype.value = function () {
              return value.call(this._target());
            };

            Promise.prototype.reason = function () {
              var target = this._target();

              target._unsetRejectionIsUnhandled();

              return reason.call(target);
            };

            Promise.prototype._value = function () {
              return this._settledValue();
            };

            Promise.prototype._reason = function () {
              this._unsetRejectionIsUnhandled();

              return this._settledValue();
            };

            Promise.PromiseInspection = PromiseInspection;
          };
        }, {}],
        33: [function (_dereq_, module, exports) {
          "use strict";

          module.exports = function (Promise, INTERNAL) {
            var util = _dereq_("./util");

            var errorObj = util.errorObj;
            var isObject = util.isObject;

            function tryConvertToPromise(obj, context) {
              if (isObject(obj)) {
                if (obj instanceof Promise) return obj;
                var then = getThen(obj);

                if (then === errorObj) {
                  if (context) context._pushContext();
                  var ret = Promise.reject(then.e);
                  if (context) context._popContext();
                  return ret;
                } else if (typeof then === "function") {
                  if (isAnyBluebirdPromise(obj)) {
                    var ret = new Promise(INTERNAL);

                    obj._then(ret._fulfill, ret._reject, undefined, ret, null);

                    return ret;
                  }

                  return doThenable(obj, then, context);
                }
              }

              return obj;
            }

            function doGetThen(obj) {
              return obj.then;
            }

            function getThen(obj) {
              try {
                return doGetThen(obj);
              } catch (e) {
                errorObj.e = e;
                return errorObj;
              }
            }

            var hasProp = {}.hasOwnProperty;

            function isAnyBluebirdPromise(obj) {
              try {
                return hasProp.call(obj, "_promise0");
              } catch (e) {
                return false;
              }
            }

            function doThenable(x, then, context) {
              var promise = new Promise(INTERNAL);
              var ret = promise;
              if (context) context._pushContext();

              promise._captureStackTrace();

              if (context) context._popContext();
              var synchronous = true;
              var result = util.tryCatch(then).call(x, resolve, reject);
              synchronous = false;

              if (promise && result === errorObj) {
                promise._rejectCallback(result.e, true, true);

                promise = null;
              }

              function resolve(value) {
                if (!promise) return;

                promise._resolveCallback(value);

                promise = null;
              }

              function reject(reason) {
                if (!promise) return;

                promise._rejectCallback(reason, synchronous, true);

                promise = null;
              }

              return ret;
            }

            return tryConvertToPromise;
          };
        }, {
          "./util": 36
        }],
        34: [function (_dereq_, module, exports) {
          "use strict";

          module.exports = function (Promise, INTERNAL, debug) {
            var util = _dereq_("./util");

            var TimeoutError = Promise.TimeoutError;

            function HandleWrapper(handle) {
              this.handle = handle;
            }

            HandleWrapper.prototype._resultCancelled = function () {
              clearTimeout(this.handle);
            };

            var afterValue = function (value) {
              return delay(+this).thenReturn(value);
            };

            var delay = Promise.delay = function (ms, value) {
              var ret;
              var handle;

              if (value !== undefined) {
                ret = Promise.resolve(value)._then(afterValue, null, null, ms, undefined);

                if (debug.cancellation() && value instanceof Promise) {
                  ret._setOnCancel(value);
                }
              } else {
                ret = new Promise(INTERNAL);
                handle = setTimeout(function () {
                  ret._fulfill();
                }, +ms);

                if (debug.cancellation()) {
                  ret._setOnCancel(new HandleWrapper(handle));
                }

                ret._captureStackTrace();
              }

              ret._setAsyncGuaranteed();

              return ret;
            };

            Promise.prototype.delay = function (ms) {
              return delay(ms, this);
            };

            var afterTimeout = function (promise, message, parent) {
              var err;

              if (typeof message !== "string") {
                if (message instanceof Error) {
                  err = message;
                } else {
                  err = new TimeoutError("operation timed out");
                }
              } else {
                err = new TimeoutError(message);
              }

              util.markAsOriginatingFromRejection(err);

              promise._attachExtraTrace(err);

              promise._reject(err);

              if (parent != null) {
                parent.cancel();
              }
            };

            function successClear(value) {
              clearTimeout(this.handle);
              return value;
            }

            function failureClear(reason) {
              clearTimeout(this.handle);
              throw reason;
            }

            Promise.prototype.timeout = function (ms, message) {
              ms = +ms;
              var ret, parent;
              var handleWrapper = new HandleWrapper(setTimeout(function timeoutTimeout() {
                if (ret.isPending()) {
                  afterTimeout(ret, message, parent);
                }
              }, ms));

              if (debug.cancellation()) {
                parent = this.then();
                ret = parent._then(successClear, failureClear, undefined, handleWrapper, undefined);

                ret._setOnCancel(handleWrapper);
              } else {
                ret = this._then(successClear, failureClear, undefined, handleWrapper, undefined);
              }

              return ret;
            };
          };
        }, {
          "./util": 36
        }],
        35: [function (_dereq_, module, exports) {
          "use strict";

          module.exports = function (Promise, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug) {
            var util = _dereq_("./util");

            var TypeError = _dereq_("./errors").TypeError;

            var inherits = _dereq_("./util").inherits;

            var errorObj = util.errorObj;
            var tryCatch = util.tryCatch;
            var NULL = {};

            function thrower(e) {
              setTimeout(function () {
                throw e;
              }, 0);
            }

            function castPreservingDisposable(thenable) {
              var maybePromise = tryConvertToPromise(thenable);

              if (maybePromise !== thenable && typeof thenable._isDisposable === "function" && typeof thenable._getDisposer === "function" && thenable._isDisposable()) {
                maybePromise._setDisposable(thenable._getDisposer());
              }

              return maybePromise;
            }

            function dispose(resources, inspection) {
              var i = 0;
              var len = resources.length;
              var ret = new Promise(INTERNAL);

              function iterator() {
                if (i >= len) return ret._fulfill();
                var maybePromise = castPreservingDisposable(resources[i++]);

                if (maybePromise instanceof Promise && maybePromise._isDisposable()) {
                  try {
                    maybePromise = tryConvertToPromise(maybePromise._getDisposer().tryDispose(inspection), resources.promise);
                  } catch (e) {
                    return thrower(e);
                  }

                  if (maybePromise instanceof Promise) {
                    return maybePromise._then(iterator, thrower, null, null, null);
                  }
                }

                iterator();
              }

              iterator();
              return ret;
            }

            function Disposer(data, promise, context) {
              this._data = data;
              this._promise = promise;
              this._context = context;
            }

            Disposer.prototype.data = function () {
              return this._data;
            };

            Disposer.prototype.promise = function () {
              return this._promise;
            };

            Disposer.prototype.resource = function () {
              if (this.promise().isFulfilled()) {
                return this.promise().value();
              }

              return NULL;
            };

            Disposer.prototype.tryDispose = function (inspection) {
              var resource = this.resource();
              var context = this._context;
              if (context !== undefined) context._pushContext();
              var ret = resource !== NULL ? this.doDispose(resource, inspection) : null;
              if (context !== undefined) context._popContext();

              this._promise._unsetDisposable();

              this._data = null;
              return ret;
            };

            Disposer.isDisposer = function (d) {
              return d != null && typeof d.resource === "function" && typeof d.tryDispose === "function";
            };

            function FunctionDisposer(fn, promise, context) {
              this.constructor$(fn, promise, context);
            }

            inherits(FunctionDisposer, Disposer);

            FunctionDisposer.prototype.doDispose = function (resource, inspection) {
              var fn = this.data();
              return fn.call(resource, resource, inspection);
            };

            function maybeUnwrapDisposer(value) {
              if (Disposer.isDisposer(value)) {
                this.resources[this.index]._setDisposable(value);

                return value.promise();
              }

              return value;
            }

            function ResourceList(length) {
              this.length = length;
              this.promise = null;
              this[length - 1] = null;
            }

            ResourceList.prototype._resultCancelled = function () {
              var len = this.length;

              for (var i = 0; i < len; ++i) {
                var item = this[i];

                if (item instanceof Promise) {
                  item.cancel();
                }
              }
            };

            Promise.using = function () {
              var len = arguments.length;
              if (len < 2) return apiRejection("you must pass at least 2 arguments to Promise.using");
              var fn = arguments[len - 1];

              if (typeof fn !== "function") {
                return apiRejection("expecting a function but got " + util.classString(fn));
              }

              var input;
              var spreadArgs = true;

              if (len === 2 && Array.isArray(arguments[0])) {
                input = arguments[0];
                len = input.length;
                spreadArgs = false;
              } else {
                input = arguments;
                len--;
              }

              var resources = new ResourceList(len);

              for (var i = 0; i < len; ++i) {
                var resource = input[i];

                if (Disposer.isDisposer(resource)) {
                  var disposer = resource;
                  resource = resource.promise();

                  resource._setDisposable(disposer);
                } else {
                  var maybePromise = tryConvertToPromise(resource);

                  if (maybePromise instanceof Promise) {
                    resource = maybePromise._then(maybeUnwrapDisposer, null, null, {
                      resources: resources,
                      index: i
                    }, undefined);
                  }
                }

                resources[i] = resource;
              }

              var reflectedResources = new Array(resources.length);

              for (var i = 0; i < reflectedResources.length; ++i) {
                reflectedResources[i] = Promise.resolve(resources[i]).reflect();
              }

              var resultPromise = Promise.all(reflectedResources).then(function (inspections) {
                for (var i = 0; i < inspections.length; ++i) {
                  var inspection = inspections[i];

                  if (inspection.isRejected()) {
                    errorObj.e = inspection.error();
                    return errorObj;
                  } else if (!inspection.isFulfilled()) {
                    resultPromise.cancel();
                    return;
                  }

                  inspections[i] = inspection.value();
                }

                promise._pushContext();

                fn = tryCatch(fn);
                var ret = spreadArgs ? fn.apply(undefined, inspections) : fn(inspections);

                var promiseCreated = promise._popContext();

                debug.checkForgottenReturns(ret, promiseCreated, "Promise.using", promise);
                return ret;
              });
              var promise = resultPromise.lastly(function () {
                var inspection = new Promise.PromiseInspection(resultPromise);
                return dispose(resources, inspection);
              });
              resources.promise = promise;

              promise._setOnCancel(resources);

              return promise;
            };

            Promise.prototype._setDisposable = function (disposer) {
              this._bitField = this._bitField | 131072;
              this._disposer = disposer;
            };

            Promise.prototype._isDisposable = function () {
              return (this._bitField & 131072) > 0;
            };

            Promise.prototype._getDisposer = function () {
              return this._disposer;
            };

            Promise.prototype._unsetDisposable = function () {
              this._bitField = this._bitField & ~131072;
              this._disposer = undefined;
            };

            Promise.prototype.disposer = function (fn) {
              if (typeof fn === "function") {
                return new FunctionDisposer(fn, this, createContext());
              }

              throw new TypeError();
            };
          };
        }, {
          "./errors": 12,
          "./util": 36
        }],
        36: [function (_dereq_, module, exports) {
          "use strict";

          var es5 = _dereq_("./es5");

          var canEvaluate = typeof navigator == "undefined";
          var errorObj = {
            e: {}
          };
          var tryCatchTarget;
          var globalObject = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : this !== undefined ? this : null;

          function tryCatcher() {
            try {
              var target = tryCatchTarget;
              tryCatchTarget = null;
              return target.apply(this, arguments);
            } catch (e) {
              errorObj.e = e;
              return errorObj;
            }
          }

          function tryCatch(fn) {
            tryCatchTarget = fn;
            return tryCatcher;
          }

          var inherits = function (Child, Parent) {
            var hasProp = {}.hasOwnProperty;

            function T() {
              this.constructor = Child;
              this.constructor$ = Parent;

              for (var propertyName in Parent.prototype) {
                if (hasProp.call(Parent.prototype, propertyName) && propertyName.charAt(propertyName.length - 1) !== "$") {
                  this[propertyName + "$"] = Parent.prototype[propertyName];
                }
              }
            }

            T.prototype = Parent.prototype;
            Child.prototype = new T();
            return Child.prototype;
          };

          function isPrimitive(val) {
            return val == null || val === true || val === false || typeof val === "string" || typeof val === "number";
          }

          function isObject(value) {
            return typeof value === "function" || typeof value === "object" && value !== null;
          }

          function maybeWrapAsError(maybeError) {
            if (!isPrimitive(maybeError)) return maybeError;
            return new Error(safeToString(maybeError));
          }

          function withAppended(target, appendee) {
            var len = target.length;
            var ret = new Array(len + 1);
            var i;

            for (i = 0; i < len; ++i) {
              ret[i] = target[i];
            }

            ret[i] = appendee;
            return ret;
          }

          function getDataPropertyOrDefault(obj, key, defaultValue) {
            if (es5.isES5) {
              var desc = Object.getOwnPropertyDescriptor(obj, key);

              if (desc != null) {
                return desc.get == null && desc.set == null ? desc.value : defaultValue;
              }
            } else {
              return {}.hasOwnProperty.call(obj, key) ? obj[key] : undefined;
            }
          }

          function notEnumerableProp(obj, name, value) {
            if (isPrimitive(obj)) return obj;
            var descriptor = {
              value: value,
              configurable: true,
              enumerable: false,
              writable: true
            };
            es5.defineProperty(obj, name, descriptor);
            return obj;
          }

          function thrower(r) {
            throw r;
          }

          var inheritedDataKeys = function () {
            var excludedPrototypes = [Array.prototype, Object.prototype, Function.prototype];

            var isExcludedProto = function (val) {
              for (var i = 0; i < excludedPrototypes.length; ++i) {
                if (excludedPrototypes[i] === val) {
                  return true;
                }
              }

              return false;
            };

            if (es5.isES5) {
              var getKeys = Object.getOwnPropertyNames;
              return function (obj) {
                var ret = [];
                var visitedKeys = Object.create(null);

                while (obj != null && !isExcludedProto(obj)) {
                  var keys;

                  try {
                    keys = getKeys(obj);
                  } catch (e) {
                    return ret;
                  }

                  for (var i = 0; i < keys.length; ++i) {
                    var key = keys[i];
                    if (visitedKeys[key]) continue;
                    visitedKeys[key] = true;
                    var desc = Object.getOwnPropertyDescriptor(obj, key);

                    if (desc != null && desc.get == null && desc.set == null) {
                      ret.push(key);
                    }
                  }

                  obj = es5.getPrototypeOf(obj);
                }

                return ret;
              };
            } else {
              var hasProp = {}.hasOwnProperty;
              return function (obj) {
                if (isExcludedProto(obj)) return [];
                var ret = [];
                /*jshint forin:false */

                enumeration: for (var key in obj) {
                  if (hasProp.call(obj, key)) {
                    ret.push(key);
                  } else {
                    for (var i = 0; i < excludedPrototypes.length; ++i) {
                      if (hasProp.call(excludedPrototypes[i], key)) {
                        continue enumeration;
                      }
                    }

                    ret.push(key);
                  }
                }

                return ret;
              };
            }
          }();

          var thisAssignmentPattern = /this\s*\.\s*\S+\s*=/;

          function isClass(fn) {
            try {
              if (typeof fn === "function") {
                var keys = es5.names(fn.prototype);
                var hasMethods = es5.isES5 && keys.length > 1;
                var hasMethodsOtherThanConstructor = keys.length > 0 && !(keys.length === 1 && keys[0] === "constructor");
                var hasThisAssignmentAndStaticMethods = thisAssignmentPattern.test(fn + "") && es5.names(fn).length > 0;

                if (hasMethods || hasMethodsOtherThanConstructor || hasThisAssignmentAndStaticMethods) {
                  return true;
                }
              }

              return false;
            } catch (e) {
              return false;
            }
          }

          function toFastProperties(obj) {
            /*jshint -W027,-W055,-W031*/
            function FakeConstructor() {}

            FakeConstructor.prototype = obj;
            var l = 8;

            while (l--) new FakeConstructor();

            return obj;
            eval(obj);
          }

          var rident = /^[a-z$_][a-z$_0-9]*$/i;

          function isIdentifier(str) {
            return rident.test(str);
          }

          function filledRange(count, prefix, suffix) {
            var ret = new Array(count);

            for (var i = 0; i < count; ++i) {
              ret[i] = prefix + i + suffix;
            }

            return ret;
          }

          function safeToString(obj) {
            try {
              return obj + "";
            } catch (e) {
              return "[no string representation]";
            }
          }

          function isError(obj) {
            return obj !== null && typeof obj === "object" && typeof obj.message === "string" && typeof obj.name === "string";
          }

          function markAsOriginatingFromRejection(e) {
            try {
              notEnumerableProp(e, "isOperational", true);
            } catch (ignore) {}
          }

          function originatesFromRejection(e) {
            if (e == null) return false;
            return e instanceof Error["__BluebirdErrorTypes__"].OperationalError || e["isOperational"] === true;
          }

          function canAttachTrace(obj) {
            return isError(obj) && es5.propertyIsWritable(obj, "stack");
          }

          var ensureErrorObject = function () {
            if (!("stack" in new Error())) {
              return function (value) {
                if (canAttachTrace(value)) return value;

                try {
                  throw new Error(safeToString(value));
                } catch (err) {
                  return err;
                }
              };
            } else {
              return function (value) {
                if (canAttachTrace(value)) return value;
                return new Error(safeToString(value));
              };
            }
          }();

          function classString(obj) {
            return {}.toString.call(obj);
          }

          function copyDescriptors(from, to, filter) {
            var keys = es5.names(from);

            for (var i = 0; i < keys.length; ++i) {
              var key = keys[i];

              if (filter(key)) {
                try {
                  es5.defineProperty(to, key, es5.getDescriptor(from, key));
                } catch (ignore) {}
              }
            }
          }

          var asArray = function (v) {
            if (es5.isArray(v)) {
              return v;
            }

            return null;
          };

          if (typeof Symbol !== "undefined" && Symbol.iterator) {
            var ArrayFrom = typeof Array.from === "function" ? function (v) {
              return Array.from(v);
            } : function (v) {
              var ret = [];
              var it = v[Symbol.iterator]();
              var itResult;

              while (!(itResult = it.next()).done) {
                ret.push(itResult.value);
              }

              return ret;
            };

            asArray = function (v) {
              if (es5.isArray(v)) {
                return v;
              } else if (v != null && typeof v[Symbol.iterator] === "function") {
                return ArrayFrom(v);
              }

              return null;
            };
          }

          var isNode = typeof process !== "undefined" && classString(process).toLowerCase() === "[object process]";

          function env(key, def) {
            return isNode ? process.env[key] : def;
          }

          function getNativePromise() {
            if (typeof Promise === "function") {
              try {
                var promise = new Promise(function () {});

                if ({}.toString.call(promise) === "[object Promise]") {
                  return Promise;
                }
              } catch (e) {}
            }
          }

          function domainBind(self, cb) {
            return self.bind(cb);
          }

          var ret = {
            isClass: isClass,
            isIdentifier: isIdentifier,
            inheritedDataKeys: inheritedDataKeys,
            getDataPropertyOrDefault: getDataPropertyOrDefault,
            thrower: thrower,
            isArray: es5.isArray,
            asArray: asArray,
            notEnumerableProp: notEnumerableProp,
            isPrimitive: isPrimitive,
            isObject: isObject,
            isError: isError,
            canEvaluate: canEvaluate,
            errorObj: errorObj,
            tryCatch: tryCatch,
            inherits: inherits,
            withAppended: withAppended,
            maybeWrapAsError: maybeWrapAsError,
            toFastProperties: toFastProperties,
            filledRange: filledRange,
            toString: safeToString,
            canAttachTrace: canAttachTrace,
            ensureErrorObject: ensureErrorObject,
            originatesFromRejection: originatesFromRejection,
            markAsOriginatingFromRejection: markAsOriginatingFromRejection,
            classString: classString,
            copyDescriptors: copyDescriptors,
            hasDevTools: typeof chrome !== "undefined" && chrome && typeof chrome.loadTimes === "function",
            isNode: isNode,
            env: env,
            global: globalObject,
            getNativePromise: getNativePromise,
            domainBind: domainBind
          };

          ret.isRecentNode = ret.isNode && function () {
            var version = process.versions.node.split(".").map(Number);
            return version[0] === 0 && version[1] > 10 || version[0] > 0;
          }();

          if (ret.isNode) ret.toFastProperties(process);

          try {
            throw new Error();
          } catch (e) {
            ret.lastLineError = e;
          }

          module.exports = ret;
        }, {
          "./es5": 13
        }]
      }, {}, [4])(4);
    });
  })();

  qx.Promise.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.lang.normalize.String": {
        "require": true
      },
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.lang.Function": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
  
     ======================================================================
  
     This class contains code based on the following work:
  
     * Mootools
       http://mootools.net/
       Version 1.1.1
  
       Copyright:
         (c) 2007 Valerio Proietti
  
       License:
         MIT: http://www.opensource.org/licenses/mit-license.php
  
     and
  
     * XRegExp
     http://xregexp.com/
     Version 1.5
  
     Copyright:
         (c) 2006-2007, Steven Levithan <http://stevenlevithan.com>
  
       License:
         MIT: http://www.opensource.org/licenses/mit-license.php
  
       Authors:
         * Steven Levithan
  
  ************************************************************************ */

  /**
   * String helper functions
   *
   * The native JavaScript String is not modified by this class. However,
   * there are modifications to the native String in {@link qx.lang.normalize.String} for
   * browsers that do not support certain features.
   *
   * @require(qx.lang.normalize.String)
   */
  qx.Bootstrap.define("qx.lang.String", {
    statics: {
      /**
       * Unicode letters.  they are taken from Steve Levithan's excellent XRegExp library [http://xregexp.com/addons/unicode/unicode-base.js]
       */
      __P_66_0: "0041-005A0061-007A00AA00B500BA00C0-00D600D8-00F600F8-02C102C6-02D102E0-02E402EC02EE0370-037403760377037A-037D03860388-038A038C038E-03A103A3-03F503F7-0481048A-05250531-055605590561-058705D0-05EA05F0-05F20621-064A066E066F0671-06D306D506E506E606EE06EF06FA-06FC06FF07100712-072F074D-07A507B107CA-07EA07F407F507FA0800-0815081A082408280904-0939093D09500958-0961097109720979-097F0985-098C098F09900993-09A809AA-09B009B209B6-09B909BD09CE09DC09DD09DF-09E109F009F10A05-0A0A0A0F0A100A13-0A280A2A-0A300A320A330A350A360A380A390A59-0A5C0A5E0A72-0A740A85-0A8D0A8F-0A910A93-0AA80AAA-0AB00AB20AB30AB5-0AB90ABD0AD00AE00AE10B05-0B0C0B0F0B100B13-0B280B2A-0B300B320B330B35-0B390B3D0B5C0B5D0B5F-0B610B710B830B85-0B8A0B8E-0B900B92-0B950B990B9A0B9C0B9E0B9F0BA30BA40BA8-0BAA0BAE-0BB90BD00C05-0C0C0C0E-0C100C12-0C280C2A-0C330C35-0C390C3D0C580C590C600C610C85-0C8C0C8E-0C900C92-0CA80CAA-0CB30CB5-0CB90CBD0CDE0CE00CE10D05-0D0C0D0E-0D100D12-0D280D2A-0D390D3D0D600D610D7A-0D7F0D85-0D960D9A-0DB10DB3-0DBB0DBD0DC0-0DC60E01-0E300E320E330E40-0E460E810E820E840E870E880E8A0E8D0E94-0E970E99-0E9F0EA1-0EA30EA50EA70EAA0EAB0EAD-0EB00EB20EB30EBD0EC0-0EC40EC60EDC0EDD0F000F40-0F470F49-0F6C0F88-0F8B1000-102A103F1050-1055105A-105D106110651066106E-10701075-1081108E10A0-10C510D0-10FA10FC1100-1248124A-124D1250-12561258125A-125D1260-1288128A-128D1290-12B012B2-12B512B8-12BE12C012C2-12C512C8-12D612D8-13101312-13151318-135A1380-138F13A0-13F41401-166C166F-167F1681-169A16A0-16EA1700-170C170E-17111720-17311740-17511760-176C176E-17701780-17B317D717DC1820-18771880-18A818AA18B0-18F51900-191C1950-196D1970-19741980-19AB19C1-19C71A00-1A161A20-1A541AA71B05-1B331B45-1B4B1B83-1BA01BAE1BAF1C00-1C231C4D-1C4F1C5A-1C7D1CE9-1CEC1CEE-1CF11D00-1DBF1E00-1F151F18-1F1D1F20-1F451F48-1F4D1F50-1F571F591F5B1F5D1F5F-1F7D1F80-1FB41FB6-1FBC1FBE1FC2-1FC41FC6-1FCC1FD0-1FD31FD6-1FDB1FE0-1FEC1FF2-1FF41FF6-1FFC2071207F2090-209421022107210A-211321152119-211D212421262128212A-212D212F-2139213C-213F2145-2149214E218321842C00-2C2E2C30-2C5E2C60-2CE42CEB-2CEE2D00-2D252D30-2D652D6F2D80-2D962DA0-2DA62DA8-2DAE2DB0-2DB62DB8-2DBE2DC0-2DC62DC8-2DCE2DD0-2DD62DD8-2DDE2E2F300530063031-3035303B303C3041-3096309D-309F30A1-30FA30FC-30FF3105-312D3131-318E31A0-31B731F0-31FF3400-4DB54E00-9FCBA000-A48CA4D0-A4FDA500-A60CA610-A61FA62AA62BA640-A65FA662-A66EA67F-A697A6A0-A6E5A717-A71FA722-A788A78BA78CA7FB-A801A803-A805A807-A80AA80C-A822A840-A873A882-A8B3A8F2-A8F7A8FBA90A-A925A930-A946A960-A97CA984-A9B2A9CFAA00-AA28AA40-AA42AA44-AA4BAA60-AA76AA7AAA80-AAAFAAB1AAB5AAB6AAB9-AABDAAC0AAC2AADB-AADDABC0-ABE2AC00-D7A3D7B0-D7C6D7CB-D7FBF900-FA2DFA30-FA6DFA70-FAD9FB00-FB06FB13-FB17FB1DFB1F-FB28FB2A-FB36FB38-FB3CFB3EFB40FB41FB43FB44FB46-FBB1FBD3-FD3DFD50-FD8FFD92-FDC7FDF0-FDFBFE70-FE74FE76-FEFCFF21-FF3AFF41-FF5AFF66-FFBEFFC2-FFC7FFCA-FFCFFFD2-FFD7FFDA-FFDC",

      /**
       * A RegExp that matches the first letter in a word - unicode aware
       */
      __P_66_1: null,

      /**
       * @type {Map} Cache for often used string operations [camelCasing and hyphenation]
       * e.g. marginTop => margin-top
       */
      __P_66_2: {},

      /**
       * Converts a hyphenated string (separated by '-') to camel case.
       *
       * Example:
       * <pre class='javascript'>qx.lang.String.camelCase("I-like-cookies"); //returns "ILikeCookies"</pre>
       *
       * @param str {String} hyphenated string
       * @return {String} camelcase string
       */
      camelCase: function (str) {
        var result = this.__P_66_2[str];

        if (!result) {
          result = str.replace(/\-([a-z])/g, function (match, chr) {
            return chr.toUpperCase();
          });

          if (str.indexOf("-") >= 0) {
            this.__P_66_2[str] = result;
          }
        }

        return result;
      },

      /**
       * Converts a camelcased string to a hyphenated (separated by '-') string.
       *
       * Example:
       * <pre class='javascript'>qx.lang.String.hyphenate("weLikeCookies"); //returns "we-like-cookies"</pre>
       *
       * @param str {String} camelcased string
       * @return {String} hyphenated string
       */
      hyphenate: function (str) {
        var result = this.__P_66_2[str];

        if (!result) {
          result = str.replace(/[A-Z]/g, function (match) {
            return '-' + match.charAt(0).toLowerCase();
          });

          if (str.indexOf("-") == -1) {
            this.__P_66_2[str] = result;
          }
        }

        return result;
      },

      /**
       * Converts a string to camel case.
       *
       * Example:
       * <pre class='javascript'>qx.lang.String.camelCase("i like cookies"); //returns "I Like Cookies"</pre>
       *
       * @param str {String} any string
       * @return {String} capitalized string
       */
      capitalize: function (str) {
        if (this.__P_66_1 === null) {
          var unicodeEscapePrefix = '\\u';
          this.__P_66_1 = new RegExp("(^|[^" + this.__P_66_0.replace(/[0-9A-F]{4}/g, function (match) {
            return unicodeEscapePrefix + match;
          }) + "])[" + this.__P_66_0.replace(/[0-9A-F]{4}/g, function (match) {
            return unicodeEscapePrefix + match;
          }) + "]", "g");
        }

        return str.replace(this.__P_66_1, function (match) {
          return match.toUpperCase();
        });
      },

      /**
       * Removes all extraneous whitespace from a string and trims it
       *
       * Example:
       *
       * <code>
       * qx.lang.String.clean(" i      like     cookies      \n\n");
       * </code>
       *
       * Returns "i like cookies"
       *
       * @param str {String} the string to clean up
       * @return {String} Cleaned up string
       */
      clean: function (str) {
        return str.replace(/\s+/g, ' ').trim();
      },

      /**
       * removes white space from the left side of a string
       *
       * @param str {String} the string to trim
       * @return {String} the trimmed string
       */
      trimLeft: function (str) {
        return str.replace(/^\s+/, "");
      },

      /**
       * removes white space from the right side of a string
       *
       * @param str {String} the string to trim
       * @return {String} the trimmed string
       */
      trimRight: function (str) {
        return str.replace(/\s+$/, "");
      },

      /**
       * Check whether the string starts with the given substring
       *
       * @deprecated {6.0} Please use String instance startsWith method instead
       *
       * @param fullstr {String} the string to search in
       * @param substr {String} the substring to look for
       * @return {Boolean} whether the string starts with the given substring
       */
      startsWith: function (fullstr, substr) {
        return fullstr.startsWith(substr);
      },

      /**
       * Check whether the string ends with the given substring
       *
       * @deprecated {6.0} Please use String instance endsWith method instead
       *
       * @param fullstr {String} the string to search in
       * @param substr {String} the substring to look for
       * @return {Boolean} whether the string ends with the given substring
       */
      endsWith: function (fullstr, substr) {
        return fullstr.endsWith(substr);
      },

      /**
       * Returns a string, which repeats a string 'length' times
       *
       * @param str {String} string used to repeat
       * @param times {Integer} the number of repetitions
       * @return {String} repeated string
       */
      repeat: function (str, times) {
        return str.length > 0 ? new Array(times + 1).join(str) : "";
      },

      /**
       * Pad a string up to a given length. Padding characters are added to the left of the string.
       *
       * @param str {String} the string to pad
       * @param length {Integer} the final length of the string
       * @param ch {String} character used to fill up the string
       * @return {String} padded string
       */
      pad: function (str, length, ch) {
        var padLength = length - str.length;

        if (padLength > 0) {
          if (typeof ch === "undefined") {
            ch = "0";
          }

          return this.repeat(ch, padLength) + str;
        } else {
          return str;
        }
      },

      /**
       * Convert the first character of the string to upper case.
       *
       * @signature function(str)
       * @param str {String} the string
       * @return {String} the string with an upper case first character
       */
      firstUp: qx.Bootstrap.firstUp,

      /**
       * Convert the first character of the string to lower case.
       *
       * @signature function(str)
       * @param str {String} the string
       * @return {String} the string with a lower case first character
       */
      firstLow: qx.Bootstrap.firstLow,

      /**
       * Check whether the string contains a given substring
       *
       * @param str {String} the string
       * @param substring {String} substring to search for
       * @return {Boolean} whether the string contains the substring
       */
      contains: function (str, substring) {
        return str.indexOf(substring) != -1;
      },

      /**
       * Print a list of arguments using a format string
       * In the format string occurrences of %n are replaced by the n'th element of the args list.
       * You can give an object as argument.
       * In this case you should specify namedArgument in your string with %{namedArgument}.
       * The named argument will be replace by the value of the property of the object named "namedArgument"
       * Example:
       * <pre class='javascript'>qx.lang.String.format("Hello %1, my name is %2", ["Egon", "Franz"]) == "Hello Egon, my name is Franz"</pre>
       * <pre class='javascript'>qx.lang.String.format("Hello %{yourName}, my name is %{myName}", {yourName: "Egon", myName: "Franz"}) == "Hello Egon, my name is Franz"</pre>
       *
       * @param pattern {String} format string
       * @param args {Array} array of arguments to insert into the format string
       * @return {String} the formatted string
       */
      format: function (pattern, args) {
        var str = pattern;
        var regexp = /%(\d+)|%{(\S[^}\s]*)}/g;

        if (!Array.isArray(args)) {
          args = [args];
        }

        var argsIsObject = args.length === 1 && typeof args[0] === "object";
        str = str.replace(regexp, function (matchedSubString, numberArgument, namedArgument) {
          if (namedArgument) {
            if (argsIsObject) {
              return args[0][namedArgument];
            }

            return namedArgument;
          }

          if (numberArgument && numberArgument > 0 && args.length >= numberArgument) {
            var index = numberArgument - 1;
            return args[index];
          }

          return matchedSubString;
        });
        return str;
      },

      /**
       * Escapes all chars that have a special meaning in regular expressions
       *
       * @param str {String} the string where to escape the chars.
       * @return {String} the string with the escaped chars.
       */
      escapeRegexpChars: function (str) {
        return str.replace(/([.*+?^${}()|[\]\/\\])/g, '\\$1');
      },

      /**
       * Converts a string to an array of characters.
       * <pre>"hello" => [ "h", "e", "l", "l", "o" ];</pre>
       *
       * @param str {String} the string which should be split
       * @return {Array} the result array of characters
       */
      toArray: function (str) {
        return str.split(/\B|\b/g);
      },

      /**
       * Remove HTML/XML tags from a string
       * Example:
       * <pre class='javascript'>qx.lang.String.stripTags("&lt;h1>Hello&lt;/h1>") == "Hello"</pre>
       *
       * @param str {String} string containing tags
       * @return {String} the string with stripped tags
       */
      stripTags: function (str) {
        return str.replace(/<\/?[^>]+>/gi, "");
      },

      /**
       * Strips <script> tags including its content from the given string.
       *
       * @param str {String} string containing tags
       * @param exec {Boolean?false} Whether the filtered code should be executed
       * @return {String} The filtered string
       */
      stripScripts: function (str, exec) {
        var scripts = "";
        var text = str.replace(/<script[^>]*>([\s\S]*?)<\/script>/gi, function () {
          scripts += arguments[1] + '\n';
          return "";
        });

        if (exec === true) {
          qx.lang.Function.globalEval(scripts);
        }

        return text;
      },

      /**
       * Quotes the given string.
       * @param str {String} String to quote.
       * @return {String} The quoted string.
       */
      quote: function (str) {
        return '"' + str.replace(/\\/g, "\\\\").replace(/\"/g, "\\\"") + '"';
      }
    }
  });
  qx.lang.String.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.AssertionError": {},
      "qx.core.Object": {},
      "qx.log.Logger": {},
      "qx.lang.String": {},
      "qx.lang.Function": {},
      "qx.data.IListData": {},
      "qx.core.ValidationError": {},
      "qx.lang.Type": {},
      "qx.lang.Array": {},
      "qx.core.ObjectRegistry": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * Single-value binding is a core component of the data binding package.
   */
  qx.Class.define("qx.data.SingleValueBinding", {
    statics: {
      /** internal reference for all bindings indexed by source object */
      __P_93_0: {},

      /** internal reference for all bindings indexed by target object */
      __P_93_1: {},

      /**
       * The function is responsible for binding a source objects property to
       * a target objects property. Both properties have to have the usual qooxdoo
       * getter and setter. The source property also needs to fire change-events
       * on every change of its value.
       * Please keep in mind, that this binding is unidirectional. If you need
       * a binding in both directions, you have to use two of this bindings.
       *
       * It's also possible to bind some kind of a hierarchy as a source. This
       * means that you can separate the source properties with a dot and bind
       * by that the object referenced to this property chain.
       * Example with an object 'a' which has object 'b' stored in its 'child'
       * property. Object b has a string property named abc:
       * <pre><code>
       * qx.data.SingleValueBinding.bind(a, "child.abc", textfield, "value");
       * </code></pre>
       * In that case, if the property abc of b changes, the textfield will
       * automatically contain the new value. Also if the child of a changes, the
       * new value (abc of the new child) will be in the textfield.
       *
       * There is also a possibility of binding an array. Therefore the array
       * {@link qx.data.IListData} is needed because this array has change events
       * which the native does not. Imagine a qooxdoo object a which has a
       * children property containing an array holding more of its own kind.
       * Every object has a name property as a string.
       * <pre>
       * var svb = qx.data.SingleValueBinding;
       * // bind the first child's name of 'a' to a textfield
       * svb.bind(a, "children[0].name", textfield, "value");
       * // bind the last child's name of 'a' to a textfield
       * svb.bind(a, "children[last].name", textfield2, "value");
       * // also deeper bindings are possible
       * svb.bind(a, "children[0].children[0].name", textfield3, "value");
       * </pre>
       *
       * As you can see in this example, the abc property of a's b will be bound
       * to the textfield. If now the value of b changed or even the a will get a
       * new b, the binding still shows the right value.
       *
       * @param sourceObject {qx.core.Object} The source of the binding.
       * @param sourcePropertyChain {String} The property chain which represents
       *   the source property.
       * @param targetObject {qx.core.Object} The object which the source should
       *   be bind to.
       * @param targetPropertyChain {String} The property chain to the target
       *   object.
       * @param options {Map?null} A map containing the options.
       *   <li>converter: A converter function which takes four parameters
       *       and should return the converted value.
       *       <ol>
       *         <li>The data to convert</li>
       *         <li>The corresponding model object, which is only set in case of the use of an controller.</li>
       *         <li>The source object for the binding</li>
       *         <li>The target object.</li>
       *       </ol>
       *       If no conversion has been done, the given value should be returned.
       *       e.g. a number to boolean converter
       *       <code>function(data, model, source, target) {return data > 100;}</code>
       *   </li>
       *   <li>onUpdate: A callback function can be given here. This method will be
       *       called if the binding was updated successful. There will be
       *       three parameter you do get in that method call.
       *       <ol>
       *         <li>The source object</li>
       *         <li>The target object</li>
       *         <li>The data</li>
       *       </ol>
       *       Here is a sample: <code>onUpdate : function(source, target, data) {...}</code>
       *   </li>
       *   <li>onSetFail: A callback function can be given here. This method will
       *       be called if the set of the value fails.
       *   </li>
       *   <li>ignoreConverter: A string which will be matched using the current
       *       property chain. If it matches, the converter will not be called.
       *   </li>
       *
       * @return {var} Returns the internal id for that binding. This can be used
       *   for referencing the binding or e.g. for removing. This is not an atomic
       *   id so you can't you use it as a hash-map index.
       *
       * @throws {qx.core.AssertionError} If the event is no data event or
       *   there is no property definition for object and property (source and
       *   target).
       */
      bind: function (sourceObject, sourcePropertyChain, targetObject, targetPropertyChain, options) {
        // check for the arguments
        // set up the target binding
        var targetListenerMap = this.__P_93_2(sourceObject, sourcePropertyChain, targetObject, targetPropertyChain, options); // get the property names


        var propertyNames = sourcePropertyChain.split("."); // stuff that's needed to store for the listener function

        var arrayIndexValues = this.__P_93_3(propertyNames);

        var sources = [];
        var listeners = [];
        var listenerIds = [];
        var eventNames = [];
        var source = sourceObject;
        var initialPromise = null; // add a try catch to make it possible to remove the listeners of the
        // chain in case the loop breaks after some listeners already added.

        try {
          // go through all property names
          for (var i = 0; i < propertyNames.length; i++) {
            var propertyName = propertyNames[i]; // check for the array

            if (arrayIndexValues[i] !== "") {
              // push the array change event
              eventNames.push("change");
            } else {
              var eventName = this.__P_93_4(source, propertyName);

              if (!eventName) {
                if (i == 0) {
                  // the root property can not change --> error
                  throw new qx.core.AssertionError("Binding property " + propertyName + " of object " + source + " not possible: No event available. Full property chain: " + sourcePropertyChain);
                }

                if (source instanceof qx.core.Object && qx.Class.hasProperty(source.constructor, propertyName)) {
                  qx.log.Logger.warn("Binding property " + propertyName + " of object " + source + " not possible: No event available. Full property chain: " + sourcePropertyChain);
                } // call the converter if no event could be found on binding creation


                initialPromise = this.__P_93_5(undefined, targetObject, targetPropertyChain, options, sourceObject);
                break;
              }

              eventNames.push(eventName);
            } // save the current source


            sources[i] = source; // check for the last property

            if (i == propertyNames.length - 1) {
              // if it is an array, set the initial value and bind the event
              if (arrayIndexValues[i] !== "") {
                // get the current value
                var itemIndex = arrayIndexValues[i] === "last" ? source.length - 1 : arrayIndexValues[i];
                var currentValue = source.getItem(itemIndex); // set the initial value

                initialPromise = this.__P_93_5(currentValue, targetObject, targetPropertyChain, options, sourceObject); // bind the event

                listenerIds[i] = this.__P_93_6(source, eventNames[i], targetObject, targetPropertyChain, options, arrayIndexValues[i]);
              } else {
                // try to set the initial value
                if (propertyNames[i] != null && source["get" + qx.lang.String.firstUp(propertyNames[i])] != null) {
                  var currentValue = source["get" + qx.lang.String.firstUp(propertyNames[i])]();
                  initialPromise = this.__P_93_5(currentValue, targetObject, targetPropertyChain, options, sourceObject);
                } // bind the property


                listenerIds[i] = this.__P_93_6(source, eventNames[i], targetObject, targetPropertyChain, options);
              } // if its not the last property

            } else {
              // create the context for the listener
              var context = {
                index: i,
                propertyNames: propertyNames,
                sources: sources,
                listenerIds: listenerIds,
                arrayIndexValues: arrayIndexValues,
                targetObject: targetObject,
                targetPropertyChain: targetPropertyChain,
                options: options,
                listeners: listeners
              }; // create a listener

              var listener = qx.lang.Function.bind(this.__P_93_7, this, context); // store the listener for further processing

              listeners.push(listener); // add the chaining listener

              listenerIds[i] = source.addListener(eventNames[i], listener);
            } // get and store the next source


            if (source["get" + qx.lang.String.firstUp(propertyNames[i])] == null) {
              source = undefined;
            } else if (arrayIndexValues[i] !== "") {
              var itemIndex = arrayIndexValues[i] === "last" ? source.length - 1 : arrayIndexValues[i];
              source = source["get" + qx.lang.String.firstUp(propertyNames[i])](itemIndex);
            } else {
              source = source["get" + qx.lang.String.firstUp(propertyNames[i])](); // the value should be undefined if we can not find the last part of the property chain

              if (source === null && propertyNames.length - 1 != i) {
                source = undefined;
              }
            }

            if (!source) {
              // call the converter if no source could be found on binding creation
              this.__P_93_5(source, targetObject, targetPropertyChain, options, sourceObject);

              break;
            }
          }
        } catch (ex) {
          // remove the already added listener
          // go through all added listeners (source)
          for (var i = 0; i < sources.length; i++) {
            // check if a source is available
            if (sources[i] && listenerIds[i]) {
              sources[i].removeListenerById(listenerIds[i]);
            }
          }

          var targets = targetListenerMap.targets;
          var targetIds = targetListenerMap.listenerIds; // go through all added listeners (target)

          for (var i = 0; i < targets.length; i++) {
            // check if a target is available
            if (targets[i] && targetIds[i]) {
              targets[i].removeListenerById(targetIds[i]);
            }
          }

          throw ex;
        } // create the id map


        var id = {
          type: "deepBinding",
          listenerIds: listenerIds,
          sources: sources,
          targetListenerIds: targetListenerMap.listenerIds,
          targets: targetListenerMap.targets,
          initialPromise: initialPromise
        }; // store the bindings

        this.__P_93_8(id, sourceObject, sourcePropertyChain, targetObject, targetPropertyChain);

        return id;
      },

      /**
       * Event listener for the chaining of the properties.
       *
       * @param context {Map} The current context for the listener.
       */
      __P_93_7: function (context) {
        // invoke the onUpdate method
        if (context.options && context.options.onUpdate) {
          context.options.onUpdate(context.sources[context.index], context.targetObject);
        } // delete all listener after the current one


        for (var j = context.index + 1; j < context.propertyNames.length; j++) {
          // remove the old sources
          var source = context.sources[j];
          context.sources[j] = null;

          if (!source) {
            continue;
          } // remove the listeners


          source.removeListenerById(context.listenerIds[j]);
        } // get the current source


        var source = context.sources[context.index]; // add new once after the current one

        for (var j = context.index + 1; j < context.propertyNames.length; j++) {
          // get and store the new source
          if (context.arrayIndexValues[j - 1] !== "") {
            source = source["get" + qx.lang.String.firstUp(context.propertyNames[j - 1])](context.arrayIndexValues[j - 1]);
          } else {
            source = source["get" + qx.lang.String.firstUp(context.propertyNames[j - 1])]();
          }

          context.sources[j] = source; // reset the target object if no new source could be found

          if (!source) {
            // use the converter if the property chain breaks [BUG# 6880]
            if (context.options && context.options.converter) {
              var ignoreConverter = false; // take care of the ignore pattern used for the controller

              if (context.options.ignoreConverter) {
                // the current property chain as string
                var currentSourceChain = context.propertyNames.slice(0, j).join("."); // match for the current pattern given in the options

                var match = currentSourceChain.match(new RegExp("^" + context.options.ignoreConverter));
                ignoreConverter = match ? match.length > 0 : false;
              }

              if (!ignoreConverter) {
                this.__P_93_9(context.targetObject, context.targetPropertyChain, context.options.converter());
              } else {
                this.__P_93_10(context.targetObject, context.targetPropertyChain);
              }
            } else {
              this.__P_93_10(context.targetObject, context.targetPropertyChain);
            }

            break;
          } // if its the last property


          if (j == context.propertyNames.length - 1) {
            // if its an array
            if (qx.Class.implementsInterface(source, qx.data.IListData) && context.arrayIndexValues[j] !== "") {
              // set the initial value
              var itemIndex = context.arrayIndexValues[j] === "last" ? source.length - 1 : context.arrayIndexValues[j];
              var currentValue = source.getItem(itemIndex);

              this.__P_93_5(currentValue, context.targetObject, context.targetPropertyChain, context.options, context.sources[context.index]); // bind the item event to the new target


              context.listenerIds[j] = this.__P_93_6(source, "change", context.targetObject, context.targetPropertyChain, context.options, context.arrayIndexValues[j]);
            } else {
              if (context.propertyNames[j] != null && source["get" + qx.lang.String.firstUp(context.propertyNames[j])] != null) {
                var currentValue = source["get" + qx.lang.String.firstUp(context.propertyNames[j])]();

                this.__P_93_5(currentValue, context.targetObject, context.targetPropertyChain, context.options, context.sources[context.index]);
              }

              var eventName = this.__P_93_4(source, context.propertyNames[j]);

              if (!eventName) {
                context.sources[j] = null;

                this.__P_93_10(context.targetObject, context.targetPropertyChain);

                return;
              } // bind the last property to the new target


              context.listenerIds[j] = this.__P_93_6(source, eventName, context.targetObject, context.targetPropertyChain, context.options);
            }
          } else {
            // check if a listener already created
            if (context.listeners[j] == null) {
              var listener = qx.lang.Function.bind(this.__P_93_7, this, context); // store the listener for further processing

              context.listeners.push(listener);
            } // add a new listener


            if (qx.Class.implementsInterface(source, qx.data.IListData)) {
              var eventName = "change";
            } else {
              var eventName = this.__P_93_4(source, context.propertyNames[j]);
            }

            if (!eventName) {
              context.sources[j] = null;

              this.__P_93_10(context.targetObject, context.targetPropertyChain);

              return;
            }

            context.listenerIds[j] = source.addListener(eventName, context.listeners[j]);
          }
        }
      },

      /**
       * Internal helper for setting up the listening to the changes on the
       * target side of the binding. Only works if the target property is a
       * property chain
       *
       * @param sourceObject {qx.core.Object} The source of the binding.
       * @param sourcePropertyChain {String} The property chain which represents
       *   the source property.
       * @param targetObject {qx.core.Object} The object which the source should
       *   be bind to.
       * @param targetPropertyChain {String} The property name of the target
       *   object.
       * @param options {Map} The options map perhaps containing the user defined
       *   converter.
       * @return {var} A map containing the listener ids and the targets.
       */
      __P_93_2: function (sourceObject, sourcePropertyChain, targetObject, targetPropertyChain, options) {
        // get the property names
        var propertyNames = targetPropertyChain.split(".");

        var arrayIndexValues = this.__P_93_3(propertyNames);

        var targets = [];
        var listeners = [];
        var listenerIds = [];
        var eventNames = [];
        var target = targetObject; // go through all property names

        for (var i = 0; i < propertyNames.length - 1; i++) {
          // check for the array
          if (arrayIndexValues[i] !== "") {
            // push the array change event
            eventNames.push("change");
          } else {
            var eventName = this.__P_93_4(target, propertyNames[i]);

            if (!eventName) {
              // if the event names could not be terminated,
              // just ignore the target chain listening
              break;
            }

            eventNames.push(eventName);
          } // save the current source


          targets[i] = target; // create a listener

          var listener = function () {
            // delete all listener after the current one
            for (var j = i + 1; j < propertyNames.length - 1; j++) {
              // remove the old sources
              var target = targets[j];
              targets[j] = null;

              if (!target) {
                continue;
              } // remove the listeners


              target.removeListenerById(listenerIds[j]);
            } // get the current target


            var target = targets[i]; // add new once after the current one

            for (var j = i + 1; j < propertyNames.length - 1; j++) {
              var firstUpPropName = qx.lang.String.firstUp(propertyNames[j - 1]); // get and store the new target

              if (arrayIndexValues[j - 1] !== "") {
                var currentIndex = arrayIndexValues[j - 1] === "last" ? target.getLength() - 1 : arrayIndexValues[j - 1];
                target = target["get" + firstUpPropName](currentIndex);
              } else {
                target = target["get" + firstUpPropName]();
              }

              targets[j] = target;

              if (!target) {
                break;
              } // check if a listener already created


              if (listeners[j] == null) {
                // store the listener for further processing
                listeners.push(listener);
              } // add a new listener


              if (qx.Class.implementsInterface(target, qx.data.IListData)) {
                var eventName = "change";
              } else {
                var eventName = qx.data.SingleValueBinding.__P_93_4(target, propertyNames[j]);

                if (!eventName) {
                  // if the event name could not be terminated,
                  // ignore the rest
                  break;
                }
              }

              listenerIds[j] = target.addListener(eventName, listeners[j]);
            }

            qx.data.SingleValueBinding.updateTarget(sourceObject, sourcePropertyChain, targetObject, targetPropertyChain, options);
          }; // store the listener for further processing


          listeners.push(listener); // add the chaining listener

          listenerIds[i] = target.addListener(eventNames[i], listener);
          var firstUpPropName = qx.lang.String.firstUp(propertyNames[i]); // get and store the next target

          if (target["get" + firstUpPropName] == null) {
            target = null;
          } else if (arrayIndexValues[i] !== "") {
            target = target["get" + firstUpPropName](arrayIndexValues[i]);
          } else {
            target = target["get" + firstUpPropName]();
          }

          if (!target) {
            break;
          }
        }

        return {
          listenerIds: listenerIds,
          targets: targets
        };
      },

      /**
       * Helper for updating the target. Gets the current set data from the source
       * and set that on the target.
       *
       * @param sourceObject {qx.core.Object} The source of the binding.
       * @param sourcePropertyChain {String} The property chain which represents
       *   the source property.
       * @param targetObject {qx.core.Object} The object which the source should
       *   be bind to.
       * @param targetPropertyChain {String} The property name of the target
       *   object.
       * @param options {Map} The options map perhaps containing the user defined
       *   converter.
       *
       * @internal
       */
      updateTarget: function (sourceObject, sourcePropertyChain, targetObject, targetPropertyChain, options) {
        var value = this.resolvePropertyChain(sourceObject, sourcePropertyChain); // convert the data before setting

        value = qx.data.SingleValueBinding.__P_93_11(value, targetObject, targetPropertyChain, options, sourceObject);

        this.__P_93_9(targetObject, targetPropertyChain, value);
      },

      /**
       * Internal helper for getting the current set value at the property chain.
       *
       * @param o {qx.core.Object} The source of the binding.
       * @param propertyChain {String} The property chain which represents
       *   the source property.
       * @return {var?undefined} Returns the set value if defined.
       */
      resolvePropertyChain: function (o, propertyChain) {
        var properties = this.__P_93_12(propertyChain);

        return this.__P_93_13(o, properties, properties.length);
      },

      /**
       * Tries to return a fitting event name to the given source object and
       * property name. First, it assumes that the property name is a real property
       * and therefore it checks the property definition for the event. The second
       * possibility is to check if there is an event with the given name. The
       * third and last possibility checked is if there is an event which is named
       * change + propertyName. If this three possibilities fail, an error will be
       * thrown.
       *
       * @param source {qx.core.Object} The source where the property is stored.
       * @param propertyName {String} The name of the property.
       * @return {String|null} The name of the corresponding event or null.
       */
      __P_93_4: function (source, propertyName) {
        // get the current event name from the property definition
        var eventName = this.__P_93_14(source, propertyName); // if no event name could be found


        if (eventName == null) {
          // check if the propertyName is the event name
          if (qx.Class.supportsEvent(source.constructor, propertyName)) {
            eventName = propertyName; // check if the change + propertyName is the event name
          } else if (qx.Class.supportsEvent(source.constructor, "change" + qx.lang.String.firstUp(propertyName))) {
            eventName = "change" + qx.lang.String.firstUp(propertyName);
          } else {
            return null;
          }
        }

        return eventName;
      },

      /**
       * Resets the value of the given target after resolving the target property
       * chain.
       *
       * @param targetObject {qx.core.Object} The object where the property chain
       *   starts.
       * @param targetPropertyChain {String} The names of the properties,
       *   separated with a dot.
       */
      __P_93_10: function (targetObject, targetPropertyChain) {
        // get the last target object of the chain
        var properties = this.__P_93_12(targetPropertyChain);

        var target = this.__P_93_13(targetObject, properties);

        if (target != null) {
          // get the name of the last property
          var lastProperty = properties[properties.length - 1]; // check for an array and set the value to null

          var index = this.__P_93_15(lastProperty);

          if (index) {
            this.__P_93_9(targetObject, targetPropertyChain, null);

            return;
          } // try to reset the property


          if (target["reset" + qx.lang.String.firstUp(lastProperty)] != undefined) {
            target["reset" + qx.lang.String.firstUp(lastProperty)]();
          } else {
            // fallback if no resetter is given (see bug #2456)
            if (typeof target["set" + qx.lang.String.firstUp(lastProperty)] != "function") {
              throw new qx.core.AssertionError("No setter for '" + lastProperty + "' on target " + target + ".");
            }

            target["set" + qx.lang.String.firstUp(lastProperty)](null);
          }
        }
      },

      /**
       * Sets the given value to the given target after resolving the
       * target property chain.
       *
       * @param targetObject {qx.core.Object} The object where the property chain
       *   starts.
       * @param targetPropertyChain {String} The names of the properties,
       *   separated with a dot.
       * @param value {var} The value to set.
       */
      __P_93_9: function (targetObject, targetPropertyChain, value) {
        // get the last target object of the chain
        var properties = this.__P_93_12(targetPropertyChain);

        var target = this.__P_93_13(targetObject, properties);

        if (target) {
          // get the name of the last property
          var lastProperty = properties[properties.length - 1]; // check for array notation

          var index = this.__P_93_15(lastProperty);

          if (index) {
            if (index === "last") {
              // check for the 'last' notation
              index = target.length - 1;
            }

            target.setItem(index, value);
          } else {
            if (typeof target["set" + qx.lang.String.firstUp(lastProperty)] != "function") {
              throw new qx.core.AssertionError("No setter for '" + lastProperty + "' on target " + target + ".");
            }

            return target["set" + qx.lang.String.firstUp(lastProperty)](value);
          }
        }
      },

      /**
       * Returns the index from a property using bracket notation, e.g.
       * "[42]" returns "42", "[last]" returns "last"
       *
       * @param propertyName {String} A property name
       * @return {String|null} Array index or null if the property name does
       * not use bracket notation
       */
      __P_93_15: function (propertyName) {
        var arrayExp = /^\[(\d+|last)\]$/;
        var arrayMatch = propertyName.match(arrayExp);

        if (arrayMatch) {
          return arrayMatch[1];
        }

        return null;
      },

      /**
       * Converts a property chain string into a list of properties and/or
       * array indexes
       * @param targetPropertyChain {String} property chain
       * @return {String[]} Array of property names
       */
      __P_93_12: function (targetPropertyChain) {
        // split properties (dot notation) and array indexes (bracket notation)
        return targetPropertyChain.replace(/\[/g, ".[").split(".").filter(function (prop) {
          return prop !== "";
        });
      },

      /**
       * Helper-Function resolving the object on which the last property of the
       * chain should be set.
       *
       * @param targetObject {qx.core.Object} The object where the property chain
       *   starts.
       * @param targetProperties {String[]} Array containing the names of the properties
       * @param index {Number?} The array index of the last property to be considered.
       * Default: The last item's index
       * @return {qx.core.Object | null} The object on which the last property
       *   should be set.
       */
      __P_93_13: function (targetObject, targetProperties, index) {
        index = index || targetProperties.length - 1;
        var target = targetObject;

        for (var i = 0; target !== null && i < index; i++) {
          try {
            var property = targetProperties[i]; // array notation

            var arrIndex = this.__P_93_15(property);

            if (arrIndex) {
              if (arrIndex === "last") {
                // check for the 'last' notation
                arrIndex = target.length - 1;
              }

              target = target.getItem(arrIndex);
            } else {
              target = target["get" + qx.lang.String.firstUp(property)]();
            }
          } catch (ex) {
            return null;
          }
        }

        return target;
      },

      /**
       * Set the given value to the target property. This method is used for
       * initially set the value.
       *
       * @param value {var} The value to set.
       * @param targetObject {qx.core.Object} The object which contains the target
       *   property.
       * @param targetPropertyChain {String} The name of the target property in the
       *   target object.
       * @param options {Map} The options map perhaps containing the user defined
       *   converter.
       * @param sourceObject {qx.core.Object} The source object of the binding (
       *   used for the onUpdate callback).
       */
      __P_93_5: function (value, targetObject, targetPropertyChain, options, sourceObject) {
        // first convert the initial value
        value = this.__P_93_11(value, targetObject, targetPropertyChain, options, sourceObject); // check if the converted value is undefined

        if (value === undefined) {
          this.__P_93_10(targetObject, targetPropertyChain);
        } // only set the initial value if one is given (may be null)


        if (value !== undefined) {
          try {
            var result = this.__P_93_9(targetObject, targetPropertyChain, value); // tell the user that the setter was invoked probably


            if (options && options.onUpdate) {
              options.onUpdate(sourceObject, targetObject, value);
            }

            return result;
          } catch (e) {
            if (!(e instanceof qx.core.ValidationError)) {
              throw e;
            }

            if (options && options.onSetFail) {
              options.onSetFail(e);
            } else {
              qx.log.Logger.warn("Failed so set value " + value + " on " + targetObject + ". Error message: " + e);
            }
          }
        }
      },

      /**
       * Checks for an array element in the given property names and adapts the
       * arrays to fit the algorithm.
       *
       * @param propertyNames {Array} The array containing the property names.
       *   Attention, this method can change this parameter!!!
       * @return {Array} An array containing the values of the array properties
       *   corresponding to the property names.
       */
      __P_93_3: function (propertyNames) {
        // array for the values of the array properties
        var arrayIndexValues = []; // go through all properties and check for array notations

        for (var i = 0; i < propertyNames.length; i++) {
          var name = propertyNames[i]; // if its an array property in the chain

          if (name.endsWith("]")) {
            // get the inner value of the array notation
            var arrayIndex = name.substring(name.indexOf("[") + 1, name.indexOf("]")); // check the arrayIndex

            if (name.indexOf("]") != name.length - 1) {
              throw new Error("Please use only one array at a time: " + name + " does not work.");
            }

            if (arrayIndex !== "last") {
              if (arrayIndex == "" || isNaN(parseInt(arrayIndex, 10))) {
                throw new Error("No number or 'last' value has been given in an array binding: " + name + " does not work.");
              }
            } // if a property is in front of the array notation


            if (name.indexOf("[") != 0) {
              // store the property name without the array notation
              propertyNames[i] = name.substring(0, name.indexOf("[")); // store the values in the array for the current iteration

              arrayIndexValues[i] = ""; // store the properties for the next iteration (the item of the array)

              arrayIndexValues[i + 1] = arrayIndex;
              propertyNames.splice(i + 1, 0, "item"); // skip the next iteration. its the array item and its already set

              i++; // it the array notation is the beginning
            } else {
              // store the array index and override the entry in the property names
              arrayIndexValues[i] = arrayIndex;
              propertyNames.splice(i, 1, "item");
            }
          } else {
            arrayIndexValues[i] = "";
          }
        }

        return arrayIndexValues;
      },

      /**
       * Internal helper method which is actually doing all bindings. That means
       * that an event listener will be added to the source object which listens
       * to the given event and invokes an set on the target property on the
       * targetObject.
       * This method does not store the binding in the internal reference store
       * so it should NOT be used from outside this class. For an outside usage,
       * use {@link #bind}.
       *
       * @param sourceObject {qx.core.Object} The source of the binding.
       * @param sourceEvent {String} The event of the source object which could
       *   be the change event in common but has to be an
       *   {@link qx.event.type.Data} event.
       * @param targetObject {qx.core.Object} The object which the source should
       *   be bind to.
       * @param targetProperty {String} The property name of the target object.
       * @param options {Map} A map containing the options. See
       *   {@link #bind} for more information.
       * @param arrayIndex {String} The index of the given array if its an array
       *   to bind.
       *
       * @return {var} Returns the internal id for that binding. This can be used
       *   for referencing the binding or e.g. for removing. This is not an atomic
       *   id so you can't you use it as a hash-map index. It's the id which will
       *   be returned by the {@link qx.core.Object#addListener} method.
       * @throws {qx.core.AssertionError} If the event is no data event or
       *   there is no property definition for the target object and target
       *   property.
       */
      __P_93_6: function (sourceObject, sourceEvent, targetObject, targetProperty, options, arrayIndex) {
        // checks
        var bindListener = function (arrayIndex, e) {
          // if an array value is given
          if (arrayIndex !== "") {
            //check if its the "last" value
            if (arrayIndex === "last") {
              arrayIndex = sourceObject.length - 1;
            } // get the data of the array


            var data = sourceObject.getItem(arrayIndex); // reset the target if the data is not set

            if (data === undefined) {
              qx.data.SingleValueBinding.__P_93_10(targetObject, targetProperty);
            } // only do something if the current array has been changed


            var start = e.getData().start;
            var end = e.getData().end;

            if (arrayIndex < start || arrayIndex > end) {
              return;
            }
          } else {
            // get the data out of the event
            var data = e.getData();
          } // debug message


          // convert the data
          data = qx.data.SingleValueBinding.__P_93_11(data, targetObject, targetProperty, options, sourceObject); // debug message

          // try to set the value
          var result;

          try {
            if (data !== undefined) {
              result = qx.data.SingleValueBinding.__P_93_9(targetObject, targetProperty, data);
            } else {
              result = qx.data.SingleValueBinding.__P_93_10(targetObject, targetProperty);
            } // tell the user that the setter was invoked probably


            if (options && options.onUpdate) {
              options.onUpdate(sourceObject, targetObject, data);
            }
          } catch (ex) {
            if (!(ex instanceof qx.core.ValidationError)) {
              throw ex;
            }

            if (options && options.onSetFail) {
              options.onSetFail(ex);
            } else {
              qx.log.Logger.warn("Failed so set value " + data + " on " + targetObject + ". Error message: " + ex);
            }
          }

          return result;
        }; // check if an array index is given


        if (!arrayIndex) {
          // if not, signal it a s an empty string
          arrayIndex = "";
        } // bind the listener function (make the array index in the listener available)


        bindListener = qx.lang.Function.bind(bindListener, sourceObject, arrayIndex); // add the listener

        var id = sourceObject.addListener(sourceEvent, bindListener);
        return id;
      },

      /**
       * This method stores the given value as a binding in the internal structure
       * of all bindings.
       *
       * @param id {var} The listener id of the id for a deeper binding.
       * @param sourceObject {qx.core.Object} The source Object of the binding.
       * @param sourceEvent {String} The name of the source event.
       * @param targetObject {qx.core.Object} The target object.
       * @param targetProperty {String} The name of the property on the target
       *   object.
       */
      __P_93_8: function (id, sourceObject, sourceEvent, targetObject, targetProperty) {
        var hash; // add the listener id to the internal registry

        hash = sourceObject.toHashCode();

        if (this.__P_93_0[hash] === undefined) {
          this.__P_93_0[hash] = [];
        }

        var binding = [id, sourceObject, sourceEvent, targetObject, targetProperty];

        this.__P_93_0[hash].push(binding); // add same binding data indexed by target object


        hash = targetObject.toHashCode();

        if (this.__P_93_1[hash] === undefined) {
          this.__P_93_1[hash] = [];
        }

        this.__P_93_1[hash].push(binding);
      },

      /**
       * This method takes the given value, checks if the user has given a
       * converter and converts the value to its target type. If no converter is
       * given by the user, the {@link #__defaultConversion} will try to convert
       * the value.
       *
       * @param value {var} The value which possibly should be converted.
       * @param targetObject {qx.core.Object} The target object.
       * @param targetPropertyChain {String} The property name of the target object.
       * @param options {Map} The options map which can includes the converter.
       *   For a detailed information on the map, take a look at
       *   {@link #bind}.
       * @param sourceObject {qx.core.Object} The source object for the binding.
       *
       * @return {var} The converted value. If no conversion has been done, the
       *   value property will be returned.
       * @throws {qx.core.AssertionError} If there is no property definition
       *   of the given target object and target property.
       */
      __P_93_11: function (value, targetObject, targetPropertyChain, options, sourceObject) {
        // do the conversion given by the user
        if (options && options.converter) {
          var model;

          if (targetObject.getModel) {
            model = targetObject.getModel();
          }

          return options.converter(value, model, sourceObject, targetObject); // try default conversion
        } else {
          var properties = this.__P_93_12(targetPropertyChain);

          var target = this.__P_93_13(targetObject, properties);

          var lastProperty = targetPropertyChain.substring(targetPropertyChain.lastIndexOf(".") + 1, targetPropertyChain.length); // if no target is currently available, return the original value

          if (target == null) {
            return value;
          }

          var propertieDefinition = qx.Class.getPropertyDefinition(target.constructor, lastProperty);
          var check = propertieDefinition == null ? "" : propertieDefinition.check;
          return this.__P_93_16(value, check);
        }
      },

      /**
       * Helper method which tries to figure out if the given property on the
       * given object does have a change event and if returns the name of it.
       *
       * @param sourceObject {qx.core.Object} The object to check.
       * @param sourceProperty {String} The name of the property.
       *
       * @return {String} The name of the change event.
       * @throws {qx.core.AssertionError} If there is no property definition of
       *   the given object property pair.
       */
      __P_93_14: function (sourceObject, sourceProperty) {
        // get the event name
        var propertieDefinition = qx.Class.getPropertyDefinition(sourceObject.constructor, sourceProperty);

        if (propertieDefinition == null) {
          return null;
        }

        return propertieDefinition.event;
      },

      /**
       * Tries to convert the data to the type given in the targetCheck argument.
       *
       * @param data {var} The data to convert.
       * @param targetCheck {String} The value of the check property. That usually
       *   contains the target type.
       * @return {Integer|String|Float} The converted data
       */
      __P_93_16: function (data, targetCheck) {
        var dataType = qx.lang.Type.getClass(data); // to integer

        if ((dataType == "Number" || dataType == "String") && (targetCheck == "Integer" || targetCheck == "PositiveInteger")) {
          data = parseInt(data, 10);
        } // to string


        if ((dataType == "Boolean" || dataType == "Number" || dataType == "Date") && targetCheck == "String") {
          data = data + "";
        } // to float


        if ((dataType == "Number" || dataType == "String") && (targetCheck == "Number" || targetCheck == "PositiveNumber")) {
          data = parseFloat(data);
        }

        return data;
      },

      /**
       * Removes the binding with the given id from the given sourceObject. The
       * id has to be the id returned by any of the bind functions.
       *
       * @param sourceObject {qx.core.Object} The source object of the binding.
       * @param id {var} The id of the binding.
       * @throws {Error} If the binding could not be found.
       */
      removeBindingFromObject: function (sourceObject, id) {
        // check for a deep binding
        if (id.type == "deepBinding") {
          // go through all added listeners (source)
          for (var i = 0; i < id.sources.length; i++) {
            // check if a source is available
            if (id.sources[i]) {
              if (id.listenerIds[i]) {
                id.sources[i].removeListenerById(id.listenerIds[i]);
              } // If the listener id is not available, it is most likely
              // caused by some hidden error situation.
              // At least an error message should be displayed
              else {
                  sourceObject.error("Could not remove deep bindings. Binding id for " + id.sources[i].classname + " could not be found!");
                }
            }
          } // go through all added listeners (target)


          for (var i = 0; i < id.targets.length; i++) {
            // check if a target is available
            if (id.targets[i]) {
              if (id.targetListenerIds[i]) {
                id.targets[i].removeListenerById(id.targetListenerIds[i]);
              } // If the target listener id is not available, it is most likely
              // caused by some hidden error situation.
              // At least an error message should be displayed
              else {
                  sourceObject.error("Could not remove target listener. Listener id for target " + id.targets[i].classname + " could not be found!");
                }
            }
          }
        } else {
          // remove the listener
          sourceObject.removeListenerById(id);
        } // remove the id from the internal reference system


        var bindings = this.getAllBindingsForObject(sourceObject); // check if the binding exists

        if (bindings != undefined) {
          for (var i = 0; i < bindings.length; i++) {
            if (bindings[i][0] == id) {
              // remove binding data from internal reference indexed by target object
              var target = bindings[i][3];

              if (this.__P_93_1[target.toHashCode()]) {
                qx.lang.Array.remove(this.__P_93_1[target.toHashCode()], bindings[i]);
              } // remove binding data from internal reference indexed by source object


              var source = bindings[i][1];

              if (this.__P_93_0[source.toHashCode()]) {
                qx.lang.Array.remove(this.__P_93_0[source.toHashCode()], bindings[i]);
              }

              return;
            }
          }
        }

        throw new Error("Binding could not be found!");
      },

      /**
       * Removes all bindings for the given object.
       *
       * @param object {qx.core.Object} The object of which the bindings should be
       *   removed.
       * @throws {qx.core.AssertionError} If the object is not in the internal
       *   registry of the bindings.
       * @throws {Error} If one of the bindings listed internally can not be
       *   removed.
       */
      removeAllBindingsForObject: function (object) {
        // check for the null value
        // get the bindings
        var bindings = this.getAllBindingsForObject(object);

        if (bindings != undefined) {
          // remove every binding with the removeBindingFromObject function
          for (var i = bindings.length - 1; i >= 0; i--) {
            this.removeBindingFromObject(object, bindings[i][0]);
          }
        }
      },

      /**
       * Removes all bindings between given objects.
       *
       * @param object {qx.core.Object} The object of which the bindings should be
       *   removed.
       * @param relatedObject {qx.core.Object} The object of which related
       *   bindings should be removed.
       * @throws {qx.core.AssertionError} If the object is not in the internal
       *   registry of the bindings.
       * @throws {Error} If one of the bindings listed internally can not be
       *   removed.
       */
      removeRelatedBindings: function (object, relatedObject) {
        // check for the null value
        // get the bindings
        var bindings = this.getAllBindingsForObject(object);

        if (bindings != undefined) {
          // remove every binding with the removeBindingFromObject function
          for (var i = bindings.length - 1; i >= 0; i--) {
            var source = bindings[i][1];
            var target = bindings[i][3];

            if (source === relatedObject || target === relatedObject) {
              this.removeBindingFromObject(object, bindings[i][0]);
            }
          }
        }
      },

      /**
       * Returns an array which lists all bindings.
       *
       * @param object {qx.core.Object} The object of which the bindings should
       *   be returned.
       *
       * @return {Array} An array of binding informations. Every binding
       *   information is an array itself containing id, sourceObject,
       *   sourceEvent, targetObject and targetProperty in that order.
       */
      getAllBindingsForObject: function (object) {
        var hash = object.toHashCode(); // create an empty array if no binding exists

        if (this.__P_93_0[hash] === undefined) {
          this.__P_93_0[hash] = [];
        } // get all bindings of object as source


        var sourceBindings = this.__P_93_0[hash]; // get all bindings of object as target

        var targetBindings = this.__P_93_1[hash] ? this.__P_93_1[hash] : [];
        return qx.lang.Array.unique(sourceBindings.concat(targetBindings));
      },

      /**
       * Removes all binding in the whole application. After that not a single
       * binding is left.
       * @deprecated {6.0} dispose and destructors are deprecated because of automatic memory management; this
       * will only work for objects explicitly registered with ObjectRegistry.register
       */
      removeAllBindings: function () {
        // go through all registered objects
        for (var hash in this.__P_93_0) {
          var object = qx.core.ObjectRegistry.fromHashCode(hash); // check for the object, perhaps its already deleted

          if (object == null) {
            delete this.__P_93_0[hash];
            continue;
          }

          this.removeAllBindingsForObject(object);
        } // reset the bindings map


        this.__P_93_0 = {};
      },

      /**
       * Returns a map containing for every bound object an array of data binding
       * information. The key of the map is the hash code of the bound objects.
       * Every binding is represented by an array containing id, sourceObject,
       * sourceEvent, targetObject and targetProperty.
       *
       * @return {Map} Map containing all bindings.
       */
      getAllBindings: function () {
        return this.__P_93_0;
      },

      /**
       * Debug function which shows some valuable information about the given
       * binding in console. For that it uses {@link qx.log.Logger}.
       *
       * @param object {qx.core.Object} the source of the binding.
       * @param id {var} The id of the binding.
       */
      showBindingInLog: function (object, id) {
        var binding; // go through all bindings of the given object

        for (var i = 0; i < this.__P_93_0[object.toHashCode()].length; i++) {
          // the first array item is the id
          if (this.__P_93_0[object.toHashCode()][i][0] == id) {
            binding = this.__P_93_0[object.toHashCode()][i];
            break;
          }
        }

        if (binding === undefined) {
          var message = "Binding does not exist!";
        } else {
          var message = "Binding from '" + binding[1] + "' (" + binding[2] + ") to the object '" + binding[3] + "' (" + binding[4] + ").";
        }

        qx.log.Logger.debug(message);
      },

      /**
       * Debug function which shows all bindings in the log console. To get only
       * one binding in the console use {@link #showBindingInLog}
       * @deprecated {6.0} qx.core.ObjectRegistry no longer stores most objects
       */
      showAllBindingsInLog: function () {
        // go through all objects in the registry
        for (var hash in this.__P_93_0) {
          var object = qx.core.ObjectRegistry.fromHashCode(hash);

          if (object) {
            for (var i = 0; i < this.__P_93_0[hash].length; i++) {
              this.showBindingInLog(object, this.__P_93_0[hash][i][0]);
            }
          }
        }
      }
    }
  });
  qx.data.SingleValueBinding.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Interface": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * Event handler Interface.
   *
   * All custom event handler like mouse or keyboard event handler must implement
   * this interface.
   */
  qx.Interface.define("qx.event.IEventHandler", {
    statics: {
      /** @type {Integer} The event target must be a dom node */
      TARGET_DOMNODE: 1,

      /** @type {Integer} The event target must be a window object */
      TARGET_WINDOW: 2,

      /** @type {Integer} The event target must be a qooxdoo object */
      TARGET_OBJECT: 4,

      /** @type {Integer} The event target must be a document node */
      TARGET_DOCUMENT: 8
    },
    members: {
      /**
       * Whether the event handler can handle events of the given type. If the
       * event handler class has a static variable called <code>IGNORE_CAN_HANDLE</code>
       * with the value <code>true</code> this function is not called. Whether the
       * handler can handle the event is them only determined by the static variables
       * <code>SUPPORTED_TYPES</code> and <code>TARGET_CHECK</code>.
       *
       * @param target {var} The target to, which the event handler should
       *     be attached
       * @param type {String} event type
       * @return {Boolean} Whether the event handler can handle events of the
       *     given type.
       */
      canHandleEvent: function (target, type) {},

      /**
       * This method is called each time an event listener, for one of the
       * supported events, is added using {@link qx.event.Manager#addListener}.
       *
       * @param target {var} The target to, which the event handler should
       *     be attached
       * @param type {String} event type
       * @param capture {Boolean} Whether to attach the event to the
       *         capturing phase or the bubbling phase of the event.
       */
      registerEvent: function (target, type, capture) {},

      /**
       * This method is called each time an event listener, for one of the
       * supported events, is removed by using {@link qx.event.Manager#removeListener}
       * and no other event listener is listening on this type.
       *
       * @param target {var} The target from, which the event handler should
       *     be removed
       * @param type {String} event type
       * @param capture {Boolean} Whether to attach the event to the
       *         capturing phase or the bubbling phase of the event.
       */
      unregisterEvent: function (target, type, capture) {}
    }
  });
  qx.event.IEventHandler.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "require": true
      },
      "qx.event.IEventHandler": {
        "require": true
      },
      "qx.event.Registration": {
        "defer": "runtime",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
       * Sebastian Werner (wpbasti)
  
  ************************************************************************ */

  /**
   * This class provides qooxdoo object event support.
   */
  qx.Class.define("qx.event.handler.Object", {
    extend: qx.core.Object,
    implement: qx.event.IEventHandler,

    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics: {
      /** @type {Integer} Priority of this handler */
      PRIORITY: qx.event.Registration.PRIORITY_LAST,

      /** @type {Map} Supported event types */
      SUPPORTED_TYPES: null,

      /** @type {Integer} Which target check to use */
      TARGET_CHECK: qx.event.IEventHandler.TARGET_OBJECT,

      /** @type {Integer} Whether the method "canHandleEvent" must be called */
      IGNORE_CAN_HANDLE: false
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /*
      ---------------------------------------------------------------------------
        EVENT HANDLER INTERFACE
      ---------------------------------------------------------------------------
      */
      // interface implementation
      canHandleEvent: function (target, type) {
        return qx.Class.supportsEvent(target.constructor, type);
      },
      // interface implementation
      registerEvent: function (target, type, capture) {// Nothing needs to be done here
      },
      // interface implementation
      unregisterEvent: function (target, type, capture) {// Nothing needs to be done here
      }
    },

    /*
    *****************************************************************************
       DEFER
    *****************************************************************************
    */
    defer: function (statics) {
      qx.event.Registration.addHandler(statics);
    }
  });
  qx.event.handler.Object.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Environment": {
        "defer": "runtime"
      }
    },
    "environment": {
      "provided": ["os.name", "os.version"],
      "required": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
       * Sebastian Fastner (fastner)
  
  ************************************************************************ */

  /**
   * This class is responsible for checking the operating systems name.
   *
   * This class is used by {@link qx.core.Environment} and should not be used
   * directly. Please check its class comment for details how to use it.
   *
   * @internal
   */
  qx.Bootstrap.define("qx.bom.client.OperatingSystem", {
    statics: {
      /**
       * Checks for the name of the operating system.
       * @return {String} The name of the operating system.
       * @internal
       */
      getName: function () {
        if (!navigator) {
          return "";
        }

        var input = navigator.platform || "";
        var agent = navigator.userAgent || "";

        if (input.indexOf("Windows") != -1 || input.indexOf("Win32") != -1 || input.indexOf("Win64") != -1 || agent.indexOf("Windows Phone") != -1) {
          return "win";
        } else if (input.indexOf("Macintosh") != -1 || input.indexOf("MacPPC") != -1 || input.indexOf("MacIntel") != -1 || input.indexOf("Mac OS X") != -1) {
          return "osx";
        } else if (agent.indexOf("RIM Tablet OS") != -1) {
          return "rim_tabletos";
        } else if (agent.indexOf("webOS") != -1) {
          return "webos";
        } else if (input.indexOf("iPod") != -1 || input.indexOf("iPhone") != -1 || input.indexOf("iPad") != -1) {
          return "ios";
        } else if (agent.indexOf("Android") != -1) {
          return "android";
        } else if (input.indexOf("Linux") != -1) {
          return "linux";
        } else if (input.indexOf("X11") != -1 || input.indexOf("BSD") != -1 || input.indexOf("Darwin") != -1) {
          return "unix";
        } else if (input.indexOf("SymbianOS") != -1) {
          return "symbian";
        } else if (input.indexOf("BlackBerry") != -1) {
          return "blackberry";
        } // don't know


        return "";
      },

      /** Maps user agent names to system IDs */
      __P_59_0: {
        // Windows
        "Windows NT 10.0": "10",
        "Windows NT 6.3": "8.1",
        "Windows NT 6.2": "8",
        "Windows NT 6.1": "7",
        "Windows NT 6.0": "vista",
        "Windows NT 5.2": "2003",
        "Windows NT 5.1": "xp",
        "Windows NT 5.0": "2000",
        "Windows 2000": "2000",
        "Windows NT 4.0": "nt4",
        "Win 9x 4.90": "me",
        "Windows CE": "ce",
        "Windows 98": "98",
        "Win98": "98",
        "Windows 95": "95",
        "Win95": "95",
        // OS X
        "Mac OS X 10_13": "10.13",
        "Mac OS X 10.13": "10.13",
        "Mac OS X 10_12": "10.12",
        "Mac OS X 10.12": "10.12",
        "Mac OS X 10_11": "10.11",
        "Mac OS X 10.11": "10.11",
        "Mac OS X 10_10": "10.10",
        "Mac OS X 10.10": "10.10",
        "Mac OS X 10_9": "10.9",
        "Mac OS X 10.9": "10.9",
        "Mac OS X 10_8": "10.8",
        "Mac OS X 10.8": "10.8",
        "Mac OS X 10_7": "10.7",
        "Mac OS X 10.7": "10.7",
        "Mac OS X 10_6": "10.6",
        "Mac OS X 10.6": "10.6",
        "Mac OS X 10_5": "10.5",
        "Mac OS X 10.5": "10.5",
        "Mac OS X 10_4": "10.4",
        "Mac OS X 10.4": "10.4",
        "Mac OS X 10_3": "10.3",
        "Mac OS X 10.3": "10.3",
        "Mac OS X 10_2": "10.2",
        "Mac OS X 10.2": "10.2",
        "Mac OS X 10_1": "10.1",
        "Mac OS X 10.1": "10.1",
        "Mac OS X 10_0": "10.0",
        "Mac OS X 10.0": "10.0"
      },

      /**
       * Checks for the version of the operating system using the internal map.
       *
       * @internal
       * @return {String} The version as strin or an empty string if the version
       *   could not be detected.
       */
      getVersion: function () {
        var version = qx.bom.client.OperatingSystem.__P_59_1(navigator.userAgent);

        if (version == null) {
          version = qx.bom.client.OperatingSystem.__P_59_2(navigator.userAgent);
        }

        if (version != null) {
          return version;
        } else {
          return "";
        }
      },

      /**
       * Detect OS version for desktop devices
       * @param userAgent {String} userAgent parameter, needed for detection.
       * @return {String} version number as string or null.
       */
      __P_59_1: function (userAgent) {
        var str = [];

        for (var key in qx.bom.client.OperatingSystem.__P_59_0) {
          str.push(key);
        }

        var reg = new RegExp("(" + str.join("|").replace(/\./g, "\.") + ")", "g");
        var match = reg.exec(userAgent);

        if (match && match[1]) {
          return qx.bom.client.OperatingSystem.__P_59_0[match[1]];
        }

        return null;
      },

      /**
       * Detect OS version for mobile devices
       * @param userAgent {String} userAgent parameter, needed for detection.
       * @return {String} version number as string or null.
       */
      __P_59_2: function (userAgent) {
        var windows = userAgent.indexOf("Windows Phone") != -1;
        var android = userAgent.indexOf("Android") != -1;
        var iOs = userAgent.match(/(iPad|iPhone|iPod)/i) ? true : false;

        if (windows) {
          var windowsVersionRegExp = new RegExp(/Windows Phone (\d+(?:\.\d+)+)/i);
          var windowsMatch = windowsVersionRegExp.exec(userAgent);

          if (windowsMatch && windowsMatch[1]) {
            return windowsMatch[1];
          }
        } else if (android) {
          var androidVersionRegExp = new RegExp(/ Android (\d+(?:\.\d+)+)/i);
          var androidMatch = androidVersionRegExp.exec(userAgent);

          if (androidMatch && androidMatch[1]) {
            return androidMatch[1];
          }
        } else if (iOs) {
          var iOsVersionRegExp = new RegExp(/(CPU|iPhone|iPod) OS (\d+)_(\d+)(?:_(\d+))*\s+/);
          var iOsMatch = iOsVersionRegExp.exec(userAgent);

          if (iOsMatch && iOsMatch[2] && iOsMatch[3]) {
            if (iOsMatch[4]) {
              return iOsMatch[2] + "." + iOsMatch[3] + "." + iOsMatch[4];
            } else {
              return iOsMatch[2] + "." + iOsMatch[3];
            }
          }
        }

        return null;
      }
    },
    defer: function (statics) {
      qx.core.Environment.add("os.name", statics.getName);
      qx.core.Environment.add("os.version", statics.getVersion);
    }
  });
  qx.bom.client.OperatingSystem.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.lang.String": {
        "require": true,
        "defer": "runtime"
      },
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.dom.Node": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (wittemann)
       * Daniel Wagner (danielwagner)
  
  ************************************************************************ */

  /**
   * Responsible class for everything concerning styles without the need of
   * an element.
   *
   * If you want to query or modify styles of HTML elements,
   * take a look at {@link qx.bom.element.Style}.
   *
   * @require(qx.lang.String)
   */
  qx.Bootstrap.define("qx.bom.Style", {
    statics: {
      /** Vendor-specific style property prefixes */
      VENDOR_PREFIXES: ["Webkit", "Moz", "O", "ms", "Khtml"],

      /**
       * Internal lookup table to map property names to CSS names
       * @internal
       */
      __P_90_0: {},

      /**
       * A reference to the native CSS.supports function (supportsCSS in Opera)
       * @internal
       */
      __P_90_1: null,

      /**
       * Takes the name of a style property and returns the name the browser uses
       * for its implementation, which might include a vendor prefix.
       *
       * @param propertyName {String} Style property name to check
       * @return {String|null} The supported property name or <code>null</code> if
       * not supported
       */
      getPropertyName: function (propertyName) {
        var style = document.documentElement.style;

        if (style[propertyName] !== undefined) {
          return propertyName;
        }

        for (var i = 0, l = this.VENDOR_PREFIXES.length; i < l; i++) {
          var prefixedProp = this.VENDOR_PREFIXES[i] + qx.lang.String.firstUp(propertyName);

          if (style[prefixedProp] !== undefined) {
            return prefixedProp;
          }
        }

        return null;
      },

      /**
       * Takes the name of a JavaScript style property and returns the
       * corresponding CSS name.
       *
       * The name of the style property is taken as is, i.e. it gets not
       * extended by vendor prefixes. The conversion into the CSS name is
       * done by string manipulation, not involving the DOM.
       *
       * Example:
       * <pre class='javascript'>qx.bom.Style.getCssName("MozTransform"); //returns "-moz-transform"</pre>
       *
       * @param propertyName {String} JavaScript style property
       * @return {String} CSS property
       */
      getCssName: function (propertyName) {
        var cssName = this.__P_90_0[propertyName];

        if (!cssName) {
          // all vendor prefixes (except for "ms") start with an uppercase letter
          cssName = propertyName.replace(/[A-Z]/g, function (match) {
            return '-' + match.charAt(0).toLowerCase();
          }); // lowercase "ms" vendor prefix needs special handling

          if (/^ms/.test(cssName)) {
            cssName = "-" + cssName;
          }

          this.__P_90_0[propertyName] = cssName;
        }

        return cssName;
      },

      /**
       * Detects CSS support by using the native CSS.supports function or by
       * applying a style to a DOM element of the given type and verifying
       * the result. Also checks for vendor-prefixed variants of the
       * value, e.g. "linear-gradient" -> "-webkit-linear-gradient". Returns the
       * (possibly vendor-prefixed) value if successful or <code>null</code> if
       * the property and/or value are not supported.
       *
       * @param element {Element} element to be used for the detection
       * @param propertyName {String} the style property to be tested
       * @param value {String} style property value to be tested
       * @param prefixed {Boolean?} try to determine the appropriate vendor prefix
       * for the value. Default: <code>true</code>
       * @return {String|null} prefixed style value or <code>null</code> if not supported
       * @internal
       */
      getAppliedStyle: function (element, propertyName, value, prefixed) {
        var cssProperty = qx.bom.Style.getCssName(propertyName);
        var win = qx.dom.Node.getWindow(element);
        var vendorPrefixes = prefixed !== false ? [null].concat(this.VENDOR_PREFIXES) : [null];

        for (var i = 0, l = vendorPrefixes.length; i < l; i++) {
          var supported = false;
          var prefixedVal = vendorPrefixes[i] ? "-" + vendorPrefixes[i].toLowerCase() + "-" + value : value;

          if (qx.bom.Style.__P_90_1) {
            supported = qx.bom.Style.__P_90_1.call(win, cssProperty, prefixedVal);
          } else {
            element.style.cssText += cssProperty + ":" + prefixedVal + ";";
            supported = typeof element.style[propertyName] == "string" && element.style[propertyName] !== "";
          }

          if (supported) {
            return prefixedVal;
          }
        }

        return null;
      }
    },
    defer: function (statics) {
      if (window.CSS && window.CSS.supports) {
        qx.bom.Style.__P_90_1 = window.CSS.supports.bind(window.CSS);
      } else if (window.supportsCSS) {
        qx.bom.Style.__P_90_1 = window.supportsCSS.bind(window);
      }
    }
  });
  qx.bom.Style.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * This exception is thrown by the {@link qx.event.GlobalError} handler if a
   * <code>window.onerror</code> event occurs in the browser.
   */
  qx.Bootstrap.define("qx.core.WindowError", {
    extend: Error,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param failMessage {String} The error message
     * @param uri {String} URI where error was raised
     * @param lineNumber {Integer} The line number where the error was raised
     * @param columnNumber {Integer} The column number where the error was raised
     * @param sourceException {Error} orginal error
     */
    construct: function (failMessage, uri, lineNumber, columnNumber, sourceException) {
      var inst = sourceException || Error.call(this, failMessage); // map stack trace properties since they're not added by Error's constructor

      if (inst.stack) {
        this.stack = inst.stack;
      }

      if (inst.stacktrace) {
        this.stacktrace = inst.stacktrace;
      }

      this.__P_91_0 = failMessage;
      this.__P_91_1 = uri || "";
      this.__P_91_2 = lineNumber === undefined ? -1 : lineNumber;
      this.__P_91_3 = columnNumber === undefined ? -1 : columnNumber;
      this.__P_91_4 = sourceException;
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __P_91_0: null,
      __P_91_1: null,
      __P_91_2: null,
      __P_91_3: null,
      __P_91_4: null,

      /**
       * Returns the error message.
       *
       * @return {String} error message
       */
      toString: function () {
        return this.__P_91_0;
      },

      /**
       * Get the URI where error was raised
       *
       * @return {String} URI where error was raised
       */
      getUri: function () {
        return this.__P_91_1;
      },

      /**
       * Get the line number where the error was raised
       *
       * @return {Integer} The line number where the error was raised
       */
      getLineNumber: function () {
        return this.__P_91_2;
      },

      /**
       * Get the column number where the error was raised
       *
       * @return {Integer} The line number where the error was raised
       */
      getColumnNumber: function () {
        return this.__P_91_3;
      },

      /**
       * Get the source exception
       *
       * @return {Error} The source error
       */
      getSourceException: function () {
        return this.__P_91_4;
      }
    }
  });
  qx.core.WindowError.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Bootstrap": {
        "usage": "dynamic",
        "construct": true,
        "require": true
      },
      "qx.core.Assert": {
        "construct": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Michael Haitz (mhaitz)
  
  ************************************************************************ */

  /**
   * This exception is thrown by the {@link qx.event.GlobalError} handler if a
   * observed method throws an exception.
   */
  qx.Bootstrap.define("qx.core.GlobalError", {
    extend: Error,

    /**
     * @param exc {Error} source exception
     * @param args {Array} arguments
     */
    construct: function (exc, args) {
      // Do not use the Environment class to keep the minimal
      // package size small [BUG #5068]
      if (qx.Bootstrap.DEBUG) {
        qx.core.Assert.assertNotUndefined(exc);
      }

      this.__P_92_0 = "GlobalError: " + (exc && exc.message ? exc.message : exc);
      var inst = Error.call(this, this.__P_92_0); // map stack trace properties since they're not added by Error's constructor

      if (inst.stack) {
        this.stack = inst.stack;
      }

      if (inst.stacktrace) {
        this.stacktrace = inst.stacktrace;
      }

      this.__P_92_1 = args;
      this.__P_92_2 = exc;
    },
    members: {
      __P_92_2: null,
      __P_92_1: null,
      __P_92_0: null,

      /**
       * Returns the error message.
       *
       * @return {String} error message
       */
      toString: function () {
        return this.__P_92_0;
      },

      /**
       * Returns the arguments which are
       *
       * @return {Object} arguments
       */
      getArguments: function () {
        return this.__P_92_1;
      },

      /**
       * Get the source exception
       *
       * @return {Error} source exception
       */
      getSourceException: function () {
        return this.__P_92_2;
      }
    }
  });
  qx.core.GlobalError.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "require": true
      },
      "qx.core.IDisposable": {
        "require": true
      },
      "qx.lang.Function": {
        "construct": true
      },
      "qx.lang.Object": {},
      "qx.event.GlobalError": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * This class manages the timer used for deferred calls. All
   * {@link qx.util.DeferredCall} instances use the single timer from this class.
   * 
   * NOTE: Instances of this class must be disposed of after use
   *
   */
  qx.Class.define("qx.util.DeferredCallManager", {
    extend: qx.core.Object,
    type: "singleton",
    implement: [qx.core.IDisposable],

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function () {
      this.__P_98_0 = {};
      this.__P_98_1 = qx.lang.Function.bind(this.__P_98_2, this);
      this.__P_98_3 = false;
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __P_98_4: null,
      __P_98_5: null,
      __P_98_0: null,
      __P_98_3: null,
      __P_98_1: null,

      /**
       * Schedule a deferred call
       *
       * @param deferredCall {qx.util.DeferredCall} The call to schedule
       */
      schedule: function (deferredCall) {
        if (this.__P_98_4 == null) {
          this.__P_98_4 = window.setTimeout(this.__P_98_1, 0);
        }

        var callKey = deferredCall.toHashCode(); // the flush is currently running and the call is already
        // scheduled

        if (this.__P_98_5 && this.__P_98_5[callKey]) {
          return;
        }

        this.__P_98_0[callKey] = deferredCall;
        this.__P_98_3 = true;
      },

      /**
       * Refresh the timeout if the current one is not active anymore.
       * This is a very special case which can happen in unit tests using
       * fakeTimers, which overrides the window.setTimeout function (amongst others)
       * after restoring the sinon sandbox the timeout must be refreshed otherwise
       * DeferredCalls would never fire.
       */
      refreshTimeout: function () {
        if (this.__P_98_4 !== null) {
          this.__P_98_4 = window.setTimeout(this.__P_98_1, 0);
        }
      },

      /**
       * Cancel a scheduled deferred call
       *
       * @param deferredCall {qx.util.DeferredCall} The call to schedule
       */
      cancel: function (deferredCall) {
        var callKey = deferredCall.toHashCode(); // the flush is currently running and the call is already
        // scheduled -> remove it from the current queue

        if (this.__P_98_5 && this.__P_98_5[callKey]) {
          this.__P_98_5[callKey] = null;
          return;
        }

        delete this.__P_98_0[callKey]; // stop timer if no other calls are waiting

        if (qx.lang.Object.isEmpty(this.__P_98_0) && this.__P_98_4 != null) {
          window.clearTimeout(this.__P_98_4);
          this.__P_98_4 = null;
        }
      },

      /**
       * Helper function for the timer.
       *
       * @signature function()
       */
      __P_98_2: qx.event.GlobalError.observeMethod(function () {
        this.__P_98_4 = null; // the queue may change while doing the flush so we work on a copy of
        // the queue and loop while the queue has any entries.

        while (this.__P_98_3) {
          this.__P_98_5 = qx.lang.Object.clone(this.__P_98_0);
          this.__P_98_0 = {};
          this.__P_98_3 = false;

          for (var key in this.__P_98_5) {
            var call = this.__P_98_5[key];

            if (call) {
              this.__P_98_5[key] = null;
              call.call();
            }
          }
        }

        this.__P_98_5 = null;
      })
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function () {
      if (this.__P_98_4 != null) {
        window.clearTimeout(this.__P_98_4);
      }

      this.__P_98_1 = this.__P_98_0 = null;
    }
  });
  qx.util.DeferredCallManager.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.util.DeferredCallManager": {
        "require": true,
        "construct": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * This class represents a wrapper for functions, which should be called after
   * the current thread of JavaScript has finished and the control is returned to
   * the browser. The wrapped function will at most be called once after the control
   * has been given back to the browser, independent of the number of {@link #call}
   * calls.
   * 
   * This class does not need to be disposed, although doing so will cancel any
   * pending call
   *
   * @require(qx.util.DeferredCallManager)
   */
  qx.Class.define("qx.util.DeferredCall", {
    extend: qx.core.Object,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param callback {Function} The callback
     * @param context {Object?window} the context in which the function will be called.
     */
    construct: function (callback, context) {
      qx.core.Object.constructor.call(this);
      this.__P_96_0 = callback;
      this.__P_96_1 = context || null;
      this.__P_96_2 = qx.util.DeferredCallManager.getInstance();
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __P_96_0: null,
      __P_96_1: null,
      __P_96_2: null,

      /**
       * Prevent the callback from being called.
       */
      cancel: function () {
        this.__P_96_2.cancel(this);
      },

      /**
       * Issue a deferred call of the callback.
       */
      schedule: function () {
        this.__P_96_2.schedule(this);
      },

      /**
       * Calls the callback directly.
       */
      call: function () {
        this.__P_96_1 ? this.__P_96_0.apply(this.__P_96_1) : this.__P_96_0();
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function () {
      this.cancel();
      this.__P_96_1 = this.__P_96_0 = this.__P_96_2 = null;
    }
  });
  qx.util.DeferredCall.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.core.IDisposable": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       Simon Bull
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Simon Bull (sbull)
       * Sebastian Werner (wpbasti)
  
  ************************************************************************ */

  /**
   * This class manages pooled Object instances.
   *
   * It exists mainly to minimize the amount of browser memory usage by reusing
   * window instances after they have been closed.  However, it could equally be
   * used to pool instances of any type of Object (expect singletons).
   *
   * It is the client's responsibility to ensure that pooled objects are not
   * referenced or used from anywhere else in the application.
   */
  qx.Class.define("qx.util.ObjectPool", {
    extend: qx.core.Object,
    implement: [qx.core.IDisposable],

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param size {Integer} Size of each class pool
     */
    construct: function (size) {
      qx.core.Object.constructor.call(this);
      this.__P_97_0 = {};

      if (size != null) {
        this.setSize(size);
      }
    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /*
      ---------------------------------------------------------------------------
        PROPERTIES
      ---------------------------------------------------------------------------
      */

      /**
       * Number of objects of each class, which are pooled.
       *
       * A size of "null" represents an unlimited pool.
       */
      size: {
        check: "Integer",
        init: Infinity
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /** @type {Map} Stores arrays of instances for all managed classes */
      __P_97_0: null,

      /*
      ---------------------------------------------------------------------------
        IMPL
      ---------------------------------------------------------------------------
      */

      /**
       * This method finds and returns an instance of a requested type in the pool,
       * if there is one.  Note that the pool determines which instance (if any) to
       * return to the client.  The client cannot get a specific instance from the
       * pool.
       *
       * @param clazz {Class} A reference to a class from which an instance should be created.
       * @return {Object} An instance of the requested type. If non existed in the pool a new
       *   one is transparently created and returned.
       */
      getObject: function (clazz) {
        if (this.$$disposed) {
          return new clazz();
        }

        if (!clazz) {
          throw new Error("Class needs to be defined!");
        }

        var obj = null;
        var pool = this.__P_97_0[clazz.classname];

        if (pool) {
          obj = pool.pop();
        }

        if (obj) {
          obj.$$pooled = false;
        } else {
          obj = new clazz();
        }

        return obj;
      },

      /**
       * This method places an Object in a pool of Objects of its type. Note that
       * once an instance has been pooled, there is no means to get that exact
       * instance back. The instance may be discarded for garbage collection if
       * the pool of its type is already full.
       *
       * It is assumed that no other references exist to this Object, and that it will
       * not be used at all while it is pooled.
       *
       * @param obj {Object} An Object instance to pool.
       */
      poolObject: function (obj) {
        // Dispose check
        if (!this.__P_97_0) {
          return;
        }

        var classname = obj.classname;
        var pool = this.__P_97_0[classname];

        if (obj.$$pooled) {
          throw new Error("Object is already pooled: " + obj);
        }

        if (!pool) {
          this.__P_97_0[classname] = pool = [];
        } // Check to see whether the pool for this type is already full


        if (pool.length > this.getSize()) {
          // Use enhanced destroy() method instead of simple dispose
          // when available to work together with queues etc.
          if (obj.destroy) {
            obj.destroy();
          } else {
            obj.dispose();
          }

          return;
        }

        obj.$$pooled = true;
        pool.push(obj);
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function () {
      var pool = this.__P_97_0;
      var classname, list, i, l;

      for (classname in pool) {
        list = pool[classname];

        for (i = 0, l = list.length; i < l; i++) {
          list[i].dispose();
        }
      }

      delete this.__P_97_0;
    }
  });
  qx.util.ObjectPool.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.util.ObjectPool": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
       * Sebastian Werner (wpbasti)
  
  ************************************************************************ */

  /**
   * Central instance pool for event objects. All event objects dispatched by the
   * event loader are pooled using this class.
   */
  qx.Class.define("qx.event.Pool", {
    extend: qx.util.ObjectPool,
    type: "singleton",
    // Even though this class contains almost no code it is required because the
    // legacy code needs a place to patch the event pooling behavior.

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function () {
      qx.util.ObjectPool.constructor.call(this, 30);
    }
  });
  qx.event.Pool.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "require": true
      },
      "qx.lang.Type": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2018 Zenesis Ltd, john.spackman@zenesis.com
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * John Spackman (johnspackman)
  
  ************************************************************************ */

  /**
   * Utility methods which implement a fast, psuedo-promises mechanism used by event handlers
   * and dispatchers.
   *
   * Event handlers are allowed to return instances of `qx.Promise`, in which case the event
   * queue is suspended until the promise is resolved.  The simplest way to handle this would be
   * to convert the result of every event handler into a `qx.Promise` via `qx.Promise.resolve`,
   * but given that by far the majority of event handlers do not return promises, this could add
   * a significant overhead; the static methods in this class allow the event handlers to be
   * triggered and only when a `qx.Promise` is returned from a handler does the event dispatch
   * mechanism switch to using promise to suspend the event queue.
   *
   * To use this, the calling code simply creates an empty object (i.e. `var tracker = {};`)
   * which is then passed to `qx.event.Utils.then`, for example:
   *
   * <code>
   * var tracker = {};
   * Utils.then(tracker, function() { ... });
   * Utils.then(tracker, function() { ... });
   * Utils.then(tracker, function() { ... });
   * Utils.catch(tracker, function() { ... });
   * </code>
   *
   * Following with the morphing nature of this class, the return type will be either the value
   * returned from the event handlers, or a promise which evaluates to that value.
   *
   * When events are aborted (eg via `event.stopPropagation()`) that causes the promise (if there
   * is one) to be rejected.
   *
   * Note that this class is not a replacement for promises and has its limitations because it
   * has been built for the express purposes of the event dispatchers.
   *
   * @internal
   * @ignore(qx.Promise)
   * @ignore(Promise)
   */
  qx.Class.define("qx.event.Utils", {
    extend: qx.core.Object,
    statics: {
      ABORT: "[[ qx.event.Utils.ABORT ]]",

      /**
       * Evaluates a value, and adds it to the tracker
       *
       * @param tracker {Object} the tracker object
       * @param fn {Function|Object?} if a function, it's evaluated as a `then`, otherwise
       *  it's encapulated in a function for `then`
       * @return {qx.Promise|Object?}
       */
      track: function (tracker, fn) {
        if (typeof fn !== "function" && !qx.lang.Type.isPromise(fn)) {
          fn = function (value) {
            return function () {
              return value;
            };
          }(fn);
        }

        return this.then(tracker, fn);
      },

      /**
       * Helper method to store a promise in a tracker
       *
       * @param tracker {Object} the tracker object
       * @param newPromise {qx.Promise} the new promise
       * @return {qx.Promise} the new promise
       */
      __P_89_0: function (tracker, newPromise) {
        tracker.promise = newPromise;
        return tracker.promise;
      },

      /**
       * Equivalent of `promise.then()`
       *
       * @param tracker {Object} the tracker object
       * @param fn {Function} the function to call when previous promises are complete
       * @return {qx.Promise?} the new promise, or the return value from `fn` if no promises are in use
       */
      then: function (tracker, fn) {
        if (tracker.rejected) {
          return null;
        }

        if (tracker.promise) {
          if (qx.lang.Type.isPromise(fn)) {
            this.__P_89_0(tracker, tracker.promise.then(fn));
          } else {
            var self = this;

            this.__P_89_0(tracker, tracker.promise.then(function (result) {
              if (tracker.rejected) {
                return null;
              }

              result = fn(result);

              if (result === qx.event.Utils.ABORT) {
                return self.reject(tracker);
              }

              return result;
            }));
          }

          this.__P_89_1(tracker);

          return tracker.promise;
        }

        if (qx.lang.Type.isPromise(fn)) {
          return this.__P_89_2(tracker, fn);
        }

        var result = fn(tracker.result);

        if (qx.lang.Type.isPromise(result)) {
          return this.__P_89_2(tracker, result);
        }

        tracker.result = result;

        if (result === qx.event.Utils.ABORT) {
          return this.reject(tracker);
        }

        return result;
      },

      /**
       * Helper method to append a promise after the current one
       *
       * @param tracker {Object} the tracker object
       * @param newPromise {qx.Promise} the new promise
       * @return {qx.Promise} the new promise
       */
      __P_89_2: function (tracker, newPromise) {
        if (tracker.promise) {
          this.__P_89_0(tracker, tracker.promise.then(function () {
            return newPromise;
          }));
        } else {
          this.__P_89_0(tracker, newPromise);
        }

        this.__P_89_1(tracker);

        return tracker.promise;
      },

      /**
       * Rejects the tracker, aborting the promise if there is one.  The caller should stop
       * immediately because if promises are not in use and exception is not thrown.
       *
       * @param tracker {Object} the tracker object
       * @return {qx.Promise?} the last promise or the value returned by the catcher
       */
      reject: function (tracker) {
        if (tracker.rejected) {
          return qx.event.Utils.ABORT;
        }

        tracker.rejected = true;

        if (tracker.promise) {
          throw new Error("Rejecting Event");
        }

        var result = this.__P_89_3(tracker);

        return result === undefined ? this.ABORT : result;
      },

      /**
       * Helper method that adds a catcher to the tracker
       *
       * @param tracker {Object} the tracker object
       */
      __P_89_1: function (tracker) {
        if (tracker.promise && tracker.catch) {
          if (!tracker.promise["qx.event.Utils.hasCatcher"]) {
            this.__P_89_0(tracker, tracker.promise.catch(this.__P_89_3.bind(this, tracker)));

            tracker.promise["qx.event.Utils.hasCatcher"] = true;
          }
        }
      },

      /**
       * This method is added with `.catch` to every promise created; because this is added
       * all the way up the promise chain to ensure that it catches everything, this method
       * supresses multiple invocations (i.e. ignores everything except the first)
       *
       * @param tracker {Object} the tracker object
       */
      __P_89_3: function (tracker, err) {
        var fn = tracker.catch;

        if (fn) {
          tracker.catch = null;
          tracker.rejected = true;
          return fn(err);
        }

        return qx.event.Utils.ABORT;
      },

      /**
       * Equivalent to `.catch()`; note that unlike promises, this method must be called *before*
       * `.then()` so that it is able to handle rejections when promises are not in use; this is
       * because `Promise.catch` only catches rejections from previous promises, but because promises
       * are *always* asynchronous the `.catch` goes at the end.  For synchronous, this is nt possible
       * so `Utils.catch` must go before `Utils.then`
       *
       * @param tracker {Object} the tracker object
       * @param fn {Function} the function to call
       */
      "catch": function (tracker, fn) {
        if (tracker.rejected) {
          fn();
          return;
        }

        if (tracker.catchers === undefined) {
          tracker.catchers = [fn];
        } else {
          tracker.catchers.push(fn);
        }

        if (tracker.catch) {
          tracker.catch = function (catch1, catch2) {
            return function () {
              catch1();
              catch2();
            };
          }(tracker.catch, fn);
        } else {
          tracker.catch = fn;
        }

        this.__P_89_1(tracker);
      },

      /**
       * Calls a listener, converting propagationStopped into a rejection
       *
       * @param tracker {Object} the tracker object
       * @param listener {Function} the event handler
       * @param context {Object?} the `this` for the event handler
       * @param event {Event} the event being fired
       * @returns {qx.Promise|?} the result of the handler
       */
      callListener: function (tracker, listener, context, event) {
        if (tracker.rejected) {
          return qx.event.Utils.ABORT;
        }

        var tmp = listener.handler.call(context, event);

        if (event.getPropagationStopped()) {
          return qx.event.Utils.ABORT;
        }

        return tmp;
      },

      /**
       * Provides a handy way to iterate over an array which at any point could
       * become asynchronous
       *
       * @param arr {Array} an array to interate over
       * @param fn {Function?} the function to call, with parameters (item, index)
       * @param ignoreAbort {Boolean?} whether to ignore the "ABORT" return value
       * @return {qx.Promise|Object?}
       */
      series: function (arr, fn, ignoreAbort) {
        var tracker = {};

        for (var index = 0; index < arr.length; index++) {
          var result = fn(arr[index], index);

          if (result instanceof qx.Promise) {
            for (++index; index < arr.length; index++) {
              (function (item, index) {
                result = result.then(function () {
                  var tmp = fn(item, index);

                  if (!ignoreAbort && tmp === qx.event.Utils.ABORT) {
                    throw new Error("Rejecting in series()");
                  }

                  return tmp;
                });
              })(arr[index], index);
            }

            return result;
          }

          if (!ignoreAbort && result === qx.event.Utils.ABORT) {
            return this.reject(tracker);
          }
        }

        return null;
      }
    }
  });
  qx.event.Utils.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.ObjectRegistry": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
  
  ************************************************************************ */

  /**
   * Methods to cleanup fields from maps/objects.
   *
   * @ignore(qx.log.Logger)
   * @ignore(qx.log)
   * @ignore(qx.ui.container.Composite)
   * @ignore(qx.ui.container.Scroll)
   * @ignore(qx.ui.container.SlideBar)
   * @ignore(qx.ui.container.Stack)
   * @ignore(qx.ui.mobile)
   * @ignore(qx.ui.mobile.container.Composite)
   * @ignore(qx.ui.mobile.core.Widget)
   */
  qx.Class.define("qx.util.DisposeUtil", {
    statics: {
      /**
       * Disconnects and disposes given objects from instance.
       * Only works with qx.core.Object based objects e.g. Widgets.
       *
       * @param obj {Object} Object which contains the fields
       * @param arr {Array} List of fields (which store objects) to dispose
       * @param disposeSingletons {Boolean?} true, if singletons should be disposed
       */
      disposeObjects: function (obj, arr, disposeSingletons) {
        var name;

        for (var i = 0, l = arr.length; i < l; i++) {
          name = arr[i];

          if (obj[name] == null || !obj.hasOwnProperty(name)) {
            continue;
          }

          if (!qx.core.ObjectRegistry.inShutDown) {
            if (obj[name].dispose) {
              // singletons
              if (!disposeSingletons && obj[name].constructor.$$instance) {
                throw new Error("The object stored in key " + name + " is a singleton! Please use disposeSingleton instead.");
              } else {
                obj[name].dispose();
              }
            } else {
              throw new Error("Has no disposable object under key: " + name + "!");
            }
          }

          obj[name] = null;
        }
      },

      /**
       * Disposes all members of the given array and deletes
       * the field which refers to the array afterwards.
       *
       * @param obj {Object} Object which contains the field
       * @param field {String} Name of the field which refers to the array
       */
      disposeArray: function (obj, field) {
        var data = obj[field];

        if (!data) {
          return;
        } // Fast path for application shutdown


        if (qx.core.ObjectRegistry.inShutDown) {
          obj[field] = null;
          return;
        } // Dispose all content


        try {
          var entry;

          for (var i = data.length - 1; i >= 0; i--) {
            entry = data[i];

            if (entry) {
              entry.dispose();
            }
          }
        } catch (ex) {
          throw new Error("The array field: " + field + " of object: " + obj + " has non disposable entries: " + ex);
        } // Reduce array size to zero


        data.length = 0; // Finally remove field

        obj[field] = null;
      },

      /**
       * Disposes all members of the given map and deletes
       * the field which refers to the map afterwards.
       *
       * @param obj {Object} Object which contains the field
       * @param field {String} Name of the field which refers to the array
       */
      disposeMap: function (obj, field) {
        var data = obj[field];

        if (!data) {
          return;
        } // Fast path for application shutdown


        if (qx.core.ObjectRegistry.inShutDown) {
          obj[field] = null;
          return;
        } // Dispose all content


        try {
          var entry;

          for (var key in data) {
            entry = data[key];

            if (data.hasOwnProperty(key) && entry) {
              entry.dispose();
            }
          }
        } catch (ex) {
          throw new Error("The map field: " + field + " of object: " + obj + " has non disposable entries: " + ex);
        } // Finally remove field


        obj[field] = null;
      },

      /**
       * Disposes a given object when another object is disposed
       *
       * @param disposeMe {Object} Object to dispose when other object is disposed
       * @param trigger {Object} Other object
       *
       */
      disposeTriggeredBy: function (disposeMe, trigger) {
        var triggerDispose = trigger.dispose;

        trigger.dispose = function () {
          triggerDispose.call(trigger);
          disposeMe.dispose();
        };
      },

      /**
       * Destroys a container and all of its children recursively.
       * @param container {qx.ui.container.Composite | qx.ui.container.Scroll |
       *   qx.ui.container.SlideBar | qx.ui.container.Stack} Container to be destroyed
       */
      destroyContainer: function (container) {
        var arr = [];

        this._collectContainerChildren(container, arr);

        var len = arr.length;

        for (var i = len - 1; i >= 0; i--) {
          arr[i].destroy();
        }

        container.destroy();
      },

      /**
       * Helper function to collect all children widgets of an container recursively.
       * @param container {qx.ui.container.Composite | qx.ui.container.Scroll | qx.ui.container.SlideBar | qx.ui.container.Stack} Container to be destroyed
       * @param arr {Array} Array which holds all children widgets
       */
      _collectContainerChildren: function (container, arr) {
        var children = container.getChildren();

        for (var i = 0; i < children.length; i++) {
          var item = children[i];
          arr.push(item);

          if (this.__P_80_0(item)) {
            this._collectContainerChildren(item, arr);
          }
        }
      },

      /**
       * Checks if the given object is a qx container widget
       *
       * @param obj {Object} The object to check
       * @return {Boolean} <code>true</code> if the object is a container for
       * child widgets
       */
      __P_80_0: function (obj) {
        var classes = [];

        if (qx.ui.mobile && obj instanceof qx.ui.mobile.core.Widget) {
          classes = [qx.ui.mobile.container.Composite];
        } else {
          classes = [qx.ui.container.Composite, qx.ui.container.Scroll, qx.ui.container.SlideBar, qx.ui.container.Stack];
        }

        for (var i = 0, l = classes.length; i < l; i++) {
          if (typeof classes[i] !== "undefined" && qx.Class.isSubClassOf(obj.constructor, classes[i])) {
            return true;
          }
        }

        return false;
      }
    }
  });
  qx.util.DisposeUtil.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Mixin": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {},
      "qx.Class": {},
      "qx.lang.Function": {},
      "qx.data.IListData": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * Mixin used for the bubbling events. If you want to use this in your own model
   * classes, be sure that every property will call the
   * {@link #_applyEventPropagation} function on every change.
   */
  qx.Mixin.define("qx.data.marshal.MEventBubbling", {
    events: {
      /**
       * The change event which will be fired on every change in the model no
       * matter what property changes. This event bubbles so the root model will
       * fire a change event on every change of its children properties too.
       *
       * Note that properties are required to call
       * {@link #_applyEventPropagation} on apply for changes to be tracked as
       * desired. It is already taken care of that properties created with the
       * {@link qx.data.marshal.Json} marshaler call this method.
       *
       * The data will contain a map with the following four keys
       *   <li>value: The new value of the property</li>
       *   <li>old: The old value of the property.</li>
       *   <li>name: The name of the property changed including its parent
       *     properties separated by dots.</li>
       *   <li>item: The item which has the changed property.</li>
       * Due to that, the <code>getOldData</code> method will always return null
       * because the old data is contained in the map.
       */
      "changeBubble": "qx.event.type.Data"
    },
    members: {
      /**
       * Apply function for every property created with the
       * {@link qx.data.marshal.Json} marshaler. It fires and
       * {@link #changeBubble} event on every change. It also adds the chaining
       * listener if possible which is necessary for the bubbling of the events.
       *
       * @param value {var} The new value of the property.
       * @param old {var} The old value of the property.
       * @param name {String} The name of the changed property.
       */
      _applyEventPropagation: function (value, old, name) {
        this.fireDataEvent("changeBubble", {
          value: value,
          name: name,
          old: old,
          item: this
        });

        this._registerEventChaining(value, old, name);
      },

      /**
       * Registers for the given parameters the changeBubble listener, if
       * possible. It also removes the old listener, if an old item with
       * a changeBubble event is given.
       *
       * @param value {var} The new value of the property.
       * @param old {var} The old value of the property.
       * @param name {String} The name of the changed property.
       */
      _registerEventChaining: function (value, old, name) {
        // if an old value is given, remove the old listener if possible
        if (old != null && old.getUserData && old.getUserData("idBubble-" + this.toHashCode()) != null) {
          var listeners = old.getUserData("idBubble-" + this.toHashCode());

          for (var i = 0; i < listeners.length; i++) {
            old.removeListenerById(listeners[i]);
          }

          old.setUserData("idBubble-" + this.toHashCode(), null);
        } // if the child supports chaining


        if (value instanceof qx.core.Object && qx.Class.hasMixin(value.constructor, qx.data.marshal.MEventBubbling)) {
          // create the listener
          var listener = qx.lang.Function.bind(this.__P_94_0, this, name); // add the listener

          var id = value.addListener("changeBubble", listener, this);
          var listeners = value.getUserData("idBubble-" + this.toHashCode());

          if (listeners == null) {
            listeners = [];
            value.setUserData("idBubble-" + this.toHashCode(), listeners);
          }

          listeners.push(id);
        }
      },

      /**
       * Listener responsible for formating the name and firing the change event
       * for the changed property.
       *
       * @param name {String} The name of the former properties.
       * @param e {qx.event.type.Data} The date event fired by the property
       *   change.
       */
      __P_94_0: function (name, e) {
        var data = e.getData();
        var value = data.value;
        var old = data.old; // if the target is an array

        if (qx.Class.hasInterface(e.getTarget().constructor, qx.data.IListData)) {
          if (data.name.indexOf) {
            var dotIndex = data.name.indexOf(".") != -1 ? data.name.indexOf(".") : data.name.length;
            var bracketIndex = data.name.indexOf("[") != -1 ? data.name.indexOf("[") : data.name.length; // brackets in the first spot is ok [BUG #5985]

            if (bracketIndex == 0) {
              var newName = name + data.name;
            } else if (dotIndex < bracketIndex) {
              var index = data.name.substring(0, dotIndex);
              var rest = data.name.substring(dotIndex + 1, data.name.length);

              if (rest[0] != "[") {
                rest = "." + rest;
              }

              var newName = name + "[" + index + "]" + rest;
            } else if (bracketIndex < dotIndex) {
              var index = data.name.substring(0, bracketIndex);
              var rest = data.name.substring(bracketIndex, data.name.length);
              var newName = name + "[" + index + "]" + rest;
            } else {
              var newName = name + "[" + data.name + "]";
            }
          } else {
            var newName = name + "[" + data.name + "]";
          } // if the target is not an array

        } else {
          // special case for array as first element of the chain [BUG #5985]
          if (parseInt(name) == name && name !== "") {
            name = "[" + name + "]";
          }

          var newName = name + "." + data.name;
        }

        this.fireDataEvent("changeBubble", {
          value: value,
          name: newName,
          old: old,
          item: data.item || e.getTarget()
        });
      }
    }
  });
  qx.data.marshal.MEventBubbling.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.data.marshal.MEventBubbling": {
        "require": true
      },
      "qx.data.IListData": {
        "require": true
      },
      "qx.lang.Array": {
        "construct": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * The data array is a special array used in the data binding context of
   * qooxdoo. It does not extend the native array of JavaScript but its a wrapper
   * for it. All the native methods are included in the implementation and it
   * also fires events if the content or the length of the array changes in
   * any way. Also the <code>.length</code> property is available on the array.
   * 
   * This class does not need to be disposed, unless you set the autoDisposeItems
   * property to true and want the items to be disposed.
   */
  qx.Class.define("qx.data.Array", {
    extend: qx.core.Object,
    include: qx.data.marshal.MEventBubbling,
    implement: [qx.data.IListData],

    /**
     * Creates a new instance of an array.
     *
     * @param param {var} The parameter can be some types.<br/>
     *   Without a parameter a new blank array will be created.<br/>
     *   If there is more than one parameter is given, the parameter will be
     *   added directly to the new array.<br/>
     *   If the parameter is a number, a new Array with the given length will be
     *   created.<br/>
     *   If the parameter is a JavaScript array, a new array containing the given
     *   elements will be created.
     */
    construct: function (param) {
      qx.core.Object.constructor.call(this); // if no argument is given

      if (param == undefined) {
        this.__P_81_0 = []; // check for elements (create the array)
      } else if (arguments.length > 1) {
        // create an empty array and go through every argument and push it
        this.__P_81_0 = [];

        for (var i = 0; i < arguments.length; i++) {
          this.__P_81_0.push(arguments[i]);
        } // check for a number (length)

      } else if (typeof param == "number") {
        this.__P_81_0 = new Array(param); // check for an array itself
      } else if (param instanceof Array) {
        this.__P_81_0 = qx.lang.Array.clone(param); // error case
      } else {
        this.__P_81_0 = [];
        this.dispose();
        throw new Error("Type of the parameter not supported!");
      } // propagate changes


      for (var i = 0; i < this.__P_81_0.length; i++) {
        this._applyEventPropagation(this.__P_81_0[i], null, i);
      } // update the length at startup


      this.__P_81_1(); // work against the console printout of the array

    },

    /*
    *****************************************************************************
       PROPERTIES
    *****************************************************************************
    */
    properties: {
      /**
       * Flag to set the dispose behavior of the array. If the property is set to
       * <code>true</code>, the array will dispose its content on dispose, too.
       */
      autoDisposeItems: {
        check: "Boolean",
        init: false
      }
    },

    /*
    *****************************************************************************
       EVENTS
    *****************************************************************************
    */
    events: {
      /**
       * The change event which will be fired if there is a change in the array.
       * The data contains a map with five key value pairs:
       * <li>start: The start index of the change.</li>
       * <li>end: The end index of the change.</li>
       * <li>type: The type of the change as a String. This can be 'add',
       * 'remove', 'order' or 'add/remove'</li>
       * <li>added: The items which has been added (as a JavaScript array)</li>
       * <li>removed: The items which has been removed (as a JavaScript array)</li>
       */
      "change": "qx.event.type.Data",

      /**
       * The changeLength event will be fired every time the length of the
       * array changes.
       */
      "changeLength": "qx.event.type.Data"
    },
    members: {
      // private members
      __P_81_0: null,

      /**
       * Concatenates the current and the given array into a new one.
       *
       * @param array {qx.data.Array|Array} The javaScript array which should be concatenated
       *   to the current array.
       *
       * @return {qx.data.Array} A new array containing the values of both former
       *   arrays.
       */
      concat: function (array) {
        array = qx.lang.Array.toNativeArray(array);

        if (array) {
          var newArray = this.__P_81_0.concat(array);
        } else {
          var newArray = this.__P_81_0.concat();
        }

        return new qx.data.Array(newArray);
      },

      /**
       * Returns the array as a string using the given connector string to
       * connect the values.
       *
       * @param connector {String} the string which should be used to past in
       *  between of the array values.
       *
       * @return {String} The array as a string.
       */
      join: function (connector) {
        return this.__P_81_0.join(connector);
      },

      /**
       * Removes and returns the last element of the array.
       * An change event will be fired.
       *
       * @return {var} The last element of the array.
       */
      pop: function () {
        var item = this.__P_81_0.pop();

        this.__P_81_1(); // remove the possible added event listener


        this._registerEventChaining(null, item, this.length - 1); // fire change bubble event


        this.fireDataEvent("changeBubble", {
          value: [],
          name: this.length + "",
          old: [item],
          item: this
        });
        this.fireDataEvent("change", {
          start: this.length - 1,
          end: this.length - 1,
          type: "remove",
          removed: [item],
          added: []
        }, null);
        return item;
      },

      /**
       * Adds an element at the end of the array.
       *
       * @param varargs {var} Multiple elements. Every element will be added to
       *   the end of the array. An change event will be fired.
       *
       * @return {Number} The new length of the array.
       */
      push: function (varargs) {
        for (var i = 0; i < arguments.length; i++) {
          this.__P_81_0.push(arguments[i]);

          this.__P_81_1(); // apply to every pushed item an event listener for the bubbling


          this._registerEventChaining(arguments[i], null, this.length - 1); // fire change bubbles event


          this.fireDataEvent("changeBubble", {
            value: [arguments[i]],
            name: this.length - 1 + "",
            old: [],
            item: this
          }); // fire change event

          this.fireDataEvent("change", {
            start: this.length - 1,
            end: this.length - 1,
            type: "add",
            added: [arguments[i]],
            removed: []
          }, null);
        }

        return this.length;
      },

      /**
       * Reverses the order of the array. An change event will be fired.
       */
      reverse: function () {
        // ignore on empty arrays
        if (this.length == 0) {
          return;
        }

        var oldArray = this.__P_81_0.concat();

        this.__P_81_0.reverse();

        this.__P_81_2(0, this.length);

        this.fireDataEvent("change", {
          start: 0,
          end: this.length - 1,
          type: "order",
          added: [],
          removed: []
        }, null); // fire change bubbles event

        this.fireDataEvent("changeBubble", {
          value: this.__P_81_0,
          name: "0-" + (this.__P_81_0.length - 1),
          old: oldArray,
          item: this
        });
      },

      /**
       * Removes the first element of the array and returns it. An change event
       * will be fired.
       *
       * @return {var} the former first element.
       */
      shift: function () {
        // ignore on empty arrays
        if (this.length == 0) {
          return;
        }

        var item = this.__P_81_0.shift();

        this.__P_81_1(); // remove the possible added event listener


        this._registerEventChaining(null, item, this.length - 1); // as every item has changed its position, we need to update the event bubbling


        this.__P_81_2(0, this.length); // fire change bubbles event


        this.fireDataEvent("changeBubble", {
          value: [],
          name: "0",
          old: [item],
          item: this
        }); // fire change event

        this.fireDataEvent("change", {
          start: 0,
          end: this.length - 1,
          type: "remove",
          removed: [item],
          added: []
        }, null);
        return item;
      },

      /**
       * Returns a new array based on the range specified by the parameters.
       *
       * @param from {Number} The start index.
       * @param to {Number?null} The zero-based end index. <code>slice</code> extracts
       *   up to but not including <code>to</code>. If omitted, slice extracts to the
       *   end of the array.
       *
       * @return {qx.data.Array} A new array containing the given range of values.
       */
      slice: function (from, to) {
        return new qx.data.Array(this.__P_81_0.slice(from, to));
      },

      /**
       * Method to remove and add new elements to the array. A change event
       * will be fired for every removal or addition unless the array is
       * identical before and after splicing.
       *
       * @param startIndex {Integer} The index where the splice should start
       * @param amount {Integer} Defines number of elements which will be removed
       *   at the given position.
       * @param varargs {var} All following parameters will be added at the given
       *   position to the array.
       * @return {qx.data.Array} An data array containing the removed elements.
       *   Keep in to dispose this one, even if you don't use it!
       */
      splice: function (startIndex, amount, varargs) {
        // store the old length
        var oldLength = this.__P_81_0.length; // invoke the slice on the array

        var returnArray = this.__P_81_0.splice.apply(this.__P_81_0, arguments); // fire a change event for the length


        if (this.__P_81_0.length != oldLength) {
          this.__P_81_1();
        } else if (amount == arguments.length - 2) {
          // if we added as much items as we removed
          var addedItems = qx.lang.Array.fromArguments(arguments, 2); // check if the array content equals the content before the operation

          for (var i = 0; i < addedItems.length; i++) {
            if (addedItems[i] !== returnArray[i]) {
              break;
            } // if all added and removed items are equal


            if (i == addedItems.length - 1) {
              // prevent all events and return a new array
              return new qx.data.Array();
            }
          }
        } // fire an event for the change


        var removed = amount > 0;
        var added = arguments.length > 2;

        if (removed || added) {
          var addedItems = qx.lang.Array.fromArguments(arguments, 2);

          if (returnArray.length == 0) {
            var type = "add";
            var end = startIndex + addedItems.length;
          } else if (addedItems.length == 0) {
            var type = "remove";
            var end = this.length - 1;
          } else {
            var type = "add/remove";
            var end = startIndex + Math.max(addedItems.length, returnArray.length) - 1;
          }

          this.fireDataEvent("change", {
            start: startIndex,
            end: end,
            type: type,
            added: addedItems,
            removed: returnArray
          }, null);
        } // remove the listeners first [BUG #7132]


        for (var i = 0; i < returnArray.length; i++) {
          this._registerEventChaining(null, returnArray[i], i);
        } // add listeners


        for (var i = 2; i < arguments.length; i++) {
          this._registerEventChaining(arguments[i], null, startIndex + (i - 2));
        } // apply event chaining for every item moved


        this.__P_81_2(startIndex + (arguments.length - 2) - amount, this.length); // fire the changeBubble event


        if (removed || added) {
          var value = [];

          for (var i = 2; i < arguments.length; i++) {
            value[i - 2] = arguments[i];
          }

          var endIndex = startIndex + Math.max(arguments.length - 3, amount - 1);
          var name = startIndex == endIndex ? endIndex : startIndex + "-" + endIndex;
          var eventData = {
            value: value,
            name: name + "",
            old: returnArray,
            item: this
          };
          this.fireDataEvent("changeBubble", eventData);
        }

        return new qx.data.Array(returnArray);
      },

      /**
       * Efficiently replaces the array with the contents of src; this will suppress the
       * change event if the array contents are the same, and will make sure that only
       * one change event is fired
       * 
       * @param src {qx.data.Array|Array} the new value to set the array to
       */
      replace: function (src) {
        src = qx.lang.Array.toNativeArray(src);

        if (this.equals(src)) {
          return;
        }

        var args = [0, this.getLength()];
        src.forEach(function (item) {
          args.push(item);
        });
        this.splice.apply(this, args);
      },

      /**
       * Sorts the array. If a function is given, this will be used to
       * compare the items. <code>changeBubble</code> event will only be fired,
       * if sorting result differs from original array.
       *
       * @param func {Function} A compare function comparing two parameters and
       *   should return a number.
       */
      sort: function (func) {
        // ignore if the array is empty
        if (this.length == 0) {
          return;
        }

        var oldArray = this.__P_81_0.concat();

        this.__P_81_0.sort.apply(this.__P_81_0, arguments); // prevent changeBubble event if nothing has been changed


        if (qx.lang.Array.equals(this.__P_81_0, oldArray) === true) {
          return;
        }

        this.__P_81_2(0, this.length);

        this.fireDataEvent("change", {
          start: 0,
          end: this.length - 1,
          type: "order",
          added: [],
          removed: []
        }, null); // fire change bubbles event

        this.fireDataEvent("changeBubble", {
          value: this.__P_81_0,
          name: "0-" + (this.length - 1),
          old: oldArray,
          item: this
        });
      },

      /**
       * Adds the given items to the beginning of the array. For every element,
       * a change event will be fired.
       *
       * @param varargs {var} As many elements as you want to add to the beginning.
       * @return {Integer} The new length of the array
       */
      unshift: function (varargs) {
        for (var i = arguments.length - 1; i >= 0; i--) {
          this.__P_81_0.unshift(arguments[i]);

          this.__P_81_1(); // apply to every item an event listener for the bubbling


          this.__P_81_2(0, this.length); // fire change bubbles event


          this.fireDataEvent("changeBubble", {
            value: [this.__P_81_0[0]],
            name: "0",
            old: [this.__P_81_0[1]],
            item: this
          }); // fire change event

          this.fireDataEvent("change", {
            start: 0,
            end: this.length - 1,
            type: "add",
            added: [arguments[i]],
            removed: []
          }, null);
        }

        return this.length;
      },

      /**
       * Returns the list data as native array. Beware of the fact that the
       * internal representation will be returned and any manipulation of that
       * can cause a misbehavior of the array. This method should only be used for
       * debugging purposes.
       *
       * @return {Array} The native array.
       */
      toArray: function () {
        return this.__P_81_0;
      },

      /**
       * Replacement function for the getting of the array value.
       * array[0] should be array.getItem(0).
       *
       * @param index {Number} The index requested of the array element.
       *
       * @return {var} The element at the given index.
       */
      getItem: function (index) {
        return this.__P_81_0[index];
      },

      /**
       * Replacement function for the setting of an array value.
       * array[0] = "a" should be array.setItem(0, "a").
       * A change event will be fired if the value changes. Setting the same
       * value again will not lead to a change event.
       *
       * @param index {Number} The index of the array element.
       * @param item {var} The new item to set.
       */
      setItem: function (index, item) {
        var oldItem = this.__P_81_0[index]; // ignore settings of already set items [BUG #4106]

        if (oldItem === item) {
          return;
        }

        this.__P_81_0[index] = item; // set an event listener for the bubbling

        this._registerEventChaining(item, oldItem, index); // only update the length if its changed


        if (this.length != this.__P_81_0.length) {
          this.__P_81_1();
        } // fire change bubbles event


        this.fireDataEvent("changeBubble", {
          value: [item],
          name: index + "",
          old: [oldItem],
          item: this
        }); // fire change event

        this.fireDataEvent("change", {
          start: index,
          end: index,
          type: "add/remove",
          added: [item],
          removed: [oldItem]
        }, null);
      },

      /**
       * This method returns the current length stored under .length on each
       * array.
       *
       * @return {Number} The current length of the array.
       */
      getLength: function () {
        return this.length;
      },

      /**
       * Returns the index of the item in the array. If the item is not in the
       * array, -1 will be returned.
       *
       * @param item {var} The item of which the index should be returned.
       * @return {Number} The Index of the given item.
       */
      indexOf: function (item) {
        return this.__P_81_0.indexOf(item);
      },

      /**
       * Returns the last index of the item in the array. If the item is not in the
       * array, -1 will be returned.
       *
       * @param item {var} The item of which the index should be returned.
       * @return {Number} The Index of the given item.
       */
      lastIndexOf: function (item) {
        return this.__P_81_0.lastIndexOf(item);
      },

      /**
       * Returns the toString of the original Array
       * @return {String} The array as a string.
       */
      toString: function () {
        if (this.__P_81_0 != null) {
          return this.__P_81_0.toString();
        }

        return "";
      },

      /*
      ---------------------------------------------------------------------------
         IMPLEMENTATION OF THE QX.LANG.ARRAY METHODS
      ---------------------------------------------------------------------------
      */

      /**
       * Check if the given item is in the current array.
       *
       * @deprecated {6.0} Please use the include method instead
       *
       * @param item {var} The item which is possibly in the array.
       * @return {Boolean} true, if the array contains the given item.
       */
      contains: function (item) {
        return this.includes(item);
      },

      /**
       * Check if the given item is in the current array.
       *
       * @param item {var} The item which is possibly in the array.
       * @return {Boolean} true, if the array contains the given item.
       */
      includes: function (item) {
        return this.__P_81_0.indexOf(item) !== -1;
      },

      /**
       * Return a copy of the given arr
       *
       * @return {qx.data.Array} copy of this
       */
      copy: function () {
        return this.concat();
      },

      /**
       * Insert an element at a given position.
       *
       * @param index {Integer} Position where to insert the item.
       * @param item {var} The element to insert.
       */
      insertAt: function (index, item) {
        this.splice(index, 0, item).dispose();
      },

      /**
       * Insert an item into the array before a given item.
       *
       * @param before {var} Insert item before this object.
       * @param item {var} The item to be inserted.
       */
      insertBefore: function (before, item) {
        var index = this.indexOf(before);

        if (index == -1) {
          this.push(item);
        } else {
          this.splice(index, 0, item).dispose();
        }
      },

      /**
       * Insert an element into the array after a given item.
       *
       * @param after {var} Insert item after this object.
       * @param item {var} Object to be inserted.
       */
      insertAfter: function (after, item) {
        var index = this.indexOf(after);

        if (index == -1 || index == this.length - 1) {
          this.push(item);
        } else {
          this.splice(index + 1, 0, item).dispose();
        }
      },

      /**
       * Remove an element from the array at the given index.
       *
       * @param index {Integer} Index of the item to be removed.
       * @return {var} The removed item.
       */
      removeAt: function (index) {
        var returnArray = this.splice(index, 1);
        var item = returnArray.getItem(0);
        returnArray.dispose();
        return item;
      },

      /**
       * Remove all elements from the array.
       *
       * @return {Array} A native array containing the removed elements.
       */
      removeAll: function () {
        // remove all possible added event listeners
        for (var i = 0; i < this.__P_81_0.length; i++) {
          this._registerEventChaining(null, this.__P_81_0[i], i);
        } // ignore if array is empty


        if (this.getLength() == 0) {
          return [];
        } // store the old data


        var oldLength = this.getLength();

        var items = this.__P_81_0.concat(); // change the length


        this.__P_81_0.length = 0;

        this.__P_81_1(); // fire change bubbles event


        this.fireDataEvent("changeBubble", {
          value: [],
          name: "0-" + (oldLength - 1),
          old: items,
          item: this
        }); // fire the change event

        this.fireDataEvent("change", {
          start: 0,
          end: oldLength - 1,
          type: "remove",
          removed: items,
          added: []
        }, null);
        return items;
      },

      /**
       * Append the items of the given array.
       *
       * @param array {Array|qx.data.IListData} The items of this array will
       * be appended.
       * @throws {Error} if the argument is not an array.
       */
      append: function (array) {
        // qooxdoo array support
        array = qx.lang.Array.toNativeArray(array); // this check is important because opera throws an uncatchable error if
        // apply is called without an array as argument.

        var oldLength = this.__P_81_0.length;
        Array.prototype.push.apply(this.__P_81_0, array); // add a listener to the new items

        for (var i = 0; i < array.length; i++) {
          this._registerEventChaining(array[i], null, oldLength + i);
        }

        var oldLength = this.length;

        this.__P_81_1(); // fire change bubbles


        var name = oldLength == this.length - 1 ? oldLength : oldLength + "-" + (this.length - 1);
        this.fireDataEvent("changeBubble", {
          value: array,
          name: name + "",
          old: [],
          item: this
        }); // fire the change event

        this.fireDataEvent("change", {
          start: oldLength,
          end: this.length - 1,
          type: "add",
          added: array,
          removed: []
        }, null);
      },

      /**
       * Removes all elements which are listed in the array.
       *
       * @param array {Array} the elements of this array will be excluded from this one
       */
      exclude: function (array) {
        array = qx.lang.Array.toNativeArray(array);
        array.forEach(function (item) {
          this.remove(item);
        }, this);
      },

      /**
       * Remove the given item.
       *
       * @param item {var} Item to be removed from the array.
       * @return {var} The removed item.
       */
      remove: function (item) {
        var index = this.indexOf(item);

        if (index != -1) {
          this.splice(index, 1).dispose();
          return item;
        }
      },

      /**
       * Check whether the given array has the same content as this.
       * Checks only the equality of the arrays' content.
       *
       * @param array {qx.data.Array} The array to check.
       * @return {Boolean} Whether the two arrays are equal.
       */
      equals: function (array) {
        if (this.length !== array.length) {
          return false;
        }

        array = qx.lang.Array.toNativeArray(array);

        for (var i = 0; i < this.length; i++) {
          if (this.getItem(i) !== array[i]) {
            return false;
          }
        }

        return true;
      },

      /**
       * Returns the sum of all values in the array. Supports
       * numeric values only.
       *
       * @return {Number} The sum of all values.
       */
      sum: function () {
        var result = 0;

        for (var i = 0; i < this.length; i++) {
          result += this.getItem(i);
        }

        return result;
      },

      /**
       * Returns the highest value in the given array.
       * Supports numeric values only.
       *
       * @return {Number | null} The highest of all values or undefined if the
       *   array is empty.
       */
      max: function () {
        var result = this.getItem(0);

        for (var i = 1; i < this.length; i++) {
          if (this.getItem(i) > result) {
            result = this.getItem(i);
          }
        }

        return result === undefined ? null : result;
      },

      /**
       * Returns the lowest value in the array. Supports
       * numeric values only.
       *
       * @return {Number | null} The lowest of all values or undefined
       *   if the array is empty.
       */
      min: function () {
        var result = this.getItem(0);

        for (var i = 1; i < this.length; i++) {
          if (this.getItem(i) < result) {
            result = this.getItem(i);
          }
        }

        return result === undefined ? null : result;
      },

      /**
       * Invokes the given function for every item in the array.
       *
       * @param callback {Function} The function which will be call for every
       *   item in the array. It will be invoked with three parameters:
       *   the item, the index and the array itself.
       * @param context {var?} The context in which the callback will be invoked.
       */
      forEach: function (callback, context) {
        for (var i = 0; i < this.__P_81_0.length; i++) {
          callback.call(context, this.__P_81_0[i], i, this);
        }
      },

      /*
      ---------------------------------------------------------------------------
        Additional JS1.6 methods
      ---------------------------------------------------------------------------
      */

      /**
       * Creates a new array with all elements that pass the test implemented by
       * the provided function. It returns a new data array instance so make sure
       * to think about disposing it.
       * @param callback {Function} The test function, which will be executed for every
       *   item in the array. The function will have three arguments.
       *   <li><code>item</code>: the current item in the array</li>
       *   <li><code>index</code>: the index of the current item</li>
       *   <li><code>array</code>: The native array instance, NOT the data array instance.</li>
       * @param self {var?undefined} The context of the callback.
       * @return {qx.data.Array} A new array instance containing only the items
       *  which passed the test.
       */
      filter: function (callback, self) {
        return new qx.data.Array(this.__P_81_0.filter(callback, self));
      },

      /**
       * Creates a new array with the results of calling a provided function on every
       * element in this array. It returns a new data array instance so make sure
       * to think about disposing it.
       * @param callback {Function} The mapping function, which will be executed for every
       *   item in the array. The function will have three arguments.
       *   <li><code>item</code>: the current item in the array</li>
       *   <li><code>index</code>: the index of the current item</li>
       *   <li><code>array</code>: The native array instance, NOT the data array instance.</li>
       * @param self {var?undefined} The context of the callback.
       * @return {qx.data.Array} A new array instance containing the new created items.
       */
      map: function (callback, self) {
        return new qx.data.Array(this.__P_81_0.map(callback, self));
      },

      /**
       * Tests whether any element in the array passes the test implemented by the
       * provided function.
       * @param callback {Function} The test function, which will be executed for every
       *   item in the array. The function will have three arguments.
       *   <li><code>item</code>: the current item in the array</li>
       *   <li><code>index</code>: the index of the current item</li>
       *   <li><code>array</code>: The native array instance, NOT the data array instance.</li>
       * @param self {var?undefined} The context of the callback.
       * @return {Boolean} <code>true</code>, if any element passed the test function.
       */
      some: function (callback, self) {
        return this.__P_81_0.some(callback, self);
      },

      /**
       * Tests whether every element in the array passes the test implemented by the
       * provided function.
       * @param callback {Function} The test function, which will be executed for every
       *   item in the array. The function will have three arguments.
       *   <li><code>item</code>: the current item in the array</li>
       *   <li><code>index</code>: the index of the current item</li>
       *   <li><code>array</code>: The native array instance, NOT the data array instance.</li>
       * @param self {var?undefined} The context of the callback.
       * @return {Boolean} <code>true</code>, if every element passed the test function.
       */
      every: function (callback, self) {
        return this.__P_81_0.every(callback, self);
      },

      /**
       * Apply a function against an accumulator and each value of the array
       * (from left-to-right) as to reduce it to a single value.
       * @param callback {Function} The accumulator function, which will be
       *   executed for every item in the array. The function will have four arguments.
       *   <li><code>previousItem</code>: the previous item</li>
       *   <li><code>currentItem</code>: the current item in the array</li>
       *   <li><code>index</code>: the index of the current item</li>
       *   <li><code>array</code>: The native array instance, NOT the data array instance.</li>
       * @param initValue {var?undefined} Object to use as the first argument to the first
       *   call of the callback.
       * @return {var} The returned value of the last accumulator call.
       */
      reduce: function (callback, initValue) {
        return this.__P_81_0.reduce(callback, initValue);
      },

      /**
       * Apply a function against an accumulator and each value of the array
       * (from right-to-left) as to reduce it to a single value.
       * @param callback {Function} The accumulator function, which will be
       *   executed for every item in the array. The function will have four arguments.
       *   <li><code>previousItem</code>: the previous item</li>
       *   <li><code>currentItem</code>: the current item in the array</li>
       *   <li><code>index</code>: the index of the current item</li>
       *   <li><code>array</code>: The native array instance, NOT the data array instance.</li>
       * @param initValue {var?undefined} Object to use as the first argument to the first
       *   call of the callback.
       * @return {var} The returned value of the last accumulator call.
       */
      reduceRight: function (callback, initValue) {
        return this.__P_81_0.reduceRight(callback, initValue);
      },

      /*
      ---------------------------------------------------------------------------
        INTERNAL HELPERS
      ---------------------------------------------------------------------------
      */

      /**
       * Internal function which updates the length property of the array.
       * Every time the length will be updated, a {@link #changeLength} data
       * event will be fired.
       */
      __P_81_1: function () {
        var oldLength = this.length;
        this.length = this.__P_81_0.length;
        this.fireDataEvent("changeLength", this.length, oldLength);
      },

      /**
       * Helper to update the event propagation for a range of items.
       * @param from {Number} Start index.
       * @param to {Number} End index.
       */
      __P_81_2: function (from, to) {
        for (var i = from; i < to; i++) {
          this._registerEventChaining(this.__P_81_0[i], this.__P_81_0[i], i);
        }

        ;
      }
    },

    /*
     *****************************************************************************
        DESTRUCTOR
     *****************************************************************************
    */
    destruct: function () {
      for (var i = 0; i < this.__P_81_0.length; i++) {
        var item = this.__P_81_0[i];

        this._applyEventPropagation(null, item, i); // dispose the items on auto dispose


        if (this.isAutoDisposeItems() && item && item instanceof qx.core.Object) {
          item.dispose();
        }
      }

      this.__P_81_0 = null;
    }
  });
  qx.data.Array.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
     qooxdoo - the new era of web development
     http://qooxdoo.org
     Copyright:
      2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
     License:
      MIT: https://opensource.org/licenses/MIT
      See the LICENSE file in the project's top-level directory for details.
     Authors:
      * Fabian Jakobs (fjakobs)
      * Martin Wittemann (martinwittemann)
  ************************************************************************ */

  /**
   * This class is the common super class for all error classes in qooxdoo.
   *
   * It has a comment and a fail message as members. The toString method returns
   * the comment and the fail message separated by a colon.
   */
  qx.Bootstrap.define("qx.type.BaseError", {
    extend: Error,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param comment {String} Comment passed to the assertion call
     * @param failMessage {String} Fail message provided by the assertion
     */
    construct: function (comment, failMessage) {
      var inst = Error.call(this, failMessage); // map stack trace properties since they're not added by Error's constructor

      if (inst.stack) {
        this.stack = inst.stack;
      }

      if (inst.stacktrace) {
        this.stacktrace = inst.stacktrace;
      }

      this.__P_95_0 = comment || ""; // opera 10 crashes if the message is an empty string!!!?!?!

      this.message = failMessage || qx.type.BaseError.DEFAULTMESSAGE;
    },

    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics: {
      DEFAULTMESSAGE: "error"
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __P_95_1: null,
      __P_95_0: null,

      /** @type {String} Fail message provided by the assertion */
      message: null,

      /**
       * Comment passed to the assertion call
       *
       * @return {String} The comment passed to the assertion call
       */
      getComment: function () {
        return this.__P_95_0;
      },

      /**
       * Get the error message
       *
       * @return {String} The error message
       */
      toString: function () {
        return this.__P_95_0 + (this.message ? ": " + this.message : "");
      }
    }
  });
  qx.type.BaseError.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.type.BaseError": {
        "construct": true,
        "require": true
      },
      "qx.dev.StackTrace": {
        "construct": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * Assertion errors are thrown if an assertion in {@link qx.core.Assert}
   * fails.
   */
  qx.Bootstrap.define("qx.core.AssertionError", {
    extend: qx.type.BaseError,

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * @param comment {String} Comment passed to the assertion call
     * @param failMessage {String} Fail message provided by the assertion
     */
    construct: function (comment, failMessage) {
      qx.type.BaseError.call(this, comment, failMessage);
      this.__P_84_0 = qx.dev.StackTrace.getStackTrace();
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      __P_84_0: null,

      /**
       * Stack trace of the error
       *
       * @return {String[]} The stack trace of the location the exception was thrown
       */
      getStackTrace: function () {
        return this.__P_84_0;
      }
    }
  });
  qx.core.AssertionError.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.bom.client.Browser": {},
      "qx.core.Environment": {
        "defer": "runtime"
      }
    },
    "environment": {
      "provided": ["runtime.name"],
      "required": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2009 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * Basic runtime detection for qooxdoo.
   *
   * This class is used by {@link qx.core.Environment} and should not be used
   * directly. Please check its class comment for details how to use it.
   *
   * @internal
   *
   * @ignore(environment)
   * @ignore(process)
   * @ignore(Titanium.*)
   */
  qx.Bootstrap.define("qx.bom.client.Runtime", {
    statics: {
      /**
       * Checks for the name of the runtime and returns it. In general, it checks
       * for rhino and node.js and if that could not be detected, it falls back
       * to the browser name defined by {@link qx.bom.client.Browser#getName}.
       * @return {String} The name of the current runtime.
       * @internal
       * @ignore(environment, process, Titanium.*, Packages)
       */
      getName: function () {
        var name = ""; // check for the Rhino runtime

        if (typeof Packages === "object" && Object.prototype.toString.call(Packages) === "[object JavaPackage]") {
          name = "rhino"; // check for the Node.js runtime
        } else if (typeof process !== "undefined") {
          name = "node.js";
        } else if (typeof Titanium !== "undefined" && typeof Titanium.userAgent !== "undefined") {
          name = "titanium";
        } else {
          // otherwise, we think its a browser
          name = qx.bom.client.Browser.getName();
        }

        return name;
      }
    },
    defer: function (statics) {
      qx.core.Environment.add("runtime.name", statics.getName);
    }
  });
  qx.bom.client.Runtime.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.bom.client.Runtime": {
        "require": true
      }
    },
    "environment": {
      "provided": [],
      "required": {
        "runtime.name": {
          "className": "qx.bom.client.Runtime"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2013 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Fabian Jakobs (fjakobs)
       * Richard Sternagel (rsternagel)
  
     ======================================================================
  
     This class contains code from:
  
     * JSON 3 (v3.2.5)
  
       Code:
         https://github.com/bestiejs/json3
  
       Copyright:
         (c) 2012-2013, Kit Cambridge
  
       License:
         MIT: https://raw.github.com/bestiejs/json3/gh-pages/LICENSE
  
     ----------------------------------------------------------------------
  
      Copyright (c) 2012-2013 Kit Cambridge.
      http://kitcambridge.be/
  
      Permission is hereby granted, free of charge, to any person obtaining a copy of
      this software and associated documentation files (the "Software"), to deal in
      the Software without restriction, including without limitation the rights to
      use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
      of the Software, and to permit persons to whom the Software is furnished to do
      so, subject to the following conditions:
  
      The above copyright notice and this permission notice shall be included in all
      copies or substantial portions of the Software.
  
      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
      IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
      FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
      AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
      LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
      OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
      SOFTWARE.
  
  ************************************************************************ */

  /**
   * Exposes (potentially polyfilled or patched) window.JSON to qooxdoo
   * (enabled by <a href="https://github.com/bestiejs/json3">JSON 3</a>).
   */
  qx.Bootstrap.define("qx.lang.Json", {
    statics: {
      /**
       * This method produces a JSON text from a JavaScript value.
       *
       * When an object value is found, if the object contains a toJSON
       * method, its toJSON method will be called and the result will be
       * stringified. A toJSON method does not serialize: it returns the
       * value represented by the name/value pair that should be serialized,
       * or undefined if nothing should be serialized. The toJSON method
       * will be passed the key associated with the value, and this will be
       * bound to the object holding the key.
       *
       * For example, this would serialize Dates as ISO strings.
       *
       * <pre class="javascript">
       *     Date.prototype.toJSON = function (key) {
       *         function f(n) {
       *             // Format integers to have at least two digits.
       *             return n < 10 ? '0' + n : n;
       *         }
       *
       *         return this.getUTCFullYear()   + '-' +
       *              f(this.getUTCMonth() + 1) + '-' +
       *              f(this.getUTCDate())      + 'T' +
       *              f(this.getUTCHours())     + ':' +
       *              f(this.getUTCMinutes())   + ':' +
       *              f(this.getUTCSeconds())   + 'Z';
       *     };
       * </pre>
       *
       * You can provide an optional replacer method. It will be passed the
       * key and value of each member, with this bound to the containing
       * object. The value that is returned from your method will be
       * serialized. If your method returns undefined, then the member will
       * be excluded from the serialization.
       *
       * If the replacer parameter is an array of strings, then it will be
       * used to select the members to be serialized. It filters the results
       * such that only members with keys listed in the replacer array are
       * stringified.
       *
       * Values that do not have JSON representations, such as undefined or
       * functions, will not be serialized. Such values in objects will be
       * dropped; in arrays they will be replaced with null. You can use
       * a replacer function to replace those with JSON values.
       * JSON.stringify(undefined) returns undefined.
       *
       * The optional space parameter produces a stringification of the
       * value that is filled with line breaks and indentation to make it
       * easier to read.
       *
       * If the space parameter is a non-empty string, then that string will
       * be used for indentation. If the space parameter is a number, then
       * the indentation will be that many spaces.
       *
       * Example:
       *
       * <pre class="javascript">
       * text = JSON.stringify(['e', {pluribus: 'unum'}]);
       * // text is '["e",{"pluribus":"unum"}]'
       *
       *
       * text = JSON.stringify(['e', {pluribus: 'unum'}], null, '\t');
       * // text is '[\n\t"e",\n\t{\n\t\t"pluribus": "unum"\n\t}\n]'
       *
       * text = JSON.stringify([new Date()], function (key, value) {
       *     return this[key] instanceof Date ?
       *         'Date(' + this[key] + ')' : value;
       * });
       * // text is '["Date(---current time---)"]'
       * </pre>
       *
       * @signature function(value, replacer, space)
       *
       * @param value {var} any JavaScript value, usually an object or array.
       *
       * @param replacer {Function?} an optional parameter that determines how
       *    object values are stringified for objects. It can be a function or an
       *    array of strings.
       *
       * @param space {String?} an optional parameter that specifies the
       *    indentation of nested structures. If it is omitted, the text will
       *    be packed without extra whitespace. If it is a number, it will specify
       *    the number of spaces to indent at each level. If it is a string
       *    (such as '\t' or '&nbsp;'), it contains the characters used to indent
       *    at each level.
       *
       * @return {String} The JSON string of the value
       */
      stringify: null,
      // will be set after the polyfill

      /**
       * This method parses a JSON text to produce an object or array.
       * It can throw a SyntaxError exception.
       *
       * The optional reviver parameter is a function that can filter and
       * transform the results. It receives each of the keys and values,
       * and its return value is used instead of the original value.
       * If it returns what it received, then the structure is not modified.
       * If it returns undefined then the member is deleted.
       *
       * Example:
       *
       * <pre class="javascript">
       * // Parse the text. Values that look like ISO date strings will
       * // be converted to Date objects.
       *
       * myData = JSON.parse(text, function (key, value)
       * {
       *   if (typeof value === 'string')
       *   {
       *     var a = /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/.exec(value);
       *     if (a) {
       *       return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4], +a[5], +a[6]));
       *     }
       *   }
       *   return value;
       * });
       *
       * myData = JSON.parse('["Date(09/09/2001)"]', function (key, value) {
       *     var d;
       *     if (typeof value === 'string' &&
       *             value.slice(0, 5) === 'Date(' &&
       *             value.slice(-1) === ')') {
       *         d = new Date(value.slice(5, -1));
       *         if (d) {
       *             return d;
       *         }
       *     }
       *     return value;
       * });
       * </pre>
       *
       * @signature function(text, reviver)
       *
       * @param text {String} JSON string to parse
       *
       * @param reviver {Function?} Optional reviver function to filter and
       *    transform the results
       *
       * @return {Object} The parsed JSON object
       */
      parse: null // will be set after the polyfill

    }
  });
  /**
   * @ignore(define.*, exports)
   * @lint ignoreUnused(JSON3)
   * @lint ignoreNoLoopBlock()
   */

  (function () {
    // define JSON3 object
    var JSON3; // prevent using CommonJS exports object,
    // by shadowing global exports object

    var exports; // prevent using AMD compatible loader,
    // by shadowing global define function

    var define;
    /*! JSON v3.2.5 | http://bestiejs.github.io/json3 | Copyright 2012-2013, Kit Cambridge | http://kit.mit-license.org */

    (function (window) {
      // This polyfill does not work under Rhino because it cannot convert POJO to object (it tries
      //  to serialize the class)
      if (qx.core.Environment.get("runtime.name") === "rhino" || qx.core.Environment.get("runtime.name") === undefined) return; // Convenience aliases.

      var getClass = {}.toString,
          isProperty,
          forEach,
          undef; // Detect the `define` function exposed by asynchronous module loaders. The
      // strict `define` check is necessary for compatibility with `r.js`.

      var isLoader = typeof define === "function" && define.amd,
          JSON3 = typeof exports === "object" && exports;

      if (JSON3 || isLoader) {
        if (typeof JSON === "object" && JSON) {
          // Delegate to the native `stringify` and `parse` implementations in
          // asynchronous module loaders and CommonJS environments.
          if (JSON3) {
            JSON3.stringify = JSON.stringify;
            JSON3.parse = JSON.parse;
          } else {
            JSON3 = JSON;
          }
        } else if (isLoader) {
          JSON3 = window.JSON = {};
        }
      } else {
        // Export for web browsers and JavaScript engines.
        JSON3 = window.JSON || (window.JSON = {});
      } // Test the `Date#getUTC*` methods. Based on work by @Yaffle.


      var isExtended = new Date(-3509827334573292);

      try {
        // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
        // results for certain dates in Opera >= 10.53.
        isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 && // Safari < 2.0.2 stores the internal millisecond time value correctly,
        // but clips the values returned by the date methods to the range of
        // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
        isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
      } catch (exception) {} // Internal: Determines whether the native `JSON.stringify` and `parse`
      // implementations are spec-compliant. Based on work by Ken Snyder.


      function has(name) {
        if (name === "bug-string-char-index") {
          // IE <= 7 doesn't support accessing string characters using square
          // bracket notation. IE 8 only supports this for primitives.
          return "a"[0] != "a";
        }

        var value,
            serialized = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}',
            isAll = name === "json";

        if (isAll || name === "json-stringify" || name === "json-parse") {
          // Test `JSON.stringify`.
          if (name == "json-stringify" || isAll) {
            var stringify = JSON3.stringify,
                stringifySupported = typeof stringify === "function" && isExtended;

            if (stringifySupported) {
              // A test function object with a custom `toJSON` method.
              (value = function () {
                return 1;
              }).toJSON = value;

              try {
                stringifySupported = // Firefox 3.1b1 and b2 serialize string, number, and boolean
                // primitives as object literals.
                stringify(0) === "0" && // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
                // literals.
                stringify(new Number()) === "0" && stringify(new String()) === '""' && // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
                // does not define a canonical JSON representation (this applies to
                // objects with `toJSON` properties as well, *unless* they are nested
                // within an object or array).
                stringify(getClass) === undef && // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
                // FF 3.1b3 pass this test.
                stringify(undef) === undef && // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
                // respectively, if the value is omitted entirely.
                stringify() === undef && // FF 3.1b1, 2 throw an error if the given value is not a number,
                // string, array, object, Boolean, or `null` literal. This applies to
                // objects with custom `toJSON` methods as well, unless they are nested
                // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
                // methods entirely.
                stringify(value) === "1" && stringify([value]) === "[1]" && // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
                // `"[null]"`.
                stringify([undef]) === "[null]" && // YUI 3.0.0b1 fails to serialize `null` literals.
                stringify(null) === "null" && // FF 3.1b1, 2 halts serialization if an array contains a function:
                // `[1, true, getClass, 1]` serializes as "[1,true,],". These versions
                // of Firefox also allow trailing commas in JSON objects and arrays.
                // FF 3.1b3 elides non-JSON values from objects and arrays, unless they
                // define custom `toJSON` methods.
                stringify([undef, getClass, null]) === "[null,null,null]" && // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
                // where character escape codes are expected (e.g., `\b` => `\u0008`).
                stringify({
                  "a": [value, true, false, null, "\x00\b\n\f\r\t"]
                }) == serialized && // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
                stringify(null, value) === "1" && stringify([1, 2], null, 1) === "[\n 1,\n 2\n]" && // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
                // serialize extended years.
                stringify(new Date(-8.64e15)) === '"-271821-04-20T00:00:00.000Z"' && // The milliseconds are optional in ES 5, but required in 5.1.
                stringify(new Date(8.64e15)) === '"+275760-09-13T00:00:00.000Z"' && // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
                // four-digit years instead of six-digit years. Credits: @Yaffle.
                stringify(new Date(-621987552e5)) === '"-000001-01-01T00:00:00.000Z"' && // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
                // values less than 1000. Credits: @Yaffle.
                stringify(new Date(-1)) === '"1969-12-31T23:59:59.999Z"';
              } catch (exception) {
                stringifySupported = false;
              }
            }

            if (!isAll) {
              return stringifySupported;
            }
          } // Test `JSON.parse`.


          if (name === "json-parse" || isAll) {
            var parse = JSON3.parse;

            if (typeof parse === "function") {
              try {
                // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
                // Conforming implementations should also coerce the initial argument to
                // a string prior to parsing.
                if (parse("0") === 0 && !parse(false)) {
                  // Simple parsing test.
                  value = parse(serialized);
                  var parseSupported = value["a"].length == 5 && value["a"][0] === 1;

                  if (parseSupported) {
                    try {
                      // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
                      parseSupported = !parse('"\t"');
                    } catch (exception) {}

                    if (parseSupported) {
                      try {
                        // FF 4.0 and 4.0.1 allow leading `+` signs, and leading and
                        // trailing decimal points. FF 4.0, 4.0.1, and IE 9-10 also
                        // allow certain octal literals.
                        parseSupported = parse("01") !== 1;
                      } catch (exception) {}
                    }
                  }
                }
              } catch (exception) {
                parseSupported = false;
              }
            }

            if (!isAll) {
              return parseSupported;
            }
          }

          return stringifySupported && parseSupported;
        }
      }

      if (!has("json")) {
        // Common `[[Class]]` name aliases.
        var functionClass = "[object Function]";
        var dateClass = "[object Date]";
        var numberClass = "[object Number]";
        var stringClass = "[object String]";
        var arrayClass = "[object Array]";
        var booleanClass = "[object Boolean]"; // Detect incomplete support for accessing string characters by index.

        var charIndexBuggy = has("bug-string-char-index"); // Define additional utility methods if the `Date` methods are buggy.

        if (!isExtended) {
          var floor = Math.floor; // A mapping between the months of the year and the number of days between
          // January 1st and the first of the respective month.

          var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334]; // Internal: Calculates the number of days between the Unix epoch and the
          // first day of the given month.

          var getDay = function (year, month) {
            return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
          };
        } // Internal: Determines if a property is a direct property of the given
        // object. Delegates to the native `Object#hasOwnProperty` method.


        if (!(isProperty = {}.hasOwnProperty)) {
          isProperty = function (property) {
            var members = {},
                constructor;

            if ((members.__proto__ = null, members.__proto__ = {
              // The *proto* property cannot be set multiple times in recent
              // versions of Firefox and SeaMonkey.
              "toString": 1
            }, members).toString != getClass) {
              // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but
              // supports the mutable *proto* property.
              isProperty = function (property) {
                // Capture and break the object's prototype chain (see section 8.6.2
                // of the ES 5.1 spec). The parenthesized expression prevents an
                // unsafe transformation by the Closure Compiler.
                var original = this.__proto__,
                    result = (property in (this.__proto__ = null, this)); // Restore the original prototype chain.

                this.__proto__ = original;
                return result;
              };
            } else {
              // Capture a reference to the top-level `Object` constructor.
              constructor = members.constructor; // Use the `constructor` property to simulate `Object#hasOwnProperty` in
              // other environments.

              isProperty = function (property) {
                var parent = (this.constructor || constructor).prototype;
                return property in this && !(property in parent && this[property] === parent[property]);
              };
            }

            members = null;
            return isProperty.call(this, property);
          };
        } // Internal: A set of primitive types used by `isHostType`.


        var PrimitiveTypes = {
          'boolean': 1,
          'number': 1,
          'string': 1,
          'undefined': 1
        }; // Internal: Determines if the given object `property` value is a
        // non-primitive.

        var isHostType = function (object, property) {
          var type = typeof object[property];
          return type == 'object' ? !!object[property] : !PrimitiveTypes[type];
        }; // Internal: Normalizes the `for...in` iteration algorithm across
        // environments. Each enumerated key is yielded to a `callback` function.


        forEach = function (object, callback) {
          var size = 0,
              Properties,
              members,
              property,
              forEach; // Tests for bugs in the current environment's `for...in` algorithm. The
          // `valueOf` property inherits the non-enumerable flag from
          // `Object.prototype` in older versions of IE, Netscape, and Mozilla.

          (Properties = function () {
            this.valueOf = 0;
          }).prototype.valueOf = 0; // Iterate over a new instance of the `Properties` class.

          members = new Properties();

          for (property in members) {
            // Ignore all properties inherited from `Object.prototype`.
            if (isProperty.call(members, property)) {
              size++;
            }
          }

          Properties = members = null; // Normalize the iteration algorithm.

          if (!size) {
            // A list of non-enumerable properties inherited from `Object.prototype`.
            members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"]; // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
            // properties.

            forEach = function (object, callback) {
              var isFunction = getClass.call(object) == functionClass,
                  property,
                  length;
              var hasProperty = !isFunction && typeof object.constructor != 'function' && isHostType(object, 'hasOwnProperty') ? object.hasOwnProperty : isProperty;

              for (property in object) {
                // Gecko <= 1.0 enumerates the `prototype` property of functions under
                // certain conditions; IE does not.
                if (!(isFunction && property === "prototype") && hasProperty.call(object, property)) {
                  callback(property);
                }
              } // Manually invoke the callback for each non-enumerable property.


              for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));
            };
          } else if (size == 2) {
            // Safari <= 2.0.4 enumerates shadowed properties twice.
            forEach = function (object, callback) {
              // Create a set of iterated properties.
              var members = {},
                  isFunction = getClass.call(object) == functionClass,
                  property;

              for (property in object) {
                // Store each property name to prevent double enumeration. The
                // `prototype` property of functions is not enumerated due to cross-
                // environment inconsistencies.
                if (!(isFunction && property === "prototype") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {
                  callback(property);
                }
              }
            };
          } else {
            // No bugs detected; use the standard `for...in` algorithm.
            forEach = function (object, callback) {
              var isFunction = getClass.call(object) == functionClass,
                  property,
                  isConstructor;

              for (property in object) {
                if (!(isFunction && property === "prototype") && isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
                  callback(property);
                }
              } // Manually invoke the callback for the `constructor` property due to
              // cross-environment inconsistencies.


              if (isConstructor || isProperty.call(object, property = "constructor")) {
                callback(property);
              }
            };
          }

          return forEach(object, callback);
        }; // Public: Serializes a JavaScript `value` as a JSON string. The optional
        // `filter` argument may specify either a function that alters how object and
        // array members are serialized, or an array of strings and numbers that
        // indicates which properties should be serialized. The optional `width`
        // argument may be either a string or number that specifies the indentation
        // level of the output.


        if (!has("json-stringify")) {
          // Internal: A map of control characters and their escaped equivalents.
          var Escapes = {
            92: "\\\\",
            34: '\\"',
            8: "\\b",
            12: "\\f",
            10: "\\n",
            13: "\\r",
            9: "\\t"
          }; // Internal: Converts `value` into a zero-padded string such that its
          // length is at least equal to `width`. The `width` must be <= 6.

          var leadingZeroes = "000000";

          var toPaddedString = function (width, value) {
            // The `|| 0` expression is necessary to work around a bug in
            // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
            return (leadingZeroes + (value || 0)).slice(-width);
          }; // Internal: Double-quotes a string `value`, replacing all ASCII control
          // characters (characters with code unit values between 0 and 31) with
          // their escaped equivalents. This is an implementation of the
          // `Quote(value)` operation defined in ES 5.1 section 15.12.3.


          var unicodePrefix = "\\u00";

          var quote = function (value) {
            var result = '"',
                index = 0,
                length = value.length,
                isLarge = length > 10 && charIndexBuggy,
                symbols;

            if (isLarge) {
              symbols = value.split("");
            }

            for (; index < length; index++) {
              var charCode = value.charCodeAt(index); // If the character is a control character, append its Unicode or
              // shorthand escape sequence; otherwise, append the character as-is.

              switch (charCode) {
                case 8:
                case 9:
                case 10:
                case 12:
                case 13:
                case 34:
                case 92:
                  result += Escapes[charCode];
                  break;

                default:
                  if (charCode < 32) {
                    result += unicodePrefix + toPaddedString(2, charCode.toString(16));
                    break;
                  }

                  result += isLarge ? symbols[index] : charIndexBuggy ? value.charAt(index) : value[index];
              }
            }

            return result + '"';
          }; // Internal: Recursively serializes an object. Implements the
          // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.


          var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {
            var value = object[property],
                className,
                year,
                month,
                date,
                time,
                hours,
                minutes,
                seconds,
                milliseconds,
                results,
                element,
                index,
                length,
                prefix,
                hasMembers,
                result;

            try {
              // Necessary for host object support.
              value = object[property];
            } catch (exception) {}

            if (typeof value === "object" && value) {
              className = getClass.call(value);

              if (className == dateClass && !isProperty.call(value, "toJSON")) {
                if (value > -1 / 0 && value < Infinity) {
                  // Dates are serialized according to the `Date#toJSON` method
                  // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
                  // for the ISO 8601 date time string format.
                  if (getDay) {
                    // Manually compute the year, month, date, hours, minutes,
                    // seconds, and milliseconds if the `getUTC*` methods are
                    // buggy. Adapted from @Yaffle's `date-shim` project.
                    date = floor(value / 864e5);

                    for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);

                    for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);

                    date = 1 + date - getDay(year, month); // The `time` value specifies the time within the day (see ES
                    // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
                    // to compute `A modulo B`, as the `%` operator does not
                    // correspond to the `modulo` operation for negative numbers.

                    time = (value % 864e5 + 864e5) % 864e5; // The hours, minutes, seconds, and milliseconds are obtained by
                    // decomposing the time within the day. See section 15.9.1.10.

                    hours = floor(time / 36e5) % 24;
                    minutes = floor(time / 6e4) % 60;
                    seconds = floor(time / 1e3) % 60;
                    milliseconds = time % 1e3;
                  } else {
                    year = value.getUTCFullYear();
                    month = value.getUTCMonth();
                    date = value.getUTCDate();
                    hours = value.getUTCHours();
                    minutes = value.getUTCMinutes();
                    seconds = value.getUTCSeconds();
                    milliseconds = value.getUTCMilliseconds();
                  } // Serialize extended years correctly.


                  value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) + "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) + // Months, dates, hours, minutes, and seconds should have two
                  // digits; milliseconds should have three.
                  "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) + // Milliseconds are optional in ES 5.0, but required in 5.1.
                  "." + toPaddedString(3, milliseconds) + "Z";
                } else {
                  value = null;
                }
              } else if (typeof value.toJSON === "function" && (className != numberClass && className != stringClass && className != arrayClass || isProperty.call(value, "toJSON"))) {
                // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the
                // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
                // ignores all `toJSON` methods on these objects unless they are
                // defined directly on an instance.
                value = value.toJSON(property);
              }
            }

            if (callback) {
              // If a replacement function was provided, call it to obtain the value
              // for serialization.
              value = callback.call(object, property, value);
            }

            if (value === null) {
              return "null";
            }

            className = getClass.call(value);

            if (className == booleanClass) {
              // Booleans are represented literally.
              return "" + value;
            } else if (className == numberClass) {
              // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
              // `"null"`.
              return value > -1 / 0 && value < Infinity ? "" + value : "null";
            } else if (className == stringClass) {
              // Strings are double-quoted and escaped.
              return quote("" + value);
            } // Recursively serialize objects and arrays.


            if (typeof value === "object") {
              // Check for cyclic structures. This is a linear search; performance
              // is inversely proportional to the number of unique nested objects.
              for (length = stack.length; length--;) {
                if (stack[length] === value) {
                  // Cyclic structures cannot be serialized by `JSON.stringify`.
                  throw TypeError();
                }
              } // Add the object to the stack of traversed objects.


              stack.push(value);
              results = []; // Save the current indentation level and indent one additional level.

              prefix = indentation;
              indentation += whitespace;

              if (className == arrayClass) {
                // Recursively serialize array elements.
                for (index = 0, length = value.length; index < length; hasMembers || (hasMembers = true), index++) {
                  element = serialize(index, value, callback, properties, whitespace, indentation, stack);
                  results.push(element === undef ? "null" : element);
                }

                result = hasMembers ? whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : "[" + results.join(",") + "]" : "[]";
              } else {
                // Recursively serialize object members. Members are selected from
                // either a user-specified list of property names, or the object
                // itself.
                forEach(properties || value, function (property) {
                  var element = serialize(property, value, callback, properties, whitespace, indentation, stack);

                  if (element !== undef) {
                    // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
                    // is not the empty string, let `member` {quote(property) + ":"}
                    // be the concatenation of `member` and the `space` character."
                    // The "`space` character" refers to the literal space
                    // character, not the `space` {width} argument provided to
                    // `JSON.stringify`.
                    results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
                  }

                  hasMembers || (hasMembers = true);
                });
                result = hasMembers ? whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : "{" + results.join(",") + "}" : "{}";
              } // Remove the object from the traversed object stack.


              stack.pop();
              return result;
            }
          }; // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.


          JSON3.stringify = function (source, filter, width) {
            var whitespace, callback, properties;

            if (typeof filter === "function" || typeof filter === "object" && filter) {
              if (getClass.call(filter) == functionClass) {
                callback = filter;
              } else if (getClass.call(filter) == arrayClass) {
                // Convert the property names array into a makeshift set.
                properties = {};

                for (var index = 0, length = filter.length, value; index < length; value = filter[index++], (getClass.call(value) == stringClass || getClass.call(value) == numberClass) && (properties[value] = 1));
              }
            }

            if (width) {
              if (getClass.call(width) == numberClass) {
                // Convert the `width` to an integer and create a string containing
                // `width` number of space characters.
                if ((width -= width % 1) > 0) {
                  for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ");
                }
              } else if (getClass.call(width) == stringClass) {
                whitespace = width.length <= 10 ? width : width.slice(0, 10);
              }
            } // Opera <= 7.54u2 discards the values associated with empty string keys
            // (`""`) only if they are used directly within an object member list
            // (e.g., `!("" in { "": 1})`).


            return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
          };
        } // Public: Parses a JSON source string.


        if (!has("json-parse")) {
          var fromCharCode = String.fromCharCode; // Internal: A map of escaped control characters and their unescaped
          // equivalents.

          var Unescapes = {
            92: "\\",
            34: '"',
            47: "/",
            98: "\b",
            116: "\t",
            110: "\n",
            102: "\f",
            114: "\r"
          }; // Internal: Stores the parser state.

          var Index, Source; // Internal: Resets the parser state and throws a `SyntaxError`.

          var abort = function () {
            Index = Source = null;
            throw SyntaxError();
          }; // Internal: Returns the next token, or `"$"` if the parser has reached
          // the end of the source string. A token may be a string, number, `null`
          // literal, or Boolean literal.


          var lex = function () {
            var source = Source,
                length = source.length,
                value,
                begin,
                position,
                isSigned,
                charCode;

            while (Index < length) {
              charCode = source.charCodeAt(Index);

              switch (charCode) {
                case 9:
                case 10:
                case 13:
                case 32:
                  // Skip whitespace tokens, including tabs, carriage returns, line
                  // feeds, and space characters.
                  Index++;
                  break;

                case 123:
                case 125:
                case 91:
                case 93:
                case 58:
                case 44:
                  // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
                  // the current position.
                  value = charIndexBuggy ? source.charAt(Index) : source[Index];
                  Index++;
                  return value;

                case 34:
                  // `"` delimits a JSON string; advance to the next character and
                  // begin parsing the string. String tokens are prefixed with the
                  // sentinel `@` character to distinguish them from punctuators and
                  // end-of-string tokens.
                  for (value = "@", Index++; Index < length;) {
                    charCode = source.charCodeAt(Index);

                    if (charCode < 32) {
                      // Unescaped ASCII control characters (those with a code unit
                      // less than the space character) are not permitted.
                      abort();
                    } else if (charCode == 92) {
                      // A reverse solidus (`\`) marks the beginning of an escaped
                      // control character (including `"`, `\`, and `/`) or Unicode
                      // escape sequence.
                      charCode = source.charCodeAt(++Index);

                      switch (charCode) {
                        case 92:
                        case 34:
                        case 47:
                        case 98:
                        case 116:
                        case 110:
                        case 102:
                        case 114:
                          // Revive escaped control characters.
                          value += Unescapes[charCode];
                          Index++;
                          break;

                        case 117:
                          // `\u` marks the beginning of a Unicode escape sequence.
                          // Advance to the first character and validate the
                          // four-digit code point.
                          begin = ++Index;

                          for (position = Index + 4; Index < position; Index++) {
                            charCode = source.charCodeAt(Index); // A valid sequence comprises four hexdigits (case-
                            // insensitive) that form a single hexadecimal value.

                            if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
                              // Invalid Unicode escape sequence.
                              abort();
                            }
                          } // Revive the escaped character.


                          value += fromCharCode("0x" + source.slice(begin, Index));
                          break;

                        default:
                          // Invalid escape sequence.
                          abort();
                      }
                    } else {
                      if (charCode == 34) {
                        // An unescaped double-quote character marks the end of the
                        // string.
                        break;
                      }

                      charCode = source.charCodeAt(Index);
                      begin = Index; // Optimize for the common case where a string is valid.

                      while (charCode >= 32 && charCode != 92 && charCode != 34) {
                        charCode = source.charCodeAt(++Index);
                      } // Append the string as-is.


                      value += source.slice(begin, Index);
                    }
                  }

                  if (source.charCodeAt(Index) == 34) {
                    // Advance to the next character and return the revived string.
                    Index++;
                    return value;
                  } // Unterminated string.


                  abort();

                default:
                  // Parse numbers and literals.
                  begin = Index; // Advance past the negative sign, if one is specified.

                  if (charCode == 45) {
                    isSigned = true;
                    charCode = source.charCodeAt(++Index);
                  } // Parse an integer or floating-point value.


                  if (charCode >= 48 && charCode <= 57) {
                    // Leading zeroes are interpreted as octal literals.
                    if (charCode == 48 && (charCode = source.charCodeAt(Index + 1), charCode >= 48 && charCode <= 57)) {
                      // Illegal octal literal.
                      abort();
                    }

                    isSigned = false; // Parse the integer component.

                    for (; Index < length && (charCode = source.charCodeAt(Index), charCode >= 48 && charCode <= 57); Index++); // Floats cannot contain a leading decimal point; however, this
                    // case is already accounted for by the parser.


                    if (source.charCodeAt(Index) == 46) {
                      position = ++Index; // Parse the decimal component.

                      for (; position < length && (charCode = source.charCodeAt(position), charCode >= 48 && charCode <= 57); position++);

                      if (position == Index) {
                        // Illegal trailing decimal.
                        abort();
                      }

                      Index = position;
                    } // Parse exponents. The `e` denoting the exponent is
                    // case-insensitive.


                    charCode = source.charCodeAt(Index);

                    if (charCode == 101 || charCode == 69) {
                      charCode = source.charCodeAt(++Index); // Skip past the sign following the exponent, if one is
                      // specified.

                      if (charCode == 43 || charCode == 45) {
                        Index++;
                      } // Parse the exponential component.


                      for (position = Index; position < length && (charCode = source.charCodeAt(position), charCode >= 48 && charCode <= 57); position++);

                      if (position == Index) {
                        // Illegal empty exponent.
                        abort();
                      }

                      Index = position;
                    } // Coerce the parsed value to a JavaScript number.


                    return +source.slice(begin, Index);
                  } // A negative sign may only precede numbers.


                  if (isSigned) {
                    abort();
                  } // `true`, `false`, and `null` literals.


                  if (source.slice(Index, Index + 4) === "true") {
                    Index += 4;
                    return true;
                  } else if (source.slice(Index, Index + 5) === "false") {
                    Index += 5;
                    return false;
                  } else if (source.slice(Index, Index + 4) === "null") {
                    Index += 4;
                    return null;
                  } // Unrecognized token.


                  abort();
              }
            } // Return the sentinel `$` character if the parser has reached the end
            // of the source string.


            return "$";
          }; // Internal: Parses a JSON `value` token.


          var get = function (value) {
            var results, hasMembers;

            if (value === "$") {
              // Unexpected end of input.
              abort();
            }

            if (typeof value === "string") {
              if ((charIndexBuggy ? value.charAt(0) : value[0]) === "@") {
                // Remove the sentinel `@` character.
                return value.slice(1);
              } // Parse object and array literals.


              if (value === "[") {
                // Parses a JSON array, returning a new JavaScript array.
                results = [];

                for (;; hasMembers || (hasMembers = true)) {
                  value = lex(); // A closing square bracket marks the end of the array literal.

                  if (value === "]") {
                    break;
                  } // If the array literal contains elements, the current token
                  // should be a comma separating the previous element from the
                  // next.


                  if (hasMembers) {
                    if (value === ",") {
                      value = lex();

                      if (value === "]") {
                        // Unexpected trailing `,` in array literal.
                        abort();
                      }
                    } else {
                      // A `,` must separate each array element.
                      abort();
                    }
                  } // Elisions and leading commas are not permitted.


                  if (value === ",") {
                    abort();
                  }

                  results.push(get(value));
                }

                return results;
              } else if (value === "{") {
                // Parses a JSON object, returning a new JavaScript object.
                results = {};

                for (;; hasMembers || (hasMembers = true)) {
                  value = lex(); // A closing curly brace marks the end of the object literal.

                  if (value == "}") {
                    break;
                  } // If the object literal contains members, the current token
                  // should be a comma separator.


                  if (hasMembers) {
                    if (value === ",") {
                      value = lex();

                      if (value === "}") {
                        // Unexpected trailing `,` in object literal.
                        abort();
                      }
                    } else {
                      // A `,` must separate each object member.
                      abort();
                    }
                  } // Leading commas are not permitted, object property names must be
                  // double-quoted strings, and a `:` must separate each property
                  // name and value.


                  if (value === "," || typeof value !== "string" || (charIndexBuggy ? value.charAt(0) : value[0]) !== "@" || lex() !== ":") {
                    abort();
                  }

                  results[value.slice(1)] = get(lex());
                }

                return results;
              } // Unexpected token encountered.


              abort();
            }

            return value;
          }; // Internal: Updates a traversed object member.


          var update = function (source, property, callback) {
            var element = walk(source, property, callback);

            if (element === undef) {
              delete source[property];
            } else {
              source[property] = element;
            }
          }; // Internal: Recursively traverses a parsed JSON object, invoking the
          // `callback` function for each value. This is an implementation of the
          // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.


          var walk = function (source, property, callback) {
            var value = source[property],
                length;

            if (typeof value === "object" && value) {
              // `forEach` can't be used to traverse an array in Opera <= 8.54
              // because its `Object#hasOwnProperty` implementation returns `false`
              // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).
              if (getClass.call(value) == arrayClass) {
                for (length = value.length; length--;) {
                  update(value, length, callback);
                }
              } else {
                forEach(value, function (property) {
                  update(value, property, callback);
                });
              }
            }

            return callback.call(source, property, value);
          }; // Public: `JSON.parse`. See ES 5.1 section 15.12.2.


          JSON3.parse = function (source, callback) {
            var result, value;
            Index = 0;
            Source = "" + source;
            result = get(lex()); // If a JSON string contains multiple tokens, it is invalid.

            if (lex() != "$") {
              abort();
            } // Reset the parser state.


            Index = Source = null;
            return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
          };
        }
      } // Export for asynchronous module loaders.


      if (isLoader) {
        define(function () {
          return JSON3;
        });
      }
    })(this || window); // End of original code.

  })(); // Finally expose (polyfilled) window.JSON as qx.lang.Json.JSON


  qx.lang.Json.stringify = window.JSON.stringify;
  qx.lang.Json.parse = window.JSON.parse;
  qx.lang.Json.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
  
  ************************************************************************ */

  /**
   * Helper functions for numbers.
   *
   * The native JavaScript Number is not modified by this class.
   *
   */
  qx.Class.define("qx.lang.Number", {
    statics: {
      /**
       * Check whether the number is in a given range
       *
       * @param nr {Number} the number to check
       * @param vmin {Integer} lower bound of the range
       * @param vmax {Integer} upper bound of the range
       * @return {Boolean} whether the number is >= vmin and <= vmax
       */
      isInRange: function (nr, vmin, vmax) {
        return nr >= vmin && nr <= vmax;
      },

      /**
       * Check whether the number is between a given range
       *
       * @param nr {Number} the number to check
       * @param vmin {Integer} lower bound of the range
       * @param vmax {Integer} upper bound of the range
       * @return {Boolean} whether the number is > vmin and < vmax
       */
      isBetweenRange: function (nr, vmin, vmax) {
        return nr > vmin && nr < vmax;
      },

      /**
       * Limit the number to a given range
       *
       * * If the number is greater than the upper bound, the upper bound is returned
       * * If the number is smaller than the lower bound, the lower bound is returned
       * * If the number is in the range, the number is returned
       *
       * @param nr {Number} the number to limit
       * @param vmin {Integer} lower bound of the range
       * @param vmax {Integer} upper bound of the range
       * @return {Integer} the limited number
       */
      limit: function (nr, vmin, vmax) {
        if (vmax != null && nr > vmax) {
          return vmax;
        } else if (vmin != null && nr < vmin) {
          return vmin;
        } else {
          return nr;
        }
      },

      /**
       * Checks the equality of two numbers regarding the imprecision of floats.
       *
       * @param x {Number}
       * @param y {Number}
       * @return {Boolean}
       */
      equals: function (x, y) {
        // 1e-14 is the relative difference.
        return x === y || Math.abs(x - y) < Number.EPSILON || Math.abs(x - y) <= Math.max(Math.abs(x), Math.abs(y)) * 1e-14;
      }
    }
  });
  qx.lang.Number.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2019 Zenesis Ltd http://www.zenesis.com
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * John Spackman (https://github.com/johnspackman/)
  
  ************************************************************************ */

  /**
   * Helper class for generating UUIDs
   */
  qx.Class.define("qx.util.Uuid", {
    extend: qx.core.Object,
    statics: {
      /**
       * Creates an RFC4122 compliant UUID/v4 - that means that collisions are possible but highly
       * unlikely (it has been said that "you would need to do-loop uuid() at max speed for 73,067 
       * years for a 50% chance of one collision").
       * 
       * The implementation of this is from https://github.com/jchook/uuid-random 
       * 
       * @returns {String} eg 534f57dc-301c-417a-ae4c-11a921716307
       */
      createUuidV4: null
    }
  });
  /**
   * @ignore(crypto)
   * @ignore(module)
   * @ignore(module.exports)
   * @ignore(Uint8Array)
   * @ignore(require)
   */

  (function () {
    var buf,
        bufIdx = 0,
        hexBytes = [],
        i; // Pre-calculate toString(16) for speed

    for (i = 0; i < 256; i++) {
      hexBytes[i] = (i + 0x100).toString(16).substr(1);
    } // Buffer random numbers for speed
    // Reduce memory usage by decreasing this number (min 16)
    // or improve speed by increasing this number (try 16384)


    uuid.BUFFER_SIZE = 4096; // Binary uuids

    uuid.bin = uuidBin; // Clear buffer

    uuid.clearBuffer = function () {
      buf = null;
      bufIdx = 0;
    }; // Test for uuid


    uuid.test = function (uuid) {
      if (typeof uuid === 'string') {
        return /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/.test(uuid);
      }

      return false;
    }; // Node & Browser support


    var crypt0;

    if (typeof crypto !== 'undefined') {
      crypt0 = crypto;
    } else if (typeof window !== 'undefined' && typeof window.msCrypto !== 'undefined') {
      crypt0 = window.msCrypto; // IE11
    }

    if (typeof module !== 'undefined' && typeof require === 'function') {
      crypt0 = crypt0 || require('crypto');
    }

    qx.util.Uuid.createUuidV4 = uuid; // Use best available PRNG
    // Also expose this so you can override it.

    uuid.randomBytes = function () {
      if (crypt0) {
        if (crypt0.randomBytes) {
          return crypt0.randomBytes;
        }

        if (crypt0.getRandomValues) {
          return function (n) {
            var bytes = new Uint8Array(n);
            crypt0.getRandomValues(bytes);
            return bytes;
          };
        }
      }

      return function (n) {
        var i,
            r = [];

        for (i = 0; i < n; i++) {
          r.push(Math.floor(Math.random() * 256));
        }

        return r;
      };
    }(); // Buffer some random bytes for speed


    function randomBytesBuffered(n) {
      if (!buf || bufIdx + n > uuid.BUFFER_SIZE) {
        bufIdx = 0;
        buf = uuid.randomBytes(uuid.BUFFER_SIZE);
      }

      return buf.slice(bufIdx, bufIdx += n);
    } // uuid.bin


    function uuidBin() {
      var b = randomBytesBuffered(16);
      b[6] = b[6] & 0x0f | 0x40;
      b[8] = b[8] & 0x3f | 0x80;
      return b;
    } // String UUIDv4 (Random)


    function uuid() {
      var b = uuidBin();
      return hexBytes[b[0]] + hexBytes[b[1]] + hexBytes[b[2]] + hexBytes[b[3]] + '-' + hexBytes[b[4]] + hexBytes[b[5]] + '-' + hexBytes[b[6]] + hexBytes[b[7]] + '-' + hexBytes[b[8]] + hexBytes[b[9]] + '-' + hexBytes[b[10]] + hexBytes[b[11]] + hexBytes[b[12]] + hexBytes[b[13]] + hexBytes[b[14]] + hexBytes[b[15]];
    }
  })();

  qx.util.Uuid.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.type.BaseError": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * A validation Error which should be thrown if a validation fails.
   */
  qx.Class.define("qx.core.ValidationError", {
    extend: qx.type.BaseError
  });
  qx.core.ValidationError.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.lang.normalize.Object": {
        "require": true
      },
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.lang.Type": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
  
     ======================================================================
  
     This class contains code based on the following work:
  
     * Underscore.js
       http://underscorejs.org
  
       Copyright:
         2009-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
  
       License:
         MIT: http://www.opensource.org/licenses/mit-license.php
  
  ************************************************************************ */

  /**
   * Helper functions to handle Object as a Hash map.
   *
   * @require(qx.lang.normalize.Object)
   * @ignore(qx.core.Assert)
   */
  qx.Bootstrap.define("qx.lang.Object", {
    statics: {
      /**
       * Clears the map from all values
       *
       * @param map {Object} the map to clear
       */
      empty: function (map) {
        for (var key in map) {
          if (map.hasOwnProperty(key)) {
            delete map[key];
          }
        }
      },

      /**
       * Check if the hash has any keys
       *
       * @signature function(map)
       * @param map {Object} the map to check
       * @return {Boolean} whether the map has any keys
       * @lint ignoreUnused(key)
       */
      isEmpty: function (map) {
        for (var key in map) {
          return false;
        }

        return true;
      },

      /**
       * Get the number of objects in the map
       *
       * @signature function(map)
       * @param map {Object} the map
       * @return {Integer} number of objects in the map
       */
      getLength: qx.Bootstrap.objectGetLength,

      /**
       * Get the values of a map as array
       *
       * @deprecated {6.0} Please use Object instance values method instead
       *
       * @param map {Object} the map
       * @return {Array} array of the values of the map
       */
      getValues: function (map) {
        return Object.values(map);
      },

      /**
       * Inserts all keys of the source object into the
       * target objects. Attention: The target map gets modified.
       *
       * @signature function(target, source, overwrite)
       * @param target {Object} target object
       * @param source {Object} object to be merged
       * @param overwrite {Boolean ? true} If enabled existing keys will be overwritten
       * @return {Object} Target with merged values from the source object
       */
      mergeWith: qx.Bootstrap.objectMergeWith,

      /**
       * Return a copy of an Object
       *
       * @param source {Object} Object to copy
       * @param deep {Boolean} If the clone should be a deep clone.
       * @return {Object} A copy of the object
       */
      clone: function (source, deep) {
        if (qx.lang.Type.isObject(source)) {
          var clone = {};

          for (var key in source) {
            if (deep) {
              clone[key] = qx.lang.Object.clone(source[key], deep);
            } else {
              clone[key] = source[key];
            }
          }

          return clone;
        } else if (qx.lang.Type.isArray(source)) {
          var clone = [];

          for (var i = 0; i < source.length; i++) {
            if (deep) {
              clone[i] = qx.lang.Object.clone(source[i], deep);
            } else {
              clone[i] = source[i];
            }
          }

          ;
          return clone;
        }

        return source;
      },

      /**
       * Perform a deep comparison to check if two objects are equal
       *
       * @param object1 {Object} the object that is compared to
       * @param object2 {Object} the object that is compared with
       * @return {Boolean} The result of the comparison
       */
      equals: function (object1, object2) {
        return qx.lang.Object.__P_63_0(object1, object2, [], []);
      },

      /**
      * Internal recursive comparison function for equals
      *
      * @param object1 {Object} the object that is compared to
      * @param object2 {Object} the object that is compared with
      * @param aStack {Object} Stack of object1 sub-objects to be traversed
      * @param bStack {Object} Stack of object2 sub-objects to be traversed
      * @return {Boolean} The result of the comparison
      *
      */
      __P_63_0: function (object1, object2, aStack, bStack) {
        // Identical objects are equal. `0 === -0`, but they aren't identical.
        // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
        if (object1 === object2) {
          return object1 !== 0 || 1 / object1 == 1 / object2;
        } // A strict comparison is necessary because `null == undefined`.


        if (object1 == null || object2 == null) {
          return object1 === object2;
        } // Compare `[[Class]]` names.


        var className = Object.prototype.toString.call(object1);

        if (className != Object.prototype.toString.call(object2)) {
          return false;
        }

        switch (className) {
          // Strings, numbers, dates, and booleans are compared by value.
          case '[object String]':
            // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
            // equivalent to `new String("5")`.
            return object1 == String(object2);

          case '[object Number]':
            // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
            // other numeric values.
            return object1 != +object1 ? object2 != +object2 : object1 == 0 ? 1 / object1 == 1 / object2 : object1 == +object2;

          case '[object Date]':
          case '[object Boolean]':
            // Coerce dates and booleans to numeric primitive values. Dates are compared by their
            // millisecond representations. Note that invalid dates with millisecond representations
            // of `NaN` are not equivalent.
            return +object1 == +object2;
          // RegExps are compared by their source patterns and flags.

          case '[object RegExp]':
            return object1.source == object2.source && object1.global == object2.global && object1.multiline == object2.multiline && object1.ignoreCase == object2.ignoreCase;
        }

        if (typeof object1 != 'object' || typeof object2 != 'object') {
          return false;
        } // Assume equality for cyclic structures. The algorithm for detecting cyclic
        // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.


        var length = aStack.length;

        while (length--) {
          // Linear search. Performance is inversely proportional to the number of
          // unique nested structures.
          if (aStack[length] == object1) {
            return bStack[length] == object2;
          }
        } // Objects with different constructors are not equivalent, but `Object`s
        // from different frames are.


        var aCtor = object1.constructor,
            bCtor = object2.constructor;

        if (aCtor !== bCtor && !(qx.Bootstrap.isFunction(aCtor) && aCtor instanceof aCtor && qx.Bootstrap.isFunction(bCtor) && bCtor instanceof bCtor) && 'constructor' in object1 && 'constructor' in object2) {
          return false;
        } // Add the first object to the stack of traversed objects.


        aStack.push(object1);
        bStack.push(object2);
        var size = 0,
            result = true; // Recursively compare objects and arrays.

        if (className == '[object Array]') {
          // Compare array lengths to determine if a deep comparison is necessary.
          size = object1.length;
          result = size == object2.length;

          if (result) {
            // Deep compare the contents, ignoring non-numeric properties.
            while (size--) {
              if (!(result = qx.lang.Object.__P_63_0(object1[size], object2[size], aStack, bStack))) {
                break;
              }
            }
          }
        } else {
          // Deep compare objects.
          for (var key in object1) {
            if (Object.prototype.hasOwnProperty.call(object1, key)) {
              // Count the expected number of properties.
              size++; // Deep compare each member.

              if (!(result = Object.prototype.hasOwnProperty.call(object2, key) && qx.lang.Object.__P_63_0(object1[key], object2[key], aStack, bStack))) {
                break;
              }
            }
          } // Ensure that both objects contain the same number of properties.


          if (result) {
            for (key in object2) {
              if (Object.prototype.hasOwnProperty.call(object2, key) && !size--) {
                break;
              }
            }

            result = !size;
          }
        } // Remove the first object from the stack of traversed objects.


        aStack.pop();
        bStack.pop();
        return result;
      },

      /**
       * Inverts a map by exchanging the keys with the values.
       *
       * If the map has the same values for different keys, information will get lost.
       * The values will be converted to strings using the toString methods.
       *
       * @param map {Object} Map to invert
       * @return {Object} inverted Map
       */
      invert: function (map) {
        var result = {};

        for (var key in map) {
          result[map[key].toString()] = key;
        }

        return result;
      },

      /**
       * Get the key of the given value from a map.
       * If the map has more than one key matching the value, the first match is returned.
       * If the map does not contain the value, <code>null</code> is returned.
       *
       * @param map {Object} Map to search for the key
       * @param value {var} Value to look for
       * @return {String|null} Name of the key (null if not found).
       */
      getKeyFromValue: function (map, value) {
        for (var key in map) {
          if (map.hasOwnProperty(key) && map[key] === value) {
            return key;
          }
        }

        return null;
      },

      /**
       * Whether the map contains the given value.
       *
       * @param map {Object} Map to search for the value
       * @param value {var} Value to look for
       * @return {Boolean} Whether the value was found in the map.
       */
      contains: function (map, value) {
        return this.getKeyFromValue(map, value) !== null;
      },

      /**
      * Convert an array into a map.
      *
      * All elements of the array become keys of the returned map by
      * calling <code>toString</code> on the array elements. The values of the
      * map are set to <code>true</code>
      *
      * @param array {Array} array to convert
      * @return {Map} the array converted to a map.
      */
      fromArray: function (array) {
        var obj = {};

        for (var i = 0, l = array.length; i < l; i++) {
          obj[array[i].toString()] = true;
        }

        return obj;
      }
    }
  });
  qx.lang.Object.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.bom.client.Engine": {
        "require": true
      },
      "qx.log.Logger": {},
      "qx.bom.client.OperatingSystem": {
        "require": true
      },
      "qx.Bootstrap": {},
      "qx.event.handler.Application": {}
    },
    "environment": {
      "provided": [],
      "required": {
        "engine.name": {
          "className": "qx.bom.client.Engine"
        },
        "engine.version": {
          "className": "qx.bom.client.Engine"
        },
        "os.name": {
          "className": "qx.bom.client.OperatingSystem"
        },
        "qx.application": {}
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Daniel Wagner (d_wagner)
       * John Spackman
  
  ************************************************************************ */

  /**
   * This is the base class for non-browser qooxdoo applications.
   */
  qx.Class.define("qx.core.BaseInit", {
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics: {
      __P_2_0: null,

      /**
       * Returns the instantiated qooxdoo application.
       *
       * @return {qx.core.Object} The application instance.
       */
      getApplication: function () {
        return this.__P_2_0 || null;
      },

      /**
       * Runs when the application is loaded. Automatically creates an instance
       * of the class defined by the setting <code>qx.application</code>.
       *
       */
      ready: function () {
        if (this.__P_2_0) {
          return;
        }

        if (qx.core.Environment.get("engine.name") == "") {
          qx.log.Logger.warn("Could not detect engine!");
        }

        if (qx.core.Environment.get("engine.version") == "") {
          qx.log.Logger.warn("Could not detect the version of the engine!");
        }

        if (qx.core.Environment.get("os.name") == "") {
          qx.log.Logger.warn("Could not detect operating system!");
        }

        qx.log.Logger.debug(this, "Load runtime: " + (new Date() - qx.Bootstrap.LOADSTART) + "ms");
        var app = qx.core.Environment.get("qx.application");
        var clazz = qx.Class.getByName(app);

        if (clazz) {
          this.__P_2_0 = new clazz();
          var start = new Date();

          this.__P_2_0.main();

          qx.log.Logger.debug(this, "Main runtime: " + (new Date() - start) + "ms");
          var start = new Date();

          this.__P_2_0.finalize();

          qx.log.Logger.debug(this, "Finalize runtime: " + (new Date() - start) + "ms");
          qx.event.handler.Application.onAppInstanceInitialized();
        } else {
          qx.log.Logger.warn("Missing application class: " + app);
        }
      },

      /**
       * Runs before the document is unloaded. Calls the application's close
       * method to check if the unload process should be stopped.
       *
       * @param e {qx.event.type.Native} Incoming beforeunload event.
       */
      __P_2_1: function (e) {
        var app = this.__P_2_0;

        if (app) {
          app.close();
        }
      },

      /**
       * Runs when the document is unloaded. Automatically terminates a previously
       * created application instance.
       *
       */
      __P_2_2: function () {
        var app = this.__P_2_0;

        if (app) {
          app.terminate();
        }
      }
    }
  });
  qx.core.BaseInit.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.bom.client.Engine": {
        "require": true,
        "defer": "runtime"
      },
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.event.IEventHandler": {
        "require": true
      },
      "qx.core.IDisposable": {
        "require": true
      },
      "qx.event.Registration": {
        "defer": "runtime",
        "require": true
      },
      "qx.lang.Function": {},
      "qx.bom.client.Browser": {
        "require": true
      },
      "qx.bom.Event": {},
      "qx.bom.client.Runtime": {
        "require": true
      },
      "qx.event.GlobalError": {
        "require": true
      }
    },
    "environment": {
      "provided": [],
      "required": {
        "engine.name": {
          "className": "qx.bom.client.Engine"
        },
        "browser.documentmode": {
          "className": "qx.bom.client.Browser"
        },
        "runtime.name": {
          "className": "qx.bom.client.Runtime"
        },
        "qx.globalErrorHandling": {
          "className": "qx.event.GlobalError"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2007-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * This handler provides events for qooxdoo application startup/shutdown logic.
   * 
   * NOTE: Instances of this class must be disposed of after use
   *
   * @require(qx.bom.client.Engine)
   */
  qx.Class.define("qx.event.handler.Application", {
    extend: qx.core.Object,
    implement: [qx.event.IEventHandler, qx.core.IDisposable],

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */

    /**
     * Create a new instance
     *
     * @param manager {qx.event.Manager} Event manager for the window to use
     */
    construct: function (manager) {
      qx.core.Object.constructor.call(this); // Define shorthands

      this._window = manager.getWindow();
      this.__P_61_0 = false;
      this.__P_61_1 = false;
      this.__P_61_2 = false;
      this.__P_61_3 = false;
      this.__P_61_4 = false; // Initialize observers

      this._initObserver(); // Store instance (only supported for main app window, this
      // is the reason why this is OK here)


      qx.event.handler.Application.$$instance = this;
    },

    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics: {
      /** @type {Integer} Priority of this handler */
      PRIORITY: qx.event.Registration.PRIORITY_NORMAL,

      /** @type {Map} Supported event types */
      SUPPORTED_TYPES: {
        ready: 1,
        shutdown: 1
      },

      /** @type {Integer} Which target check to use */
      TARGET_CHECK: qx.event.IEventHandler.TARGET_WINDOW,

      /** @type {Integer} Whether the method "canHandleEvent" must be called */
      IGNORE_CAN_HANDLE: true,

      /**
       * Sends the currently running application the ready signal. Used
       * exclusively by package loader system.
       *
       * @internal
       */
      onScriptLoaded: function () {
        var inst = qx.event.handler.Application.$$instance;

        if (inst) {
          inst.__P_61_5();
        }
      },

      /**
       * Notifies that the application has finished initialization
       *
       * @internal
       */
      onAppInstanceInitialized: function () {
        var inst = qx.event.handler.Application.$$instance;

        if (inst) {
          inst.__P_61_6();
        }
      }
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /*
      ---------------------------------------------------------------------------
        EVENT HANDLER INTERFACE
      ---------------------------------------------------------------------------
      */
      // interface implementation
      canHandleEvent: function (target, type) {},
      // interface implementation
      registerEvent: function (target, type, capture) {// Nothing needs to be done here
      },
      // interface implementation
      unregisterEvent: function (target, type, capture) {// Nothing needs to be done here
      },
      __P_61_2: null,
      __P_61_3: null,
      __P_61_0: null,
      __P_61_1: null,
      __P_61_4: null,

      /*
      ---------------------------------------------------------------------------
        USER ACCESS
      ---------------------------------------------------------------------------
      */

      /**
       * Fires a global ready event.
       *
       */
      __P_61_5: function () {
        // Wrapper qxloader needed to be compatible with old generator
        if (!this.__P_61_2 && this.__P_61_0 && qx.$$loader.scriptLoaded) {
          // If qooxdoo is loaded within a frame in IE, the document is ready before
          // the "ready" listener can be added. To avoid any startup issue check
          // for the availability of the "ready" listener before firing the event.
          // So at last the native "load" will trigger the "ready" event.
          if (qx.core.Environment.get("engine.name") == "mshtml") {
            if (qx.event.Registration.hasListener(this._window, "ready")) {
              this.__P_61_2 = true; // Fire user event

              qx.event.Registration.fireEvent(this._window, "ready");
            }
          } else {
            this.__P_61_2 = true; // Fire user event

            qx.event.Registration.fireEvent(this._window, "ready");
          }
        }
      },

      /**
       * Fires a global "appinitialized" event.
       *
       */
      __P_61_6: function () {
        this.__P_61_3 = true; // Fire user event

        qx.event.Registration.fireEvent(this._window, "appinitialized");
      },

      /**
       * Whether the application is ready.
       *
       * @return {Boolean} ready status
       */
      isApplicationReady: function () {
        return this.__P_61_2;
      },

      /**
       * Whether the application is initialized
       *
       * @return {Boolean} initialization status
       */
      isApplicationInitialized: function () {
        return this.__P_61_3;
      },

      /*
      ---------------------------------------------------------------------------
        OBSERVER INIT/STOP
      ---------------------------------------------------------------------------
      */

      /**
       * Initializes the native application event listeners.
       *
       */
      _initObserver: function () {
        // in Firefox the loader script sets the ready state
        if (qx.$$domReady || document.readyState == "complete" || document.readyState == "ready") {
          this.__P_61_0 = true;

          this.__P_61_5();
        } else {
          this._onNativeLoadWrapped = qx.lang.Function.bind(this._onNativeLoad, this);

          if (qx.core.Environment.get("engine.name") == "gecko" || qx.core.Environment.get("engine.name") == "opera" || qx.core.Environment.get("engine.name") == "webkit" || qx.core.Environment.get("engine.name") == "mshtml" && qx.core.Environment.get("browser.documentmode") > 8) {
            // Using native method supported by Mozilla, Webkit, Opera and IE >= 9
            qx.bom.Event.addNativeListener(this._window, "DOMContentLoaded", this._onNativeLoadWrapped);
          } else {
            var self = this; // Continually check to see if the document is ready

            var timer = function () {
              try {
                // If IE is used, use the trick by Diego Perini
                // http://javascript.nwbox.com/IEContentLoaded/
                document.documentElement.doScroll("left");

                if (document.body) {
                  self._onNativeLoadWrapped();
                }
              } catch (error) {
                window.setTimeout(timer, 100);
              }
            };

            timer();
          } // Additional load listener as fallback


          qx.bom.Event.addNativeListener(this._window, "load", this._onNativeLoadWrapped);
        }

        if (qx.core.Environment.get("runtime.name") == "rhino" || qx.core.Environment.get("runtime.name") == "node.js") {
          return;
        }

        this._onNativeUnloadWrapped = qx.lang.Function.bind(this._onNativeUnload, this);
        qx.bom.Event.addNativeListener(this._window, "unload", this._onNativeUnloadWrapped);
      },

      /**
       * Disconnect the native application event listeners.
       *
       */
      _stopObserver: function () {
        if (this._onNativeLoadWrapped) {
          qx.bom.Event.removeNativeListener(this._window, "load", this._onNativeLoadWrapped);
        }

        qx.bom.Event.removeNativeListener(this._window, "unload", this._onNativeUnloadWrapped);
        this._onNativeLoadWrapped = null;
        this._onNativeUnloadWrapped = null;
      },

      /*
      ---------------------------------------------------------------------------
        NATIVE LISTENER
      ---------------------------------------------------------------------------
      */

      /**
       * When qx.globalErrorHandling is enabled the callback will observed
       */
      _onNativeLoad: function () {
        var callback = qx.core.Environment.select("qx.globalErrorHandling", {
          "true": qx.event.GlobalError.observeMethod(this.__P_61_7),
          "false": this.__P_61_7
        });
        callback.apply(this, arguments);
      },

      /**
       * Event listener for native load event
       */
      __P_61_7: function () {
        this.__P_61_0 = true;

        this.__P_61_5();
      },

      /**
       * When qx.globalErrorHandling is enabled the callback will observed
       */
      _onNativeUnload: function () {
        var callback = qx.core.Environment.select("qx.globalErrorHandling", {
          "true": qx.event.GlobalError.observeMethod(this.__P_61_8),
          "false": this.__P_61_8
        });
        callback.apply(this, arguments);
      },

      /**
       * Event listener for native unload event
       */
      __P_61_8: function () {
        if (!this.__P_61_4) {
          this.__P_61_4 = true;

          try {
            // Fire user event
            qx.event.Registration.fireEvent(this._window, "shutdown");
          } catch (e) {
            // IE doesn't execute the "finally" block if no "catch" block is present
            throw e;
          }
        }
      }
    },

    /*
    *****************************************************************************
       DESTRUCTOR
    *****************************************************************************
    */
    destruct: function () {
      this._stopObserver();

      this._window = null;
    },

    /*
    *****************************************************************************
       DEFER
    *****************************************************************************
    */
    defer: function (statics) {
      qx.event.Registration.addHandler(statics);
    }
  });
  qx.event.handler.Application.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Interface": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
  
  ************************************************************************ */

  /**
   * This interface defines what an application class has to implement.
   */
  qx.Interface.define("qx.application.IApplication", {
    members: {
      /**
       * Called when the application relevant classes are loaded and ready.
       *
       */
      main: function () {},

      /**
       * Called when the application's main method was executed to handle
       * "final" tasks like rendering or retrieving data.
       *
       */
      finalize: function () {},

      /**
       * Called in the document.beforeunload event of the browser. If the method
       * returns a string value, the user will be asked by the browser, whether
       * he really wants to leave the page. The return string will be displayed in
       * the message box.
       *
       * @return {String?null} message text on unloading the page
       */
      close: function () {},

      /**
       * This method contains the last code which is run inside the page and may contain cleanup code.
       *
       */
      terminate: function () {}
    }
  });
  qx.application.IApplication.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "require": true
      },
      "qx.application.IApplication": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Thomas Herchenroeder (thron7)
  
  ************************************************************************ */

  /**
   * For a basic, out-of-browser application (running e.g. on Node.js, Rhino).
   */
  qx.Class.define("qx.application.Basic", {
    extend: qx.core.Object,
    implement: [qx.application.IApplication],
    members: {
      // interface method
      main: function () {// empty
      },
      // interface method
      finalize: function () {// empty
      },
      // interface method
      close: function () {// empty
      },
      // interface method
      terminate: function () {// empty
      }
    }
  });
  qx.application.Basic.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.application.Basic": {
        "require": true
      },
      "qx.tool.cli.Cli": {},
      "qx.tool.compiler.Console": {},
      "qx.log.Logger": {
        "defer": "runtime"
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2020 Henner Kollmann
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Henner Kollmann (Henner.Kollmann@gmx.de, @hkollmann)
  
  ************************************************************************ */

  /**
   * This is the main application class of the compiler.
   * 
   * @asset(qx/tool/*)
   *
   */
  qx.Class.define("qx.tool.cli.Application", {
    extend: qx.application.Basic,
    members: {
      /**
       * This method contains the initial application code and gets called
       * during startup of the application
       */
      main: async function () {
        try {
          await new qx.tool.cli.Cli().run();
        } catch (e) {
          qx.tool.compiler.Console.error("Error: " + (e.stack || e.message));
          process.exit(1);
        }
      }
    },
    defer: function (statics) {
      qx.log.Logger.setLevel("error");
    }
  });
  qx.tool.cli.Application.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.Promise": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
   *
   *    qooxdoo-compiler - node.js based replacement for the Qooxdoo python
   *    toolchain
   *
   *    https://github.com/qooxdoo/qooxdoo-compiler
   *
   *    Copyright:
   *      2011-2017 Zenesis Limited, http://www.zenesis.com
   *
   *    License:
   *      MIT: https://opensource.org/licenses/MIT
   *
   *      This software is provided under the same licensing terms as Qooxdoo,
   *      please see the LICENSE file in the Qooxdoo project's top-level directory
   *      for details.
   *
   *    Authors:
   *      * John Spackman (john.spackman@zenesis.com, @johnspackman)
   *
   * *********************************************************************** */
  const {
    promisify
  } = require("util");

  const nodePromisify = promisify;

  const PromisePool = require("es6-promise-pool");

  qx.Class.define("qx.tool.utils.Promisify", {
    statics: {
      MAGIC_KEY: "__isPromisified__",
      IGNORED_PROPS: /^(?:promises|length|name|arguments|caller|callee|prototype|__isPromisified__)$/,
      promisifyAll: function (target, fn) {
        Object.getOwnPropertyNames(target).forEach(key => {
          if (this.IGNORED_PROPS.test(key) || fn && fn(key, target) === false) {
            return;
          }

          if (typeof target[key] !== "function") {
            return;
          }

          if (this.isPromisified(target[key])) {
            return;
          }

          var promisifiedKey = key + "Async";
          target[promisifiedKey] = this.promisify(target[key]);
          [key, promisifiedKey].forEach(key => {
            Object.defineProperty(target[key], this.MAGIC_KEY, {
              value: true,
              configurable: true,
              enumerable: false,
              writable: true
            });
          });
        });
        return target;
      },
      isPromisified: function (fn) {
        try {
          return fn[this.MAGIC_KEY] === true;
        } catch (e) {
          return false;
        }
      },
      promisify: function (fn, context) {
        fn = nodePromisify(fn);

        if (context) {
          fn = fn.bind(context);
        }

        return fn;
      },

      async poolEachOf(arr, size, fn) {
        let index = 0;
        let pool = new PromisePool(() => {
          if (index >= arr.length) {
            return null;
          }

          let item = arr[index++];
          return fn(item);
        }, 10);
        await pool.start();
      },

      async map(arr, fn) {
        return await qx.Promise.all(arr.map(fn));
      },

      async some(arr, fn) {
        return await new qx.Promise((resolve, reject) => {
          let count = 0;
          arr.forEach((...args) => {
            qx.Promise.resolve(fn(...args)).then(result => {
              count++;

              if (result && resolve) {
                resolve(true);
                resolve = null;
              }

              if (count == arr.length && resolve) {
                resolve(false);
              }

              return null;
            });
          });
        });
      },

      async someEach(arr, fn) {
        let index = 0;

        const next = () => {
          if (index >= arr.length) {
            return qx.Promise.resolve(false);
          }

          let item = arr[index++];
          return qx.Promise.resolve(fn(item)).then(result => {
            if (result) {
              return true;
            }

            return next();
          });
        };

        return await next();
      },

      async somePool(arr, size, fn) {
        return await new qx.Promise((resolve, reject) => {
          let index = 0;
          let pool = new PromisePool(() => {
            if (!resolve) {
              return null;
            }

            if (index >= arr.length) {
              resolve(false);
              return null;
            }

            let item = arr[index++];
            return fn(item).then(result => {
              if (result && resolve) {
                resolve(true);
                resolve = null;
              }
            });
          }, 10);
          pool.start();
        });
      },

      call: function (fn) {
        return new Promise((resolve, reject) => {
          fn((err, ...args) => {
            if (err) {
              reject(err);
            } else {
              resolve(...args);
            }
          });
        });
      },
      callback: function (promise, cb) {
        if (cb) {
          promise = promise.then((...args) => cb(null, ...args)).catch(err => cb(err));
        }

        return promise;
      },
      fs: null,
      each: function (coll, fn) {
        return qx.tool.utils.Promisify.eachOf(coll, fn);
      },
      forEachOf: function (coll, fn) {
        return qx.tool.utils.Promisify.eachOf(coll, fn);
      },
      eachOf: function (coll, fn) {
        let promises = Object.keys(coll).map(key => fn(coll[key], key));
        return qx.Promise.all(promises);
      },
      eachSeries: function (coll, fn) {
        return qx.tool.utils.Promisify.eachOfSeries(coll, fn);
      },
      forEachOfSeries: function (coll, fn) {
        return qx.tool.utils.Promisify.eachOfSeries(coll, fn);
      },
      eachOfSeries: function (coll, fn) {
        let keys = Object.keys(coll);
        let index = 0;

        function next() {
          if (index == keys.length) {
            return qx.Promise.resolve();
          }

          let key = keys[index];
          index++;
          var result = fn(coll[key], key);
          return qx.Promise.resolve(result).then(next);
        }

        return next();
      }
    },
    defer: function (statics) {
      statics.fs = statics.promisifyAll(require("fs"), function (key, fs) {
        return key !== "SyncWriteStream";
      });
    }
  });
  qx.tool.utils.Promisify.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.tool.utils.Promisify": {
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.tool.compiler.Version": {},
      "qx.tool.compiler.Console": {},
      "qx.lang.Array": {},
      "qx.tool.config.Compile": {},
      "qx.tool.config.Lockfile": {},
      "qx.tool.cli.api.CompilerApi": {},
      "qx.tool.utils.Json": {},
      "qx.tool.cli.commands.package.Install": {},
      "qx.tool.utils.Utils": {},
      "qx.lang.Type": {},
      "qx.tool.cli.api.LibraryApi": {},
      "qx.lang.Object": {},
      "qx.tool.compiler.resources.ScssConverter": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2018 Zenesis Ltd
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * John Spackman (john.spackman@zenesis.com, @johnspackman)
  
  ************************************************************************ */
  const path = require("upath");

  const fs = qx.tool.utils.Promisify.fs;

  const semver = require("semver");
  /**
   * Entry point for the CLI
   */

  /* global window */


  qx.Class.define("qx.tool.cli.Cli", {
    extend: qx.core.Object,

    construct() {
      qx.core.Object.constructor.call(this);

      if (qx.tool.cli.Cli.__P_3_0) {
        throw new Error("qx.tool.cli.Cli has already been initialized!");
      }

      qx.tool.cli.Cli.__P_3_0 = this;
    },

    members: {
      /** @type {yargs} the current yargs instance */
      yargs: null,

      /** @type {Object} the current argv */
      argv: null,

      /** @type {CompilerApi} the CompilerApi instance */
      _compilerApi: null,

      /** @type {String} the compile.js filename, if there is one */
      _compileJsFilename: null,

      /** @type {String} the compile.json filename, if there is one */
      _compileJsonFilename: null,

      /** @type {Object} Parsed arguments */
      _parsedArgs: null,

      /** @type {Promise} Promise that resolves to the _parsedArgs, but only when completely finished parsing them */
      __P_3_1: null,

      /** @type {Boolean} Whether libraries have had their `.load()` method called yet */
      __P_3_2: false,

      /**
       * Creates an instance of yargs, with minimal options
       *
       * @return {yargs}
       */
      __P_3_3() {
        return this.yargs = require("yargs").locale("en").version().strict(false).showHelpOnFail().help(false).option("force", {
          describe: "Override warnings",
          type: "boolean",
          default: false,
          alias: "F"
        }).option("config-file", {
          describe: "Specify the config file to use",
          type: "string",
          alias: "c"
        }).option("verbose", {
          alias: "v",
          describe: "enables additional progress output to console",
          default: false,
          type: "boolean"
        }).option("quiet", {
          alias: "q",
          describe: "suppresses normal progress output to console",
          type: "boolean"
        }).option("block-global-framework", {
          describe: "prevents use of global override of the framework (used for deployment)",
          type: "boolean",
          default: false
        });
      },

      /**
       * Initialises this.argv with the bare minimum required to load the config files and begin
       * processing
       */
      async __P_3_4() {
        var title = "qooxdoo command line interface";
        title = "\n" + title + "\n" + "=".repeat(title.length); // NOTE:: We CANNOT get the framework version here because we will not know which framework
        //  to load until we have parse the command line args

        title += `
Versions: @qooxdoo/compiler    v${qx.tool.compiler.Version.VERSION}
`;
        title += "\n";
        title += `Typical usage:
        qx <commands> [options]
        
      Type qx <command> --help for options and subcommands.`;

        let yargs = this.__P_3_3().usage(title);

        this.argv = yargs.argv;
      },

      /**
       * Reloads this.argv with the full set of arguments
       */
      async __P_3_5() {
        let yargs = this.__P_3_3().help(true).option("set", {
          describe: "sets an environment value for the compiler",
          nargs: 1,
          requiresArg: true,
          type: "string",
          array: true
        }).option("set-env", {
          describe: "sets an environment value for the application",
          nargs: 1,
          requiresArg: true,
          type: "string",
          array: true
        }).check(argv => {
          // validate that "set-env" is not set or if it is
          // set it's items are strings in the form of key=value
          const regexp = /^[^=\s]+=.+$/;
          const setEnv = argv["set-env"];

          if (!(setEnv === undefined || !setEnv.some(item => !regexp.test(item)))) {
            throw new Error("Argument check failed: --set-env must be a key=value pair.");
          }

          return true;
        });

        qx.tool.cli.Cli.addYargsCommands(yargs, ["Add", "Clean", "Compile", "Config", "Deploy", "Package", "Pkg", // alias for Package
        "Create", "Lint", "Run", "Test", "Serve"], "qx.tool.cli.commands");
        this.argv = await yargs.demandCommand().strict().argv;
        await this.__P_3_6();
      },

      /**
       * This is to notify the commands after loading the full args.
       * The commands can overload special arg arguments here.
       * e.g. Deploy will will overload the target.
       */
      __P_3_7: function () {
        let cmd = this._compilerApi.getCommand();

        if (cmd) {
          this._compilerApi.getCommand().processArgs(this.argv);
        }
      },

      /**
       * Calls the `.load()` method of each library, safe to call multiple times.  This is
       * to delay the calling of `load()` until after we know that the command has been selected
       * by Yargs
       */
      async __P_3_6() {
        if (this.__P_3_2) {
          return;
        }

        this.__P_3_2 = true;

        for (let i = 0, arr = this._compilerApi.getLibraryApis(); i < arr.length; i++) {
          let libraryApi = arr[i];
          await libraryApi.load();
        }

        await this._compilerApi.afterLibrariesLoaded();
      },

      /**
       * Processes a command.  All commands should use this method when invoked by Yargs, because it
       * provides a standard error control and makes sure that the libraries know what command has
       * been selected.
       *
       * @param command {qx.tool.cli.Command} the command being run
       */
      async processCommand(command) {
        qx.tool.compiler.Console.getInstance().setVerbose(this.argv.verbose);
        command.setCompilerApi(this._compilerApi);

        this._compilerApi.setCommand(command);

        await this.__P_3_6();

        try {
          return await command.process();
        } catch (e) {
          qx.tool.compiler.Console.error("Error: " + (e.stack || e.message));
          process.exit(1);
          return null;
        }
      },

      /**
       * Returns the parsed command line and configuration data
       *
       * @return {Object}
       */
      async getParsedArgs() {
        return await this.__P_3_1;
      },

      /**
       * Parses the command line and loads configuration data from a .js or .json file;
       * if you provide a .js file the file must be a module which returns an object which
       * has any of these properties:
       *
       *  CompilerApi - the class (derived from qx.tool.cli.api.CompilerApi)
       *    for configuring the compiler
       *
       * Each library can also have a compile.js, and that is also a module which can
       * return an object with any of these properties:
       *
       *  LibraryApi - the class (derived from qx.tool.cli.api.LibraryApi)
       *    for configuring the library
       *
       */
      async run() {
        var args = qx.lang.Array.clone(process.argv);
        args.shift();
        process.title = args.join(" ");
        this.__P_3_1 = this.__P_3_8();
        await this.__P_3_1;
      },

      /**
       * Does the work of parsing command line arguments and loading `compile.js[on]`
       */
      async __P_3_8() {
        await this.__P_3_4();
        /*
         * Detect and load compile.json and compile.js
         */

        let defaultConfigFilename = qx.tool.config.Compile.config.fileName;

        if (this.argv.configFile) {
          process.chdir(path.dirname(this.argv.configFile));
          this.argv.configFile = path.basename(this.argv.configFile);
          defaultConfigFilename = this.argv.configFile;
        }

        var lockfileContent = {
          version: qx.tool.config.Lockfile.getInstance().getVersion()
        };
        let compileJsFilename = qx.tool.cli.Cli.compileJsFilename;
        let compileJsonFilename = qx.tool.config.Compile.config.fileName;

        if (defaultConfigFilename) {
          if (defaultConfigFilename.match(/\.js$/)) {
            compileJsFilename = defaultConfigFilename;
          } else {
            compileJsonFilename = defaultConfigFilename;
          }
        }

        if (await fs.existsAsync(compileJsonFilename)) {
          this._compileJsonFilename = compileJsonFilename;
        }
        /*
         * Create a CompilerAPI
         */


        let CompilerApi = qx.tool.cli.api.CompilerApi;

        if (await fs.existsAsync(compileJsFilename)) {
          let compileJs = await this.__P_3_9(compileJsFilename);
          this._compileJsFilename = compileJsFilename;

          if (compileJs.CompilerApi) {
            CompilerApi = compileJs.CompilerApi;
          }
        }

        let compilerApi = this._compilerApi = new CompilerApi(this).set({
          rootDir: ".",
          configFilename: compileJsonFilename
        });
        await compilerApi.load();
        let config = compilerApi.getConfiguration();
        /*
         * Open the lockfile and check versions
         */

        if (defaultConfigFilename) {
          let lockfile = qx.tool.config.Lockfile.config.fileName;

          try {
            var name = path.join(path.dirname(defaultConfigFilename), lockfile);
            lockfileContent = (await qx.tool.utils.Json.loadJsonAsync(name)) || lockfileContent;
          } catch (ex) {// Nothing
          } // check semver-type compatibility (i.e. compatible as long as major version stays the same)


          let schemaVersion = semver.coerce(qx.tool.config.Lockfile.getInstance().getVersion(), true).raw;
          let fileVersion = lockfileContent && lockfileContent.version ? semver.coerce(lockfileContent.version, true).raw : "1.0.0";

          if (semver.major(schemaVersion) > semver.major(fileVersion)) {
            if (this.argv.force) {
              let config = {
                verbose: this.argv.verbose,
                quiet: this.argv.quiet,
                save: false
              };
              const installer = new qx.tool.cli.commands.package.Install(config);
              let filepath = installer.getLockfilePath();
              let backup = filepath + ".old";
              await fs.copyFileAsync(filepath, backup);

              if (!this.argv.quiet) {
                qx.tool.compiler.Console.warn(`*** A backup of ${lockfile} has been saved to ${backup}, in case you need to revert to it. ***`);
              }

              await installer.deleteLockfile();

              for (let lib of lockfileContent.libraries) {
                if (!(await installer.isInstalled(lib.uri, lib.repo_tag))) {
                  if (lib.repo_tag) {
                    await installer.install(lib.uri, lib.repo_tag);
                  } else if (lib.path && fs.existsSync(lib.path)) {
                    await installer.installFromLocaPath(lib.path, lib.uri);
                  }
                } else if (this.argv.verbose) {
                  qx.tool.compiler.Console.info(`>>> ${lib.uri}@${lib.repo_tag} is already installed.`);
                }
              }

              lockfileContent = await installer.getLockfileData();
            } else {
              throw new qx.tool.utils.Utils.UserError(`*** Warning ***\n` + `The schema of '${lockfile}' has changed. Execute 'qx clean && qx compile --force' to delete and regenerate it.\n` + `You might have to re-apply manual modifications to '${lockfile}'.`);
            }
          }
        }
        /*
         * Locate and load libraries
         */


        if (!config.libraries) {
          if (fs.existsSync("Manifest.json")) {
            config.libraries = ["."];
          }
        }

        if (lockfileContent.libraries) {
          config.packages = {};
          lockfileContent.libraries.forEach(function (library) {
            config.libraries.push(library.path);
            config.packages[library.uri] = library.path;
          });
        } // check if we need to load libraries, needs more robust test


        let needLibraries = qx.lang.Type.isArray(this.argv._) && this.argv._[0] !== "clean"; // check if libraries are loaded

        if (config.libraries && needLibraries) {
          if (!config.libraries.every(libData => fs.existsSync(libData + "/Manifest.json"))) {
            qx.tool.compiler.Console.log("One or more libraries not found - trying to install them from library repository...");
            const installer = new qx.tool.cli.commands.package.Install({
              quiet: true,
              save: false
            });
            await installer.process();
          }

          for (const aPath of config.libraries) {
            let libCompileJsFilename = path.join(aPath, qx.tool.cli.Cli.compileJsFilename);
            let LibraryApi = qx.tool.cli.api.LibraryApi;

            if (await fs.existsAsync(libCompileJsFilename)) {
              let compileJs = await this.__P_3_9(libCompileJsFilename);

              if (compileJs.LibraryApi) {
                LibraryApi = compileJs.LibraryApi;
              }
            }

            let libraryApi = new LibraryApi().set({
              rootDir: aPath,
              compilerApi: compilerApi
            });
            compilerApi.addLibraryApi(libraryApi);
            await libraryApi.initialize();
          }
        }
        /*
         * Now everything is loaded, we can process the command line properly
         */


        await this.__P_3_5();

        this.__P_3_7();

        let parsedArgs = {
          target: this.argv.target,
          outputPath: null,
          locales: null,
          writeAllTranslations: this.argv.writeAllTranslations,
          environment: {},
          verbose: this.argv.verbose
        };

        if (this.argv.locale && this.argv.locale.length) {
          parsedArgs.locales = this.argv.locale;
        }

        if (this.argv["set-env"]) {
          this.argv["set-env"].forEach(function (kv) {
            var m = kv.match(/^([^=\s]+)(=(.+))?$/);
            var key = m[1];
            var value = m[3];
            parsedArgs.environment[key] = value;
          });
        }

        config.targetType = parsedArgs.target || config.defaultTarget || "source";

        if (!config.locales) {
          config.locales = [];
        }

        if (typeof parsedArgs.writeAllTranslations == "boolean") {
          config.writeAllTranslations = parsedArgs.writeAllTranslations;
        }

        if (!config.environment) {
          config.environment = {};
        } // Set the environment variables coming from command line arguments
        // in target's environment object. If that object doesn't exist create
        // one and assign it to the target.


        if (config.targets) {
          const target = config.targets.find(target => target.type === config.targetType);
          target.environment = target.environment || {};
          qx.lang.Object.mergeWith(target.environment, parsedArgs.environment, true);
        }

        if (config.sass && config.sass.compiler !== undefined) {
          qx.tool.compiler.resources.ScssConverter.USE_V6_COMPILER = config.sass.compiler == "latest";
        } else {
          qx.tool.compiler.resources.ScssConverter.USE_V6_COMPILER = null;
        }

        if (config.sass && config.sass.copyOriginal) {
          qx.tool.compiler.resources.ScssConverter.COPY_ORIGINAL_FILES = true;
        }

        if (!config.serve) {
          config.serve = {};
        }

        if (this.isExplicitArg("listen-port")) {
          config.serve.listenPort = this.argv.listenPort;
        } else {
          config.serve.listenPort = config.serve.listenPort || this.argv.listenPort;
        }

        this._parsedArgs = await compilerApi.getConfiguration();
        return this._parsedArgs;
      },

      /**
       * Loads a .js file using `require`, handling exceptions as best as possible
       *
       * @param aPath {String} the file to load
       * @return {Object} the module
       */
      __P_3_9: async function (aPath) {
        try {
          let module = require(path.resolve(aPath));

          return module;
        } catch (e) {
          let lines = e.stack.split("\n");

          for (let i = 0; i < lines.length; i++) {
            if (lines[i].match(/^\s+at/)) {
              lines.splice(i);
            }
          }

          let lineNumber = lines[0].split("evalmachine.<anonymous>:")[1];

          if (lineNumber !== undefined) {
            lines.shift();
            throw new Error("Error while reading " + aPath + " at line " + lineNumber + "\n" + lines.join("\n"));
          } else {
            throw new Error("Error while reading " + aPath + "\n" + lines.join("\n"));
          }
        }
      },

      /**
       * Returns the CompilerApi instance
       *
       * @return {CompilerApi}
       */
      getCompilerApi() {
        return this._compilerApi;
      },

      /**
       * Returns the filename of compile.js, if there is one
       *
       * @return {String?} filename
       */
      getCompileJsFilename() {
        return this._compileJsFilename;
      },

      /**
       * Returns the filename of compile.json, if there is one
       *
       * @return {String?} filename
       */
      getCompileJsonFilename() {
        return this._compileJsonFilename;
      },

      /**
       * Detects whether the command line explicit set an option (as opposed to yargs
       * providing a default value).  Note that this does not handle aliases, use the
       * actual, full option name.
       *
       * @param option {String} the name of the option, eg "listen-port"
       * @return {Boolean}
       */
      isExplicitArg(option) {
        function searchForOption(option) {
          return process.argv.indexOf(option) > -1;
        }

        return searchForOption(`-${option}`) || searchForOption(`--${option}`);
      }

    },
    statics: {
      compileJsFilename: "compile.js",

      /** {CompileJs} singleton instance */
      __P_3_0: null,

      /**
       * Returns the singleton instance, throws an error if it has not been created
       *
       * @return {qx.tool.cli.Cli}
       */
      getInstance() {
        if (!qx.tool.cli.Cli.__P_3_0) {
          throw new Error("CompileJs has not been initialized yet!");
        }

        return qx.tool.cli.Cli.__P_3_0;
      },

      /**
       * Adds commands to Yargs
       *
       * @param yargs {yargs} the Yargs instance
       * @param classNames {String[]} array of class names, each of which is in the `packageName` package
       * @param packageName {String} the name of the package to find each command class
       */
      addYargsCommands: function (yargs, classNames, packageName) {
        let pkg = null;
        packageName.split(".").forEach(seg => {
          if (pkg === null) {
            pkg = window[seg];
          } else {
            pkg = pkg[seg];
          }
        });
        classNames.forEach(cmd => {
          let Clazz = pkg[cmd];
          let data = Clazz.getYargsCommand();

          if (data) {
            if (data.handler === undefined) {
              data.handler = argv => qx.tool.cli.Cli.getInstance().processCommand(new Clazz(argv));
            }

            yargs.command(data);
          }
        });
      }
    }
  });
  qx.tool.cli.Cli.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "require": true
      },
      "qx.lang.String": {
        "defer": "runtime"
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
   *
   *    qooxdoo-compiler - node.js based replacement for the Qooxdoo python
   *    toolchain
   *
   *    https://github.com/qooxdoo/qooxdoo-compiler
   *
   *    Copyright:
   *      2011-2017 Zenesis Limited, http://www.zenesis.com
   *
   *    License:
   *      MIT: https://opensource.org/licenses/MIT
   *
   *      This software is provided under the same licensing terms as Qooxdoo,
   *      please see the LICENSE file in the Qooxdoo project's top-level directory
   *      for details.
   *
   *    Authors:
   *      * John Spackman (john.spackman@zenesis.com, @johnspackman)
   *
   * *********************************************************************** */

  /**
   * The Console handles output of compiler messages for the end user (i.e. not debugging output).
   * The output is based around message IDs, which relate to translatable strings, plus arguments.
   */
  qx.Class.define("qx.tool.compiler.Console", {
    extend: qx.core.Object,
    properties: {
      /** Whether verbose logging is enabled */
      verbose: {
        init: false,
        check: "Boolean"
      },

      /** Whether to output all messages as machine readable data structures */
      machineReadable: {
        init: false,
        check: "Boolean"
      },

      /**
       * Function that is used to output console messages; called with:
       *   str {String} complete message to output
       *   msgId {String} original message ID
       *   ...args {Object...} original arguments to message
       */
      writer: {
        init: null,
        nullable: true,
        check: "Function"
      },

      /** Colour prefix for console output */
      colorOn: {
        init: "",
        nullable: false,
        check: "String"
      }
    },
    members: {
      /**
       * Prints the message
       *
       * @param msgId {String} translatable message ID
       * @param args {Object...} arguments
       */
      print: function (msgId, ...args) {
        for (var i = 0; i < args.length; i++) {
          var arg = args[i];

          if (typeof arg !== "string" && typeof arg !== "number" && arg !== null) {
            args[i] = String(arg);
          }
        }

        if (this.isMachineReadable()) {
          let str = "##" + msgId + ":" + JSON.stringify(args);
          console.log(str);
        } else {
          var writer = this.getWriter();
          let str = this.decode(msgId, ...args);

          if (writer) {
            writer(str, msgId, ...args);
          } else {
            console.log(str);
          }
        }
      },

      /**
       * Decodes the message ID and arguments into a string to be presented in the output
       *
       * @param msgId {String} translatable message ID
       * @param args {Object...} arguments
       * @return {String} complete message
       */
      decode: function (msgId, ...args) {
        var msg = qx.tool.compiler.Console.MESSAGE_IDS[msgId];

        if (msg) {
          let str = qx.lang.String.format(msg.message, args || []);
          return str;
        }

        let str = msgId + JSON.stringify(args);
        return str;
      },

      /**
       * Returns the type of the message, eg error, warning, etc
       * 
       * @param msgId {String} the message ID to lookup
       * @return {String} the type of message, can be one of "message" (default) or "error", "warning"
       */
      getMessageType(msgId) {
        let msg = qx.tool.compiler.Console.MESSAGE_IDS[msgId];
        return msg ? msg.type : null;
      },

      /**
       * console.log equivalent, with colorization
       */
      log(...args) {
        console.log(this.getColorOn() + args.join(" "));
      },

      /**
       * console.debug equivalent, with colorization
       */
      debug(...args) {
        console.debug(this.getColorOn() + args.join(" "));
      },

      /**
       * console.info equivalent, with colorization
       */
      info(...args) {
        console.info(this.getColorOn() + args.join(" "));
      },

      /**
       * console.warn equivalent, with colorization
       */
      warn(...args) {
        console.warn(this.getColorOn() + args.join(" "));
      },

      /**
       * console.error equivalent, with colorization
       */
      error(...args) {
        console.error(this.getColorOn() + args.join(" "));
      }

    },
    defer: function (statics) {
      /*
       * Errors
       */
      statics.addMessageIds({
        // Compiler errors (@see {ClassFile})
        "qx.tool.compiler.class.invalidProperties": "Invalid 'properties' key in class definition",
        "qx.tool.compiler.compiler.missingClassDef": "FATAL Missing class definition - no call to qx.Class.define (or qx.Mixin.define etc)",
        "qx.tool.compiler.compiler.syntaxError": "FATAL Syntax error: %1",
        "qx.tool.compiler.compiler.invalidExtendClause": "FATAL Invalid `extend` clause - expected to find a class name (without quotes or `new`)",
        "qx.tool.compiler.compiler.invalidClassDefinitionEntry": "Unexpected property %2 in %1 definition",
        "qx.tool.compiler.compiler.wrongClassName": "Wrong class name or filename - expected to find at least %1 but only found [%2]",
        // Application errors (@see {Application})
        "qx.tool.compiler.application.partRecursive": "Part %1 has recursive dependencies on other parts",
        "qx.tool.compiler.application.duplicatePartNames": "Duplicate parts named '%1'",
        "qx.tool.compiler.application.noBootPart": "Cannot find a boot part",
        "qx.tool.compiler.application.conflictingExactPart": "Conflicting exact match for %1, could be %2 or %3",
        "qx.tool.compiler.application.conflictingBestPart": "Conflicting best match for %1, could be %2 or %3",
        "qx.tool.compiler.application.missingRequiredLibrary": "Cannot find required library %1",
        "qx.tool.compiler.application.missingScriptResource": "Cannot find script resource: %1",
        "qx.tool.compiler.application.missingCssResource": "Cannot find CSS resource: %1",
        // Target errors (@see {Target})
        "qx.tool.compiler.target.missingAppLibrary": "Cannot find library required to create application for %1",
        // Library errors (@see {Library})
        "qx.tool.compiler.library.emptyManifest": "Empty Manifest.json in library at %1",
        "qx.tool.compiler.library.cannotCorrectCase": "Unable to correct case for library in %1 because it uses source/resource directories which are outside the library",
        "qx.tool.compiler.library.cannotFindPath": "Cannot find path %2 required by library %1",
        // Targets
        "qx.tool.compiler.build.uglifyParseError": "Parse error in output file %4, line %1 column %2: %3",
        // Fonts
        "qx.tool.compiler.webfonts.error": "Error compiling webfont %1, error=%2",
        // Progress
        "qx.tool.compiler.maker.appFatalError": "Cannot write application '%1' because it has fatal errors"
      }, "error");
      /*
       * Warnings
       */

      statics.addMessageIds({
        "qx.tool.compiler.class.blockedMangle": "The mangling of private variable '%1' has been blocked because it is referenced as a string before it is declared",
        "qx.tool.compiler.translate.invalidMessageId": "Cannot interpret message ID %1",
        "qx.tool.compiler.translate.invalidMessageIds": "Cannot interpret message ID %1, %2",
        "qx.tool.compiler.translate.invalidMessageIds3": "Cannot interpret message ID %1, %2, %3",
        "qx.tool.compiler.testForUnresolved": "Unexpected termination when testing for unresolved symbols, node type %1",
        "qx.tool.compiler.testForFunctionParameterType": "Unexpected type of function parameter, node type %1",
        "qx.tool.compiler.defer.unsafe": "Unsafe use of 'defer' method to access external class: %1",
        "qx.tool.compiler.symbol.unresolved": "Unresolved use of symbol %1",
        "qx.tool.compiler.environment.unreachable": "Environment check '%1' may be indeterminable, add to Manifest/provides/environment or use class name prefix",
        "qx.tool.compiler.target.missingBootJs": "There is no reference to index.js script in the index.html copied from %1 (see https://git.io/fh7NI)",

        /* eslint-disable no-template-curly-in-string */
        "qx.tool.compiler.target.missingPreBootJs": "There is no reference to ${preBootJs} in the index.html copied from %1 (see https://git.io/fh7NI)",

        /* eslint-enable no-template-curly-in-string */
        "qx.tool.compiler.maker.appNotHeadless": "Compiling application '%1' but the target supports non-headless output, you may find unwanted dependencies are loaded during startup"
      }, "warning");
    },
    statics: {
      __P_23_0: null,

      /**
       * Returns the singleton instance
       */
      getInstance: function () {
        if (!this.__P_23_0) {
          this.__P_23_0 = new qx.tool.compiler.Console();
        }

        return this.__P_23_0;
      },

      /**
       * Prints the message
       *
       * @param args {Object...} arguments
       */
      print: function (...args) {
        return this.getInstance().print(...args);
      },

      /**
       * Decodes the message ID and arguments into a string to be presented in the output
       *
       * @param args {Object...} arguments
       * @return {String} complete message
       */
      decode: function (...args) {
        return this.getInstance().decode(...args);
      },

      /**
       * console.log equivalent, with colorization
       */
      log(...args) {
        return this.getInstance().log(...args);
      },

      /**
       * console.debug equivalent, with colorization
       */
      debug(...args) {
        return this.getInstance().debug(...args);
      },

      /**
       * console.info equivalent, with colorization
       */
      info(...args) {
        return this.getInstance().info(...args);
      },

      /**
       * console.warn equivalent, with colorization
       */
      warn(...args) {
        return this.getInstance().warn(...args);
      },

      /**
       * console.error equivalent, with colorization
       */
      error(...args) {
        return this.getInstance().error(...args);
      },

      /**
       * Message strings for markers, ie errors and warnings.  The strings are stored as statics
       * here, but that's because the CLI is currently assembled by hand and therefore does not
       * support translations.  When the CLI is itself compiled by `qx compile`, these strings
       * will move into translation files.
       */
      MESSAGE_IDS: {},

      /**
       * Adds message IDs; this is a method because it allows other components (eg qxoodoo-cli) to
       * use it
       *
       * @param obj {Object} map of id strings to message text
       * @param type {String?} the type of message, can be one of "message" (default) or "error", "warning"
       */
      addMessageIds: function (obj, type) {
        for (var id in obj) {
          this.MESSAGE_IDS[id] = {
            id: id,
            message: obj[id],
            type: type || "message"
          };
        }
      },

      /**
       * Decodes a marker into a String description
       * @param marker {Map} containing:
       *    msgId {String}
       *    start {Map} containing:
       *        line {Integer}
       *        column? {Integer}
       *    end? {Map} containing:
       *        line {Integer}
       *        column? {Integer}
       *    args? {Object[]}
       * @param showPosition {Boolean?} whether to include line/column info (default is true)
       * @return {String}
       */
      decodeMarker: function (marker, showPosition) {
        var msg = qx.tool.compiler.Console.MESSAGE_IDS[marker.msgId] || marker.msgId;
        var type = msg.type ? msg.type + ": " : "";
        var str = "";
        var pos = marker.pos;

        if (showPosition !== false && pos && pos.start && pos.start.line) {
          str += "[" + pos.start.line;

          if (pos.start.column) {
            str += "," + pos.start.column;
          }

          if (pos.end && pos.end.line && pos.end.line !== pos.start.line && pos.end.column !== pos.start.column) {
            str += " to " + pos.end.line;

            if (pos.end.column) {
              str += "," + pos.end.column;
            }
          }

          str += "] ";
        }

        try {
          str += type + qx.lang.String.format(msg.message, marker.args || []);
        } catch (e) {
          throw new Error(`Unknown message id ${marker.msgId}.`);
        }

        return str;
      }
    }
  });
  qx.tool.compiler.Console.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
  ************************************************************************ */

  /**
   * NOTE: This is automatically generated by bootstrap-compiler.js
  */
  qx.Class.define("qx.tool.compiler.Version", {
    extend: qx.core.Object,
    statics: {
      VERSION: "1.0.0-beta-20210111-1639"
    }
  });
  qx.tool.compiler.Version.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.tool.utils.Promisify": {
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.lang.Type": {
        "construct": true
      },
      "qx.tool.utils.Json": {},
      "qx.tool.compiler.Console": {},
      "qx.tool.utils.Utils": {},
      "qx.util.ResourceManager": {},
      "qx.tool.config.Manifest": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2019 The qooxdoo developers
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Boulanger (info@bibliograph.org, @cboulanger)
  
  ************************************************************************ */
  const fs = qx.tool.utils.Promisify.fs;

  const process = require("process");

  const path = require("upath");

  const semver = require("semver");

  const get_value = require("get-value");

  const set_value = require("set-value");

  const unset_value = require("unset-value");
  /**
   * An abstract model for config files
   */


  qx.Class.define("qx.tool.config.Abstract", {
    extend: qx.core.Object,
    statics: {
      /**
       * The base URL of all json schema definitions
       */
      schemaBaseUrl: "https://qooxdoo.org/schema"
    },
    construct: function (config) {
      qx.core.Object.constructor.call(this);

      if (qx.lang.Type.isObject(config)) {
        this.set(config);
      }

      for (let prop of ["fileName", "version"]) {
        if (!this.get(prop)) {
          throw new Error(`Property ${prop} must be set when instantiating ${this.classname}`);
        }
      }

      if (!config.baseDir) {
        this.setBaseDir(process.cwd());
      }
    },
    properties: {
      /**
       * Name of the config file
       */
      fileName: {
        check: "String"
      },

      /**
       * The path to the directory containing the config file
       * Defaults to process.cwd()
       */
      baseDir: {
        check: "String"
      },

      /**
       * Schema version of the config file
       * If string, validate all data against this version of the schema
       * If null, do not validate
       */
      version: {
        validate: version => semver.coerce(version) !== null,
        check: "String",
        nullable: true
      },

      /**
       * The config data
       */
      data: {
        check: "Object",
        event: "changeData",
        validate: "_validateData",
        nullable: false
      },

      /**
       * Flag to indicate that data has changed and needs to be saved
       */
      dirty: {
        check: "Boolean",
        init: false,
        event: "changeDirty"
      },

      /**
       * Flag to indicate that data has been loaded
       */
      loaded: {
        check: "Boolean",
        init: false,
        event: "changeLoaded"
      },

      /**
       * Whether to throw an Error if validation fails (false, default),
       * or to simply output a warning to the console (true)
       */
      warnOnly: {
        check: "Boolean",
        init: false
      },

      /**
       * Whether to validate the model data (default: true)
       */
      validate: {
        check: "Boolean",
        init: true
      },

      /**
       * Whether to create the file if it doesn't exist yet (default: false)
       * Setting this to true doesn't automatically create it, you still need to
       * call save(). It just prevents an error during loading the config data.
       * Only works if a "templateFunction" has been set.
       */
      createIfNotExists: {
        check: "Boolean",
        init: false
      },

      /**
       * A function that returns the config file template which is used if no
       * file exists and the "createIfNotExists" property is set to true
       */
      templateFunction: {
        check: "Function",
        nullable: false
      }
    },
    members: {
      /**
       * The json-schema object
       */
      __P_47_0: null,

      /**
       * Validates the given data against the schema that the model has been
       * initialized with. Throws if not valid.
       * @param data The config data
       * @private
       */
      _validateData(data) {
        if (!this.isValidate() || this.getVersion() === null) {
          return;
        }

        if (!this.__P_47_0) {
          throw new Error(`Cannot validate - no schema available! Please load the model first.`);
        }

        try {
          qx.tool.utils.Json.validate(data, this.__P_47_0);
        } catch (e) {
          let msg = `Error validating data for ${this.getRelativeDataPath()}: ${e.message}`;

          if (this.isWarnOnly()) {
            qx.tool.compiler.Console.warn(msg);
          } else {
            throw new qx.tool.utils.Utils.UserError(msg);
          }
        }
      },

      /**
       * The path to the configuration file
       * @return {String}
       */
      getDataPath() {
        return path.join(this.getBaseDir(), this.getFileName());
      },

      /**
       * The path to the configuration file, relative to CWD
       */
      getRelativeDataPath() {
        return path.relative(process.cwd(), this.getDataPath());
      },

      /**
       * Returns the part of the schema URI that is identical for all paths
       * @private
       */
      _getSchemaFileName() {
        let [name, ext] = this.getFileName().split(/\./);
        let version = String(semver.coerce(this.getVersion())).replace(/\./g, "-");
        return `${name}-${version}.${ext}`;
      },

      /**
       * Path to the schema json file in the file system
       * @return {String}
       */
      getSchemaPath() {
        return qx.util.ResourceManager.getInstance().toUri(`qx/tool/schema/${this._getSchemaFileName()}`);
      },

      /**
       * Returns the URL of the JSON schema
       * @return {String}
       */
      getSchemaUri() {
        return qx.tool.config.Abstract.schemaBaseUrl + "/" + this._getSchemaFileName();
      },

      /**
       * Returns the json-schema object
       * @return {Object}
       */
      getSchema() {
        return this.__P_47_0;
      },

      /**
       * Returns true if the config file exists, false if not
       * @return {Promise<Boolean>}
       */
      async exists() {
        return await fs.existsAsync(this.getDataPath());
      },

      /**
       * This method can be used to get the config model singleton in a initialized
       * state. It loads the config data into the model, unless data has already been
       * loaded. If no argument is given, load from the file specified when the
       * instance was created. If an json object is passed, use that data. In both
       * cases, the data is validated against the schema that the model has been
       * initialized with, unless it is missing schema information (for
       * backwards-compatibility). Returns the instance for chaining. To reload
       * the data, set the "loaded" property to false first.
       *
       * @param {Object|undefined} data The json data
       * @return {qx.tool.config.Abstract} Returns the instance for chaining
       */
      async load(data = undefined) {
        if (data === undefined) {
          if (this.isLoaded()) {
            // don't load again
            return this;
          }

          if (await fs.existsAsync(this.getDataPath())) {
            // load data from file
            data = qx.tool.utils.Json.parseJson(await fs.readFileAsync(this.getDataPath(), "utf8"));
          } else if (this.isCreateIfNotExists()) {
            // we're supposed to create it, make sure we're in the library root
            if (await qx.tool.config.Manifest.getInstance().exists()) {
              // but only if we have a template
              let templateFunction = this.getTemplateFunction();

              if (templateFunction) {
                data = templateFunction.bind(this)();

                if (!qx.lang.Type.isObject(data)) {
                  throw new Error(`Template for config file ${this.getRelativeDataPath()} is invalid. Must be an object.`);
                }
              } else {
                throw new Error(`Cannot create config file ${this.getRelativeDataPath()} without a template.`);
              }
            } else {
              throw new Error(`Cannot create config file ${this.getRelativeDataPath()} since no Manifest exists. Are you in the library root?`);
            }
          } else {
            throw new Error(`Cannot load config file: ${this.getRelativeDataPath()} does not exist. Are you in the library root?`);
          }
        } // load schema if validation is enabled


        if (this.isValidate() && this.getVersion() !== null) {
          if (!this.__P_47_0) {
            let s = this.getSchemaPath();

            if (!fs.existsSync(s)) {
              throw new Error(`No schema file exists at ${this.getSchemaPath()}`);
            }

            this.__P_47_0 = await qx.tool.utils.Json.loadJsonAsync(s);
          } // check initial data


          let dataSchemaInfo = qx.tool.utils.Json.getSchemaInfo(data);

          if (!dataSchemaInfo) {
            throw new Error(`Invalid data: no schema found, must be of schema ${this.getSchemaUri()}!`);
          }

          let dataVersion = semver.coerce(dataSchemaInfo.version);
          let schemaVersion = semver.coerce(this.getVersion());

          if (dataVersion !== schemaVersion) {
            // migrate the data if possible
            data = this._migrateData(data, dataVersion, schemaVersion);
          }
        } // validate and save


        this.setData(data);
        this.setLoaded(true);
        return this;
      },

      /**
       * Migrates the data to a new schema if possible or throws otherwise
       * @param {Object} data
       * @param {String} dataVersion (Semver)
       * @param {String} schemaVersion (Semver)
       * @return {Object}
       * @private
       */
      _migrateData(data, dataVersion, schemaVersion) {
        let dataMjVer = Number(semver.major(dataVersion));
        let schemaMjVer = Number(semver.major(schemaVersion));

        switch (true) {
          // identical
          case dataMjVer === schemaMjVer:
            return data;
          // 0->1: add schema id

          case dataMjVer === 0 && schemaMjVer === 1:
            data.$schema = this.getSchemaUri();
            break;
          // throw otherwise

          default:
            throw new Error(`Configuration file schema version mismatch: expected v${schemaMjVer}, found v${dataMjVer}. Could not migrate data.`);
        }

        this.setDirty(true);
        return data;
      },

      /**
       * Returns a value from the configuration map
       * @param prop_path {String|Array} The property path. See https://github.com/jonschlinkert/get-value#usage
       * @param options {*?} See https://github.com/jonschlinkert/get-value#options
       * @return {*}
       */
      getValue(prop_path, options) {
        return get_value(this.getData(), prop_path, options);
      },

      /**
       * Sets a value from the configuration map and validates the result against
       * the json schema of the model
       * @param prop_path {String|Array} The property path. See https://github.com/jonschlinkert/set-value#usage
       * @param value {*}
       * @param options {*?} See https://github.com/jonschlinkert/get-value#options
       * @return {qx.tool.config.Abstract} Returns the instance for chaining
       */
      setValue(prop_path, value, options) {
        let originalValue = this.getValue(prop_path, options);
        set_value(this.getData(), prop_path, value, options);

        try {
          this.validate();
        } catch (e) {
          // revert change
          if (originalValue === undefined) {
            unset_value(this.getData(), prop_path);
          } else {
            set_value(this.getData(), prop_path, originalValue, options);
          } // throw


          throw e;
        }

        this.setDirty(true);
        return this;
      },

      /**
       * Unsets a property from the configuration map and validates the model
       * @param prop_path {String|Array} The property path. See https://github.com/jonschlinkert/set-value#usage
       * @param options {*?} See https://github.com/jonschlinkert/get-value#options
       * @return {qx.tool.config.Abstract} Returns the instance for chaining
       */
      unset(prop_path, options) {
        let originalValue = this.getValue(prop_path, options);
        unset_value(this.getData(), prop_path);

        try {
          this.validate();
        } catch (e) {
          // revert value
          set_value(this.getData(), prop_path, originalValue, options); // throw

          throw e;
        }

        this.setDirty(true);
        return this;
      },

      /**
       * Transforms a value at a given property path, using a function.
       * @param prop_path {String|Array}
       *    The property path. See https://github.com/jonschlinkert/set-value#usage
       * @param transformFunc {Function}
       *    The transformation function, which receives the value of the property
       *    and returns the transformed value, which then is validated and saved.
       * @param options {*?} See https://github.com/jonschlinkert/get-value#options
       * @return {qx.tool.config.Abstract} Returns the instance for chaining
       */
      transform(prop_path, transformFunc, options) {
        let transformedValue = transformFunc(this.getValue(prop_path, options));

        if (transformedValue === undefined) {
          throw new Error("Return value of transformation fuction must not be undefined.");
        }

        this.setValue(prop_path, transformedValue, options);
        return this;
      },

      /**
       * Given a map containing property paths as keys and arbitrary values,
       * return the map with values that are true if the property path exists
       * and false otherwise.
       * @param propOrMap
       * @return {boolean|*}
       */
      keyExists(propOrMap) {
        if (qx.lang.Type.isString(propOrMap)) {
          return this.getValue(propOrMap) !== undefined;
        } else if (qx.lang.Type.isObject(propOrMap)) {
          let res = false;

          for (let key of Object.getOwnPropertyNames(propOrMap)) {
            propOrMap[key] = this.keyExists(key);
            res = res || propOrMap[key];
          }

          return res;
        }

        throw new TypeError("Invalid argument");
      },

      /**
       * Validates the stored config model data. Used when data is changed
       * outside of the API
       */
      validate() {
        this._validateData(this.getData());
      },

      /**
       * Save the data to the config file
       * @return {Promise<void>}
       */
      async save() {
        this.validate();
        await qx.tool.utils.Json.saveJsonAsync(this.getDataPath(), this.getData());
      }

    }
  });
  qx.tool.config.Abstract.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.tool.config.Abstract": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2019 The qooxdoo developers
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Boulanger (info@bibliograph.org, @cboulanger)
  
  ************************************************************************ */

  /**
   * A model for the compile.json file
   */
  qx.Class.define("qx.tool.config.Compile", {
    extend: qx.tool.config.Abstract,
    type: "singleton",
    statics: {
      config: {
        fileName: "compile.json",
        version: "^1.0.0"
      }
    },
    construct: function () {
      qx.tool.config.Abstract.constructor.call(this, qx.tool.config.Compile.config);
    }
  });
  qx.tool.config.Compile.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.tool.utils.Promisify": {
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.tool.cli.LogAppender": {
        "construct": true
      },
      "qx.tool.cli.ConfigDb": {},
      "qx.tool.cli.commands.package.Migrate": {},
      "qx.tool.config.Registry": {},
      "qx.tool.utils.Json": {},
      "qx.lang.Type": {},
      "qx.tool.config.Manifest": {},
      "qx.tool.config.Compile": {},
      "qx.tool.utils.Utils": {},
      "qx.tool.compiler.Console": {},
      "qx.util.ResourceManager": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2017 Zenesis Ltd
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * John Spackman (john.spackman@zenesis.com, @johnspackman)
       * Christian Boulanger (info@bibliograph.org, @cboulanger)
  
  ************************************************************************ */
  const fs = qx.tool.utils.Promisify.fs;

  const process = require("process");

  const child_process = require("child_process");

  const path = require("upath");

  const semver = require("semver");

  const replace_in_file = require("replace-in-file");
  /**
   * Base class for commands
   */


  qx.Class.define("qx.tool.cli.commands.Command", {
    extend: qx.core.Object,
    construct: function (argv) {
      qx.core.Object.constructor.call(this);
      this.argv = argv;

      if (argv.verbose) {
        qx.tool.cli.LogAppender.setMinLevel("debug");
      }
    },
    properties: {
      /**
       * A reference to the current compilerApi instance
       * @var {qx.tool.cli.api.CompilerApi}
       */
      compilerApi: {
        check: "qx.tool.cli.api.CompilerApi",
        nullable: true
      }
    },
    members: {
      argv: null,
      compileJs: null,

      async process() {
        let argv = this.argv;

        if (argv.set) {
          let configDb = await qx.tool.cli.ConfigDb.getInstance();
          argv.set.forEach(function (kv) {
            var m = kv.match(/^([^=\s]+)(=(.+))?$/);

            if (m) {
              var key = m[1];
              var value = m[3];
              configDb.setOverride(key, value);
            } else {
              throw new Error(`Failed to parse environment setting commandline option '--set ${kv}'`);
            }
          });
        } // check if we have to migrate files


        await new qx.tool.cli.commands.package.Migrate(this.argv).process(true);
      },

      /**
       * This is to notify the commands after loading the full args.
       * The commands can overload special arg arguments here.
       * e.g. Deploy will will overload the target.
       *
       * @param {*} argv : args to procvess
       *
       */
      processArgs: function (argv) {// Nothing
      },

      /**
       * Returns data on the project in which the CLI commands are executed. If a qooxdoo.json file
       * exists, the data is taken from there. If not, it tries the following:
       * 1) If a Manifest.json exists in the current dir, it is assumed to be the main library dir.
       * 2) if a compile.json file exists in the current dir, it is assumed to be the application dir
       * 3) if not, the subdir demo/default is checked for a compile.json file.
       *
       * @return {Promise<Object>} A promise that resolves to a map containing the following keys:
       * 'libraries': an array of maps containing a 'path' property with a relative path to a library folder,
       * 'applications': an array of maps containing a 'path' property with a relative path to an
       * application folder. If no project data can be determined, resolves to an empty map.
       */
      getProjectData: async function () {
        let qooxdooJsonPath = path.join(process.cwd(), qx.tool.config.Registry.config.fileName);
        let data = {
          libraries: [],
          applications: []
        };

        if (await fs.existsAsync(qooxdooJsonPath)) {
          let qooxdooJson = await qx.tool.utils.Json.loadJsonAsync(qooxdooJsonPath);

          if (qx.lang.Type.isArray(qooxdooJson.libraries)) {
            data.libraries = qooxdooJson.libraries;
          }

          if (qx.lang.Type.isArray(qooxdooJson.applications)) {
            data.applications = qooxdooJson.applications;
          }
        }

        if (await fs.existsAsync(path.join(process.cwd(), qx.tool.config.Manifest.config.fileName))) {
          if (!data.libraries.find(lib => lib.path === ".")) {
            data.libraries.push({
              path: "."
            });
          }
        }

        if (await fs.existsAsync(path.join(process.cwd(), qx.tool.config.Compile.config.fileName))) {
          if (!data.applications.find(app => app.path === ".")) {
            data.applications.push({
              path: "."
            });
          }
        }

        return data;
      },

      /**
       * Returns the path to the current library. If the current directory contains several libraries,
       * the first one found is returned.
       * @throws {Error} Throws an error if no library can be found.
       * @return {String} A promise that resolves with the absolute path to the library
       */
      getLibraryPath: async function () {
        let {
          libraries
        } = await this.getProjectData();

        if (libraries instanceof Array && libraries.length) {
          return path.resolve(process.cwd(), libraries[0].path);
        }

        throw new qx.tool.utils.Utils.UserError("Cannot find library path - are you in the right directory?");
      },

      /**
       * Returns the path to the current application, depending on the current
       * working directory. If a directory contains several applications, the first one found is
       * returned.
       * @throws {Error} Throws an error if no application can be found.
       * @return {Promise<String>} A promise that resolves with the absolute path to the application
       */
      getApplicationPath: async function () {
        let {
          applications
        } = await this.getProjectData();

        if (applications instanceof Array && applications.length) {
          return path.resolve(process.cwd(), applications[0].path);
        }

        throw new qx.tool.utils.Utils.UserError("Cannot find application path - are you in the right directory?");
      },

      /**
       * Returns the absolute path to the qooxdoo framework used by the current project
       * @return {Promise<String>} Promise that resolves with the path {String}
       */
      getAppQxPath: async function () {
        if (!(await fs.existsAsync(path.join(process.cwd(), qx.tool.config.Compile.config.fileName)))) {
          return this.getGlobalQxPath();
        }

        let compileConfig = await qx.tool.config.Compile.getInstance().load();
        let qxpath = false;
        let appPath = await this.getApplicationPath();
        let libraries = compileConfig.getValue("libraries");

        if (libraries) {
          for (let somepath of libraries) {
            let manifestPath = somepath;

            if (!path.isAbsolute(somepath)) {
              manifestPath = path.join(appPath, manifestPath);
            }

            manifestPath = path.join(manifestPath, qx.tool.config.Manifest.config.fileName);
            let manifest = await qx.tool.utils.Json.loadJsonAsync(manifestPath);

            try {
              if (manifest.provides && manifest.provides.namespace === "qx") {
                qxpath = path.dirname(manifestPath);
                return qxpath;
              }
            } catch (e) {
              qx.tool.compiler.Console.warn(`Invalid manifest file ${manifestPath}.`);
            }
          }
        }

        return this.getGlobalQxPath();
      },

      /**
       * Returns a promise that resolves to the path to the qooxdoo library
       * @return {Promise<*|never|string>}
       */
      getGlobalQxPath: async function () {
        if (!this.argv["block-global-framework"]) {
          // Config override
          let cfg = await qx.tool.cli.ConfigDb.getInstance();
          let dir = cfg.db("qx.library");

          if (dir) {
            let manifestPath = path.join(dir, qx.tool.config.Manifest.config.fileName);

            if (await fs.existsAsync(manifestPath)) {
              return dir;
            }
          }
        } // This project's node_modules


        if (await fs.existsAsync("node_modules/@qooxdoo/framework/" + qx.tool.config.Manifest.config.fileName)) {
          return path.resolve("node_modules/@qooxdoo/framework");
        } // The compiler's qooxdoo


        let filename = require.resolve("@qooxdoo/framework/package.json");

        return path.dirname(filename);
      },

      /**
       * Returns the absolute path to the qooxdoo framework used by the current project, unless
       * the user provided a CLI option "qxpath", in which case this value is returned.
       * @return {Promise<String>} Promise that resolves with the absolute path
       */
      getUserQxPath: async function () {
        let qxpath = await this.getAppQxPath();
        return path.isAbsolute(qxpath) ? qxpath : path.resolve(qxpath);
      },

      /**
       * Returns the version of the qooxdoo framework used by the current project
       * @throws {Error} If the version cannot be determined
       * @return {Promise<String>} Promise that resolves with the version string
       */
      getUserQxVersion: async function () {
        let qxpath = await this.getUserQxPath();
        let qxversion = await this.getLibraryVersion(qxpath);
        return qxversion;
      },

      /**
       * Given the path to a library folder, returns the library version from its manifest
       * @param {String} libPath
       * @return {String} Version
       */
      getLibraryVersion: async function (libPath) {
        let manifestPath = path.join(libPath, qx.tool.config.Manifest.config.fileName);
        let manifest = await qx.tool.utils.Json.loadJsonAsync(manifestPath);
        let version;

        try {
          version = manifest.info.version;
        } catch (e) {
          throw new qx.tool.utils.Utils.UserError(`No valid version data in manifest.`);
        }

        if (!semver.valid(version)) {
          throw new qx.tool.utils.Utils.UserError(`Manifest at ${manifestPath} contains invalid version number "${version}". Please use a semver compatible version.`);
        }

        return version;
      },

      /**
       * Awaitable wrapper around child_process.spawn.
       * Runs a command in a separate process. The output of the command
       * is ignored. Throws when the exit code is not 0.
       * @param  {String} cmd Name of the command
       * @param  {Array} args Array of arguments to the command
       * @return {Promise<Number>} A promise that resolves with the exit code
       */
      run: function (cmd, args) {
        let opts = {
          env: process.env
        };
        return new Promise((resolve, reject) => {
          let exe = child_process.spawn(cmd, args, opts); // suppress all output unless in verbose mode

          exe.stdout.on("data", data => {
            if (this.argv.verbose) {
              qx.tool.compiler.Console.log(data.toString());
            }
          });
          exe.stderr.on("data", data => {
            if (this.argv.verbose) {
              qx.tool.compiler.Console.error(data.toString());
            }
          });
          exe.on("close", code => {
            if (code !== 0) {
              let message = `Error executing '${cmd} ${args.join(" ")}'. Use --verbose to see what went wrong.`;
              throw new qx.tool.utils.Utils.UserError(message);
            } else {
              resolve(0);
            }
          });
          exe.on("error", reject);
        });
      },

      /**
       * Awaitable wrapper around child_process.exec
       * Executes a command and return its result wrapped in a Promise.
       * @param cmd {String} Command with all parameters
       * @return {Promise<String>} Promise that resolves with the result
       */
      exec: function (cmd) {
        return new Promise((resolve, reject) => {
          child_process.exec(cmd, (err, stdout, stderr) => {
            if (err) {
              reject(err);
            }

            if (stderr) {
              reject(new Error(stderr));
            }

            resolve(stdout);
          });
        });
      },

      /**
       * Returns the absolute path to the template directory
       * @return {String}
       */
      getTemplateDir: function () {
        let dir = qx.util.ResourceManager.getInstance().toUri("qx/tool/cli/templates/template_vars.js");
        dir = path.dirname(dir);
        return dir;
      },

      /**
       * Returns the absolute path to the node_module directory
       * @return {String}
       * not used
       */
      getNodeModuleDir: function () {
        return qx.tool.cli.commands.Command.NODE_MODULES_DIR;
      },

      /**
       * Detects whether the command line explicit set an option (as opposed to yargs
       * providing a default value).  Note that this does not handle aliases, use the
       * actual, full option name.
       *
       * @param option {String} the name of the option, eg "listen-port"
       * @return {Boolean}
       */
      isExplicitArg(option) {
        function searchForOption(option) {
          return process.argv.indexOf(option) > -1;
        }

        return searchForOption(`-${option}`) || searchForOption(`--${option}`);
      },

      /**
       * Given an array of [newPath,oldPath], return those array which need to be
       * renamed.
       * @param fileList {[]}
       * @return []
       */
      checkFilesToRename(fileList) {
        let filesToRename = [];

        for (let [newPath, oldPath] of fileList) {
          if (!fs.existsSync(newPath) && fs.existsSync(oldPath)) {
            filesToRename.push([newPath, oldPath]);
          }
        }

        return filesToRename;
      },

      /**
       * Migrate files/schemas or announces the migration.
       * @param {String[]} fileList Array containing arrays of [new name, old name]
       * @param {String[]} replaceInFilesArr Optional array containing objects compatible with https://github.com/adamreisnz/replace-in-file
       * @param {Boolean} annouceOnly If true, annouce the migration. If false (default), just apply it.
       * @private
       */
      async migrate(fileList, replaceInFilesArr = [], annouceOnly = false) {
        let quiet = this.argv.quiet;

        if (qx.lang.Type.isArray(fileList)) {
          let filesToRename = this.checkFilesToRename(fileList);

          if (filesToRename.length) {
            if (annouceOnly) {
              // announce migration
              qx.tool.compiler.Console.warn(`*** Warning: Some metadata filenames have changed. The following files will be renamed:`);

              for (let [newPath, oldPath] of filesToRename) {
                qx.tool.compiler.Console.warn(`    '${oldPath}' => '${newPath}'.`);
              }
            } else {
              // apply migration
              for (let [newPath, oldPath] of filesToRename) {
                try {
                  await fs.renameAsync(oldPath, newPath);

                  if (!quiet) {
                    qx.tool.compiler.Console.info(`Renamed '${oldPath}' to '${newPath}'.`);
                  }
                } catch (e) {
                  qx.tool.compiler.Console.error(`Renaming '${oldPath}' to '${newPath}' failed: ${e.message}.`);
                  process.exit(1);
                }
              }
            }
          }
        }

        if (qx.lang.Type.isArray(replaceInFilesArr) && replaceInFilesArr.length) {
          for (let replaceInFiles of replaceInFilesArr) {
            if (annouceOnly) {
              qx.tool.compiler.Console.warn(`*** In the file(s) ${replaceInFiles.files}, '${replaceInFiles.from}' will be changed to '${replaceInFiles.to}'.`);
              return;
            }

            try {
              let results = await replace_in_file(replaceInFiles);

              if (!quiet) {
                let files = results.filter(result => result.hasChanged).map(result => result.file);
                qx.tool.compiler.Console.info(`The following files were changed: ${files.join(", ")}`);
              }
            } catch (e) {
              qx.tool.compiler.Console.error(`Error replacing in files: ${e.message}`);
              process.exit(1);
            }
          }
        }
      }

    }
  });
  qx.tool.cli.commands.Command.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.log.Logger": {
        "defer": "runtime"
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2017 Zenesis Ltd
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * John Spackman (john.spackman@zenesis.com, @johnspackman)
       * Sebastian Werner (wpbasti)
  
   ************************************************************************ */
  qx.Class.define("qx.tool.cli.LogAppender", {
    statics: {
      __P_5_0: "warn",
      __P_5_1: ["error", "warn", "info", "debug", "trace"],
      setMinLevel: function (minLevel) {
        this.__P_5_0 = minLevel;
      },

      /**
       * Processes a single log entry
       *
       * @param entry
       *          {Map} The entry to process
       */
      process: function (entry) {
        var numLevel = this.__P_5_1[entry.level] || 0;

        if (numLevel > this.__P_5_0) {
          return;
        }

        var level = entry.level !== "debug" && console[entry.level] ? entry.level : "log";

        if (console[level]) {
          var args = this.toText(entry);
          console[level](args);
        }
      },

      /**
       * Converts a single log entry to plain text
       *
       * @param entry
       *          {Map} The entry to process
       * @return {String} the formatted log entry
       */
      toText: function (entry) {
        return this.toTextArray(entry).join(" ");
      },

      /**
       * Converts a single log entry to an array of plain text
       *
       * @param entry
       *          {Map} The entry to process
       * @return {Array} Argument list ready message array.
       */
      toTextArray: function (entry) {
        var output = [];
        var items = entry.items;
        var item;
        var msg;

        for (var i = 0, il = items.length; i < il; i++) {
          item = items[i];
          msg = item.text;

          if (item.trace && item.trace.length > 0) {
            msg += "\n" + item.trace;
          }

          if (msg instanceof Array) {
            var list = [];

            for (var j = 0, jl = msg.length; j < jl; j++) {
              list.push(msg[j].text);
            }

            if (item.type === "map") {
              output.push("{", list.join(", "), "}");
            } else {
              output.push("[", list.join(", "), "]");
            }
          } else {
            output.push(msg);
          }
        }

        return output;
      },

      /**
       * Formats a numeric time offset to 6 characters.
       *
       * @param offset
       *          {Integer} Current offset value
       * @param length
       *          {Integer?6} Refine the length
       * @return {String} Padded string
       */
      formatOffset: function (offset, length) {
        var str = offset.toString();
        var diff = (length || 6) - str.length;
        var pad = "";

        for (var i = 0; i < diff; i++) {
          pad += "0";
        }

        return pad + str;
      }
    },
    defer: function (statics) {
      qx.log.Logger.register(statics);
    }
  });
  qx.tool.cli.LogAppender.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.tool.utils.Promisify": {
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.tool.cli.commands.Command": {
        "require": true
      },
      "qx.tool.cli.Cli": {},
      "qx.tool.config.Lockfile": {},
      "qx.tool.config.Manifest": {},
      "qx.tool.compiler.Console": {},
      "qx.tool.cli.ConfigDb": {},
      "qx.tool.utils.Utils": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2017 Christian Boulanger
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Boulanger (info@bibliograph.org, @cboulanger)
  
  ************************************************************************ */
  const fs = qx.tool.utils.Promisify.fs;

  const path = require("upath");

  const process = require("process");

  const jsonlint = require("jsonlint");

  const stringify = require("json-stable-stringify");
  /**
   * Handles library packages
   */


  qx.Class.define("qx.tool.cli.commands.Package", {
    extend: qx.tool.cli.commands.Command,
    statics: {
      /**
       * The name of the directory in which to download the package files
       */
      cache_dir: "qx_packages",

      /**
       * The previous name of the directory in which to download the package files
       */
      legacy_cache_dir: "contrib",

      /**
       * The name of the file that caches the package registry
       */
      package_cache_name: "package-cache.json",

      /**
       * The previous name of the file that caches the package registry
       */
      legacy_package_cache_name: "contrib-cache.json",

      /**
       * The lockfile with library versions etc.
       */
      lockfile: {
        filename: "qx-lock.json",
        legacy_filename: "contrib.json"
      },

      /**
       * The URL of the cached repository data
       */
      repository_cache_url: "https://raw.githubusercontent.com/qooxdoo/package-cache/master/cache.json",

      /**
       * The yargs command data
       * @return {{}}
       */
      getYargsCommand: function () {
        return {
          command: "package <command> [options]",
          desc: "manages qooxdoo packages",
          builder: yargs => {
            qx.tool.cli.Cli.addYargsCommands(yargs, ["Install", "List", "Publish", "Remove", "Update", "Upgrade", "Migrate"], "qx.tool.cli.commands.package");
            return yargs.showHelpOnFail().help();
          }
        };
      }
    },
    members: {
      /**
       * The current cache object
       */
      __P_13_0: null,

      /**
       * Returns the absolute path to the lockfile.
       * @return {String}
       */
      getLockfilePath: function () {
        return path.join(process.cwd(), qx.tool.config.Lockfile.config.fileName);
      },

      /**
       * Deletes the lockfile
       * @return {Promise<void>}
       */
      async deleteLockfile() {
        await fs.unlinkAsync(this.getLockfilePath());
      },

      /**
       * Returns the lockfile data. Deprecated. Use {@link qx.tool.cli.commands.Package#getLockfileModel}
       * @deprecated
       * @return {Object}
       */
      async getLockfileData() {
        return (await this.getLockfileModel()).getData();
      },

      /**
       * Returns the model of the lockfile
       * @return {Promise<qx.tool.config.Lockfile>}
       */
      async getLockfileModel() {
        return qx.tool.config.Lockfile.getInstance().load();
      },

      /**
       * Returns the model of the manifest
       * @return {Promise<qx.tool.config.Manifest>}
       */
      async getManifestModel() {
        return qx.tool.config.Manifest.getInstance().load();
      },

      /**
       * Convenience method to return all config file models as an array
       * @return {Array} containing [{qx.tool.config.Manifest}, {qx.tool.config.Lockfile}, {qx.tool.config.Compile}]
       */
      async _getConfigData() {
        return [await this.getManifestModel(), await this.getLockfileModel()];
      },

      /**
       * Save configuration data if their content has changed
       * @return {Promise<void>}
       * @private
       */
      async _saveConfigData() {
        const [manifestModel, lockfileModel] = await this._getConfigData();

        if (this.argv.save && manifestModel.isDirty()) {
          await manifestModel.save();

          if (this.argv.verbose) {
            qx.tool.compiler.Console.info(`>>> Saved dependency data to ${manifestModel.getRelativeDataPath()}`);
          }
        }

        if (lockfileModel.isDirty()) {
          await lockfileModel.save();

          if (this.argv.verbose) {
            qx.tool.compiler.Console.info(`>>> Saved library data to ${lockfileModel.getRelativeDataPath()}`);
          }
        }
      },

      /**
       * Returns the tag name of the given library in the given package, if installed.
       * Returns false if not installed.
       * @param {String} repo_name
       * @param {String} library_name
       * @return {String|false}
       */
      async getInstalledLibraryTag(repo_name, library_name) {
        let library = (await this.getLockfileModel()).getValue("libraries").find(lib => lib.repo_name === repo_name && lib.library_name === library_name);
        return library ? library.repo_tag : false;
      },

      /**
       * Returns the data of the given library, if installed.
       * Returns false if not installed.
       * @param {String} library_name
       * @return {Object|false}
       */
      async getInstalledLibraryData(library_name) {
        return (await this.getLockfileModel()).getValue("libraries").find(lib => lib.library_name === library_name);
      },

      /**
       * Returns the absolute path to the file that persists the cache object
       * @return {String}
       */
      getCachePath: function () {
        return path.join(qx.tool.cli.ConfigDb.getDirectory(), qx.tool.cli.commands.Package.package_cache_name);
      },

      /**
       * Returns the URL of the package registry data on GitHub
       * @return {String}
       */
      getRepositoryCacheUrl: function () {
        return qx.tool.cli.commands.Package.repository_cache_url;
      },

      /**
       * Returns the cache object, retrieving it from a local file if necessary
       * @return {Object}
       * @todo use config model API for cache file
       */
      getCache: function (readFromFile = false) {
        if (!readFromFile && this.__P_13_0 && typeof this.__P_13_0 == "object") {
          return this.__P_13_0;
        }

        try {
          this.__P_13_0 = jsonlint.parse(fs.readFileSync(this.getCachePath(), "UTF-8"));
        } catch (e) {
          this.__P_13_0 = {
            repos: {
              list: [],
              data: {}
            },
            compat: {}
          };
        }

        return this.__P_13_0;
      },

      /**
       * Manually overwrite the cache data
       * @param data {Object}
       * @return {void}
       */
      setCache: function (data) {
        this.__P_13_0 = data;
      },

      /**
       * Saves the cache to a hidden local file
       * @return {void}
       */
      saveCache: async function () {
        await qx.tool.utils.Utils.makeParentDir(this.getCachePath());
        await fs.writeFileAsync(this.getCachePath(), JSON.stringify(this.__P_13_0, null, 2), "UTF-8");
      },

      /**
       * Exports the cache to an external file. Note that the structure of the cache
       * data can change any time. Do not build anything on it. You have been warned.
       * @param path {String}
       * @return {void}
       */
      exportCache: async function (path) {
        try {
          let cache = this.__P_13_0 || this.getCache(true);
          let data = stringify(cache, {
            space: 2
          });
          await fs.writeFileAsync(path, data, "UTF-8");
        } catch (e) {
          qx.tool.compiler.Console.error(`Error exporting cache to ${path}:` + e.message);
          process.exit(1);
        }
      },

      /**
       * Clears the cache
       */
      clearCache: function () {
        this.__P_13_0 = null;

        try {
          fs.unlinkSync(this.getCachePath());
        } catch (e) {}
      }
    }
  });
  qx.tool.cli.commands.Package.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.tool.config.Abstract": {
        "construct": true,
        "require": true
      },
      "qx.tool.cli.commands.Package": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2019 The qooxdoo developers
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Boulanger (info@bibliograph.org, @cboulanger)
  
  ************************************************************************ */

  /**
   * A model for the lockfile, which has a version, but no "official" schema (yet)
   */
  const version = "2.1.0";
  qx.Class.define("qx.tool.config.Lockfile", {
    extend: qx.tool.config.Abstract,
    type: "singleton",
    statics: {
      config: {
        fileName: qx.tool.cli.commands.Package.lockfile.filename,
        version,
        validate: false,
        createIfNotExists: true,
        templateFunction: () => ({
          libraries: [],
          version
        })
      }
    },
    construct: function () {
      qx.tool.config.Abstract.constructor.call(this, qx.tool.config.Lockfile.config);
    }
  });
  qx.tool.config.Lockfile.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "require": true
      },
      "qx.tool.compiler.Console": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
   *
   *    qooxdoo-compiler - node.js based replacement for the Qooxdoo python
   *    toolchain
   *
   *    https://github.com/qooxdoo/qooxdoo-compiler
   *
   *    Copyright:
   *      2011-2019 Zenesis Limited, http://www.zenesis.com
   *
   *    License:
   *      MIT: https://opensource.org/licenses/MIT
   *
   *      This software is provided under the same licensing terms as Qooxdoo,
   *      please see the LICENSE file in the Qooxdoo project's top-level directory
   *      for details.
   *
   *    Authors:
   *      * John Spackman (john.spackman@zenesis.com, @johnspackman)
   *
   * *********************************************************************** */
  const path = require("path");

  const fs = require("fs");
  /**
   * Base class for the compiler API classes
   */


  qx.Class.define("qx.tool.cli.api.AbstractApi", {
    extend: qx.core.Object,
    properties: {
      rootDir: {
        check: "String",
        nullable: false
      },

      /** Configuration data for the compiler */
      configuration: {
        init: {}
      }
    },
    members: {
      /**
       * Loads the configuration
       *
       * @return {Map} configuration data
       */
      async load() {
        return this.getConfiguration();
      },

      /**
       * Called by the compiler API during initialisation - this is an ideal
       * place to install additional commands, because a command has not yet
       * been selected 
       */
      async initialize() {// Nothing
      },

      /**
       * 
       * helper to load an npm module. Check if it can be loaded before
       * If not install the module with 'npm install --no-save --no-package-lock' to the current library
       * 
       * @param module {String} module to check
       */
      require: function (module) {
        let exists = fs.existsSync(path.join(process.cwd(), "node_modules", module));

        if (!exists) {
          this.loadNpmModule(module);
        }

        return require(module);
      },

      /**
        * 
        * install an npm module with 'npm install --no-save --no-package-lock' to the current library
        * 
        * @param module {String} module to load
        */
      loadNpmModule: function (module) {
        const {
          execSync
        } = require("child_process");

        let s = `npm install --no-save --no-package-lock ${module}`;
        qx.tool.compiler.Console.info(s);
        execSync(s, {
          stdio: "inherit"
        });
      }
    }
  });
  qx.tool.cli.api.AbstractApi.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.tool.utils.Promisify": {
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.tool.cli.api.AbstractApi": {
        "construct": true,
        "require": true
      },
      "qx.tool.utils.Json": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
   *
   *    qooxdoo-compiler - node.js based replacement for the Qooxdoo python
   *    toolchain
   *
   *    https://github.com/qooxdoo/qooxdoo-compiler
   *
   *    Copyright:
   *      2011-2019 Zenesis Limited, http://www.zenesis.com
   *
   *    License:
   *      MIT: https://opensource.org/licenses/MIT
   *
   *      This software is provided under the same licensing terms as Qooxdoo,
   *      please see the LICENSE file in the Qooxdoo project's top-level directory
   *      for details.
   *
   *    Authors:
   *      * John Spackman (john.spackman@zenesis.com, @johnspackman)
   *
   * *********************************************************************** */
  const path = require("path");

  const fs = qx.tool.utils.Promisify.fs;
  /**
   * Provides an API for the compiler
   * 
   */

  qx.Class.define("qx.tool.cli.api.CompilerApi", {
    extend: qx.tool.cli.api.AbstractApi,
    construct: function () {
      qx.tool.cli.api.AbstractApi.constructor.call(this);
      this.__P_7_0 = {};
    },
    properties: {
      /** Default filename to load from */
      configFilename: {
        check: "String",
        nullable: false
      },

      /** The current command */
      command: {
        init: null,
        nullable: true,
        check: "qx.tool.cli.commands.Command",
        event: "changeCommand"
      }
    },
    members: {
      __P_7_0: null,

      /**
       * Register compiler tests
       * @param cmd {qx.tool.cli.commands.Command} current command
       */
      async beforeTests(cmd) {// Nothing
      },

      /**
       * called after deployment happens
       * 
       * @param data {Object}  contains deployment infos with the following properties:
       *           targetDir  : {String}  The target dir of the build
       *           deployDir  : {String}  The output dir for the deployment
       *           argv       : {Object}  Arguments
       *           application: {Object}  application to build
       * @return {Promise<void>}
       */
      async afterDeploy(data) {// Nothing
      },

      /**
       * Loads the configuration data
       * 
       * @overridden
       */
      async load() {
        let compileJsonPath = path.join(this.getRootDir(), this.getConfigFilename());
        let config = {};

        if (await fs.existsAsync(compileJsonPath)) {
          config = await qx.tool.utils.Json.loadJsonAsync(compileJsonPath);
        }

        this.setConfiguration(config);
        return qx.tool.cli.api.CompilerApi.prototype.load.base.call(this);
      },

      /**
       * Called after all libraries have been loaded and added to the compilation data
       */
      async afterLibrariesLoaded() {
        for (let arr = this.getLibraryApis(), i = 0; i < arr.length; i++) {
          await arr[i].afterLibrariesLoaded();
        }
      },

      /**
       * Adds a library configuration
       * 
       * @param libraryApi {LibraryApi} the configuration for the library
       */
      addLibraryApi(libraryApi) {
        let dir = path.resolve(libraryApi.getRootDir());
        this.__P_7_0[dir] = libraryApi;
      },

      /**
       * Returns an array of library configurations
       * 
       * @return {LibraryApi[]}
       */
      getLibraryApis() {
        return Object.values(this.__P_7_0);
      }

    }
  });
  qx.tool.cli.api.CompilerApi.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.tool.utils.Promisify": {
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.tool.utils.json.Parser": {},
      "qx.tool.utils.json.Stringify": {},
      "qx.lang.Type": {},
      "qx.tool.compiler.Console": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
   *
   *    qooxdoo-compiler - node.js based replacement for the Qooxdoo python
   *    toolchain
   *
   *    https://github.com/qooxdoo/qooxdoo-compiler
   *
   *    Copyright:
   *      2011-2018 Zenesis Limited, http://www.zenesis.com
   *
   *    License:
   *      MIT: https://opensource.org/licenses/MIT
   *
   *      This software is provided under the same licensing terms as Qooxdoo,
   *      please see the LICENSE file in the Qooxdoo project's top-level directory
   *      for details.
   *
   *    Authors:
   *      * John Spackman (john.spackman@zenesis.com, @johnspackman)
   *      * oetiker
   *      * cboulanger
   *
   * *********************************************************************** */
  const Ajv = require("ajv");

  const betterAjvErrors = require("better-ajv-errors");

  const fs = qx.tool.utils.Promisify.fs;
  qx.Class.define("qx.tool.utils.Json", {
    statics: {
      /**
       * Parses JSON string into an object
       * @param str {String} the data to parse
       * @return {Object}
       */
      parseJson: function (str) {
        if (str === null || !str.trim()) {
          return null;
        }

        let ast = qx.tool.utils.json.Parser.parseToAst(str.trim());
        return qx.tool.utils.json.Stringify.astToObject(ast);
      },

      /**
       * Validates a json object against the given schema signature and outputs
       * diagnostic information if validation failed
       * @param json {Object} The json object to check
       * @param schema {Array|Object}
       *    The json-schema object or an array of schema objects. If array,
       *    only the first is used to validate, but the first schema can
       *    refer to the others.
       * @param warnOnly {Boolean} If true, do not throw a fatal error
       * @return {Boolean}
       *    Returns true if successful and false on failure if the
       *    'warnOnly' parameter is true
       */
      validate(json, schema, warnOnly = false) {
        let ajv = new Ajv({
          allErrors: true,
          jsonPointers: true
        });

        if (qx.lang.Type.isArray(schema)) {
          ajv.addSchema(schema);
          schema = schema[0].$id;
        }

        if (ajv.validate(schema, json)) {
          // success!
          return true;
        }

        if (warnOnly) {
          const message = betterAjvErrors(schema.$id, json, ajv.errors, {
            format: "cli",
            indent: 2
          });
          qx.tool.compiler.Console.warn("JSON data does not validate against " + schema.$id + ":\n" + message);
          return false;
        } // throw fatal error


        let err = betterAjvErrors(schema.$id, json, ajv.errors, {
          format: "js"
        });
        let msg;

        if (Array.isArray(err) && err.length) {
          msg = err.reduce((prev, curr, index) => `${prev} ${index + 1}) ${curr.error}`, "").trim();
        } else if (Array.isArray(ajv.errors)) {
          msg = ajv.errors.reduce((prev, curr, index) => `${prev} ${index + 1}) ${curr.dataPath} ${curr.message}`, "").trim();
        } else {
          msg = "Unknown error during validation.";
        }

        throw new Error(msg);
      },

      /**
       * Identify the type and version of the config file schema in the data that
       * has been passed. Return an object containing type and version of the json
       * schema, or null if no schema could been detected
       * Todo: This needs to be rewritten.
       * @param data {Object} JSON data
       * @return {{type,version}|null}
       */
      getSchemaInfo: function (data) {
        let schemaInfo = {};

        if (data.$schema) {
          let match = data.$schema.match(/\/([^-]+)-([^.]+)\.json$/);

          if (match) {
            schemaInfo.type = match[1].toLocaleLowerCase();
            schemaInfo.version = match[2].replace(/-/g, ".");
          } else {
            // deprecated schema url
            let match = data.$schema.match(/\/v([^/]+)\/([^.]+)\.json$/);

            if (match) {
              schemaInfo.type = match[2].toLocaleLowerCase();
              schemaInfo.version = match[1];
            }
          } // guess file type, this would be easy with the file name!

        } else if (data.targets) {
          schemaInfo.type = "compile";
          schemaInfo.version = "0";
        } else if (data.info && data.provides) {
          schemaInfo.type = "manifest";
          schemaInfo.version = "0";
        } else if (data.libraries || data.contribs) {
          schemaInfo.type = "qooxdoo";
          schemaInfo.version = "0";
        } // no schema was found


        if (Object.getOwnPropertyNames(schemaInfo).length === 0) {
          return null;
        }

        return schemaInfo;
      },

      /**
       * Loads JSON data from a file and returns it as an object; if the file does not exist, then
       * null is returned
       *
       * @param filename {String} the filename to load
       * @return {Object|null} the parsed contents, or null if the file does not exist
       */
      loadJsonAsync: async function (filename) {
        if (!(await fs.existsAsync(filename))) {
          return null;
        }

        let data = await fs.readFileAsync(filename, "utf8");

        try {
          return qx.tool.utils.Json.parseJson(data);
        } catch (ex) {
          throw new Error("Failed to load " + filename + ": " + ex);
        }
      },

      /**
       * Saves JSON data to a file, or erases the file if data is null
       *
       * @param filename {String} filename to write to
       * @param data {Object|null} the data to write. If null, remove the file
       */
      saveJsonAsync: async function (filename, data) {
        if (data !== null) {
          await fs.writeFileAsync(filename, JSON.stringify(data, null, 2), "utf8");
        } else if (await fs.existsAsync(filename)) {
          fs.unlinkAsync(filename);
        }
      }
    }
  });
  qx.tool.utils.Json.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.tool.utils.Promisify": {
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.tool.cli.commands.Package": {
        "require": true
      },
      "qx.tool.compiler.Console": {},
      "qx.tool.utils.Utils": {},
      "qx.lang.Type": {},
      "qx.tool.cli.commands.package.Update": {},
      "qx.tool.cli.commands.package.List": {},
      "qx.tool.config.Manifest": {},
      "qx.tool.utils.Json": {},
      "qx.tool.config.Compile": {},
      "qx.tool.config.Lockfile": {},
      "qx.Promise": {},
      "qx.core.Assert": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2017 Christian Boulanger
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Boulanger (info@bibliograph.org, @cboulanger)
  
  ************************************************************************ */
  const download = require("download");

  const fs = qx.tool.utils.Promisify.fs;

  const path = require("upath");

  const process = require("process");

  const semver = require("semver");

  const rimraf = require("rimraf");
  /**
   * Installs a package
   */


  qx.Class.define("qx.tool.cli.commands.package.Install", {
    extend: qx.tool.cli.commands.Package,
    statics: {
      /**
       * Yarg commands data
       * @return {{}}
       */
      getYargsCommand: function () {
        return {
          command: "install [uri[@release_tag]]",
          describe: `installs the latest compatible release of package (as per Manifest.json). Use "-r <release tag>" or @<release tag> to install a particular release.
        examples: 
           * qx package install name: Install latest published version
           * qx package install name@v0.0.2: Install version 0.0.2,
           * qx package install name@master: Install current master branch from github`,
          builder: {
            "release": {
              alias: "r",
              describe: "Use a specific release tag instead of the tag of the latest compatible release",
              nargs: 1,
              requiresArg: true,
              type: "string"
            },
            "ignore": {
              alias: "i",
              describe: "Ignore unmatch of qooxdoo"
            },
            "verbose": {
              alias: "v",
              describe: "Verbose logging"
            },
            "quiet": {
              alias: "q",
              describe: "No output"
            },
            "save": {
              alias: "s",
              default: true,
              describe: "Save the libraries as permanent dependencies"
            },
            "from-path": {
              alias: "p",
              nargs: 1,
              describe: "Install a library/the given library from a local path"
            }
          }
        };
      }
    },
    members: {
      /**
       * @var {Boolean}
       */
      __P_17_0: false,

      /**
       * API method to install a library via its URI and version tag
       * @param {String} library_uri
       * @param {String} release_tag
       * @return {Promise<void>}
       */
      async install(library_uri, release_tag) {
        let installee = library_uri + (release_tag ? "@" + release_tag : "");

        if (this.argv.verbose) {
          qx.tool.compiler.Console.info(`>>> To be installed: ${installee}`);
        }

        this.argv.uri = installee;
        this.argv.fromPath = false;
        await this.process();
      },

      /**
       * API method to install a library from a local path
       * @param {String} local_path
       * @param {String} library_uri Optional library URI.
       * @return {Promise<void>}
       */
      async installFromLocaPath(local_path, library_uri) {
        if (!path.isAbsolute(local_path)) {
          local_path = path.join(process.cwd(), local_path);
        }

        if (this.argv.verbose) {
          qx.tool.compiler.Console.info(`>>> To be installed: ${library_uri || "local libarary"} from ${local_path}`);
        }

        this.argv.uri = library_uri;
        this.argv.fromPath = local_path;
        await this.process();
      },

      /**
       * API method to check if a library has been installed
       * @param {String} library_uri
       * @param {String} release_tag
       * @return {Promise<Boolean>}
       */
      async isInstalled(library_uri, release_tag) {
        return (await this.getLockfileModel()).getValue("libraries").some(lib => lib.uri === library_uri && (release_tag === undefined || release_tag === lib.repo_tag));
      },

      /**
       * Installs a package
       */
      process: async function () {
        await qx.tool.cli.commands.package.Install.prototype.process.base.call(this);
        await this.__P_17_1();
        const [manifestModel, lockfileModel] = await this._getConfigData(); // create shorthand for uri@id

        this.argv.uri = this.argv.uri || this.argv["uri@release_tag"]; // if no library uri has been passed, install from lockfile or manifest

        if (!this.argv.uri && !this.argv.fromPath) {
          if (lockfileModel.getValue("libraries").length) {
            await this.__P_17_2();
          } else {
            await this.__P_17_3(manifestModel.getData());
            await this._saveConfigData();
          }

          return;
        } // library uri and id, which can be none (=latest), version, or tree-ish expression


        let uri = this.argv.uri;
        let id;

        if (this.argv.release) {
          id = this.argv.release;
        } else if (uri) {
          [uri, id] = uri.split(/@/);
        } // prepend "v" to valid semver strings


        if (semver.valid(id) && id[0] !== "v") {
          if (this.argv.verbose) {
            qx.tool.compiler.Console.info(`>>> Prepending "v" to ${id}.`);
          }

          id = `v${id}`;
        }

        if (this.argv.fromPath) {
          // install from local path?
          if (id) {
            throw new qx.tool.utils.Utils.UserError(`Version identifier cannot be used when installing from local path.`);
          }

          let saveToManifest = uri ? this.argv.save : false;
          await this.__P_17_4(uri, this.argv.fromPath, saveToManifest);
        } else if (!id || qx.lang.Type.isString(id) && id.startsWith("v")) {
          // install library/libraries from GitHub release
          await this.__P_17_5(uri, id, this.argv.save);
        } else {
          // install library from GitHub code tree
          await this.__P_17_6(uri, id, this.argv.save);
        }

        await this._saveConfigData();

        if (this.argv.verbose) {
          qx.tool.compiler.Console.info(">>> Done.");
        }
      },

      /**
       * Update repo cache
       * @return {Promise<void>}
       * @private
       */
      async __P_17_1() {
        let repos_cache = this.getCache().repos;

        if (repos_cache.list.length === 0) {
          if (!this.argv.quiet) {
            qx.tool.compiler.Console.info(">>> Updating cache...");
          }

          this.clearCache(); // implicit update

          await new qx.tool.cli.commands.package.Update({
            quiet: true
          }).process();
          await new qx.tool.cli.commands.package.List({
            quiet: true
          }).process();
        }
      },

      /**
       * Returns information on the given URI
       * @param {String} uri
       * @return {{package_path: string | string, repo_name: string}}
       * @private
       */
      __P_17_7(uri) {
        if (!uri) {
          throw new qx.tool.utils.Utils.UserError("No package resource identifier given");
        } // currently, the uri is github_username/repo_name[/path/to/repo].


        let parts = uri.split(/\//);
        let repo_name = parts.slice(0, 2).join("/");
        let package_path = parts.length > 2 ? parts.slice(2).join("/") : "";

        if (!this.getCache().repos.data[repo_name]) {
          throw new qx.tool.utils.Utils.UserError(`A repository '${repo_name}' cannot be found.`);
        }

        return {
          repo_name,
          package_path
        };
      },

      /**
       * Installs libraries in a repository from a given release tag name
       * @param {String} uri The name of the repository (e.g. qooxdoo/qxl.apiviewer),
       *  or of a library within a repository (such as ergobyte/qookery/qookeryace)
       * @param {String} tag_name The tag name of the release, such as "v1.1.0"
       * @param {Boolean} writeToManifest Whether the library should be written to
       * Manifest.json as a dependency
       * @return {Promise<void>}
       * @private
       */
      __P_17_5: async function (uri, tag_name, writeToManifest) {
        let qooxdoo_version = await this.getUserQxVersion();

        let {
          repo_name,
          package_path
        } = this.__P_17_7(uri);

        if (!tag_name) {
          let cache = this.getCache();

          if (cache.compat[qooxdoo_version] === undefined) {
            if (this.argv.verbose && !this.argv.quiet) {
              qx.tool.compiler.Console.info(">>> Updating cache...");
            }

            await new qx.tool.cli.commands.package.List({
              quiet: true,
              all: true
            }).process();
            cache = this.getCache(true);
          }

          tag_name = cache.compat[qooxdoo_version][repo_name];

          if (!tag_name) {
            throw new qx.tool.utils.Utils.UserError(`'${repo_name}' has no stable release compatible with qooxdoo version ${qooxdoo_version}.
             To install anyways, use --release x.y.z.
             Please ask the library maintainer to release a compatible version`);
          }
        }

        if (this.argv.verbose) {
          qx.tool.compiler.Console.info(`>>> Installing '${uri}', release '${tag_name}' for qooxdoo version: ${qooxdoo_version}`);
        }

        let {
          download_path
        } = await this.__P_17_8(repo_name, tag_name); // iterate over contained libraries

        let found = false;
        let repo_data = this.getCache().repos.data[repo_name];

        if (!repo_data) {
          throw new qx.tool.utils.Utils.UserError(`A repository '${repo_name}' cannot be found.`);
        }

        let release_data = repo_data.releases.data[tag_name];

        if (!release_data) {
          throw new qx.tool.utils.Utils.UserError(`'${repo_name}' has no release '${tag_name}'.`);
        } // TO DO: the path in the cache data should be the path to the library containing Manifest.json, not to the Manifest.json itself


        for (let {
          path: manifest_path
        } of release_data.manifests) {
          if (package_path && path.dirname(manifest_path) !== package_path) {
            // if a path component exists, only install the library in this path
            continue;
          }

          let library_uri = path.join(repo_name, path.dirname(manifest_path));
          found = true;
          await this.__P_17_9(library_uri, tag_name, download_path, writeToManifest);
        }

        if (!found) {
          throw new qx.tool.utils.Utils.UserError(`The package/library identified by '${uri}' could not be found.`);
        }
      },

      /**
       * Installs libraries in a given repository from the given hash of a code tree
       * independent from the library cache. This ignores dependency constraints.
       * The given uri must point to a folder containing Manifest.json
       * @param {String} uri
       *  The path to a library in a a repository
       *  (e.g. qooxdoo/qxl.apiviewer or ergobyte/qookery/qookeryace)
       * @param {String} hash
       *  A path into the code tree on GitHub such as "tree/892f44d1d1ae5d65c7dd99b18da6876de2f2a920"
       * @param {Boolean} writeToManifest Whether the library should be written to
       * Manifest.json as a dependency
       * @return {Promise<void>}
       * @private
       */
      __P_17_6: async function (uri, hash, writeToManifest) {
        let qooxdoo_version = await this.getUserQxVersion();

        if (this.argv.verbose) {
          qx.tool.compiler.Console.info(`>>> Installing '${uri}' from tree hash '${hash}' for qooxdoo version ${qooxdoo_version}`);
        }

        let {
          repo_name
        } = this.__P_17_7(uri);

        let {
          download_path
        } = await this.__P_17_8(repo_name, hash);
        await this.__P_17_9(uri, hash, download_path, writeToManifest);
      },

      /**
       * Installs libraries from a local path
       * @param {String} uri
       *  The URI identifying a library (e.g. qooxdoo/qxl.apiviewer or
       *  ergobyte/qookery/qookeryace)
       * @param {String} dir
       *  The path to a local directory
       * @param {Boolean} writeToManifest
       *  Whether the library should be written to Manifest.json as a dependency
       * @return {Promise<void>}
       * @private
       */
      async __P_17_4(uri, dir, writeToManifest = false) {
        let qooxdoo_version = await this.getUserQxVersion();

        if (this.argv.verbose) {
          qx.tool.compiler.Console.info(`>>> Installing '${uri}' from '${dir}' for qooxdoo version ${qooxdoo_version}`);
        }

        await this.__P_17_9(uri, undefined, dir, writeToManifest);
      },

      /**
       * Updates the data in the lockfile and (optionally) in the manifest
       * @param {String} uri The path to a library in a a repository
       * (e.g. qooxdoo/qxl.apiviewer or ergobyte/qookery/qookeryace)
       * @param {String} id
       *  The tag name of a release such as "v1.1.0" or a tree hash such as
       *  tree/892f44d1d1ae5d65c7dd99b18da6876de2f2a920
       * @param {String} download_path The path to the downloaded repository
       * @param {Boolean} writeToManifest
       *  Whether the library should be written to Manifest.json as a dependency
       * @return {Promise<void>}
       * @private
       */
      async __P_17_9(uri, id, download_path, writeToManifest) {
        let {
          repo_name,
          package_path
        } = uri ? this.__P_17_7(uri) : {
          repo_name: "",
          package_path: ""
        };
        const [manifestModel, lockfileModel] = await this._getConfigData();
        let library_path = path.join(download_path, package_path);
        let manifest_path = path.join(library_path, qx.tool.config.Manifest.config.fileName);

        if (!fs.existsSync(manifest_path)) {
          throw new qx.tool.utils.Utils.UserError(`No manifest file in '${library_path}'.`);
        }

        let {
          info
        } = qx.tool.utils.Json.parseJson(fs.readFileSync(manifest_path, "utf-8"));
        let local_path = path.relative(process.cwd(), library_path); // create entry

        let lib = {
          library_name: info.name,
          library_version: info.version,
          path: local_path
        };

        if (uri) {
          lib.uri = uri;
        } // remote library info


        if (repo_name) {
          lib.repo_name = repo_name;

          if (id) {
            lib.repo_tag = id;
          }
        } // do we already have an entry for the library that matches either the URI or the local path?


        let index = lockfileModel.getValue("libraries").findIndex(elem => uri && elem.uri === uri || !uri && elem.path === local_path);

        if (index >= 0) {
          lockfileModel.setValue(["libraries", index], lib);

          if (this.argv.verbose) {
            qx.tool.compiler.Console.info(`>>> Updating already existing lockfile entry for ${info.name}, ${info.version}, installed from '${uri ? uri : local_path}'.`);
          }
        } else {
          lockfileModel.transform("libraries", libs => libs.push(lib) && libs);

          if (this.argv.verbose) {
            qx.tool.compiler.Console.info(`>>> Added new lockfile entry for ${info.name}, ${info.version}, installed from '${uri ? uri : local_path}'.`);
          }
        }

        if (writeToManifest) {
          manifestModel.setValue(["requires", uri], "^" + info.version);
        }

        let appsInstalled = await this.__P_17_10(library_path);

        if (!appsInstalled && this.argv.verbose) {
          qx.tool.compiler.Console.info(`>>> No applications installed for ${uri}.`);
        }

        let depsInstalled = await this.__P_17_11(library_path);

        if (!depsInstalled && this.argv.verbose) {
          qx.tool.compiler.Console.info(`>>> No dependencies installed for ${uri}.`);
        }

        if (!this.argv.quiet) {
          qx.tool.compiler.Console.info(`Installed ${info.name} (${uri}, ${info.version})`);
        }
      },

      /**
       * Given a download path of a library, install its dependencies
       * @param {String} downloadPath
       * @return {Promise<Boolean>} Wether any libraries were installed
       */
      __P_17_11: async function (downloadPath) {
        let manifest_file = path.join(downloadPath, qx.tool.config.Manifest.config.fileName);
        let manifest = await qx.tool.utils.Json.loadJsonAsync(manifest_file);

        if (!manifest.requires) {
          if (this.argv.verbose) {
            qx.tool.compiler.Console.info(`>>> ${manifest_file} does not contain library dependencies.`);
          }

          return false;
        }

        if (this.argv.verbose) {
          qx.tool.compiler.Console.info(`>>> Installing libraries from ${manifest_file}.`);
        }

        return this.__P_17_3(manifest);
      },

      /**
       * Given a library's manifest data, install its dependencies
       * @param {Object} manifest
       * @return {Promise<Boolean>} Wether any libraries were installed
       */
      async __P_17_3(manifest) {
        for (let lib_uri of Object.getOwnPropertyNames(manifest.requires)) {
          let lib_range = manifest.requires[lib_uri];

          switch (lib_uri) {
            case "qooxdoo-compiler":
            case "@qooxdoo/compiler":
              break;

            case "qooxdoo-sdk":
            case "@qooxdoo/framework":
              {
                let qxVer = await this.getUserQxVersion();

                if (!semver.satisfies(qxVer, lib_range, {
                  loose: true
                }) && this.argv.ignore) {
                  throw new qx.tool.utils.Utils.UserError(`Library '${lib_uri}' needs @qooxdoo/framework version ${lib_range}, found ${qxVer}`);
                }

                break;
              }

            default:
              {
                // version info is semver range -> released version
                if (semver.validRange(lib_range)) {
                  let {
                    tag
                  } = this.__P_17_12(lib_uri, lib_range);

                  if (!tag) {
                    throw new qx.tool.utils.Utils.UserError(`No satisfying release found for ${lib_uri}@${lib_range}!`);
                  }

                  if (!(await this.isInstalled(lib_uri, tag))) {
                    await this.__P_17_5(lib_uri, tag, false);
                    break;
                  }

                  if (this.argv.verbose) {
                    qx.tool.compiler.Console.info(`>>> ${lib_uri}@${tag} is already installed.`);
                  }

                  break;
                } // treat version info as tree-ish identifier


                if (!(await this.isInstalled(lib_uri, lib_range))) {
                  try {
                    await this.__P_17_6(lib_uri, lib_range, false);
                    break;
                  } catch (e) {
                    throw new qx.tool.utils.Utils.UserError(`Could not install ${lib_uri}@${lib_range}: ${e.message}`);
                  }
                }

                if (this.argv.verbose) {
                  qx.tool.compiler.Console.info(`>>> ${lib_uri}@${lib_range} is already installed.`);
                }
              }
          }
        }

        return true;
      },

      /**
       * Given the URI of a library repo and a semver range, returns the highest
       * version compatible with the semver range and the release tag containing
       * this version.
       * @param {String} lib_uri The URI of the library
       * @param {String} lib_range The semver range
       * @return {Object} Returns an object with the keys "tag" and "version"
       * @private
       */
      __P_17_12(lib_uri, lib_range) {
        let {
          repo_name
        } = this.__P_17_7(lib_uri);

        let lib = this.getCache().repos.data[repo_name];

        if (!lib) {
          throw new qx.tool.utils.Utils.UserError(`${lib_uri} is not in the library registry!`);
        } // map version to release (this helps with prereleases)


        let version2release = {};
        let versionList = lib.releases.list.map(tag => {
          // all libraries in a package MUST have the same version
          let version = lib.releases.data[tag].manifests[0].info.version;
          version2release[version] = tag;
          return version;
        });
        let highestCompatibleVersion = semver.maxSatisfying(versionList, lib_range, {
          loose: true
        });
        return {
          version: highestCompatibleVersion,
          tag: version2release[highestCompatibleVersion]
        };
      },

      /**
       * Given the download path of a library, install its applications
       * todo use config API, use compile.js where it exists
       * @param {String} downloadPath
       * @return {Promise<Boolean>} Returns true if applications were installed
       */
      __P_17_10: async function (downloadPath) {
        let manifest = await qx.tool.utils.Json.loadJsonAsync(path.join(downloadPath, qx.tool.config.Manifest.config.fileName));

        if (!manifest.provides || !manifest.provides.application) {
          return false;
        }

        let manifestApp = manifest.provides.application;
        const compileConfigModel = await qx.tool.config.Compile.getInstance();

        if (!(await compileConfigModel.exists())) {
          qx.tool.compiler.Console.info(">>> Cannot install application " + (manifestApp.name || manifestApp["class"]) + " because compile.json does not exist (you must manually add it)");
          return false;
        }

        compileConfigModel.load();
        let app = compileConfigModel.getValue("applications").find(app => {
          if (manifestApp.name && app.name) {
            return manifestApp.name === app.name;
          }

          return manifestApp["class"] === app["class"];
        });

        if (!app) {
          compileConfigModel.transform("applications", apps => apps.concat([manifestApp]));
          app = manifestApp;
        }

        if (compileConfigModel.isDirty()) {
          await compileConfigModel.save();
        }

        if (this.argv.verbose) {
          qx.tool.compiler.Console.info(">>> Installed application " + (app.name || app["class"]));
        }

        return true;
      },

      /**
       * Download repos listed in the lockfile
       * @return {Promise<void>}
       * @private
       */
      __P_17_2: async function () {
        if (this.argv.verbose) {
          qx.tool.compiler.Console.info(`>>> Downloading libraries listed in ${qx.tool.config.Lockfile.config.fileName}...`);
        }

        let libraries = (await this.getLockfileData()).libraries;
        return qx.Promise.all(libraries.filter(lib => lib.repo_name && lib.repo_tag).map(lib => this.__P_17_8(lib.repo_name, lib.repo_tag)));
      },

      /**
       * Downloads a release
       * @return {Object} A map containing {release_data, download_path}
       * @param {String} repo_name The name of the repository
       * @param {String} treeish
       *  If prefixed by "v", the name of a release tag. Otherwise, arbitrary
       *  tree-ish expression (see https://help.github.com/en/articles/getting-permanent-links-to-files)
       * @param {Boolean} force Overwrite existing downloads
       * @return {{download_path:String}}
       */
      __P_17_8: async function (repo_name, treeish = null, force = false) {
        qx.core.Assert.assertNotNull(treeish, "Empty tree-ish id is not allowed");
        let url = `https://github.com/${repo_name}/archive/${treeish}.zip`; // create local directory

        let dir_name = `${repo_name}_${treeish}`.replace(/[\^./*?"'<>:]/g, "_");
        let parts = [process.cwd(), qx.tool.cli.commands.Package.cache_dir, dir_name];
        let dir_exists;
        let download_path = parts.reduce((prev, current) => {
          let dir = prev + path.sep + current;

          if (!fs.existsSync(dir)) {
            fs.mkdirSync(dir);
            dir_exists = false;
          } else {
            dir_exists = true;
          }

          return dir;
        }); // download zip

        if (!force && dir_exists) {
          if (this.argv.verbose) {
            qx.tool.compiler.Console.info(`>>> Repository '${repo_name}', '${treeish}' has already been downloaded to ${download_path}. To download again, execute 'qx clean'.`);
          }
        } else {
          if (this.argv.verbose) {
            qx.tool.compiler.Console.info(`>>> Downloading repository '${repo_name}', '${treeish}' from ${url} to ${download_path}`);
          }

          try {
            await download(url, download_path, {
              extract: true,
              strip: 1
            });
          } catch (e) {
            // remove download path so that failed downloads do not result in empty folder
            if (this.argv.verbose) {
              qx.tool.compiler.Console.info(`>>> Download failed: ${e.message}. Removing download folder.`);
            }

            rimraf.sync(download_path);
            qx.tool.compiler.Console.error(`Could not install '${repo_name}@${treeish}'. Use the --verbose flag for more information.`);
            process.exit(1);
          }
        }

        return {
          download_path,
          dir_exists
        };
      }
    }
  });
  qx.tool.cli.commands.package.Install.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2017 Zenesis Ltd
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * John Spackman (john.spackman@zenesis.com, @johnspackman)
  
  ************************************************************************ */
  const path = require("upath");

  const fs = require("fs");

  const async = require("async");

  const {
    promisify
  } = require("util");

  const child_process = require("child_process");
  /**
   * Utility methods
   */


  qx.Class.define("qx.tool.utils.Utils", {
    extend: qx.core.Object,
    statics: {
      /**
       * Creates a Promise which can be resolved/rejected externally - it has
       * the resolve/reject methods as properties
       *
       * @returns {Promise} a promise
       */
      newExternalPromise: function () {
        var resolve;
        var reject;
        var promise = new Promise((resolve_, reject_) => {
          resolve = resolve_;
          reject = reject_;
        });
        promise.resolve = resolve;
        promise.reject = reject;
        return promise;
      },
      promisifyThis: function promisifyThis(fn, self, ...args) {
        return new Promise((resolve, reject) => {
          args = args.slice();
          args.push(function (err, result) {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          });

          try {
            fn.apply(self, args);
          } catch (ex) {
            reject(ex);
          }
        });
      },

      /**
       * Error that can be thrown to indicate wrong user input  and which doesn't
       * need a stack trace
       *
       * @param {string} message
       * @returns {Error}
       */
      UserError: class extends Error {
        constructor(message) {
          super(message);
          this.name = "UserError";
          this.stack = null;
        }

      },

      /**
       * Formats the time in a human readable format, eg "1h 23m 45.678s"
       *
       * @param {number} millisec
       * @returns {string} formatted string
       */
      formatTime(millisec) {
        var seconds = Math.floor(millisec / 1000);
        var minutes = Math.floor(seconds / 60);
        var hours = Math.floor(minutes / 60);
        millisec %= 1000;
        var result = "";

        if (hours) {
          result += (hours > 9 ? hours : "0" + hours) + "h ";
        }

        if (hours || minutes) {
          result += (minutes > 9 ? minutes : "0" + minutes) + "m ";
        }

        if (seconds > 9 || !hours && !minutes) {
          result += seconds;
        } else if (hours || minutes) {
          result += "0" + seconds;
        }

        result += "." + (millisec > 99 ? "" : millisec > 9 ? "0" : "00") + millisec + "s";
        return result;
      },

      /**
       * Creates a dir
       * @param dir
       * @param cb
       */
      mkpath: function mkpath(dir, cb) {
        dir = path.normalize(dir);
        var segs = dir.split(path.sep);
        var made = "";
        async.eachSeries(segs, function (seg, cb) {
          if (made.length || !seg.length) {
            made += "/";
          }

          made += seg;
          fs.exists(made, function (exists) {
            if (!exists) {
              fs.mkdir(made, function (err) {
                if (err && err.code === "EEXIST") {
                  err = null;
                }

                cb(err);
              });
              return;
            }

            fs.stat(made, function (err, stat) {
              if (err) {
                cb(err);
              } else if (stat.isDirectory()) {
                cb(null);
              } else {
                cb(new Error("Cannot create " + made + " (in " + dir + ") because it exists and is not a directory", "ENOENT"));
              }
            });
          });
        }, function (err) {
          cb(err);
        });
      },

      /**
       * Creates the parent directory of a filename, if it does not already exist
       */
      mkParentPath: function mkParentPath(dir, cb) {
        var segs = dir.split(/[\\\/]/);
        segs.pop();

        if (!segs.length) {
          return cb && cb();
        }

        dir = segs.join(path.sep);
        return this.mkpath(dir, cb);
      },

      /**
       * Creates the parent directory of a filename, if it does not already exist
       *
       * @param {string} filename the filename to create the parent directory of
       *
       * @return {Promise?} the value
       */
      makeParentDir: function (filename) {
        const mkParentPath = promisify(this.mkParentPath).bind(this);
        return mkParentPath(filename);
      },

      /**
       * Creates a directory, if it does not exist, including all intermediate paths
       *
       * @param {string} filename the directory to create
       *
       * @return {Promise?} the value
       */
      makeDirs: function (filename) {
        const mkpath = promisify(this.mkpath);
        return mkpath(filename);
      },

      /**
       * Writable stream that keeps track of what the current line number is
       */
      LineCountingTransform: null,

      /**
       * Writable stream that strips out sourceMappingURL comments
       */
      StripSourceMapTransform: null,

      /**
       * Writable stream that keeps track of what's been written and can return
       * a copy as a string
       */
      ToStringWriteStream: null,

      /*  Function to test if an object is a plain object, i.e. is constructed
      **  by the built-in Object constructor and inherits directly from Object.prototype
      **  or null. Some built-in objects pass the test, e.g. Math which is a plain object
      **  and some host or exotic objects may pass also.
      **
      **  @param {} obj - value to test
      **  @returns {Boolean} true if passes tests, false otherwise
      *
      * @see https://stackoverflow.com/a/5878101/2979698
      */
      isPlainObject: function (obj) {
        // Basic check for Type object that's not null
        if (typeof obj == "object" && obj !== null) {
          // If Object.getPrototypeOf supported, use it
          if (typeof Object.getPrototypeOf == "function") {
            var proto = Object.getPrototypeOf(obj);
            return proto === Object.prototype || proto === null;
          } // Otherwise, use internal class
          // This should be reliable as if getPrototypeOf not supported, is pre-ES5


          return Object.prototype.toString.call(obj) == "[object Object]";
        } // Not an object


        return false;
      },

      /**
       * Runs the given command and returns an object containing information on the
       * `exitCode`, the `output`, potential `error`s, and additional `messages`.
       * @param {String} cwd The current working directory
       * @param {String} args One or more command line arguments, including the
       * command itself
       * @return {{exitCode: Number, output: String, error: *, messages: *}}
       */
      async runCommand(cwd, ...args) {
        let options = {};

        if (typeof cwd == "object") {
          options = cwd;
        } else {
          args = args.filter(value => {
            if (typeof value == "string") {
              return true;
            }

            if (!options) {
              options = value;
            }

            return false;
          });

          if (!options.cwd) {
            options.cwd = cwd;
          }

          if (!options.cmd) {
            options.cmd = args.shift();
          }

          if (!options.args) {
            options.args = args;
          }
        }

        return new Promise((resolve, reject) => {
          let env = process.env;

          if (options.env) {
            env = Object.assign({}, env);
            Object.assign(env, options.env);
          }

          let proc = child_process.spawn(options.cmd, options.args, {
            cwd: options.cwd,
            shell: true,
            env: env
          });
          let result = {
            exitCode: null,
            output: "",
            error: "",
            messages: null
          };
          proc.stdout.on("data", data => {
            data = data.toString().trim();
            console.log(data);
            result.output += data;
          });
          proc.stderr.on("data", data => {
            data = data.toString().trim();
            console.error(data);
            result.error += data;
          });
          proc.on("close", code => {
            result.exitCode = code;
            resolve(result);
          });
          proc.on("error", err => {
            reject(err);
          });
        });
      }

    },

    defer(statics) {
      const {
        Writable,
        Transform
      } = require("stream");

      class LineCountingTransform extends Transform {
        constructor(options) {
          super(options);
          this.__P_50_0 = 1;
        }

        _write(chunk, encoding, callback) {
          let str = chunk.toString();

          for (let i = 0; i < str.length; i++) {
            if (str[i] == "\n") {
              this.__P_50_0++;
            }
          }

          this.push(str);
          callback();
        }

        getLineNumber() {
          return this.__P_50_0;
        }

      }

      statics.LineCountingTransform = LineCountingTransform;

      class StripSourceMapTransform extends Transform {
        constructor(options) {
          super(options);
          this.__P_50_1 = "";
        }

        _transform(chunk, encoding, callback) {
          let str = this.__P_50_1 + chunk.toString();
          let pos = str.lastIndexOf("\n");

          if (pos > -1) {
            this.__P_50_1 = str.substring(pos);
            str = str.substring(0, pos);
          } else {
            this.__P_50_1 = str;
            str = "";
          }

          str = str.replace(/\n\/\/\#\s*sourceMappingURL=.*$/m, "");
          this.push(str);
          callback();
        }

        _flush(callback) {
          let str = this.__P_50_1;
          this.__P_50_1 = null;
          str = str.replace(/\n\/\/\#\s*sourceMappingURL=.*$/m, "");
          this.push(str);
          callback();
        }

      }

      statics.StripSourceMapTransform = StripSourceMapTransform;

      class ToStringWriteStream extends Writable {
        constructor(dest, options) {
          super(options);
          this.__P_50_2 = dest;
          this.__P_50_3 = "";
        }

        _write(chunk, encoding, callback) {
          this.__P_50_3 += chunk.toString();

          if (this.__P_50_2) {
            this.__P_50_2.write(chunk, encoding, callback);
          } else if (callback) {
            callback();
          }
        }

        toString() {
          return this.__P_50_3;
        }

      }

      statics.ToStringWriteStream = ToStringWriteStream;
    }

  });
  qx.tool.utils.Utils.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.tool.cli.api.AbstractApi": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
   *
   *    qooxdoo-compiler - node.js based replacement for the Qooxdoo python
   *    toolchain
   *
   *    https://github.com/qooxdoo/qooxdoo-compiler
   *
   *    Copyright:
   *      2011-2019 Zenesis Limited, http://www.zenesis.com
   *
   *    License:
   *      MIT: https://opensource.org/licenses/MIT
   *
   *      This software is provided under the same licensing terms as Qooxdoo,
   *      please see the LICENSE file in the Qooxdoo project's top-level directory
   *      for details.
   *
   *    Authors:
   *      * John Spackman (john.spackman@zenesis.com, @johnspackman)
   *
   * *********************************************************************** */

  /**
   * Provides an API for an individual library
   */
  qx.Class.define("qx.tool.cli.api.LibraryApi", {
    extend: qx.tool.cli.api.AbstractApi,
    properties: {
      /** The Compiler API */
      compilerApi: {
        nullable: false,
        check: "qx.tool.cli.api.CompilerApi"
      }
    },
    members: {
      /**
       * Called to load any library-specific configuration and update the compilerConfig
       * 
       * @overridden
       */
      async load() {
        return qx.tool.cli.api.LibraryApi.prototype.load.base.call(this);
      },

      /**
       * Called after all libraries have been loaded and added to the compilation data
       */
      async afterLibrariesLoaded() {// Nothing
      }

    }
  });
  qx.tool.cli.api.LibraryApi.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.lang.Type": {
        "construct": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
   *
   *    qooxdoo-compiler - node.js based replacement for the Qooxdoo python
   *    toolchain
   *
   *    https://github.com/qooxdoo/qooxdoo-compiler
   *
   *    Copyright:
   *      2011-2019 Zenesis Limited, http://www.zenesis.com
   *
   *    License:
   *      MIT: https://opensource.org/licenses/MIT
   *
   *      This software is provided under the same licensing terms as Qooxdoo,
   *      please see the LICENSE file in the Qooxdoo project's top-level directory
   *      for details.
   *
   *    Authors:
   *      * John Spackman (john.spackman@zenesis.com, @johnspackman)
   *
   * *********************************************************************** */

  /**
   * Basic helper base class for matching files
   */
  qx.Class.define("qx.tool.compiler.resources.AbstractMatcher", {
    extend: qx.core.Object,
    type: "abstract",

    /**
     * Constructor
     * 
     * @param match {Array[String]|String|RegEx?} the reg ex to match filenames, or the extension, 
     * or an array of extensions
     */
    construct: function (match) {
      qx.core.Object.constructor.call(this);

      if (match) {
        if (qx.lang.Type.isArray(match)) {
          match = match.map(elem => {
            if (elem[0] != ".") {
              elem = "." + elem;
            }

            return elem;
          });

          this.__P_33_0 = filename => match.some(elem => filename.endsWith(elem));
        } else if (typeof match == "string") {
          if (match[0] != ".") {
            match = "." + match;
          }

          this.__P_33_0 = filename => filename.endsWith(match);
        } else {
          this.__P_33_0 = filename => match.test(filename);
        }
      }
    },
    members: {
      __P_33_0: null,

      /**
       * Called to determine whether this handler is appropriate for the given filename;
       * default implementation is to check the RegEx passed to the constructor
       */
      matches: function (filename) {
        return this.__P_33_0 !== null && this.__P_33_0(filename);
      }
    }
  });
  qx.tool.compiler.resources.AbstractMatcher.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.tool.compiler.resources.AbstractMatcher": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
   *
   *    qooxdoo-compiler - node.js based replacement for the Qooxdoo python
   *    toolchain
   *
   *    https://github.com/qooxdoo/qooxdoo-compiler
   *
   *    Copyright:
   *      2011-2017 Zenesis Limited, http://www.zenesis.com
   *
   *    License:
   *      MIT: https://opensource.org/licenses/MIT
   *
   *      This software is provided under the same licensing terms as Qooxdoo,
   *      please see the LICENSE file in the Qooxdoo project's top-level directory
   *      for details.
   *
   *    Authors:
   *      * John Spackman (john.spackman@zenesis.com, @johnspackman)
   *
   * *********************************************************************** */

  /**
   * Instances of ResourceConverter are used by the resource manager to transfer resources into
   * the target output, where they require something more than just copying (eg SCSS compilation)
   */
  qx.Class.define("qx.tool.compiler.resources.ResourceConverter", {
    extend: qx.tool.compiler.resources.AbstractMatcher,
    type: "abstract",
    members: {
      /**
       * Allows the converter to decide to not copy the resource at all
       */
      isDoNotCopy(filename) {
        return false;
      },

      /**
       * Detects whether the file needs to be recompiled/coverted/analysed/ etc, and is done after
       * checks determine whether the file datetime stamp indicate it's necessary
       * 
       * @param target {Target} the target
       * @param asset {Asset} the asset to copy
       * @param srcFilename {String} full path to the file
       * @param destFilename {String} full path to the destination file
       * @param isThemeFile {Booelan} true if the file is a theme file (as opposed to a normal resource file)
       * 
       * @return {Boolean}
       */
      async needsConvert(target, asset, srcFilename, destFilename, isThemeFile) {
        return false;
      },

      /**
       * Returns the destination filename, or null if default is to be used
       * 
       * @param target {Target} the target
       * @param asset {Asset} the asset to copy
       * @return {String?} full path to the file
       */
      getDestFilename(target, asset) {
        return null;
      },

      /**
       * Allows a file to be recompiled/coverted/analysed/ etc; must return a Promise which resolves
       * when complete.  Data can be stored in the resource database by modifying the fileInfo
       * 
       * @param target {Target} the target
       * @param asset {Asset} the asset to copy
       * @param srcFilename {String} full path to the file
       * @param destFilename {String} full path to the destination file
       * @param isThemeFile {Boolean} whether the file is in a theme
       * @return {String[]} list of filenames that are required for the compilation (dependencies); may be null
       */
      async compile(target, asset, srcFilename, destFilename, isThemeFile) {
        throw new Error("No implementation for " + this.classname + ".convert");
      }

    }
  });
  qx.tool.compiler.resources.ResourceConverter.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.tool.utils.Promisify": {
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.tool.compiler.resources.ResourceConverter": {
        "construct": true,
        "require": true
      },
      "qx.tool.utils.files.Utils": {},
      "qx.tool.compiler.resources.ScssFile": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
   *
   *    qooxdoo-compiler - node.js based replacement for the Qooxdoo python
   *    toolchain
   *
   *    https://github.com/qooxdoo/qooxdoo-compiler
   *
   *    Copyright:
   *      2011-2017 Zenesis Limited, http://www.zenesis.com
   *
   *    License:
   *      MIT: https://opensource.org/licenses/MIT
   *
   *      This software is provided under the same licensing terms as Qooxdoo,
   *      please see the LICENSE file in the Qooxdoo project's top-level directory
   *      for details.
   *
   *    Authors:
   *      * Henner Kollmann (henner.kollmann@gmx.de)
   *
   * *********************************************************************** */
  var path = require("upath");

  var sass = require("node-sass");

  const fs = qx.tool.utils.Promisify.fs;
  qx.Class.define("qx.tool.compiler.resources.ScssConverter", {
    extend: qx.tool.compiler.resources.ResourceConverter,
    construct: function () {
      qx.tool.compiler.resources.ResourceConverter.constructor.call(this);
    },
    members: {
      matches(filename) {
        filename = path.basename(filename);
        return filename[0] != '_' && filename.endsWith(".scss");
      },

      getDestFilename(target, asset) {
        let filename;

        if (!qx.tool.compiler.resources.ScssConverter.isNewCompiler()) {
          filename = path.join(target.getOutputDir(), "resource", asset.getFilename().replace(/\bscss\b/g, "css"));
        } else {
          filename = path.join(target.getOutputDir(), "resource", asset.getFilename().replace(/\.scss$/, ".css"));
        }

        return filename;
      },

      async convert(target, asset, srcFilename, destFilename, isThemeFile) {
        if (qx.tool.compiler.resources.ScssConverter.COPY_ORIGINAL_FILES) {
          let copyFilename = path.join(target.getOutputDir(), "resource", asset.getFilename());
          await qx.tool.utils.files.Utils.copyFile(srcFilename, copyFilename);
        }

        if (!qx.tool.compiler.resources.ScssConverter.isNewCompiler()) {
          return this.legacyMobileSassConvert(target, asset, srcFilename, destFilename);
        }

        let scssFile = new qx.tool.compiler.resources.ScssFile(target, asset.getLibrary(), asset.getFilename());
        scssFile.setThemeFile(isThemeFile);
        return scssFile.compile(destFilename);
      },

      /**
       * The traditional SASS compilation; it does not use the newer advanced SASS compiler and so
       * does not support relative `url()` paths and automatically has Qooxdoo SASS built in.
       */
      async legacyMobileSassConvert(target, asset, srcFilename, destFilename) {
        if (qx.tool.compiler.resources.ScssConverter.COPY_ORIGINAL_FILES) {
          let copyFilename = path.join(target.getOutputDir(), "resource", asset.getFilename());
          await qx.tool.utils.files.Utils.copyFile(srcFilename, copyFilename);
        }

        let qooxdooPath = target.getAnalyser().getQooxdooPath();
        let data = await fs.readFileAsync(srcFilename, "utf8");

        if (!data || !data.trim()) {
          await fs.writeFileAsync(destFilename, "");
          await fs.unlinkAsync(destFilename + ".map");
        } else {
          let sassOptions = {
            data: data,
            includePaths: [path.dirname(srcFilename), path.join(qooxdooPath, "source/resource/qx/mobile/scss"), path.join(qooxdooPath, "source/resource/qx/scss")],
            outFile: destFilename,
            sourceMap: destFilename + ".map",
            outputStyle: "compressed"
          };
          let result = await qx.tool.utils.Promisify.call(cb => sass.render(sassOptions, (err, result) => {
            if (err) {
              cb(new Error(err.message));
            } else {
              cb(null, result);
            }
          }));
          await fs.writeFileAsync(destFilename, result.css);
          await fs.writeFileAsync(destFilename + ".map", result.map);
        }
      }

    },
    statics: {
      /** @type {Boolean} Default is true for the API, the CLI will set this to null */
      USE_V6_COMPILER: true,

      /** @type {Boolean} Whether to copy .scss files */
      COPY_ORIGINAL_FILES: false,

      isNewCompiler() {
        if (qx.tool.compiler.resources.ScssConverter.USE_V6_COMPILER === null) {
          console.warn("DEPRECATED: Using the Qooxdoo v5 style of SASS Compilation; this is backwards compatible but the default will change in v7 to use the new style (see https://git.io/JfTPV for details, and how to disable this warning).");
          qx.tool.compiler.resources.ScssConverter.USE_V6_COMPILER = false;
        }

        return qx.tool.compiler.resources.ScssConverter.USE_V6_COMPILER;
      }

    }
  });
  qx.tool.compiler.resources.ScssConverter.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.bom.client.Engine": {},
      "qx.core.Environment": {
        "defer": "runtime"
      }
    },
    "environment": {
      "provided": ["io.maxrequests", "io.ssl", "io.xhr"],
      "required": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Carsten Lergenmueller (carstenl)
       * Fabian Jakobs (fbjakobs)
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * Determines browser-dependent information about the transport layer.
   *
   * This class is used by {@link qx.core.Environment} and should not be used
   * directly. Please check its class comment for details how to use it.
   *
   * @internal
   */
  qx.Bootstrap.define("qx.bom.client.Transport", {
    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics: {
      /**
       * Returns the maximum number of parallel requests the current browser
       * supports per host addressed.
       *
       * Note that this assumes one connection can support one request at a time
       * only. Technically, this is not correct when pipelining is enabled (which
       * it currently is only for IE 8 and Opera). In this case, the number
       * returned will be too low, as one connection supports multiple pipelined
       * requests. This is accepted for now because pipelining cannot be
       * detected from JavaScript and because modern browsers have enough
       * parallel connections already - it's unlikely an app will require more
       * than 4 parallel XMLHttpRequests to one server at a time.
       *
       * @internal
       * @return {Integer} Maximum number of parallel requests
       */
      getMaxConcurrentRequestCount: function () {
        var maxConcurrentRequestCount; // Parse version numbers.

        var versionParts = qx.bom.client.Engine.getVersion().split(".");
        var versionMain = 0;
        var versionMajor = 0;
        var versionMinor = 0; // Main number

        if (versionParts[0]) {
          versionMain = versionParts[0];
        } // Major number


        if (versionParts[1]) {
          versionMajor = versionParts[1];
        } // Minor number


        if (versionParts[2]) {
          versionMinor = versionParts[2];
        } // IE 8 gives the max number of connections in a property
        // see http://msdn.microsoft.com/en-us/library/cc197013(VS.85).aspx


        if (window.maxConnectionsPerServer) {
          maxConcurrentRequestCount = window.maxConnectionsPerServer;
        } else if (qx.bom.client.Engine.getName() == "opera") {
          // Opera: 8 total
          // see http://operawiki.info/HttpProtocol
          maxConcurrentRequestCount = 8;
        } else if (qx.bom.client.Engine.getName() == "webkit") {
          // Safari: 4
          // http://www.stevesouders.com/blog/2008/03/20/roundup-on-parallel-connections/
          // Bug #6917: Distinguish Chrome from Safari, Chrome has 6 connections
          //       according to
          //      http://stackoverflow.com/questions/561046/how-many-concurrent-ajax-xmlhttprequest-requests-are-allowed-in-popular-browser
          maxConcurrentRequestCount = 4;
        } else if (qx.bom.client.Engine.getName() == "gecko" && (versionMain > 1 || versionMain == 1 && versionMajor > 9 || versionMain == 1 && versionMajor == 9 && versionMinor >= 1)) {
          // FF 3.5 (== Gecko 1.9.1): 6 Connections.
          // see  http://gemal.dk/blog/2008/03/18/firefox_3_beta_5_will_have_improved_connection_parallelism/
          maxConcurrentRequestCount = 6;
        } else {
          // Default is 2, as demanded by RFC 2616
          // see http://blogs.msdn.com/ie/archive/2005/04/11/407189.aspx
          maxConcurrentRequestCount = 2;
        }

        return maxConcurrentRequestCount;
      },

      /**
       * Checks whether the app is loaded with SSL enabled which means via https.
       *
       * @internal
       * @return {Boolean} <code>true</code>, if the app runs on https
       */
      getSsl: function () {
        return window.location.protocol === "https:";
      },

      /**
       * Checks what kind of XMLHttpRequest object the browser supports
       * for the current protocol, if any.
       *
       * The standard XMLHttpRequest is preferred over ActiveX XMLHTTP.
       *
       * @internal
       * @return {String}
       *  <code>"xhr"</code>, if the browser provides standard XMLHttpRequest.<br/>
       *  <code>"activex"</code>, if the browser provides ActiveX XMLHTTP.<br/>
       *  <code>""</code>, if there is not XHR support at all.
       */
      getXmlHttpRequest: function () {
        // Standard XHR can be disabled in IE's security settings,
        // therefore provide ActiveX as fallback. Additionally,
        // standard XHR in IE7 is broken for file protocol.
        var supports = window.ActiveXObject ? function () {
          if (window.location.protocol !== "file:") {
            try {
              new window.XMLHttpRequest();
              return "xhr";
            } catch (noXhr) {}
          }

          try {
            new window.ActiveXObject("Microsoft.XMLHTTP");
            return "activex";
          } catch (noActiveX) {}
        }() : function () {
          try {
            new window.XMLHttpRequest();
            return "xhr";
          } catch (noXhr) {}
        }();
        return supports || "";
      }
    },
    defer: function (statics) {
      qx.core.Environment.add("io.maxrequests", statics.getMaxConcurrentRequestCount);
      qx.core.Environment.add("io.ssl", statics.getSsl);
      qx.core.Environment.add("io.xhr", statics.getXmlHttpRequest);
    }
  });
  qx.bom.client.Transport.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.bom.client.Device": {},
      "qx.bom.client.Engine": {
        "defer": "load",
        "require": true
      },
      "qx.bom.client.Transport": {
        "defer": "load",
        "require": true
      },
      "qx.util.LibraryManager": {
        "defer": "runtime"
      }
    },
    "environment": {
      "provided": [],
      "required": {
        "engine.name": {
          "className": "qx.bom.client.Engine",
          "defer": true
        },
        "io.ssl": {
          "className": "qx.bom.client.Transport",
          "defer": true
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Fabian Jakobs (fjakobs)
  
  ************************************************************************ */

  /**
   * Contains information about images (size, format, clipping, ...) and
   * other resources like CSS files, local data, ...
   */
  qx.Class.define("qx.util.ResourceManager", {
    extend: qx.core.Object,
    type: "singleton",

    /*
    *****************************************************************************
       CONSTRUCTOR
    *****************************************************************************
    */
    construct: function () {
      qx.core.Object.constructor.call(this);
    },

    /*
    *****************************************************************************
       STATICS
    *****************************************************************************
    */
    statics: {
      /** @type {Map} the shared image registry */
      __P_65_0: qx.$$resources || {},

      /** @type {Map} prefix per library used in HTTPS mode for IE */
      __P_65_1: {}
    },

    /*
    *****************************************************************************
       MEMBERS
    *****************************************************************************
    */
    members: {
      /**
       * Detects whether there is a high-resolution image available.
       * A high-resolution image is assumed to have the same file name as
       * the parameter source, but with a pixelRatio identifier before the file
       * extension, like "@2x".
       * Medium Resolution: "example.png", high-resolution: "example@2x.png"
       *
       * @param lowResImgSrc {String} source of the low resolution image.
       * @param factor {Number} Factor to find the right image. If not set calculated by getDevicePixelRatio()
       * @return {String|Boolean} If a high-resolution image source.
       */
      findHighResolutionSource: function (lowResImgSrc, factor) {
        var pixelRatioCandidates = ["3", "2", "1.5"]; // Calculate the optimal ratio, based on the rem scale factor of the application and the device pixel ratio.

        if (!factor) {
          factor = parseFloat(qx.bom.client.Device.getDevicePixelRatio().toFixed(2));
        }

        if (factor <= 1) {
          return false;
        }

        var i = pixelRatioCandidates.length;

        while (i > 0 && factor > pixelRatioCandidates[--i]) {}

        var hiResImgSrc;
        var k; // Search for best img with a higher resolution.

        for (k = i; k >= 0; k--) {
          hiResImgSrc = this.getHighResolutionSource(lowResImgSrc, pixelRatioCandidates[k]);

          if (hiResImgSrc) {
            return hiResImgSrc;
          }
        } // Search for best img with a lower resolution.


        for (k = i + 1; k < pixelRatioCandidates.length; k++) {
          hiResImgSrc = this.getHighResolutionSource(lowResImgSrc, pixelRatioCandidates[k]);

          if (hiResImgSrc) {
            return hiResImgSrc;
          }
        }

        return null;
      },

      /**
       * Returns the source name for the high-resolution image based on the passed
       * parameters.
       * @param source {String} the source of the medium resolution image.
       * @param pixelRatio {Number} the pixel ratio of the high-resolution image.
       * @return {String} the high-resolution source name or null if no source could be found.
       */
      getHighResolutionSource: function (source, pixelRatio) {
        var fileExtIndex = source.lastIndexOf('.');

        if (fileExtIndex > -1) {
          var pixelRatioIdentifier = "@" + pixelRatio + "x";
          var candidate = source.slice(0, fileExtIndex) + pixelRatioIdentifier + source.slice(fileExtIndex);

          if (this.has(candidate)) {
            return candidate;
          }
        }

        return null;
      },

      /**
       * Get all known resource IDs.
       *
       * @param pathfragment{String|null|undefined} an optional path fragment to check against with id.indexOf(pathfragment)
       * @return {Array|null} an array containing the IDs or null if the registry is not initialized
       */
      getIds: function (pathfragment) {
        var registry = qx.util.ResourceManager.__P_65_0;

        if (!registry) {
          return null;
        }

        return Object.keys(registry).filter(function (key) {
          return !pathfragment || key.indexOf(pathfragment) != -1;
        });
      },

      /**
       * Whether the registry has information about the given resource.
       *
       * @param id {String} The resource to get the information for
       * @return {Boolean} <code>true</code> when the resource is known.
       */
      has: function (id) {
        return !!qx.util.ResourceManager.__P_65_0[id];
      },

      /**
       * Get information about an resource.
       *
       * @param id {String} The resource to get the information for
       * @return {Array} Registered data or <code>null</code>
       */
      getData: function (id) {
        return qx.util.ResourceManager.__P_65_0[id] || null;
      },

      /**
       * Returns the width of the given resource ID,
       * when it is not a known image <code>0</code> is
       * returned.
       *
       * @param id {String} Resource identifier
       * @return {Integer} The image width, maybe <code>null</code> when the width is unknown
       */
      getImageWidth: function (id) {
        var size;

        if (id && id.startsWith("@")) {
          var part = id.split("/");
          size = parseInt(part[2], 10);

          if (size) {
            id = part[0] + "/" + part[1];
          }
        }

        var entry = qx.util.ResourceManager.__P_65_0[id]; // [ width, height, codepoint ]

        if (size && entry) {
          var width = Math.ceil(size / entry[1] * entry[0]);
          return width;
        }

        return entry ? entry[0] : null;
      },

      /**
       * Returns the height of the given resource ID,
       * when it is not a known image <code>0</code> is
       * returned.
       *
       * @param id {String} Resource identifier
       * @return {Integer} The image height, maybe <code>null</code> when the height is unknown
       */
      getImageHeight: function (id) {
        if (id && id.startsWith("@")) {
          var part = id.split("/");
          var size = parseInt(part[2], 10);

          if (size) {
            return size;
          }
        }

        var entry = qx.util.ResourceManager.__P_65_0[id];
        return entry ? entry[1] : null;
      },

      /**
       * Returns the format of the given resource ID,
       * when it is not a known image <code>null</code>
       * is returned.
       *
       * @param id {String} Resource identifier
       * @return {String} File format of the image
       */
      getImageFormat: function (id) {
        if (id && id.startsWith("@")) {
          return "font";
        }

        var entry = qx.util.ResourceManager.__P_65_0[id];
        return entry ? entry[2] : null;
      },

      /**
       * Returns the format of the combined image (png, gif, ...), if the given
       * resource identifier is an image contained in one, or the empty string
       * otherwise.
       *
       * @param id {String} Resource identifier
       * @return {String} The type of the combined image containing id
       */
      getCombinedFormat: function (id) {
        var clippedtype = "";
        var entry = qx.util.ResourceManager.__P_65_0[id];
        var isclipped = entry && entry.length > 4 && typeof entry[4] == "string" && this.constructor.__P_65_0[entry[4]];

        if (isclipped) {
          var combId = entry[4];
          var combImg = this.constructor.__P_65_0[combId];
          clippedtype = combImg[2];
        }

        return clippedtype;
      },

      /**
       * Converts the given resource ID to a full qualified URI
       *
       * @param id {String} Resource ID
       * @return {String} Resulting URI
       */
      toUri: function (id) {
        if (id == null) {
          return id;
        }

        var entry = qx.util.ResourceManager.__P_65_0[id];

        if (!entry) {
          return id;
        }

        if (typeof entry === "string") {
          var lib = entry;
        } else {
          var lib = entry[3]; // no lib reference
          // may mean that the image has been registered dynamically

          if (!lib) {
            return id;
          }
        }

        var urlPrefix = "";

        if (qx.core.Environment.get("engine.name") == "mshtml" && qx.core.Environment.get("io.ssl")) {
          urlPrefix = qx.util.ResourceManager.__P_65_1[lib];
        }

        return urlPrefix + qx.util.LibraryManager.getInstance().get(lib, "resourceUri") + "/" + id;
      },

      /**
       * Construct a data: URI for an image resource.
       *
       * Constructs a data: URI for a given resource id, if this resource is
       * contained in a base64 combined image. If this is not the case (e.g.
       * because the combined image has not been loaded yet), returns the direct
       * URI to the image file itself.
       *
       * @param resid {String} resource id of the image
       * @return {String} "data:" or "http:" URI
       */
      toDataUri: function (resid) {
        var resentry = this.constructor.__P_65_0[resid];
        var combined = resentry ? this.constructor.__P_65_0[resentry[4]] : null;
        var uri;

        if (combined) {
          var resstruct = combined[4][resid];
          uri = "data:image/" + resstruct["type"] + ";" + resstruct["encoding"] + "," + resstruct["data"];
        } else {
          uri = this.toUri(resid);
        }

        return uri;
      },

      /**
       * Checks whether a given resource id for an image is a font handle.
       *
       * @param resid {String} resource id of the image
       * @return {Boolean} True if it's a font URI
       */
      isFontUri: function (resid) {
        return resid ? resid.startsWith("@") : false;
      }
    },
    defer: function (statics) {
      if (qx.core.Environment.get("engine.name") == "mshtml") {
        // To avoid a "mixed content" warning in IE when the application is
        // delivered via HTTPS a prefix has to be added. This will transform the
        // relative URL to an absolute one in IE.
        // Though this warning is only displayed in conjunction with images which
        // are referenced as a CSS "background-image", every resource path is
        // changed when the application is served with HTTPS.
        if (qx.core.Environment.get("io.ssl")) {
          for (var lib in qx.$$libraries) {
            var resourceUri;

            if (qx.util.LibraryManager.getInstance().get(lib, "resourceUri")) {
              resourceUri = qx.util.LibraryManager.getInstance().get(lib, "resourceUri");
            } else {
              // default for libraries without a resourceUri set
              statics.__P_65_1[lib] = "";
              continue;
            }

            var href; //first check if there is base url set

            var baseElements = document.getElementsByTagName("base");

            if (baseElements.length > 0) {
              href = baseElements[0].href;
            } // It is valid to to begin a URL with "//" so this case has to
            // be considered. If the to resolved URL begins with "//" the
            // manager prefixes it with "https:" to avoid any problems for IE


            if (resourceUri.match(/^\/\//) != null) {
              statics.__P_65_1[lib] = window.location.protocol;
            } // If the resourceUri begins with a single slash, include the current
            // hostname
            else if (resourceUri.match(/^\//) != null) {
                if (href) {
                  statics.__P_65_1[lib] = href;
                } else {
                  statics.__P_65_1[lib] = window.location.protocol + "//" + window.location.host;
                }
              } // If the resolved URL begins with "./" the final URL has to be
              // put together using the document.URL property.
              // IMPORTANT: this is only applicable for the source version
              else if (resourceUri.match(/^\.\//) != null) {
                  var url = document.URL;
                  statics.__P_65_1[lib] = url.substring(0, url.lastIndexOf("/") + 1);
                } else if (resourceUri.match(/^http/) != null) {
                  // Let absolute URLs pass through
                  statics.__P_65_1[lib] = "";
                } else {
                  if (!href) {
                    // check for parameters with URLs as value
                    var index = window.location.href.indexOf("?");

                    if (index == -1) {
                      href = window.location.href;
                    } else {
                      href = window.location.href.substring(0, index);
                    }
                  }

                  statics.__P_65_1[lib] = href.substring(0, href.lastIndexOf("/") + 1);
                }
          }
        }
      }
    }
  });
  qx.util.ResourceManager.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2012 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Author:
       * Daniel Wagner (danielwagner)
  
  ************************************************************************ */

  /**
   * Provides read/write access to library-specific information such as
   * source/resource URIs.
   */
  qx.Class.define("qx.util.LibraryManager", {
    extend: qx.core.Object,
    type: "singleton",
    statics: {
      /** @type {Map} The libraries used by this application */
      __P_83_0: qx.$$libraries || {}
    },
    members: {
      /**
       * Checks whether the library with the given namespace is known to the
       * application.
       * @param namespace {String} The library's namespace
       * @return {Boolean} <code>true</code> if the given library is known
       */
      has: function (namespace) {
        return !!qx.util.LibraryManager.__P_83_0[namespace];
      },

      /**
       * Returns the value of an attribute of the given library
       * @param namespace {String} The library's namespace
       * @param key {String} Name of the attribute
       * @return {var|null} The attribute's value or <code>null</code> if it's not defined
       */
      get: function (namespace, key) {
        return qx.util.LibraryManager.__P_83_0[namespace][key] ? qx.util.LibraryManager.__P_83_0[namespace][key] : null;
      },

      /**
       * Sets an attribute on the given library.
       *
       * @param namespace {String} The library's namespace
       * @param key {String} Name of the attribute
       * @param value {var} Value of the attribute
       */
      set: function (namespace, key, value) {
        qx.util.LibraryManager.__P_83_0[namespace][key] = value;
      }
    }
  });
  qx.util.LibraryManager.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.tool.config.Abstract": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2019 The qooxdoo developers
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Boulanger (info@bibliograph.org, @cboulanger)
  
  ************************************************************************ */

  /**
   * A model for the Manifest.json file
   */
  qx.Class.define("qx.tool.config.Manifest", {
    extend: qx.tool.config.Abstract,
    type: "singleton",
    statics: {
      config: {
        fileName: "Manifest.json",
        version: "1.0.0"
      }
    },
    construct: function () {
      qx.tool.config.Abstract.constructor.call(this, qx.tool.config.Manifest.config);
    }
  });
  qx.tool.config.Manifest.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.tool.utils.Json": {},
      "qx.tool.utils.Utils": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2018 Zenesis Ltd
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * John Spackman (john.spackman@zenesis.com, @johnspackman)
  
  ************************************************************************ */
  const path = require("path");
  /**
   * Controls access to the local configuration
   */


  qx.Class.define("qx.tool.cli.ConfigDb", {
    extend: qx.core.Object,
    construct: function () {
      qx.core.Object.constructor.call(this);
      this.__P_4_0 = {};
    },
    properties: {
      path: {
        nullable: false,
        check: "String",
        apply: "_applyPath"
      }
    },
    members: {
      __P_4_1: null,
      __P_4_0: null,

      /**
       * Apply for path property
       * @returns
       */
      _applyPath: async function (value, oldValue) {
        this.__P_4_1 = {};
      },

      /**
       * Loads the configuration
       */
      load: async function () {
        this.__P_4_1 = (await qx.tool.utils.Json.loadJsonAsync(this.getPath())) || {};
      },

      /**
       * Saves the configuration
       */
      save: async function () {
        await qx.tool.utils.Utils.makeParentDir(this.getPath());
        await qx.tool.utils.Json.saveJsonAsync(this.getPath(), this.__P_4_1);
      },

      /**
       * Sets a temporary override
       */
      setOverride(key, value) {
        if (value === undefined) {
          delete this.__P_4_0[key];
        } else {
          this.__P_4_0[key] = value;
        }
      },

      /**
       * Returns the database root.  If the `path` parameter is provided, this will try and locate it;
       * if `defaultValue` is provided then it will create the object and also any intermediate objects
       * along the way.  If `path` is not returned, then the root object is returned
       *
       * @param path {String?} optional path into the database; note array subscripts are not supported
       * @param defaultValue {Object?} optional value to assign if it does not exist.
       * @return {Object?} the value
       */
      db: function (path, defaultValue) {
        if (path) {
          let override = this.__P_4_0[path];

          if (override) {
            return override;
          }

          var result = this.__P_4_1;
          var segs = path.split(".");

          for (var i = 0; i < segs.length; i++) {
            let seg = segs[i];
            var tmp = result[seg];

            if (tmp === undefined) {
              if (defaultValue === undefined) {
                return undefined;
              }

              if (i == segs.length - 1) {
                tmp = result[seg] = defaultValue;
              } else {
                tmp = result[seg] = {};
              }
            }

            result = tmp;
          }

          return result;
        }

        return this.__P_4_1;
      }
    },
    defer: function (statics) {
      statics.__P_4_2 = path.join(require("os").homedir(), ".qooxdoo/");
    },
    statics: {
      /** Singleton default instance */
      __P_4_3: null,

      /** The directory where config files (any any other temporary/cached data) is kept */
      __P_4_2: null,

      /**
       * Gets the default instance of ConfigDb, loaded with the global config
       *
       * @returns {ConfigDb}
       */
      getInstance: async function () {
        let db = qx.tool.cli.ConfigDb.__P_4_3;

        if (!db) {
          db = qx.tool.cli.ConfigDb.__P_4_3 = new qx.tool.cli.ConfigDb();
          db.setPath(path.join(qx.tool.cli.ConfigDb.getDirectory(), "config.json"));
          await db.load();
        }

        return db;
      },

      /**
       * Returns the local directory, where cache and configuration are kept
       */
      getDirectory: function () {
        return this.__P_4_2;
      },

      /**
       * Wrapper for non-static version of db
       *
       * @see qx.tool.cli.ConfigDb.db
       */
      db: function (path, defaultValue) {
        return qx.tool.cli.ConfigDb.getInstance().db(path, defaultValue);
      }
    }
  });
  qx.tool.cli.ConfigDb.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.tool.utils.Promisify": {
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.tool.cli.commands.Package": {
        "require": true
      },
      "qx.tool.cli.ConfigDb": {},
      "qx.tool.compiler.Console": {},
      "qx.tool.cli.commands.package.Upgrade": {},
      "qx.tool.config.Registry": {},
      "qx.tool.config.Abstract": {},
      "qx.tool.config.Manifest": {},
      "qx.lang.Type": {},
      "qx.tool.compiler.Version": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2017 Christian Boulanger
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Boulanger (info@bibliograph.org, @cboulanger)
  
  ************************************************************************ */
  const process = require("process");

  const path = require("upath");

  const semver = require("semver");

  const fs = qx.tool.utils.Promisify.fs;
  /**
   * Installs a package
   */

  qx.Class.define("qx.tool.cli.commands.package.Migrate", {
    extend: qx.tool.cli.commands.Package,
    statics: {
      /**
       * Flag to prevent recursive call to process()
       */
      migrationInProcess: false,

      /**
       * Return the Yargs configuration object
       * @return {{}}
       */
      getYargsCommand: function () {
        return {
          command: "migrate",
          describe: "migrates the package system to a newer version.",
          builder: {
            "verbose": {
              alias: "v",
              describe: "Verbose logging"
            },
            "quiet": {
              alias: "q",
              describe: "No output"
            }
          }
        };
      }
    },
    members: {
      /**
       * Announces or applies a migration
       * @param {Boolean} announceOnly If true, announce the migration without
       * applying it.
       */
      process: async function (announceOnly = false) {
        const self = qx.tool.cli.commands.package.Migrate;

        if (self.migrationInProcess) {
          return;
        }

        self.migrationInProcess = true;
        let needFix = false; // do not call this.base(arguments) here!

        let pkg = qx.tool.cli.commands.Package;
        let cwd = process.cwd();
        let migrateFiles = [[path.join(cwd, pkg.lockfile.filename), path.join(cwd, pkg.lockfile.legacy_filename)], [path.join(cwd, pkg.cache_dir), path.join(cwd, pkg.legacy_cache_dir)], [path.join(qx.tool.cli.ConfigDb.getDirectory(), pkg.package_cache_name), path.join(qx.tool.cli.ConfigDb.getDirectory(), pkg.legacy_package_cache_name)]];

        if (this.checkFilesToRename(migrateFiles).length) {
          let replaceInFiles = [{
            files: path.join(cwd, ".gitignore"),
            from: pkg.legacy_cache_dir + "/",
            to: pkg.cache_dir + "/"
          }];
          await this.migrate(migrateFiles, replaceInFiles, announceOnly);

          if (announceOnly) {
            needFix = true;
          } else {
            if (!this.argv.quiet) {
              qx.tool.compiler.Console.info("Fixing path names in the lockfile...");
            }

            this.argv.reinstall = true;
            await new qx.tool.cli.commands.package.Upgrade(this.argv).process();
          }
        } // Migrate all manifest in a package


        const registryModel = qx.tool.config.Registry.getInstance();
        let manifestModels = [];

        if (await registryModel.exists()) {
          // we have a qooxdoo.json index file containing the paths of libraries in the repository
          await registryModel.load();
          let libraries = registryModel.getLibraries();

          for (let library of libraries) {
            manifestModels.push(new qx.tool.config.Abstract(qx.tool.config.Manifest.config).set({
              baseDir: path.join(cwd, library.path)
            }));
          }
        } else if (fs.existsSync(qx.tool.config.Manifest.config.fileName)) {
          manifestModels.push(qx.tool.config.Manifest.getInstance());
        }

        for (const manifestModel of manifestModels) {
          await manifestModel.set({
            warnOnly: true
          }).load();
          manifestModel.setValidate(false);
          needFix = false;
          let s = "";

          if (!qx.lang.Type.isArray(manifestModel.getValue("info.authors"))) {
            needFix = true;
            s += "   missing info.authors\n";
          }

          if (!semver.valid(manifestModel.getValue("info.version"))) {
            needFix = true;
            s += "   missing or invalid info.version\n";
          }

          let obj = {
            "info.qooxdoo-versions": null,
            "info.qooxdoo-range": null,
            "provides.type": null,
            "requires.qxcompiler": null,
            "requires.qooxdoo-sdk": null,
            "requires.qooxdoo-compiler": null
          };

          if (manifestModel.keyExists(obj)) {
            needFix = true;
            s += "   obsolete entry:\n";

            for (let key in obj) {
              if (obj[key]) {
                s += "      " + key + "\n";
              }
            }
          }

          if (needFix) {
            if (announceOnly) {
              qx.tool.compiler.Console.warn("*** Manifest(s) need to be updated:\n" + s);
            } else {
              manifestModel.transform("info.authors", authors => {
                if (authors === "") {
                  return [];
                } else if (qx.lang.Type.isString(authors)) {
                  return [{
                    name: authors
                  }];
                } else if (qx.lang.Type.isObject(authors)) {
                  return [{
                    name: authors.name,
                    email: authors.email
                  }];
                } else if (qx.lang.Type.isArray(authors)) {
                  return authors.map(r => qx.lang.Type.isObject(r) ? {
                    name: r.name,
                    email: r.email
                  } : {
                    name: r
                  });
                }

                return [];
              }).transform("info.version", version => {
                let coerced = semver.coerce(version);

                if (coerced === null) {
                  qx.tool.compiler.Console.warn(`*** Version string '${version}' could not be interpreted as semver, changing to 1.0.0`);
                  return "1.0.0";
                }

                return String(coerced);
              }).unset("info.qooxdoo-versions").unset("info.qooxdoo-range").unset("provides.type").unset("requires.qxcompiler").unset("requires.qooxdoo-compiler").unset("requires.qooxdoo-sdk");
              await manifestModel.save();

              if (!this.argv.quiet) {
                qx.tool.compiler.Console.info(`Updated settings in ${manifestModel.getRelativeDataPath()}.`);
              }
            }
          } // check framework and compiler dependencies
          // if none are given in the Manifest, use the present framework and compiler


          const compiler_version = qx.tool.compiler.Version.VERSION;
          const compiler_range = manifestModel.getValue("requires.@qooxdoo/compiler") || compiler_version;
          const framework_version = await this.getLibraryVersion(await this.getGlobalQxPath());
          const framework_range = manifestModel.getValue("requires.@qooxdoo/framework") || framework_version;

          if (!semver.satisfies(compiler_version, compiler_range) || !semver.satisfies(framework_version, framework_range)) {
            needFix = true;

            if (announceOnly) {
              qx.tool.compiler.Console.warn("*** Framework and/or compiler dependencies in Manifest need to be updated.");
            } else {
              manifestModel.setValue("requires.@qooxdoo/compiler", "^" + compiler_version).setValue("requires.@qooxdoo/framework", "^" + framework_version);
              manifestModel.setWarnOnly(false); // now model should validate

              await manifestModel.save();

              if (!this.argv.quiet) {
                qx.tool.compiler.Console.info(`Updated dependencies in ${manifestModel.getRelativeDataPath()}.`);
              }
            }
          }

          manifestModel.setValidate(true);
        }

        if (!announceOnly) {
          let compileJsonFilename = path.join(process.cwd(), "compile.json");
          let replaceInFiles = [{
            files: compileJsonFilename,
            from: "\"qx/browser\"",
            to: "\"@qooxdoo/qx/browser\""
          }];
          await this.migrate([compileJsonFilename], replaceInFiles);
        }

        let compileJsFilename = path.join(process.cwd(), "compile.js");

        if (await fs.existsAsync(compileJsFilename)) {
          let data = await fs.readFileAsync(compileJsFilename, "utf8");

          if (data.indexOf("module.exports") < 0) {
            qx.tool.compiler.Console.warn("*** Your compile.js appears to be missing a `module.exports` statement - please see https://git.io/fjBqU for more details");
          }
        }

        self.migrationInProcess = false;

        if (needFix) {
          if (announceOnly) {
            qx.tool.compiler.Console.error(`*** Please run 'qx package migrate' to apply the changes. If you don't want this, downgrade to a previous version of the compiler.`);
            process.exit(1);
          }

          qx.tool.compiler.Console.info("Migration completed.");
        } else if (!announceOnly && !this.argv.quiet) {
          qx.tool.compiler.Console.info("Everything is up-to-date. No migration necessary.");
        }
      }
    }
  });
  qx.tool.cli.commands.package.Migrate.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.tool.config.Abstract": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2019 The qooxdoo developers
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Boulanger (info@bibliograph.org, @cboulanger)
  
  ************************************************************************ */

  /**
   * A model for the Manifest.json file
   */
  qx.Class.define("qx.tool.config.Registry", {
    extend: qx.tool.config.Abstract,
    type: "singleton",
    statics: {
      config: {
        fileName: "qooxdoo.json",
        version: "1.0.0"
      }
    },
    construct: function () {
      qx.tool.config.Abstract.constructor.call(this, qx.tool.config.Registry.config);
    },
    members: {
      getLibraries() {
        return this.getValue("libraries");
      }

    }
  });
  qx.tool.config.Registry.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.tool.utils.json.Parser": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
   *
   *    qooxdoo-compiler - node.js based replacement for the Qooxdoo python
   *    toolchain
   *
   *    https://github.com/qooxdoo/qooxdoo-compiler
   *
   *    Copyright:
   *      2011-2019 Zenesis Limited, http://www.zenesis.com
   *      Vlad Trushin <monospectr@mail.ru> (https://github.com/vtrushin)
   *
   *    License:
   *      MIT: https://opensource.org/licenses/MIT
   *
   *      This software is provided under the same licensing terms as Qooxdoo,
   *      please see the LICENSE file in the Qooxdoo project's top-level directory
   *      for details.
   *
   *    Authors:
   *      * John Spackman (john.spackman@zenesis.com, @johnspackman)
   *      * Vlad Trushin (monospectr@mail.ru, @vtrushin)
   *
   * *********************************************************************** */

  /* eslint-disable no-label */

  /* eslint-disable no-prototype-builtins */

  /* eslint-disable no-redeclare */

  /* eslint-disable no-constant-condition */

  /* eslint-disable no-labels */
  const __P_53_0 = {
    LEFT_BRACE: 0,
    // {
    RIGHT_BRACE: 1,
    // }
    LEFT_BRACKET: 2,
    // [
    RIGHT_BRACKET: 3,
    // ]
    COLON: 4,
    // :
    COMMA: 5,
    // ,
    STRING: 6,
    //
    NUMBER: 7,
    //
    TRUE: 8,
    // true
    FALSE: 9,
    // false
    NULL: 10,
    // null
    COMMENT: 11,
    WHITESPACE: 12
  };
  /**
   * Tokenizer, based on json-to-ast by Vlad trushin 
   */

  qx.Class.define("qx.tool.utils.json.Tokenizer", {
    extend: qx.core.Object,
    construct: function (input, settings) {
      qx.core.Object.constructor.call(this);
      this.input = input;
      this.settings = settings || {};
      this.tokens = null;
      this.tokenIndex = -1;
    },
    members: {
      token() {
        if (this.tokens === null) {
          throw new Error("No tokens to return (have you called tokenize?)");
        }

        if (this.tokenIndex >= this.tokens.length) {
          throw new Error("No more tokens available");
        }

        if (this.tokenIndex < 0) {
          return this.next();
        }

        return this.tokens[this.tokenIndex];
      },

      hasMore() {
        const tokenTypes = qx.tool.utils.json.Tokenizer.tokenTypes;

        if (this.tokens === null) {
          throw new Error("No tokens to return (have you called tokenize?)");
        }

        if (this.settings.returnWhitespace) {
          return this.tokenIndex < this.tokens.length;
        }

        var tokenIndex = this.tokenIndex;

        if (tokenIndex < 0) {
          tokenIndex = 0;
        }

        for (; tokenIndex < this.tokens.length; tokenIndex++) {
          var token = this.tokens[tokenIndex];

          if (token.type != tokenTypes.COMMENT && token.type != tokenTypes.WHITESPACE) {
            return true;
          }
        }

        return false;
      },

      next() {
        const tokenTypes = qx.tool.utils.json.Tokenizer.tokenTypes;

        if (this.tokens === null) {
          throw new Error("No tokens to return (have you called tokenize?)");
        }

        if (this.tokenIndex >= this.tokens.length) {
          throw new Error("No more tokens to get");
        }

        if (this.settings.returnWhitespace) {
          if (this.tokenIndex < this.tokens.length) {
            return this.tokens[++this.tokenIndex];
          }
        } else {
          for (++this.tokenIndex; this.tokenIndex < this.tokens.length; this.tokenIndex++) {
            var token = this.tokens[this.tokenIndex];

            if (token.type != tokenTypes.COMMENT && token.type != tokenTypes.WHITESPACE) {
              return token;
            }
          }
        }

        return null;
      },

      tokenize() {
        const Tokenizer = qx.tool.utils.json.Tokenizer;
        let line = 1;
        let column = 1;
        let index = 0;
        const tokens = this.tokens = [];
        var input = this.input;

        while (index < input.length) {
          const args = [input, index, line, column, this.settings];
          const matched = Tokenizer.parseWhitespace(...args) || Tokenizer.parseComment(...args) || Tokenizer.parseChar(...args) || Tokenizer.parseKeyword(...args) || Tokenizer.parseString(...args) || Tokenizer.parseNumber(...args);

          if (matched) {
            const token = {
              type: matched.type,
              value: matched.value,
              loc: qx.tool.utils.json.Parser.location(line, column, index, matched.line, matched.column, matched.index, this.settings.source)
            };

            if (matched.rawValue) {
              token.rawValue = matched.rawValue;
            }

            tokens.push(token);
            index = matched.index;
            line = matched.line;
            column = matched.column;
          } else {
            qx.tool.utils.json.Parser.error(Tokenizer.cannotTokenizeSymbol(input.charAt(index), line, column), input, line, column);
          }
        }

        return tokens;
      }

    },
    statics: {
      tokenTypes: __P_53_0,
      punctuatorTokensMap: {
        // Lexeme: Token
        "{": __P_53_0.LEFT_BRACE,
        "}": __P_53_0.RIGHT_BRACE,
        "[": __P_53_0.LEFT_BRACKET,
        "]": __P_53_0.RIGHT_BRACKET,
        ":": __P_53_0.COLON,
        ",": __P_53_0.COMMA
      },
      keywordTokensMap: {
        // Lexeme: Token config
        "true": {
          type: __P_53_0.TRUE,
          value: true
        },
        "false": {
          type: __P_53_0.FALSE,
          value: false
        },
        "null": {
          type: __P_53_0.NULL,
          value: null
        }
      },
      stringStates: {
        _START_: 0,
        START_QUOTE_OR_CHAR: 1,
        ESCAPE: 2
      },
      escapes: {
        "\"": "\"",
        // Quotation mask
        "\\": "\\",
        // Reverse solidus
        "/": "/",
        // Solidus
        "b": "\b",
        // Backspace
        "f": "\f",
        // Form feed
        "n": "\n",
        // New line
        "r": "\r",
        // Carriage return
        "t": "\t",
        // Horizontal tab
        "u": "u" // 4 hexadecimal digits

      },
      numberStates: {
        _START_: 0,
        MINUS: 1,
        ZERO: 2,
        DIGIT: 3,
        POINT: 4,
        DIGIT_FRACTION: 5,
        EXP: 6,
        EXP_DIGIT_OR_SIGN: 7
      },

      // HELPERS
      isDigit1to9(char) {
        return char >= "1" && char <= "9";
      },

      isDigit(char) {
        return char >= "0" && char <= "9";
      },

      isHex(char) {
        return qx.tool.utils.json.Tokenizer.isDigit(char) || char >= "a" && char <= "f" || char >= "A" && char <= "F";
      },

      isExp(char) {
        return char === "e" || char === "E";
      },

      // ERRORS
      cannotTokenizeSymbol(symbol, line, column) {
        return `Cannot tokenize symbol <${symbol}> at ${line}:${column}`;
      },

      // PARSERS
      parseWhitespace(input, index, line, column) {
        var value = "";

        while (true) {
          var char = input.charAt(index);

          if (char === "\r") {
            // CR (Unix)
            index++;
            line++;
            column = 1;
            value += char;

            if (input.charAt(index) === "\n") {
              // CRLF (Windows)
              index++;
              value += "\n";
            }
          } else if (char === "\n") {
            // LF (MacOS)
            index++;
            line++;
            column = 1;
            value += char;
          } else if (char === "\t" || char === " ") {
            index++;
            column++;
            value += char;
          } else {
            break;
          }
        }

        if (value.length == 0) {
          return null;
        }

        return {
          index,
          line,
          column,
          type: qx.tool.utils.json.Tokenizer.tokenTypes.WHITESPACE,
          value: value
        };
      },

      parseComment(input, index, line, column) {
        const str = input.substring(index, index + 2);
        const startIndex = index;

        if (str === "/*") {
          for (index += 2; index < input.length; index++) {
            var char = input[index];

            if (char === "*" && input[index + 1] === "/") {
              index += 2;
              column += 2;
              break;
            } else if (char === "\r") {
              // CR (Unix)
              index++;
              line++;
              column = 1;

              if (input.charAt(index) === "\n") {
                // CRLF (Windows)
                index++;
              }
            } else if (char === "\n") {
              // LF (MacOS)
              index++;
              line++;
              column = 1;
            } else {
              column++;
            }
          }

          return {
            index,
            line,
            column,
            type: qx.tool.utils.json.Tokenizer.tokenTypes.COMMENT,
            value: input.substring(startIndex, index)
          };
        } else if (str === "//") {
          for (index += 2; index < input.length; index++) {
            var char = input[index];

            if (char === "\r") {
              // CR (Unix)
              index++;
              line++;
              column = 1;

              if (input.charAt(index) === "\n") {
                // CRLF (Windows)
                index++;
              }

              break;
            } else if (char === "\n") {
              // LF (MacOS)
              index++;
              line++;
              column = 1;
              break;
            }
          }

          return {
            index,
            line,
            column,
            type: qx.tool.utils.json.Tokenizer.tokenTypes.COMMENT,
            value: input.substring(startIndex, index)
          };
        }

        return null;
      },

      parseChar(input, index, line, column) {
        const char = input.charAt(index);
        const punctuatorTokensMap = qx.tool.utils.json.Tokenizer.punctuatorTokensMap;

        if (char in punctuatorTokensMap) {
          return {
            type: punctuatorTokensMap[char],
            line,
            column: column + 1,
            index: index + 1,
            value: char
          };
        }

        return null;
      },

      parseKeyword(input, index, line, column) {
        const keywordTokensMap = qx.tool.utils.json.Tokenizer.keywordTokensMap;

        for (const name in keywordTokensMap) {
          if (keywordTokensMap.hasOwnProperty(name) && input.substr(index, name.length) === name) {
            const {
              type,
              value
            } = keywordTokensMap[name];
            return {
              type,
              line,
              column: column + name.length,
              index: index + name.length,
              value
            };
          }
        }

        return null;
      },

      parseString(input, index, line, column, settings) {
        const {
          stringStates,
          tokenTypes,
          escapes
        } = qx.tool.utils.json.Tokenizer;
        const startIndex = index;
        let buffer = "";
        let state = stringStates._START_;

        while (index < input.length) {
          const char = input.charAt(index);

          switch (state) {
            case stringStates._START_:
              {
                if (char === "\"") {
                  state = stringStates.START_QUOTE_OR_CHAR;
                  index++;
                } else {
                  return null;
                }

                break;
              }

            case stringStates.START_QUOTE_OR_CHAR:
              {
                if (char === "\\") {
                  state = stringStates.ESCAPE;
                  index++;
                } else if (char === "\"") {
                  index++;
                  var result = {
                    type: tokenTypes.STRING,
                    line,
                    column: column + index - startIndex,
                    index,
                    value: buffer
                  };

                  if (settings.verbose) {
                    result.rawValue = input.substring(startIndex, index);
                  }

                  return result;
                } else {
                  buffer += char;
                  index++;
                }

                break;
              }

            case stringStates.ESCAPE:
              {
                if (char in escapes) {
                  if (char === "u") {
                    index++;

                    for (let i = 0; i < 4; i++) {
                      const curChar = input.charAt(index);

                      if (curChar && qx.tool.utils.json.Tokenizer.isHex(curChar)) {
                        buffer += curChar;
                        index++;
                      } else {
                        return null;
                      }
                    }
                  } else {
                    buffer += escapes[char];
                    index++;
                  }

                  state = stringStates.START_QUOTE_OR_CHAR;
                } else {
                  return null;
                }

                break;
              }
          }
        }

        return null;
      },

      parseNumber(input, index, line, column) {
        const numberStates = qx.tool.utils.json.Tokenizer.numberStates;
        const startIndex = index;
        let passedValueIndex = index;
        let state = numberStates._START_;

        iterator: while (index < input.length) {
          const char = input.charAt(index);

          switch (state) {
            case numberStates._START_:
              {
                if (char === "-") {
                  state = numberStates.MINUS;
                } else if (char === "0") {
                  passedValueIndex = index + 1;
                  state = numberStates.ZERO;
                } else if (qx.tool.utils.json.Tokenizer.isDigit1to9(char)) {
                  passedValueIndex = index + 1;
                  state = numberStates.DIGIT;
                } else {
                  return null;
                }

                break;
              }

            case numberStates.MINUS:
              {
                if (char === "0") {
                  passedValueIndex = index + 1;
                  state = numberStates.ZERO;
                } else if (qx.tool.utils.json.Tokenizer.isDigit1to9(char)) {
                  passedValueIndex = index + 1;
                  state = numberStates.DIGIT;
                } else {
                  return null;
                }

                break;
              }

            case numberStates.ZERO:
              {
                if (char === ".") {
                  state = numberStates.POINT;
                } else if (qx.tool.utils.json.Tokenizer.isExp(char)) {
                  state = numberStates.EXP;
                } else {
                  break iterator;
                }

                break;
              }

            case numberStates.DIGIT:
              {
                if (qx.tool.utils.json.Tokenizer.isDigit(char)) {
                  passedValueIndex = index + 1;
                } else if (char === ".") {
                  state = numberStates.POINT;
                } else if (qx.tool.utils.json.Tokenizer.isExp(char)) {
                  state = numberStates.EXP;
                } else {
                  break iterator;
                }

                break;
              }

            case numberStates.POINT:
              {
                if (qx.tool.utils.json.Tokenizer.isDigit(char)) {
                  passedValueIndex = index + 1;
                  state = numberStates.DIGIT_FRACTION;
                } else {
                  break iterator;
                }

                break;
              }

            case numberStates.DIGIT_FRACTION:
              {
                if (qx.tool.utils.json.Tokenizer.isDigit(char)) {
                  passedValueIndex = index + 1;
                } else if (qx.tool.utils.json.Tokenizer.isExp(char)) {
                  state = numberStates.EXP;
                } else {
                  break iterator;
                }

                break;
              }

            case numberStates.EXP:
              {
                if (char === "+" || char === "-") {
                  state = numberStates.EXP_DIGIT_OR_SIGN;
                } else if (qx.tool.utils.json.Tokenizer.isDigit(char)) {
                  passedValueIndex = index + 1;
                  state = numberStates.EXP_DIGIT_OR_SIGN;
                } else {
                  break iterator;
                }

                break;
              }

            case numberStates.EXP_DIGIT_OR_SIGN:
              {
                if (qx.tool.utils.json.Tokenizer.isDigit(char)) {
                  passedValueIndex = index + 1;
                } else {
                  break iterator;
                }

                break;
              }
          }

          index++;
        }

        if (passedValueIndex > 0) {
          return {
            type: qx.tool.utils.json.Tokenizer.tokenTypes.NUMBER,
            line,
            column: column + passedValueIndex - startIndex,
            index: passedValueIndex,
            value: parseFloat(input.substring(startIndex, passedValueIndex))
          };
        }

        return null;
      }

    }
  });
  qx.tool.utils.json.Tokenizer.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.tool.utils.json.Tokenizer": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
   *
   *    qooxdoo-compiler - node.js based replacement for the Qooxdoo python
   *    toolchain
   *
   *    https://github.com/qooxdoo/qooxdoo-compiler
   *
   *    Copyright:
   *      2011-2019 Zenesis Limited, http://www.zenesis.com
   *      Vlad Trushin <monospectr@mail.ru> (https://github.com/vtrushin)
   *
   *    License:
   *      MIT: https://opensource.org/licenses/MIT
   *
   *      This software is provided under the same licensing terms as Qooxdoo,
   *      please see the LICENSE file in the Qooxdoo project's top-level directory
   *      for details.
   *
   *    Authors:
   *      * John Spackman (john.spackman@zenesis.com, @johnspackman)
   *      * Vlad Trushin (monospectr@mail.ru, @vtrushin)
   *
   * *********************************************************************** */

  /**
   * Parser, based on json-to-ast by Vlad trushin 
   */
  qx.Class.define("qx.tool.utils.json.Parser", {
    statics: {
      literals: [qx.tool.utils.json.Tokenizer.tokenTypes.STRING, qx.tool.utils.json.Tokenizer.tokenTypes.NUMBER, qx.tool.utils.json.Tokenizer.tokenTypes.TRUE, qx.tool.utils.json.Tokenizer.tokenTypes.FALSE, qx.tool.utils.json.Tokenizer.tokenTypes.NULL],
      objectStates: {
        _START_: 0,
        OPEN_OBJECT: 1,
        PROPERTY: 2,
        COMMA: 3
      },
      propertyStates: {
        _START_: 0,
        KEY: 1,
        COLON: 2
      },
      arrayStates: {
        _START_: 0,
        OPEN_ARRAY: 1,
        VALUE: 2,
        COMMA: 3
      },
      defaultSettings: {
        verbose: true,
        source: null
      },

      location(startLine, startColumn, startOffset, endLine, endColumn, endOffset, source) {
        return {
          start: {
            line: startLine,
            column: startColumn,
            offset: startOffset
          },
          end: {
            line: endLine,
            column: endColumn,
            offset: endOffset
          },
          source: source || null
        };
      },

      comment(value, name, token) {
        if (token.comments !== undefined) {
          var valueComments = value[name];

          if (valueComments === undefined) {
            valueComments = value[name] = [];
          }

          token.comments.forEach(function (comment) {
            valueComments.push({
              loc: comment.loc,
              source: comment.value
            });
          });
        }
      },

      parseObject(input, tokenizer, settings) {
        const {
          objectStates
        } = qx.tool.utils.json.Parser;
        const tokenTypes = qx.tool.utils.json.Tokenizer.tokenTypes; // object: LEFT_BRACE (property (COMMA property)*)? RIGHT_BRACE

        let startToken;
        let object = {
          type: "object",
          children: []
        };
        let state = objectStates._START_;

        while (tokenizer.hasMore()) {
          const token = tokenizer.token();

          switch (state) {
            case objectStates._START_:
              {
                if (token.type === tokenTypes.LEFT_BRACE) {
                  startToken = token;
                  state = objectStates.OPEN_OBJECT;

                  if (settings.verbose) {
                    object.startToken = tokenizer.tokenIndex;
                    qx.tool.utils.json.Parser.comment(object, "leadingComments", token);
                  }

                  tokenizer.next();
                } else {
                  return null;
                }

                break;
              }

            case objectStates.OPEN_OBJECT:
              {
                if (token.type === tokenTypes.RIGHT_BRACE) {
                  if (settings.verbose) {
                    object.loc = qx.tool.utils.json.Parser.location(startToken.loc.start.line, startToken.loc.start.column, startToken.loc.start.offset, token.loc.end.line, token.loc.end.column, token.loc.end.offset, settings.source);
                    object.endToken = tokenizer.tokenIndex;
                    qx.tool.utils.json.Parser.comment(object, "trailingComments", token);
                  }

                  tokenizer.next();
                  return {
                    value: object
                  };
                }

                const property = qx.tool.utils.json.Parser.parseProperty(input, tokenizer, settings);
                object.children.push(property.value);
                state = objectStates.PROPERTY;
                break;
              }

            case objectStates.PROPERTY:
              {
                if (token.type === tokenTypes.RIGHT_BRACE) {
                  if (settings.verbose) {
                    object.loc = qx.tool.utils.json.Parser.location(startToken.loc.start.line, startToken.loc.start.column, startToken.loc.start.offset, token.loc.end.line, token.loc.end.column, token.loc.end.offset, settings.source);
                    object.endToken = tokenizer.tokenIndex;
                    qx.tool.utils.json.Parser.comment(object, "trailingComments", token);
                  }

                  tokenizer.next();
                  return {
                    value: object
                  };
                } else if (token.type === tokenTypes.COMMA) {
                  qx.tool.utils.json.Parser.comment(object.children[object.children.length - 1], "trailingComments", token);
                  state = objectStates.COMMA;
                  tokenizer.next();
                } else {
                  qx.tool.utils.json.Parser.error(qx.tool.utils.json.Parser.unexpectedToken(input.substring(token.loc.start.offset, token.loc.end.offset), token.loc.start.line, token.loc.start.column), input, token.loc.start.line, token.loc.start.column);
                }

                break;
              }

            case objectStates.COMMA:
              {
                const property = qx.tool.utils.json.Parser.parseProperty(input, tokenizer, settings);

                if (property) {
                  object.children.push(property.value);
                  state = objectStates.PROPERTY;
                } else {
                  qx.tool.utils.json.Parser.error(qx.tool.utils.json.Parser.unexpectedToken(input.substring(token.loc.start.offset, token.loc.end.offset), token.loc.start.line, token.loc.start.column), input, token.loc.start.line, token.loc.start.column);
                }

                break;
              }
          }
        }

        qx.tool.utils.json.Parser.error(qx.tool.utils.json.Parser.unexpectedEnd());
        return null;
      },

      parseProperty(input, tokenizer, settings) {
        const {
          objectStates,
          propertyStates
        } = qx.tool.utils.json.Parser;
        const tokenTypes = qx.tool.utils.json.Tokenizer.tokenTypes; // property: STRING COLON value

        let startToken;
        let property = {
          type: "property",
          key: null,
          value: null
        };
        let state = objectStates._START_;

        while (tokenizer.hasMore()) {
          const token = tokenizer.token();

          switch (state) {
            case propertyStates._START_:
              {
                if (token.type === tokenTypes.STRING) {
                  const key = {
                    type: "identifier",
                    value: token.value
                  };

                  if (settings.verbose) {
                    key.loc = token.loc;
                    property.startToken = key.startToken = key.endToken = tokenizer.tokenIndex;
                    qx.tool.utils.json.Parser.comment(key, "leadingComments", token);
                  }

                  startToken = token;
                  property.key = key;
                  state = propertyStates.KEY;
                  tokenizer.next();
                } else {
                  return null;
                }

                break;
              }

            case propertyStates.KEY:
              {
                if (token.type === tokenTypes.COLON) {
                  if (settings.verbose) {
                    qx.tool.utils.json.Parser.comment(property.key, "trailingComments", token);
                    property.colonToken = token;
                  }

                  state = propertyStates.COLON;
                  tokenizer.next();
                } else {
                  qx.tool.utils.json.Parser.error(qx.tool.utils.json.Parser.unexpectedToken(input.substring(token.loc.start.offset, token.loc.end.offset), token.loc.start.line, token.loc.start.column), input, token.loc.start.line, token.loc.start.column);
                }

                break;
              }

            case propertyStates.COLON:
              {
                const value = qx.tool.utils.json.Parser.parseValue(input, tokenizer, settings);
                property.value = value.value;

                if (settings.verbose) {
                  property.endToken = value.value.endToken;
                  property.loc = qx.tool.utils.json.Parser.location(startToken.loc.start.line, startToken.loc.start.column, startToken.loc.start.offset, value.value.loc.end.line, value.value.loc.end.column, value.value.loc.end.offset, settings.source);
                }

                return {
                  value: property
                };
              }
          }
        }

        return null;
      },

      parseArray(input, tokenizer, settings) {
        const {
          arrayStates
        } = qx.tool.utils.json.Parser;
        const tokenTypes = qx.tool.utils.json.Tokenizer.tokenTypes; // array: LEFT_BRACKET (value (COMMA value)*)? RIGHT_BRACKET

        let startToken;
        let array = {
          type: "array",
          children: []
        };
        let state = arrayStates._START_;
        let token;

        while (tokenizer.hasMore()) {
          token = tokenizer.token();

          switch (state) {
            case arrayStates._START_:
              {
                if (token.type === tokenTypes.LEFT_BRACKET) {
                  startToken = token;

                  if (settings.verbose) {
                    array.startToken = tokenizer.tokenIndex;
                    qx.tool.utils.json.Parser.comment(array, "leadingComments", token);
                  }

                  state = arrayStates.OPEN_ARRAY;
                  tokenizer.next();
                } else {
                  return null;
                }

                break;
              }

            case arrayStates.OPEN_ARRAY:
              {
                if (token.type === tokenTypes.RIGHT_BRACKET) {
                  if (settings.verbose) {
                    array.loc = qx.tool.utils.json.Parser.location(startToken.loc.start.line, startToken.loc.start.column, startToken.loc.start.offset, token.loc.end.line, token.loc.end.column, token.loc.end.offset, settings.source);
                    array.endToken = tokenizer.tokenIndex;
                    qx.tool.utils.json.Parser.comment(array, "trailingComments", token);
                  }

                  tokenizer.next();
                  return {
                    value: array
                  };
                }

                let value = qx.tool.utils.json.Parser.parseValue(input, tokenizer, settings);
                array.children.push(value.value);
                state = arrayStates.VALUE;
                break;
              }

            case arrayStates.VALUE:
              {
                if (token.type === tokenTypes.RIGHT_BRACKET) {
                  if (settings.verbose) {
                    array.loc = qx.tool.utils.json.Parser.location(startToken.loc.start.line, startToken.loc.start.column, startToken.loc.start.offset, token.loc.end.line, token.loc.end.column, token.loc.end.offset, settings.source);
                    array.endToken = tokenizer.tokenIndex;
                    qx.tool.utils.json.Parser.comment(array, "trailingComments", token);
                  }

                  tokenizer.next();
                  return {
                    value: array
                  };
                } else if (token.type === tokenTypes.COMMA) {
                  state = arrayStates.COMMA;
                  tokenizer.next();
                } else {
                  qx.tool.utils.json.Parser.error(qx.tool.utils.json.Parser.unexpectedToken(input.substring(token.loc.start.offset, token.loc.end.offset), token.loc.start.line, token.loc.start.column), input, token.loc.start.line, token.loc.start.column);
                }

                break;
              }

            case arrayStates.COMMA:
              {
                let value = qx.tool.utils.json.Parser.parseValue(input, tokenizer, settings);
                array.children.push(value.value);
                state = arrayStates.VALUE;
                break;
              }
          }
        }

        qx.tool.utils.json.Parser.error(qx.tool.utils.json.Parser.unexpectedEnd());
        return null;
      },

      parseLiteral(input, tokenizer, settings) {
        // literal: STRING | NUMBER | TRUE | FALSE | NULL
        const token = tokenizer.token();
        const isLiteral = qx.tool.utils.json.Parser.literals.indexOf(token.type) !== -1;

        if (isLiteral) {
          let value = token.value;

          if (token.type == qx.tool.utils.json.Tokenizer.tokenTypes.STRING) {
            value = value.replace(/\\(.)/g, "$1");
          }

          const literal = {
            type: "literal",
            value: value,
            rawValue: input.substring(token.loc.start.offset, token.loc.end.offset)
          };

          if (settings.verbose) {
            literal.loc = token.loc;
            literal.startToken = literal.endToken = tokenizer.tokenIndex;
            qx.tool.utils.json.Parser.comment(literal, "leadingComments", token);
          }

          tokenizer.next();
          return {
            value: literal
          };
        }

        return null;
      },

      parseValue(input, tokenizer, settings) {
        // value: literal | object | array
        const token = tokenizer.token();
        const value = qx.tool.utils.json.Parser.parseLiteral(...arguments) || qx.tool.utils.json.Parser.parseObject(...arguments) || qx.tool.utils.json.Parser.parseArray(...arguments);

        if (value) {
          return value;
        }

        qx.tool.utils.json.Parser.error(qx.tool.utils.json.Parser.unexpectedToken(input.substring(token.loc.start.offset, token.loc.end.offset), token.loc.start.line, token.loc.start.column), input, token.loc.start.line, token.loc.start.column);
        return null;
      },

      parseToAst(input, settings) {
        settings = Object.assign({}, qx.tool.utils.json.Parser.defaultSettings, settings);
        const tokenizer = new qx.tool.utils.json.Tokenizer(input, settings);
        tokenizer.tokenize();

        if (!tokenizer.hasMore()) {
          qx.tool.utils.json.Parser.error(qx.tool.utils.json.Parser.unexpectedEnd());
        }

        const value = qx.tool.utils.json.Parser.parseValue(input, tokenizer, settings);

        if (!tokenizer.hasMore()) {
          var result = value.value;

          if (settings.verbose) {
            result.tokenizer = tokenizer;
          }

          return result;
        }

        const token = tokenizer.next();
        qx.tool.utils.json.Parser.error(qx.tool.utils.json.Parser.unexpectedToken(input.substring(token.loc.start.offset, token.loc.end.offset), token.loc.start.line, token.loc.start.column), input, token.loc.start.line, token.loc.start.column);
        return null;
      },

      parse(input, settings) {
        return qx.tool.utils.json.Parser.parseToAst(input, settings);
      },

      unexpectedEnd() {
        return "Unexpected end of JSON input";
      },

      unexpectedToken(token, line, column) {
        return `Unexpected token <${token}> at ${line}:${column}`;
      },

      error(message, source, line, column) {
        function showCodeFragment(source, linePosition, columnPosition) {
          const lines = source.split(/\n|\r\n?|\f/);
          const line = lines[linePosition - 1];
          const marker = new Array(columnPosition).join(" ") + "^";
          return line + "\n" + marker;
        }

        class ParseError extends SyntaxError {
          constructor(message, source, linePosition, columnPosition) {
            const fullMessage = linePosition ? message + "\n" + showCodeFragment(source, linePosition, columnPosition) : message;
            super(fullMessage);
            this.rawMessage = message;
          }

        }

        throw new ParseError(message, source, line, column);
      }

    }
  });
  qx.tool.utils.json.Parser.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "require": true
      },
      "qx.tool.utils.json.Writer": {},
      "qx.lang.Type": {},
      "qx.tool.utils.json.Tokenizer": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
   *
   *    qooxdoo-compiler - node.js based replacement for the Qooxdoo python
   *    toolchain
   *
   *    https://github.com/qooxdoo/qooxdoo-compiler
   *
   *    Copyright:
   *      2011-2019 Zenesis Limited, http://www.zenesis.com
   *
   *    License:
   *      MIT: https://opensource.org/licenses/MIT
   *
   *      This software is provided under the same licensing terms as Qooxdoo,
   *      please see the LICENSE file in the Qooxdoo project's top-level directory
   *      for details.
   *
   *    Authors:
   *      * John Spackman (john.spackman@zenesis.com, @johnspackman)
   *
   * *********************************************************************** */

  /* eslint-disable no-redeclare */

  /**
   * Stringify 
   */
  qx.Class.define("qx.tool.utils.json.Stringify", {
    extend: qx.core.Object,
    statics: {
      /**
       * Pretty prints an AST tree
       */
      prettyPrint(ast) {
        var writer = new qx.tool.utils.json.Writer();
        /**
         * Writes a node, used recursively
         */

        function writeNode(node) {
          switch (node.type) {
            case "object":
              writer.comments(node.leadingComments);
              writer.write("{\n").indent(+1);
              node.children.forEach(function (child, index) {
                if (index > 0) {
                  writer.write(",\n");
                }

                writer.write("\"" + child.key.value + "\" : ");
                writeNode(child.value);
              });

              if (node.children.length) {
                writer.write("\n");
              }

              writer.comments(node.trailingComments);
              writer.indent(-1).write("}");
              break;

            case "array":
              writer.comments(node.leadingComments);
              writer.write("[\n").indent(+1);
              node.children.forEach(function (child, index) {
                if (index > 0) {
                  writer.write(",\n");
                }

                writeNode(child.value);
              });

              if (node.children.length) {
                writer.write("\n");
              }

              writer.comments(node.trailingComments);
              writer.indent(-1).write("]\n");
              break;

            case "property":
              writeNode(node.key);
              writer.write(" : ");
              writeNode(node.value);
              break;

            case "identifier":
              writer.write("\"" + node.value + "\"");
              break;

            case "literal":
              writer.comments(node.leadingComments);
              writer.write(node.rawValue);
              writer.comments(node.trailingComments);
              break;

            default:
              throw new Error("Unexpected node type '" + node.type + "'");
          }
        }

        writeNode(ast);
        return writer.buffer;
      },

      /**
       * Prints an object out, using the AST to preserve formatting and whitespace 
       * (and include comments) wherever possible.  Any parts of the object which
       * do not have a corresponding AST tree will be pretty printed  
       * 
       * This is only really suitable for amendments to the object graph because
       * preserving formatting & comments relies on a 1:1 comparison between the
       * AST and the object.  This means that if you move a subset of an object to 
       * another part of the object graph, it will be seen as a deletion of one
       * subset and a brand new subset - you will loose all comments as well as 
       * layout. 
       * 
       * @param object {Object}
       * @param ast {Tokenizer}
       * @return {String}
       */
      reprint(object, ast) {
        var writer = new qx.tool.utils.json.Writer();

        if (!ast) {
          prettyPojo(object);
          return writer.buffer;
        }

        var tokenizer = ast.tokenizer;
        /*
         * Pretty prints any old POJO or native value
         */

        function prettyPojo(obj) {
          if (typeof obj == "string") {
            writer.write("\"" + obj + "\"");
          } else if (typeof obj == "number") {
            writer.write(obj);
          } else if (typeof obj == "boolean") {
            writer.write(obj ? "true" : "false");
          } else if (qx.lang.Type.isArray(obj)) {
            writer.write("[ ");
            obj.forEach(function (elem, index) {
              if (index != 0) {
                writer.write(", ");
              }

              prettyPojo(elem);
            });
            writer.write(" ]");
          } else {
            var first = true;
            var oldIndent = writer.matchIndent();
            writer.write("{\n").indent(+1);

            for (var name in obj) {
              if (!first) {
                writer.write(",\n");
              }

              writer.write("\"" + name + "\": ");
              prettyPojo(obj[name]);
              first = false;
            }

            writer.write("\n").indent(-1).write("}");
            writer.resetIndent(oldIndent);
          }
        }
        /*
         * Pretty prints a key:value pair
         */


        function prettyPojoProperty(key, value) {
          writer.write("\"" + key + "\": ");
          prettyPojo(value);
        }
        /*
         * Writes tokens which underly the AST, up to a given index
         */


        var startTokenIndex = 0;

        function writeTokensUntil(index) {
          if (startTokenIndex > -1) {
            while (startTokenIndex < index) {
              var token = tokenizer.tokens[startTokenIndex];
              writer.write(token.rawValue || token.value);
              startTokenIndex++;
            }
          }
        }
        /*
         * Writes an object, comparing it with the AST node.  Used recursively 
         */


        function writeNode(object, node) {
          /*
           * Pretty prints a node to the writer
           */
          function pretty(node) {
            var str = qx.tool.utils.json.Stringify.prettyPrint(node);
            writer.write(str);
            startTokenIndex = -1;
          }
          /*
           * Calculates the largest endToken
           * 
           * @param endToken {Number} current largest endToken, or -1 for none
           * @param node {AST Node}
           */


          function maxEndToken(endToken, node) {
            var index;

            if (node.endToken !== undefined) {
              index = node.endToken;
            } else if (node.startToken !== undefined) {
              index = node.startToken;
            } else {
              return endToken;
            }

            if (endToken > index) {
              return endToken;
            }

            return index;
          } // No startToken?  Then it was not parsed, pretty print it


          if (node.startToken === undefined) {
            pretty(node);
            return;
          }

          switch (node.type) {
            case "object":
              // If it's not the correct type, then pretty print
              if (!qx.tool.utils.json.Stringify.isPlainObject(object)) {
                prettyPojo(object);
                return;
              } // Create lookups


              var childAstLookup = {};
              node.children.forEach(function (child, index) {
                childAstLookup[child.key.value] = child;
              });
              var childPropertyLookup = {};

              for (var name in object) {
                childPropertyLookup[name] = object[name];
              } // Opening brace


              writeTokensUntil(node.startToken + 1); // Output known children first

              var endToken = -1;
              var first = true;

              for (var i = 0; i < node.children.length; i++) {
                var child = node.children[i];
                var key = child.key.value;
                var value = object[key]; // Deleted a child?

                if (value === undefined) {
                  writeTokensUntil(child.key.startToken);
                  startTokenIndex = child.value.endToken + 1;

                  if (first && i < node.children.length - 1) {
                    while (tokenizer.tokens[startTokenIndex].type != qx.tool.utils.json.Tokenizer.tokenTypes.COMMA) {
                      startTokenIndex++;
                    }

                    startTokenIndex++;
                  }

                  continue;
                }

                first = false;
                endToken = maxEndToken(endToken, child.value); // Write existing property

                writeTokensUntil(child.value.startToken);
                writeNode(value, child.value);
                delete childPropertyLookup[key];
              } // Added properties


              var first = node.children.length === 0;
              var oldIndent = writer.matchIndent();

              for (var name in childPropertyLookup) {
                if (!first) {
                  writer.write(",\n");
                  first = false;
                }

                prettyPojoProperty(name, childPropertyLookup[name]);
              } // Unindent and output the closing brace


              writer.resetIndent(oldIndent);

              if (endToken === -1) {
                startTokenIndex = node.endToken;
              } else {
                startTokenIndex = endToken + 1;
              }

              writeTokensUntil(node.endToken + 1);
              break;

            case "array":
              if (!qx.lang.Type.isArray(object)) {
                prettyPojo(object);
                return;
              } // Opening brace


              writeTokensUntil(node.startToken + 1);

              for (var i = 0; i < object.length; i++) {
                var child = i < node.children.length ? node.children[i] : undefined;

                if (child !== undefined) {
                  writeTokensUntil(child.startToken);
                  writeNode(object[i], child);
                  startTokenIndex = child.endToken + 1;
                } else {
                  var oldIndent = writer.matchIndent();

                  if (i != 0) {
                    writer.write(",\n");
                  }

                  prettyPojo(object[i]);
                  writer.resetIndent(oldIndent); //startTokenIndex = node.endToken;
                }
              } // Closing brace


              writeTokensUntil(node.endToken + 1);
              break;

            case "property":
              break;

            case "literal":
              // Check type
              if (!qx.tool.utils.json.Stringify.isLiteral(object)) {
                prettyPojo(object);
                startTokenIndex = node.endToken + 1;
                return;
              } // If it has not changed, then use the AST


              if (qx.tool.utils.json.Stringify.isSameLiteral(node, object)) {
                writeTokensUntil(node.startToken + 1); // New value, but try and preserve prefix comment & whitespace
              } else {
                writeTokensUntil(node.startToken);

                if (typeof object === "string") {
                  writer.write("\"" + object + "\"");
                } else {
                  writer.write(object);
                }

                startTokenIndex = node.startToken + 1;
              }

              break;

            default:
              throw new Error("Unexpected node type '" + node.type + "'");
          }
        } // Go


        writeNode(object, ast); // Append any whitespace or comments which trail the JSON

        if (startTokenIndex > -1) {
          while (startTokenIndex < tokenizer.tokens.length) {
            var token = tokenizer.tokens[startTokenIndex++];

            if (token.type != qx.tool.utils.json.Tokenizer.tokenTypes.COMMENT && token.type != qx.tool.utils.json.Tokenizer.tokenTypes.WHITESPACE) {
              break;
            }

            writer.write(token.rawValue || token.value);
          }
        }

        return writer.buffer;
      },

      /**
       * Converts an AST into an ordinary POJO 
       */
      astToObject(ast, settings) {
        function writeNode(node) {
          var result;

          switch (node.type) {
            case "object":
              result = {};
              node.children.forEach(function (child, index) {
                result[child.key.value] = writeNode(child.value);
              });
              break;

            case "array":
              result = [];
              node.children.forEach(function (child, index) {
                result.push(writeNode(child));
              });
              break;

            case "literal":
              result = node.value;
              break;

            default:
              throw new Error("Unexpected node type '" + node.type + "'");
          }

          return result;
        }

        return writeNode(ast);
      },

      /**
       * Detects whether the value is a native object
       * 
       * @param obj {Object}
       * @returns boolean
       */
      isPlainObject(obj) {
        if (typeof obj === "object" && obj !== null) {
          var proto = Object.getPrototypeOf(obj);
          return proto === Object.prototype || proto === null;
        }

        return false;
      },

      /**
       * Detects whether the value is a literal value
       * 
       * @param obj {Object}
       * @returns boolean
       */
      isLiteral(obj) {
        if (obj === null || typeof obj === "string" || typeof obj === "number" || typeof obj === "boolean") {
          return true;
        }

        return false;
      },

      /**
       * Compares a node to see if it is the same as a literal value
       */
      isSameLiteral(node, object) {
        if (node.rawValue === null && object === null) {
          return true;
        }

        if (node.rawValue !== null && object === null || node.rawValue === null && object !== null) {
          return false;
        }

        if (typeof node.value !== typeof object) {
          return false;
        }

        if (typeof node.value === "string") {
          return node.value === object;
        }

        return node.rawValue == object;
      }

    }
  });
  qx.tool.utils.json.Stringify.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.tool.cli.commands.Package": {
        "require": true
      },
      "qx.tool.compiler.Console": {},
      "qx.tool.cli.ConfigDb": {},
      "qx.tool.utils.Utils": {},
      "qx.tool.utils.Json": {},
      "qx.tool.config.Manifest": {},
      "qx.tool.config.Lockfile": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2017 Christian Boulanger
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Boulanger (info@bibliograph.org, @cboulanger)
  
  ************************************************************************ */
  const process = require("process");

  const Search = require("github-api/dist/components/Search");

  const Repository = require("github-api/dist/components/Repository");

  const fetch = require("node-fetch");

  const semver = require("semver");

  const inquirer = require("inquirer");

  const path = require("upath");
  /**
   * Updates the local cache with information of available library packages
   */


  qx.Class.define("qx.tool.cli.commands.package.Update", {
    extend: qx.tool.cli.commands.Package,
    statics: {
      getYargsCommand: function () {
        return {
          command: "update [repository]",
          describe: "updates information on packages from github. Has to be called before the other commands. If a package URI is supplied, only update information on that package",
          builder: {
            "file": {
              alias: "f",
              describe: "Output result to a file"
            },
            "search": {
              alias: "S",
              describe: "Search GitHub for repos (as opposed to using the cached nightly data)"
            },
            "all-versions": {
              alias: "a",
              describe: "Retrieve all releases (as opposed to the latest minor/patch release of each major release)"
            },
            "verbose": {
              alias: "v",
              describe: "Verbose logging"
            },
            "quiet": {
              alias: "q",
              describe: "No output"
            },
            "export-only": {
              alias: "E",
              describe: "Export the current cache without updating it first (requires --file)"
            }
          }
        };
      }
    },
    members: {
      /**
       * Updates the cache with information from GitHub.
       */
      process: async function () {
        // init
        let names = [];
        const argv = this.argv;
        const update_repo_only = argv.repository; // export only

        if (argv.exportOnly) {
          if (!argv.file) {
            qx.tool.compiler.Console.error("Path required via --file argument.");
            process.exit(1);
          }

          this.exportCache(argv.file);
          return;
        }

        if (!update_repo_only) {
          this.clearCache();
        }

        let cfg = await qx.tool.cli.ConfigDb.getInstance();
        let github = cfg.db("github", {});
        const self = this; // Create the cache

        if (!argv.search) {
          // Retrieve the data from the repository
          await updateFromRepository();
        } else {
          if (!github.token) {
            let response = await inquirer.prompt([{
              type: "input",
              name: "token",
              message: "Searching GitHub requires an API token - visit https://github.com/settings/tokens to obtain one (you do not need to assign any permissions, just create a token);\nWhat is your GitHub API Token ? "
            }]);

            if (!response.token) {
              qx.tool.compiler.Console.error("You have not provided a GitHub token.");
              return;
            }

            github.token = response.token;
            cfg.save();
          } // Generate data from GitHub API


          await updateFromGitHubAPI();
        }

        let num_libraries = this.getCache().num_libraries;

        if (num_libraries && !argv.quiet) {
          qx.tool.compiler.Console.info(`Found ${num_libraries} releases of libraries.`);
          qx.tool.compiler.Console.info(`Run 'qx package list' in the root dir of your project to see which versions of these libraries are compatible.`);
        } // save cache and export it if requested


        await this.saveCache();

        if (argv.file) {
          await this.exportCache(argv.file);
        }

        async function updateFromRepository() {
          if (!argv.quiet) {
            qx.tool.compiler.Console.log("Downloading cache from GitHub ...");
          }

          let url = self.getRepositoryCacheUrl();

          try {
            let res = await fetch(url);
            let data = await res.json();
            self.setCache(data);
          } catch (e) {
            throw new qx.tool.utils.Utils.UserError(e.message);
          }
        }

        async function updateFromGitHubAPI() {
          const auth = {
            token: github.token
          };
          const search = new Search({}, auth);
          let num_libraries = 0; // repositories

          if (!argv.quiet) {
            qx.tool.compiler.Console.log("Searching for package repositories on GitHub...");
          }

          let query = "topic:qooxdoo-package fork:true";

          if (update_repo_only) {
            query += " " + update_repo_only;
          }

          let result = await search.forRepositories({
            q: query
          }); // backwards-compatibility

          query = "topic:qooxdoo-contrib fork:true";

          if (update_repo_only) {
            query += " " + update_repo_only;
          }

          let result2 = await search.forRepositories({
            q: query
          });
          let repos = result.data.concat(result2.data);
          let repo_lookup = {};
          let repos_data = self.getCache().repos.data; // iterate over repositories

          for (let repo of repos) {
            let name = repo.full_name; // already dealt with

            if (repo_lookup[name]) {
              continue;
            }

            repo_lookup[name] = repo; // if a repository name has been given, only update this repo

            if (update_repo_only && name !== update_repo_only) {
              continue;
            }

            if (argv.verbose) {
              qx.tool.compiler.Console.info(`### Found ${name} ...`);
            }

            names.push(name);
            let repository = new Repository(name, auth);
            repos_data[name] = {
              description: repo.description,
              url: repo.url,
              releases: {
                list: [],
                data: {}
              }
            }; // get releases

            try {
              var releases_data = await repository.listReleases();
            } catch (e) {
              qx.tool.compiler.Console.error("Error retrieving releases: " + e);
              continue;
            } // filter releases to speed up updates


            let releases = releases_data.data // filter out invalid release names unless "--all-versions"
            .filter(r => argv["all-versions"] ? true : semver.valid(r.tag_name, true)) // attach a clean version number
            .map(r => {
              r.version = semver.valid(r.tag_name, true) || "0.0.0";
              return r;
            }) // sort by version number
            .sort((a, b) => semver.compare(a.version, b.version)) // use only the latest minor/patch unless "--all-versions"
            .filter((r, i, a) => r.version !== "0.0.0" && (argv["all-versions"] ? true : i === a.length - 1 || semver.major(a[i + 1].version) > semver.major(r.version)));
            let versions = releases.map(r => r.version);

            if (argv.verbose) {
              qx.tool.compiler.Console.info(`>>> Retrieved ${releases.length} release(s) of ${name}: ${versions.join(", ")}.`);
            } // get Manifest.json of each release to determine compatible qooxdoo versions


            for (let release of releases) {
              let tag_name = release.tag_name;
              let releases = repos_data[name].releases; // list of paths to manifest files, default is Manifest.json in the root dir

              let manifests = [{
                path: "."
              }]; // can be overridden by a qoxdoo.json in the root dir

              let qooxdoo_data;

              if (argv.verbose) {
                qx.tool.compiler.Console.log(`>>> Trying to retrieve 'qooxdoo.json' for ${name} ${tag_name}...`);
              }

              try {
                // @todo check if the method can return JSON to save parsing
                qooxdoo_data = await repository.getContents(tag_name, "qooxdoo.json", true);

                if (argv.verbose) {
                  qx.tool.compiler.Console.log(`>>>  File exists, checking for libraries...`);
                }

                let data = qooxdoo_data.data;

                if (typeof data == "string") {
                  try {
                    data = qx.tool.utils.Json.parseJson(data);
                  } catch (e) {
                    if (argv.verbose) {
                      qx.tool.compiler.Console.warn(`!!!  Parse error: ${e.message}`);
                    }
                  }
                } // we have a list of Manifest.json paths!


                manifests = data.libraries || data.contribs; // to do remove data.contribs. eventually, only there for BC
              } catch (e) {
                // no qooxdoo.json
                if (e.message.match(/404/)) {
                  if (argv.verbose) {
                    qx.tool.compiler.Console.log(`>>> No qooxdoo.json`);
                  }
                } else if (argv.verbose) {
                  qx.tool.compiler.Console.warn(`!!! Error: ${e.message}`);
                }
              } // create a list of libraries via their manifests


              for (let [index, {
                path: manifest_path
              }] of manifests.entries()) {
                let manifest_data;
                manifest_path = path.join(manifest_path, qx.tool.config.Manifest.config.fileName);

                try {
                  if (argv.verbose) {
                    qx.tool.compiler.Console.log(`>>> Retrieving Manifest file '${manifest_path}' for ${name} ${tag_name}...`);
                  }

                  manifest_data = await repository.getContents(tag_name, manifest_path, true);
                } catch (e) {
                  if (e.message.match(/404/)) {
                    if (argv.verbose) {
                      qx.tool.compiler.Console.warn(`!!!  File does not exist.`);
                    }
                  } else if (argv.verbose) {
                    qx.tool.compiler.Console.warn(`!!! Error: ${e.message}`);
                  }

                  continue;
                } // retrieve compatible qooxdoo versions


                let data = manifest_data.data; // @todo check if the method can return JSON to save parsing

                if (typeof data == "string") {
                  try {
                    data = qx.tool.utils.Json.parseJson(data);
                  } catch (e) {
                    if (argv.verbose) {
                      qx.tool.compiler.Console.warn(`!!! Parse error: ${e.message}`);
                      qx.tool.compiler.Console.log(data);
                    }

                    continue;
                  }
                } // qooxdoo version @deprecated


                var qx_versions = data.info["qooxdoo-versions"]; // @deprecated

                var qx_version_range = data.requires && (data.requires["@qooxdoo/framework"] || data.requires["qooxdoo-sdk"]) || data.info["qooxdoo-range"];

                if (argv.verbose && data.info["qooxdoo-range"]) {
                  qx.tool.compiler.Console.warn(`!!! info.qooxdoo-range is deprecated. Please use the requires["@qooxdoo/framework"] key instead.`);
                }

                if (argv.verbose && data.requires && data.requires["qooxdoo-sdk"]) {
                  qx.tool.compiler.Console.warn(`!!! requires["qooxdoo-sdk"] is deprecated. Please use the requires["@qooxdoo/framework"] key instead.`);
                } // provide backwards-compatibility for info.qooxdoo-versions containing the semver range
                // (to be removed)


                if (typeof qx_versions == "string" && !qx_version_range) {
                  qx_version_range = qx_versions;

                  if (argv.verbose) {
                    qx.tool.compiler.Console.warn(`!!! info.qooxdoo-version is deprecated. Please use the requires["@qooxdoo/framework"] key instead.`);
                  }
                } // provide backwards-compatibility for info.qooxdoo-version


                if (qx_versions instanceof Array && qx_versions.length && !qx_version_range) {
                  qx_version_range = qx_versions.join(" || ");

                  if (argv.verbose) {
                    qx.tool.compiler.Console.warn(`!!! Manifest key 'info.qooxdoo-version' is deprecated. Please use the requires["@qooxdoo/framework"] key instead.`);
                  }
                }

                if (!qx_version_range) {
                  if (argv.verbose) {
                    qx.tool.compiler.Console.warn(`!!! No compatibility information, skipping...`);
                  }

                  continue;
                }

                if (!semver.validRange(qx_version_range, {
                  loose: true
                })) {
                  if (argv.verbose) {
                    qx.tool.compiler.Console.warn(`!!! Invalid compatibility information, skipping...`);
                  }

                  continue;
                } // add information to manifest index


                qx_versions = qx_version_range;
                manifests[index] = {
                  path: manifest_path,
                  qx_versions,
                  info: data.info,
                  requires: data.requires,
                  provides: data.provides
                };
                num_libraries++;

                if (argv.verbose) {
                  qx.tool.compiler.Console.log(`>>> ${name} ${tag_name}: Found package '${data.info.name}' (compatible with ${qx_versions})`);
                } else if (!argv.quiet) {
                  process.stdout.write("."); // output dots to indicate progress
                }
              } // end iteration over manifests
              // save data in cache


              let zip_url = `https://github.com/${name}/archive/${tag_name}.zip`;
              releases.list.push(tag_name);
              releases.data[tag_name] = {
                id: release.id,
                published_at: release.published_at,
                comment: release.body,
                title: release.name,
                prerelease: release.prerelease,
                manifests,
                zip_url
              };
            } // end iteration over releases

          } // end iteration over repos
          // wrap-up


          self.getCache().version = qx.tool.config.Lockfile.getInstance().getVersion();
          self.getCache().num_libraries = num_libraries;

          if (!update_repo_only) {
            self.getCache().repos.list = names.sort();
          }

          if (!argv.quiet && !argv.verbose) {
            process.stdout.write("\n");
          }
        }
      }
    }
  });
  qx.tool.cli.commands.package.Update.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.tool.cli.commands.Package": {
        "require": true
      },
      "qx.tool.compiler.Console": {},
      "qx.tool.utils.Utils": {},
      "qx.lang.Type": {},
      "qx.tool.config.Manifest": {},
      "qx.tool.utils.Json": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
     2017 Christian Boulanger
  
     License:
     MIT: https://opensource.org/licenses/MIT
     See the LICENSE file in the project's top-level directory for details.
  
     Authors:
     * Christian Boulanger (info@bibliograph.org, @cboulanger)
  
  ************************************************************************ */
  const semver = require("semver");

  const columnify = require("columnify");

  const path = require("upath");
  /**
   * Lists compatible packages
   */


  qx.Class.define("qx.tool.cli.commands.package.List", {
    extend: qx.tool.cli.commands.Package,
    statics: {
      /**
       * The name of a "fake" repository containing libraries from local paths
       */
      localPathRepoName: "_local_",

      /**
       * Returns the yargs command data
       * @return {Object}
       */
      getYargsCommand: function () {
        return {
          command: "list [repository]",
          describe: "if no repository name is given, lists all available packages that are compatible with the project's qooxdoo version (\"--all\" lists incompatible ones as well). Otherwise, list all compatible packages.",
          builder: {
            all: {
              alias: "a",
              describe: "Show all versions, including incompatible ones"
            },
            verbose: {
              alias: "v",
              describe: "Verbose logging"
            },
            quiet: {
              alias: "q",
              describe: "No output"
            },
            json: {
              alias: "j",
              describe: "Output list as JSON literal"
            },
            installed: {
              alias: "i",
              describe: "Show only installed libraries"
            },
            namespace: {
              alias: "n",
              describe: "Display library namespace"
            },
            match: {
              alias: "m",
              describe: "Filter by regular expression (case-insensitive)"
            },
            "libraries": {
              alias: "l",
              describe: "List libraries only (no repositories)"
            },
            "short": {
              alias: "s",
              describe: "Omit title and description to make list more compact"
            },
            "noheaders": {
              alias: "H",
              describe: "Omit header and footer"
            },
            "prereleases": {
              alias: "p",
              describe: "Include prereleases into latest compatible releases"
            },
            "uris-only": {
              alias: "u",
              describe: "Output only the GitHub URIs of the packages which are used to install the packages. Implies --noheaders and --libraries."
            }
          }
        };
      }
    },
    members: {
      /**
       * Lists library packages compatible with the current project
       */
      process: async function () {
        await qx.tool.cli.commands.package.List.prototype.process.base.call(this);
        this.__P_18_0 = [];
        this.__P_18_1 = {};
        this.__P_18_2 = {};
        const localPathRepoName = qx.tool.cli.commands.package.List.localPathRepoName;
        let repos_cache = this.getCache().repos; // implicit qx package update, disabled
        // if (repos_cache.list.length === 0 || this.getCache().version !== qx.tool.config.Lockfile.getInstance().getVersion()) {
        //   await (new qx.tool.cli.commands.package.Update({quiet:true})).process();
        // }

        let qooxdoo_version = await this.getUserQxVersion();
        let num_compat_repos = await this.__P_18_3(qooxdoo_version);

        if (this.argv.verbose) {
          qx.tool.compiler.Console.log(`>>> We have ${num_compat_repos} packages compatible with qooxdoo version ${qooxdoo_version}`);
        }

        if (num_compat_repos === 0 && !this.argv.all && !this.argv.quiet) {
          qx.tool.compiler.Console.info(`Currently, no packages compatible with qooxdoo version ${qooxdoo_version} exist.`);
          return;
        } // detailed repo information


        let repo = this.argv.repository;

        if (repo) {
          if (!repos_cache.list.includes(repo)) {
            throw new qx.tool.utils.Utils.UserError(`Repository ${repo} does not exist or is not a qooxdoo package repo.`);
          }

          if (this.__P_18_1[repo] && this.__P_18_1[repo].length) {
            let columnify_options = {
              columnSplitter: "   ",
              config: {
                description: {
                  maxWidth: 60
                },
                compatibility: {
                  dataTransform: function (data) {
                    switch (data) {
                      case "false":
                        return "not compatible / untested";

                      case "true":
                        return "√";

                      default:
                        return "";
                    }
                  }
                },
                installedVersion: {
                  dataTransform: function (data) {
                    switch (data) {
                      case "false":
                        return "-";

                      default:
                        return data;
                    }
                  }
                }
              }
            };

            if (!this.argv.quiet) {
              let data = this.__P_18_1[repo] // shallow copy
              .map(row => Object.assign({}, row)) // sort
              .sort((a, b) => a.name.localeCompare(b.name));

              let pretty = data // another shallow copy
              .map(row => Object.assign({}, row)) // clean up and omit redundant cell values
              .map((row, index) => {
                delete row.manifest;

                if (index) {
                  let previousRow = data[index - 1];

                  for (let key of Object.getOwnPropertyNames(row).reverse()) {
                    if (["compatibility", "required_qx_version"].indexOf(key) > -1) {
                      continue;
                    }

                    if (row[key] === previousRow[key] && row.name === previousRow.name) {
                      row[key] = "";
                    }
                  }
                }

                return row;
              }); // output list

              if (this.argv.json) {
                // as JSON
                qx.tool.compiler.Console.info(JSON.stringify(data, null, 2));
              } else {
                qx.tool.compiler.Console.info(columnify(pretty, columnify_options));
              }
            }
          } else if (this.argv.verbose) {
            qx.tool.compiler.Console.info(`Repository ${repo} does not contain suitable qooxdoo libraries.`);
          }

          return;
        } // list output


        let columns;

        if (this.argv.urisOnly) {
          columns = ["uri"];
          this.argv.noheaders = true;
          this.argv.libraries = true;
        } else if (this.argv.short) {
          columns = ["uri", "installedVersion", "latestVersion", "latestCompatible"];
        } else {
          columns = ["uri", "name", "description", "installedVersion", "latestVersion", "latestCompatible"];
        }

        if (this.argv.namespace || this.argv.installed) {
          columns.splice(1, 0, "namespace");
        }

        let columnify_options = {
          showHeaders: !this.argv.noheaders,
          columnSplitter: "   ",
          columns,
          config: {
            name: {
              maxWidth: 25
            },
            description: {
              maxWidth: 60
            },
            installedVersion: {
              headingTransform: () => "INSTALLED",
              dataTransform: data => data === "false" ? "" : data
            },
            latestVersion: {
              headingTransform: () => "LATEST",
              dataTransform: data => data === "false" ? "-" : data
            },
            latestCompatible: {
              headingTransform: () => "COMPATIBLE",
              dataTransform: data => data === "false" ? "-" : data
            }
          }
        }; // filter by compatibility unless --all

        let list = this.argv.all ? this.__P_18_0 : this.__P_18_0.filter(item => item.latestCompatible || this.argv.installed && item.name === localPathRepoName); // sort

        list.sort((l, r) => {
          l = l.name.toLowerCase();
          r = r.name.toLowerCase();
          return l < r ? -1 : l > r ? 1 : 0;
        }); // list all libraries contained in a repo

        let expanded_list = [];

        for (let repo of list) {
          let repo_libs = [];

          if (!qx.lang.Type.isArray(this.__P_18_1[repo.name])) {
            continue;
          }

          for (let library of this.__P_18_1[repo.name]) {
            if (!semver.valid(library.version)) {
              if (this.argv.verbose) {
                qx.tool.compiler.Console.warn(`>>> Ignoring '${repo.name}' ${library.name}': invalid version format '${library.version}'.`);
              }

              continue;
            }

            if (repo.name === localPathRepoName || semver.eq(library.version, repo.latestVersion)) {
              let uri = repo.name === qx.tool.cli.commands.package.List.localPathRepoName ? library.path : path.join(repo.name, library.path || "");
              repo_libs.push({
                type: "library",
                uri,
                namespace: library.namespace,
                name: library.name,
                description: library.summary || repo.description,
                installedVersion: library.installedVersion,
                latestVersion: repo.latestVersion,
                latestCompatible: repo.latestCompatible,
                manifest: library.manifest
              });
            }
          } // add title to multiple-library repos


          if (repo_libs.length > 1 && !(this.argv.libraries || this.argv.short || repo.name === localPathRepoName)) {
            expanded_list.push({
              type: "repository",
              uri: repo.name,
              name: "",
              description: repo.description,
              installedVersion: "",
              latestVersion: repo.latestVersion,
              latestCompatible: repo.latestCompatible
            });

            if (!this.argv.json && !this.argv.installed && !this.argv.match && !this.argv.urisOnly) {
              // add an indent to group libraries in a repository
              repo_libs = repo_libs.map(lib => {
                lib.uri = "| " + lib.uri;
                return lib;
              });
            }
          }

          expanded_list = expanded_list.concat(repo_libs);
        } // filter by regular expression if requested


        if (this.argv.match) {
          let exp = new RegExp(this.argv.match, "i");
          expanded_list = expanded_list.filter(lib => lib.uri.match(exp) || lib.name.match(exp) || lib.description.match(exp));
        } // show only installed libraries if requested


        if (this.argv.installed) {
          expanded_list = expanded_list.filter(lib => Boolean(lib.installedVersion));
        } // output list


        if (this.argv.json) {
          // as JSON
          qx.tool.compiler.Console.info(JSON.stringify(expanded_list, null, 2));
        } else if (!this.argv.quiet) {
          // as columns
          qx.tool.compiler.Console.info(columnify(expanded_list, columnify_options));

          if (!this.argv.noheaders) {
            qx.tool.compiler.Console.info();
            qx.tool.compiler.Console.info("Note on columns: LATEST: Latest release that can be installed with this CLI;");
            qx.tool.compiler.Console.info("                 COMPATIBLE: Latest release that is semver-compatible with the qooxdoo version used.");

            if (!this.argv.all) {
              qx.tool.compiler.Console.info("To see all libraries, including potentially incompatible ones, use 'qx package list --all'.");
            }
          }
        } // save to cache


        this.getCache().compat[qooxdoo_version] = this.__P_18_2[qooxdoo_version];
        await this.saveCache();
      },

      /**
       * compatibility indexes
       */
      __P_18_0: null,
      __P_18_1: null,
      __P_18_2: null,

      /**
       * Create compatibilty indexes of repositories and the contained libraries
       * @param qooxdoo_version {String} The qooxdoo version to check compatibiity with
       * @return {Number} The number of repositories containing compatible libraries
       */
      __P_18_3: async function (qooxdoo_version) {
        if (this.argv.installed) {
          // local libraries
          const localPathRepoName = qx.tool.cli.commands.package.List.localPathRepoName;

          this.__P_18_0.push({
            name: localPathRepoName,
            description: "Libraries on local filesystem"
          });

          this.__P_18_1[localPathRepoName] = [];
          let libData = await this.getLockfileData();

          for (let lib of libData.libraries) {
            if (!lib.repo_name) {
              let manifest_path = path.join(process.cwd(), lib.path, qx.tool.config.Manifest.config.fileName);
              let manifest = await qx.tool.utils.Json.loadJsonAsync(manifest_path);
              let info = manifest.info;

              this.__P_18_1[localPathRepoName].push({
                name: info.name,
                namespace: manifest.provides.namespace,
                summary: info.summary,
                version: "v" + info.version,
                compatibility: semver.satisfies(qooxdoo_version, manifest.requires["qooxdoo-sdk"], true),
                path: path.relative(process.cwd(), path.dirname(manifest_path)),
                installedVersion: "v" + info.version,
                manifest
              });
            }
          }
        } // repositories


        let repos_cache = this.getCache().repos;
        let num_compat_repos = 0;

        if (this.__P_18_2[qooxdoo_version] === undefined) {
          this.__P_18_2[qooxdoo_version] = {};
        } // iterate over repositories


        for (let repo_name of repos_cache.list) {
          let repo_data = repos_cache.data[repo_name]; // filter out repositories that are deprecated or should not be listed unless --all

          let d = repo_data.description;

          if (!this.argv.all && d && (d.includes("(deprecated)") || d.includes("(unlisted)"))) {
            if (this.argv.verbose) {
              qx.tool.compiler.Console.warn(`>>> Ignoring ${repo_name}: Deprecated or unlisted. `);
            }

            continue;
          }

          let tag_names = repo_data.releases.list;
          let {
            description
          } = repo_data;
          let hasCompatibleRelease = false;
          let latestVersion = false;
          let repoInstalledVersion = false; // iterate over releases

          for (let tag_name of tag_names) {
            let release_data = repo_data.releases.data[tag_name];
            let {
              prerelease,
              manifests
            } = release_data; // iterate over library manifests in that release

            for (let manifest of manifests) {
              let {
                qx_versions,
                info,
                provides,
                path: manifest_path
              } = manifest;
              let installedVersion = false;

              if (info === undefined) {
                if (this.argv.verbose) {
                  qx.tool.compiler.Console.warn(`>>> Ignoring ${repo_name} ${tag_name}: Undefined info field. `);
                }

                continue;
              } // library version MUST match tag name (which can be longer, for example with pre-release info (alpha, beta, pre, rc etc)


              let library_name = info.name;
              let version = info.version;
              let tag_version = tag_name.replace(/v/, "");

              if (version !== tag_version.substr(0, version.length)) {
                if (this.argv.verbose) {
                  qx.tool.compiler.Console.warn(`>>> Ignoring ${repo_name} ${tag_name}, library '${library_name}': mismatch between tag version '${tag_version}' and library version '${version}'.`);
                }

                continue;
              } // save latest version


              try {
                if (!latestVersion || semver.gt(version, latestVersion, true)) {
                  latestVersion = tag_name;
                }
              } catch (e) {
                if (this.argv.verbose) {
                  qx.tool.compiler.Console.warn(`>>> Ignoring ${repo_name} ${tag_name}, library '${library_name}': invalid version format '${version}'.`);
                }
              } // installed from GitHub?


              let installed = await this.getInstalledLibraryTag(repo_name, library_name);

              if (installed) {
                installedVersion = installed;
                repoInstalledVersion = installed;
              } else {
                let lib = await this.getInstalledLibraryData(library_name);

                if (lib) {
                  installedVersion = "v" + lib.library_version;
                }
              } // check compatibility of library


              let compatibility = semver.satisfies(qooxdoo_version, qx_versions, true); // prepare indexes

              if (this.__P_18_1[repo_name] === undefined) {
                this.__P_18_1[repo_name] = [];
              } // use the latest compatible release, i.e the one that satisfies the following conditions:
              // 1) must be semver-compatible with the qooxdoo version
              // 2) must be the higher than any other version found so far
              // 3) should not be a pre-release unless there are no other compatible releases


              let latestCompatibleRelease = this.__P_18_2[qooxdoo_version][repo_name];
              let latestCompatibleVersion = latestCompatibleRelease ? latestCompatibleRelease.replace(/v/, "") : undefined;

              if (compatibility === true && (latestCompatibleRelease === undefined || semver.gt(tag_version, latestCompatibleVersion, false) && (!prerelease || this.argv.prereleases))) {
                this.__P_18_2[qooxdoo_version][repo_name] = tag_name;
                hasCompatibleRelease = true;
              } // save data


              this.__P_18_1[repo_name].push({
                name: info.name,
                namespace: provides ? provides.namespace : "",
                summary: info.summary,
                version,
                compatibility,
                required_qx_version: qx_versions,
                path: path.dirname(manifest_path),
                installedVersion,
                manifest
              });
            }
          }

          if (hasCompatibleRelease) {
            num_compat_repos++;
          } // add to list


          this.__P_18_0.push({
            name: repo_name,
            description,
            installedVersion: repoInstalledVersion,
            latestVersion,
            latestCompatible: hasCompatibleRelease ? this.__P_18_2[qooxdoo_version][repo_name] : false
          });
        }

        return num_compat_repos;
      }
    }
  });
  qx.tool.cli.commands.package.List.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "require": true
      },
      "qx.Promise": {},
      "qx.tool.utils.Utils": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
   *
   *    qooxdoo-compiler - node.js based replacement for the Qooxdoo python
   *    toolchain
   *
   *    https://github.com/qooxdoo/qooxdoo-compiler
   *
   *    Copyright:
   *      2011-2017 Zenesis Limited, http://www.zenesis.com
   *
   *    License:
   *      MIT: https://opensource.org/licenses/MIT
   *
   *      This software is provided under the same licensing terms as Qooxdoo,
   *      please see the LICENSE file in the Qooxdoo project's top-level directory
   *      for details.
   *
   *    Authors:
   *      * John Spackman (john.spackman@zenesis.com, @johnspackman)
   *
   * *********************************************************************** */
  const fs = require("fs");

  const path = require("path");

  const rimraf = require("rimraf");

  const {
    promisify
  } = require("util");

  const stat = promisify(fs.stat);
  const mkdir = promisify(fs.mkdir);
  const readdir = promisify(fs.readdir);
  const rename = promisify(fs.rename);
  qx.Class.define("qx.tool.utils.files.Utils", {
    extend: qx.core.Object,
    statics: {
      async findAllFiles(dir, fnEach) {
        let filenames;

        try {
          filenames = await readdir(dir);
        } catch (ex) {
          if (ex.code == "ENOENT") {
            return;
          }

          throw ex;
        }

        await qx.Promise.all(filenames.map(async shortName => {
          let filename = path.join(dir, shortName);
          let tmp = await stat(filename);

          if (tmp.isDirectory()) {
            await qx.tool.utils.files.Utils.findAllFiles(filename, fnEach);
          } else {
            await fnEach(filename);
          }
        }));
      },

      /**
       * Synchronises two files or folders; files are copied from/to but only if their
       * modification time or size has changed.
       * @param from {String} path to copy from
       * @param to {String} path to copy to
       * @param filter {Function?} optional filter method to validate filenames before sync
       * @async
       */
      sync: function (from, to, filter) {
        var t = this;

        function copy(statFrom, statTo) {
          if (statFrom.isDirectory()) {
            var p;

            if (statTo === null) {
              p = mkdir(to);
            } else {
              p = Promise.resolve();
            }

            return p.then(() => readdir(from).then(files => Promise.all(files.map(file => t.sync(from + "/" + file, to + "/" + file, filter)))));
          } else if (statFrom.isFile()) {
            return qx.Promise.resolve(filter ? filter(from, to) : true).then(result => result && t.copyFile(from, to));
          }

          return undefined;
        }

        return new Promise((resolve, reject) => {
          var statFrom = null;
          var statTo = null;
          stat(from).then(tmp => {
            statFrom = tmp;
            return stat(to).then(tmp => statTo = tmp).catch(err => {
              if (err.code !== "ENOENT") {
                throw err;
              }
            });
          }).then(() => {
            if (!statTo || statFrom.isDirectory() != statTo.isDirectory()) {
              return t.deleteRecursive(to).then(() => copy(statFrom, statTo));
            } else if (statFrom.isDirectory() || statFrom.mtime.getTime() > statTo.mtime.getTime() || statFrom.size != statTo.size) {
              return copy(statFrom, statTo);
            }

            return undefined;
          }).then(resolve).catch(reject);
        });
      },

      /**
       * Copies a file
       * @param from {String} path to copy from
       * @param to {String} path to copy to
       * @async
       */
      copyFile: function (from, to) {
        return new Promise((resolve, reject) => {
          qx.tool.utils.Utils.mkParentPath(to, function () {
            var rs = fs.createReadStream(from, {
              flags: "r",
              encoding: "binary"
            });
            var ws = fs.createWriteStream(to, {
              flags: "w",
              encoding: "binary"
            });
            rs.on("end", function () {
              resolve();
            });
            rs.on("error", reject);
            ws.on("error", reject);
            rs.pipe(ws);
          });
        });
      },

      /**
       * Returns the stats for a file, or null if the file does not exist
       *
       * @param filename
       * @returns {fs.Stat}
       * @async
       */
      safeStat: function (filename) {
        return new Promise((resolve, reject) => {
          fs.stat(filename, function (err, stats) {
            if (err && err.code != "ENOENT") {
              reject(err);
            } else {
              resolve(err ? null : stats);
            }
          });
        });
      },

      /**
       * Deletes a file, does nothing if the file does not exist
       *
       * @param filename {String} file to delete
       * @async
       */
      safeUnlink: function (filename) {
        return new Promise((resolve, reject) => {
          fs.unlink(filename, function (err) {
            if (err && err.code != "ENOENT") {
              reject(err);
            } else {
              resolve();
            }
          });
        });
      },

      /**
       * Renames a file, does nothing if the file does not exist
       *
       * @param from {String} file to rename
       * @param to {String} new filename
       * @async
       */
      safeRename: function (from, to) {
        return new Promise((resolve, reject) => {
          fs.rename(from, to, function (err) {
            if (err && err.code != "ENOENT") {
              reject(err);
            } else {
              resolve();
            }
          });
        });
      },

      /**
       * Rotates files so that this file does not exist, by renaming the existing file to have a ".1"
       * appended, and the ".1" to be renamed to ".2" etc, up to `length` versions
       *
       * @param filename {String} filename to rotate
       * @param length {Integer} maximum number of files
       * @async
       */
      rotateUnique: async function (filename, length) {
        if ((await this.safeStat(filename)) && length > 1) {
          var lastFile = null;

          for (var i = length; i > 0; i--) {
            var tmp = filename + "." + i;

            if (i == length) {
              await this.safeUnlink(tmp);
            } else if (await this.safeStat(tmp)) {
              await rename(tmp, lastFile);
            }

            lastFile = tmp;
          }

          await rename(filename, lastFile);
        }
      },

      /**
       * Deletes a file or directory; directories are recursively removed
       * @param name {String} file or dir to delete
       * @async
       */
      deleteRecursive: function (name) {
        return new Promise((resolve, reject) => {
          rimraf(name, err => {
            if (err) {
              reject(err);
            } else {
              resolve();
            }
          });
        });
      },

      /**
       * Normalises the path and corrects the case of the path to match what is actually on the filing system
       *
       * @param dir {String} the filename to normalise
       * @returns {String} the new path
       * @async
       */
      correctCase: function (dir) {
        var drivePrefix = "";

        if (process.platform === "win32" && dir.match(/^[a-zA-Z]:/)) {
          drivePrefix = dir.substring(0, 2);
          dir = dir.substring(2);
        }

        dir = dir.replace(/\\/g, "/");
        var segs = dir.split("/");

        if (!segs.length) {
          return drivePrefix + dir;
        }

        var currentDir;
        var index;

        if (segs[0].length) {
          currentDir = "";
          index = 0;
        } else {
          currentDir = "/";
          index = 1;
        }

        function bumpToNext(nextSeg) {
          index++;

          if (currentDir.length && currentDir !== "/") {
            currentDir += "/";
          }

          currentDir += nextSeg;
          return next();
        }

        function next() {
          if (index == segs.length) {
            if (process.platform === "win32") {
              currentDir = currentDir.replace(/\//g, "\\");
            }

            return Promise.resolve(drivePrefix + currentDir);
          }

          let nextSeg = segs[index];

          if (nextSeg == "." || nextSeg == "..") {
            return bumpToNext(nextSeg);
          }

          return new Promise((resolve, reject) => {
            fs.readdir(currentDir.length == 0 ? "." : drivePrefix + currentDir, {
              encoding: "utf8"
            }, (err, files) => {
              if (err) {
                reject(err);
                return;
              }

              let nextLowerCase = nextSeg.toLowerCase();
              let exact = false;
              let insensitive = null;

              for (let i = 0; i < files.length; i++) {
                if (files[i] === nextSeg) {
                  exact = true;
                  break;
                }

                if (files[i].toLowerCase() === nextLowerCase) {
                  insensitive = files[i];
                }
              }

              if (!exact && insensitive) {
                nextSeg = insensitive;
              }

              bumpToNext(nextSeg).then(resolve);
            });
          });
        }

        return new Promise((resolve, reject) => {
          fs.stat(drivePrefix + dir, err => {
            if (err) {
              if (err.code == "ENOENT") {
                resolve(drivePrefix + dir);
              } else {
                reject(err);
              }
            } else {
              next().then(resolve);
            }
          });
        });
      }
    }
  });
  qx.tool.utils.files.Utils.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.tool.utils.Promisify": {
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.Promise": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
   *
   *    qooxdoo-compiler - node.js based replacement for the Qooxdoo python
   *    toolchain
   *
   *    https://github.com/qooxdoo/qooxdoo-compiler
   *
   *    Copyright:
   *      2011-2019 Zenesis Limited, http://www.zenesis.com
   *
   *    License:
   *      MIT: https://opensource.org/licenses/MIT
   *
   *      This software is provided under the same licensing terms as Qooxdoo,
   *      please see the LICENSE file in the Qooxdoo project's top-level directory
   *      for details.
   *
   *    Authors:
   *      * John Spackman (john.spackman@zenesis.com, @johnspackman)
   *
   * *********************************************************************** */

  /**
   * @ignore(require)
   */

  /* eslint-disable @qooxdoo/qx/no-illegal-private-usage */
  const fs = qx.tool.utils.Promisify.fs;

  const path = require("upath");

  const nodeSass = require("node-sass");
  /**
   * @ignore(process)
   */


  qx.Class.define("qx.tool.compiler.resources.ScssFile", {
    extend: qx.core.Object,
    construct: function (target, library, filename) {
      qx.core.Object.constructor.call(this);
      this.__P_36_0 = library;
      this.__filename = filename;
      this.__P_36_1 = target;
      this.__P_36_2 = {};
      this.__P_36_3 = {};
    },
    properties: {
      file: {
        nullable: false,
        check: "String",
        event: "changeFile"
      },
      themeFile: {
        init: false,
        check: "Boolean"
      }
    },
    members: {
      __P_36_0: null,
      __filename: null,
      __P_36_4: null,
      __P_36_5: null,
      __P_36_2: null,
      __P_36_3: null,

      /**
       * Compiles the SCSS, returns a list of files that were imported)
       * 
       * @param outputFilename {String} output
       * @return {String[]} dependent files
       */
      async compile(outputFilename) {
        this.__P_36_4 = path.dirname(outputFilename);
        this.__P_36_5 = {};
        let inputFileData = await this.loadSource(this.__filename, this.__P_36_0);
        await new qx.Promise((resolve, reject) => {
          nodeSass.render({
            // Always have file so that the source map knows the name of the original
            file: this.__filename,
            // data provides the contents, `file` is only used for the sourcemap filename
            data: inputFileData,
            outputStyle: "compressed",
            sourceMap: true,
            outFile: path.basename(outputFilename),

            /*
             * Importer
             */
            importer: (url, prev, done) => {
              let contents = this.__P_36_2[url];

              if (!contents) {
                let tmp = this.__P_36_3[url];

                if (tmp) {
                  contents = this.__P_36_2[tmp];
                }
              }

              return contents ? {
                contents
              } : null;
            },
            functions: {
              "qooxdooUrl($filename, $url)": ($filename, $url, done) => this.__P_36_6($filename, $url, done)
            }
          }, (error, result) => {
            if (error) {
              this.error("Error status " + error.status + " in " + this.__filename + "[" + error.line + "," + error.column + "]: " + error.message);
              resolve(error); // NOT reject

              return;
            }

            fs.writeFileAsync(outputFilename, result.css.toString(), "utf8").then(() => fs.writeFileAsync(outputFilename + ".map", result.map.toString(), "utf8")).then(() => resolve(null)).catch(reject);
          });
        });
        return Object.keys(this.__P_36_2);
      },

      _analyseFilename(url, currentFilename) {
        var m = url.match(/^([a-z0-9_.]+):(\/?[^\/].*)/);

        if (m) {
          return {
            namespace: m[1],
            filename: m[2],
            externalUrl: null
          };
        } // It's a real URL like http://abc.com/..


        if (url.match(/^[a-z0-9_]+:\/\//)) {
          return {
            externalUrl: url
          };
        } // It's either absolute to the website (i.e. begins with a slash) or it's
        //  relative to the current file


        if (url[0] == "/") {
          return {
            namespace: null,
            filename: url
          };
        } // Must be relative to current file


        let dir = path.dirname(currentFilename);
        let filename = path.resolve(dir, url);

        let library = this.__P_36_1.getAnalyser().getLibraries().find(library => filename.startsWith(path.resolve(library.getRootDir())));

        if (!library) {
          this.error("Cannot find library for " + url + " in " + currentFilename);
          return null;
        }

        let libResourceDir = path.join(library.getRootDir(), this.isThemeFile() ? library.getThemePath() : library.getResourcePath());
        return {
          namespace: library.getNamespace(),
          filename: path.relative(libResourceDir, filename),
          externalUrl: null
        };
      },

      reloadSource(filename) {
        filename = path.resolve(filename);
        delete this.__P_36_2[filename];
        return this.loadSource(filename);
      },

      async loadSource(filename, library) {
        filename = path.relative(process.cwd(), path.resolve(this.isThemeFile() ? library.getThemeFilename(filename) : library.getResourceFilename(filename)));
        let absFilename = filename;

        if (path.extname(absFilename) == "") {
          absFilename += ".scss";
        }

        let exists = fs.existsSync(absFilename);

        if (!exists) {
          let name = path.basename(absFilename);

          if (name[0] != "_") {
            let tmp = path.join(path.dirname(absFilename), "_" + name);
            exists = fs.existsSync(tmp);

            if (exists) {
              absFilename = tmp;
            }
          }
        }

        if (!exists) {
          this.__P_36_2[absFilename] = null;
          return null;
        }

        if (this.__P_36_2[absFilename] !== undefined) {
          return qx.Promise.resolve(this.__P_36_2[absFilename]);
        }

        let contents = await fs.readFileAsync(absFilename, "utf8");
        let promises = [];
        contents = contents.replace(/@import\s+["']([^;]+)["']/ig, (match, p1, offset) => {
          let pathInfo = this._analyseFilename(p1, absFilename);

          if (pathInfo.externalUrl) {
            return "@import \"" + pathInfo.externalUrl + "\"";
          }

          let newLibrary = this.__P_36_1.getAnalyser().findLibrary(pathInfo.namespace);

          if (!newLibrary) {
            this.error("Cannot find file to import, url=" + p1 + " in file " + absFilename);
            return null;
          }

          promises.push(this.loadSource(pathInfo.filename, newLibrary));
          return "@import \"" + path.relative(process.cwd(), newLibrary.getResourceFilename(pathInfo.filename)) + "\"";
        });
        contents = contents.replace(/\burl\s*\(\s*([^\)]+)*\)/ig, (match, url) => {
          let c = url[0];

          if (c === "\'" || c === "\"") {
            url = url.substring(1);
          }

          c = url[url.length - 1];

          if (c === "\'" || c === "\"") {
            url = url.substring(0, url.length - 1);
          } //return `qooxdooUrl("${filename}", "${url}")`;


          let pathInfo = this._analyseFilename(url, filename);

          if (pathInfo) {
            if (pathInfo.externalUrl) {
              return `url("${pathInfo.externalUrl}")`;
            }

            if (pathInfo.namespace) {
              let targetFile = path.relative(process.cwd(), path.join(this.__P_36_1.getOutputDir(), "resource", pathInfo.filename));
              let relative = path.relative(this.__P_36_4, targetFile);
              return `url("${relative}")`;
            }
          }

          return `url("${url}")`;
        });
        this.__P_36_2[absFilename] = contents;
        this.__P_36_3[filename] = absFilename;
        await qx.Promise.all(promises);
        return contents;
      },

      getSourceFilenames() {
        return Object.keys(this.__P_36_2);
      },

      __P_36_6($filename, $url, done) {
        let currentFilename = $filename.getValue();
        let url = $url.getValue();

        let pathInfo = this._analyseFilename(url, currentFilename);

        if (pathInfo) {
          if (pathInfo.externalUrl) {
            return nodeSass.types.String("url(" + pathInfo.externalUrl + ")");
          }

          if (pathInfo.namespace) {
            let targetFile = path.relative(process.cwd(), path.join(this.__P_36_1.getOutputDir(), "resource", pathInfo.filename));
            let relative = path.relative(this.__P_36_4, targetFile);
            return nodeSass.types.String("url(" + relative + ")");
          }
        }

        return nodeSass.types.String("url(" + url + ")");
      }

    }
  });
  qx.tool.compiler.resources.ScssFile.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Environment": {
        "defer": "runtime"
      }
    },
    "environment": {
      "provided": ["device.name", "device.touch", "device.type", "device.pixelRatio"],
      "required": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * The class is responsible for device detection. This is specially useful
   * if you are on a mobile device.
   *
   * This class is used by {@link qx.core.Environment} and should not be used
   * directly. Please check its class comment for details how to use it.
   *
   * @internal
   */
  qx.Bootstrap.define("qx.bom.client.Device", {
    statics: {
      /** Maps user agent names to device IDs */
      __P_82_0: {
        "Windows Phone": "iemobile",
        "iPod": "ipod",
        "iPad": "ipad",
        "iPhone": "iphone",
        "PSP": "psp",
        "PLAYSTATION 3": "ps3",
        "Nintendo Wii": "wii",
        "Nintendo DS": "ds",
        "XBOX": "xbox",
        "Xbox": "xbox"
      },

      /**
       * Returns the name of the current device if detectable. It falls back to
       * <code>pc</code> if the detection for other devices fails.
       *
       * @internal
       * @return {String} The string of the device found.
       */
      getName: function () {
        var str = [];

        for (var key in qx.bom.client.Device.__P_82_0) {
          str.push(key);
        }

        var reg = new RegExp("(" + str.join("|").replace(/\./g, "\.") + ")", "g");
        var match = reg.exec(navigator.userAgent);

        if (match && match[1]) {
          return qx.bom.client.Device.__P_82_0[match[1]];
        }

        return "pc";
      },

      /**
       * Determines on what type of device the application is running.
       * Valid values are: "mobile", "tablet" or "desktop".
       * @return {String} The device type name of determined device.
       */
      getType: function () {
        return qx.bom.client.Device.detectDeviceType(navigator.userAgent);
      },

      /**
       * Detects the device type, based on given userAgentString.
       *
       * @param userAgentString {String} userAgent parameter, needed for decision.
       * @return {String} The device type name of determined device: "mobile","desktop","tablet"
       */
      detectDeviceType: function (userAgentString) {
        if (qx.bom.client.Device.detectTabletDevice(userAgentString)) {
          return "tablet";
        } else if (qx.bom.client.Device.detectMobileDevice(userAgentString)) {
          return "mobile";
        }

        return "desktop";
      },

      /**
       * Detects if a device is a mobile phone. (Tablets excluded.)
       * @param userAgentString {String} userAgent parameter, needed for decision.
       * @return {Boolean} Flag which indicates whether it is a mobile device.
       */
      detectMobileDevice: function (userAgentString) {
        return /android.+mobile|ip(hone|od)|bada\/|blackberry|BB10|maemo|opera m(ob|in)i|fennec|NetFront|phone|psp|symbian|IEMobile|windows (ce|phone)|xda/i.test(userAgentString);
      },

      /**
       * Detects if a device is a tablet device.
       * @param userAgentString {String} userAgent parameter, needed for decision.
       * @return {Boolean} Flag which indicates whether it is a tablet device.
       */
      detectTabletDevice: function (userAgentString) {
        var isIE10Tablet = /MSIE 10/i.test(userAgentString) && /ARM/i.test(userAgentString) && !/windows phone/i.test(userAgentString);
        var isCommonTablet = !/android.+mobile|Tablet PC/i.test(userAgentString) && /Android|ipad|tablet|playbook|silk|kindle|psp/i.test(userAgentString);
        return isIE10Tablet || isCommonTablet;
      },

      /**
       * Detects the device's pixel ratio. Returns 1 if detection is not possible.
       *
       * @return {Number} The device's pixel ratio
       */
      getDevicePixelRatio: function () {
        if (typeof window.devicePixelRatio !== "undefined") {
          return window.devicePixelRatio;
        }

        return 1;
      },

      /**
       * Detects if either touch events or pointer events are supported.
       * Additionally it checks if touch is enabled for pointer events.
       *
       * @return {Boolean} <code>true</code>, if the device supports touch
       */
      getTouch: function () {
        return "ontouchstart" in window || window.navigator.maxTouchPoints > 0 || window.navigator.msMaxTouchPoints > 0;
      }
    },
    defer: function (statics) {
      qx.core.Environment.add("device.name", statics.getName);
      qx.core.Environment.add("device.touch", statics.getTouch);
      qx.core.Environment.add("device.type", statics.getType);
      qx.core.Environment.add("device.pixelRatio", statics.getDevicePixelRatio);
    }
  });
  qx.bom.client.Device.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.tool.cli.commands.Package": {
        "require": true
      },
      "qx.tool.cli.commands.package.Update": {},
      "qx.tool.cli.commands.package.List": {},
      "qx.tool.compiler.Console": {},
      "qx.tool.cli.commands.package.Install": {},
      "qx.lang.Type": {},
      "qx.tool.utils.Utils": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
     2017 Christian Boulanger
  
     License:
     MIT: https://opensource.org/licenses/MIT
     See the LICENSE file in the project's top-level directory for details.
  
     Authors:
     * Christian Boulanger (info@bibliograph.org, @cboulanger)
  
  ************************************************************************ */

  /**
   * Lists compatible library packages
   */
  qx.Class.define("qx.tool.cli.commands.package.Upgrade", {
    extend: qx.tool.cli.commands.Package,
    statics: {
      getYargsCommand: function () {
        return {
          command: "upgrade [library_uri]",
          describe: "if no library URI is given, upgrades all available libraries to the latest compatible version, otherwise upgrade only the package identified by the URI.",
          builder: {
            quiet: {
              alias: "q",
              describe: "No output"
            },
            "verbose": {
              alias: "v",
              describe: "Verbose logging"
            },
            "releases-only": {
              alias: "r",
              describe: "Upgrade regular releases only (this leaves versions based on branches, commits etc. untouched)",
              default: true
            },
            "reinstall": {
              alias: "R",
              describe: "Do not upgrade, reinstall current version"
            },
            "dryrun": {
              alias: "d",
              describe: "Show result only, do not actually upgrade"
            },
            "prereleases": {
              alias: "p",
              describe: "Use prereleases if available"
            }
          }
        };
      }
    },
    members: {
      async process() {
        await qx.tool.cli.commands.package.Upgrade.prototype.process.base.call(this);
        await new qx.tool.cli.commands.package.Update({
          quiet: true,
          prereleases: this.argv.prereleases
        }).process();
        await new qx.tool.cli.commands.package.List({
          quiet: true,
          prereleases: this.argv.prereleases
        }).process();

        if (!this.argv.quiet) {
          qx.tool.compiler.Console.info("Upgrading project dependencies to their latest available releases...");
        }

        let data = await this.getLockfileData();
        let found = false;
        const installer = new qx.tool.cli.commands.package.Install({
          quiet: this.argv.quiet,
          verbose: this.argv.verbose
        });

        for (const library of data.libraries) {
          // do not upggrade libraries that are not from a repository
          if (!library.repo_name || !library.repo_tag) {
            continue;
          }

          if (!library.uri) {
            library.uri = library.repo_name;
          } // if a library to upgrade has been provided, skip non-matching ones


          if (this.argv.library_uri && library.uri !== this.argv.library_uri) {
            continue;
          }

          found = true;

          if (this.argv.releasesOnly && (!qx.lang.Type.isString(library.repo_tag) || !library.repo_tag.startsWith("v"))) {
            if (!this.argv.quiet) {
              qx.tool.compiler.Console.info(`Skipping ${library.library_name} (${library.uri}@${library.repo_tag}) since it is not a release.`);
            }

            continue;
          }

          try {
            if (this.argv.dryrun) {
              qx.tool.compiler.Console.info(`Dry run. Not upgrading ${library.library_name} (${library.uri}@${library.repo_tag}).`);
              continue;
            }

            if (library.repo_tag && this.argv.reinstall) {
              await installer.install(library.uri, library.repo_tag);
            } else {
              await installer.install(library.uri);
            }
          } catch (e) {
            qx.tool.compiler.Console.warn(e.message);
          }
        }

        if (!found) {
          throw new qx.tool.utils.Utils.UserError(`Library '${this.argv.library_uri}' is not installed.`);
        }
      }

    }
  });
  qx.tool.cli.commands.package.Upgrade.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
   *
   *    qooxdoo-compiler - node.js based replacement for the Qooxdoo python
   *    toolchain
   *
   *    https://github.com/qooxdoo/qooxdoo-compiler
   *
   *    Copyright:
   *      2011-2019 Zenesis Limited, http://www.zenesis.com
   *
   *    License:
   *      MIT: https://opensource.org/licenses/MIT
   *
   *      This software is provided under the same licensing terms as Qooxdoo,
   *      please see the LICENSE file in the Qooxdoo project's top-level directory
   *      for details.
   *
   *    Authors:
   *      * John Spackman (john.spackman@zenesis.com, @johnspackman)
   *
   * *********************************************************************** */

  /**
   * Writer for serialising JSON, automatically indenting as required
   */
  qx.Class.define("qx.tool.utils.json.Writer", {
    extend: qx.core.Object,
    construct: function () {
      qx.core.Object.constructor.call(this);
      this.buffer = "";
      this.__P_54_0 = 0;
      this.__P_54_1 = "";
      this.__P_54_2 = 0;
    },
    members: {
      /**
       * Writes a string/number.  Multiple lines are rewritten with indentation at the
       * start of each line
       */
      write(str) {
        if (str === null) {
          str = "null";
        } else if (str === undefined) {
          str = "undefined";
        } else if (typeof str === "number") {
          str = str.toString();
        } else if (typeof str === "boolean") {
          str = str ? "true" : "false";
        } else if (typeof str !== "string") {
          throw new Error("Can only write strings and numbers");
        }

        var startPos = 0;
        /* eslint-disable no-constant-condition */

        while (true) {
          var pos = str.indexOf("\n", startPos);

          if (pos > -1) {
            this.buffer += str.substring(startPos, pos + 1);
            this.__P_54_2 = this.buffer.length;
            this.buffer += this.__P_54_1;
            startPos = pos + 1;
          } else {
            this.buffer += str.substring(startPos);
            break;
          }
        }

        return this;
      },

      /**
       * Outputs comments
       */
      comments(comments) {
        var t = this;

        if (comments) {
          comments.forEach(function (comment) {
            t.write(comment.source + "\n");
          });
        }
      },

      /**
       * Increases or decreases the indentation level (one indent is two spaces)
       * 
       * @param count {Number} number to increase/decrease by
       */
      indent(count) {
        if (this.__P_54_0 + count < 0) {
          throw new Error("Unbalanced indent");
        }

        this.__P_54_0 += count;
        var indentStr = this.__P_54_1;

        if (count > 0) {
          var str = "";

          for (var i = 0; i < count; i++) {
            str += "  ";
          }

          indentStr += str;
        } else {
          indentStr = indentStr.substring(0, indentStr.length + count * 2);
        }

        var line = this.buffer.substring(this.__P_54_2);

        if (!line.match(/[^\s]/)) {
          this.buffer = this.buffer.substring(0, this.__P_54_2) + indentStr;
        }

        this.__P_54_1 = indentStr;
        return this;
      },

      /**
       * Detects the current indentation level in the output, which has been added manually,
       * ie outside of the `indent()` method.  When outputting an AST via `reprint()`, whitespace
       * is copied too, this allows the code to adopt whatever indentation level has been
       * output by the AST so that injecting `prettyPrint()`-ed new objects are at the same\
       * level.
       * 
       * The old indent is returned, and should be passed to `resetIndent()` to restore the
       * previous value.
       * 
       * @return {Object} previous indentation
       */
      matchIndent() {
        var line = this.buffer.substring(this.__P_54_2);
        var m = line.match(/^([\s]*)/);
        var indent = m[0];
        var oldIndent = this.__P_54_1;
        this.__P_54_1 = indent;
        return oldIndent;
      },

      /**
       * Restores the previous indentation settings prior to `matchIndent()`
       * 
       * @param indent {Object} previous indentation settings
       */
      resetIndent(indent) {
        this.__P_54_1 = indent;
      }

    }
  });
  qx.tool.utils.json.Writer.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.tool.cli.Cli": {},
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.application.Basic": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2020 Henner Kollmann
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Henner Kollmann (Henner.Kollmann@gmx.de, @hkollmann)
  
  ************************************************************************ */

  /**
   * This is the main application class of the compiler; it does nothing
   * during startup so that it can be used as a library
   * 
   * @asset(qx/tool/*)
   * @use qx.tool.cli.Cli
   */
  qx.Class.define("qx.tool.cli.LibraryApplication", {
    extend: qx.application.Basic,
    members: {
      main() {// Nothing to do
      }

    }
  });
  qx.tool.cli.LibraryApplication.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.tool.compiler.Console": {
        "defer": "runtime"
      },
      "qx.tool.utils.Utils": {},
      "qx.tool.config.Compile": {},
      "qx.tool.utils.files.Utils": {},
      "qx.Promise": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2017 Zenesis Ltd
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * John Spackman (john.spackman@zenesis.com, @johnspackman)
  
  ************************************************************************ */
  const fs = require("fs");

  const path = require("upath");

  const chokidar = require("chokidar");

  qx.Class.define("qx.tool.cli.Watch", {
    extend: qx.core.Object,
    construct: function (maker) {
      qx.core.Object.constructor.call(this);
      this.__P_6_0 = maker;
      this.__P_6_1 = {
        classesCompiled: 0
      };
      this.__P_6_2 = {};
      this.__P_6_3 = [];
    },
    properties: {
      debug: {
        init: false,
        check: "Boolean"
      }
    },
    events: {
      "making": "qx.event.type.Event",
      "remaking": "qx.event.type.Event",
      "made": "qx.event.type.Event",
      "configChanged": "qx.event.type.Event"
    },
    members: {
      __P_6_4: null,
      __P_6_5: null,
      __P_6_6: false,
      __P_6_0: null,
      __P_6_1: null,
      __P_6_7: null,
      __P_6_8: false,
      __P_6_9: null,
      __P_6_10: null,
      __P_6_2: null,
      __P_6_3: null,

      async setConfigFilenames(arr) {
        if (!arr) {
          this.__P_6_3 = [];
        } else {
          this.__P_6_3 = arr.map(filename => path.resolve(filename));
        }
      },

      start() {
        if (this.isDebug()) {
          qx.tool.compiler.Console.debug("DEBUG: Starting watch");
        }

        if (this.__P_6_4) {
          throw new Error("Cannot start watching more than once");
        }

        this.__P_6_4 = qx.tool.utils.Utils.newExternalPromise();
        var dirs = [];

        var analyser = this.__P_6_0.getAnalyser();

        analyser.addListener("compiledClass", function () {
          this.__P_6_1.classesCompiled++;
        }, this);
        dirs.push(qx.tool.config.Compile.config.fileName);
        dirs.push("compile.js");
        analyser.getLibraries().forEach(function (lib) {
          let dir = path.join(lib.getRootDir(), lib.getSourcePath());
          dirs.push(dir);
          dir = path.join(lib.getRootDir(), lib.getResourcePath());
          dirs.push(dir);
          dir = path.join(lib.getRootDir(), lib.getThemePath());
          dirs.push(dir);
        });
        var applications = this.__P_6_5 = [];

        this.__P_6_0.getApplications().forEach(function (application) {
          var data = {
            application: application,
            dependsOn: {},
            outOfDate: false
          };
          applications.push(data);
          let dir = application.getBootPath();

          if (dir && !dirs.includes(dir)) {
            dirs.push(dir);
          }
        });

        if (this.isDebug()) {
          qx.tool.compiler.Console.debug(`DEBUG: applications=${JSON.stringify(applications.map(d => d.application.getName()))}`);
          qx.tool.compiler.Console.debug(`DEBUG: dirs=${JSON.stringify(dirs)}`);
        }

        var confirmed = [];
        Promise.all(dirs.map(dir => new Promise((resolve, reject) => {
          dir = path.resolve(dir);
          fs.stat(dir, function (err) {
            if (err) {
              if (err.code == "ENOENT") {
                resolve();
              } else {
                reject(err);
              }

              return;
            } // On case insensitive (but case preserving) filing systems, qx.tool.utils.files.Utils.correctCase
            // is needed corrects because chokidar needs the correct case in order to detect changes.


            qx.tool.utils.files.Utils.correctCase(dir).then(dir => {
              confirmed.push(dir);
              resolve();
            });
          });
        }))).then(() => {
          qx.tool.compiler.Console.debug(`DEBUG: confirmed=${JSON.stringify(confirmed)}`);
          var watcher = this._watcher = chokidar.watch(confirmed, {//ignored: /(^|[\/\\])\../
          });
          watcher.on("change", filename => this.__P_6_11("change", filename));
          watcher.on("add", filename => this.__P_6_11("add", filename));
          watcher.on("unlink", filename => this.__P_6_11("unlink", filename));
          watcher.on("ready", () => {
            this.__P_6_6 = true;

            this.__P_6_12();
          });
          watcher.on("error", err => {
            qx.tool.compiler.Console.print(err.code == "ENOSPC" ? "qx.tool.cli.watch.enospcError" : "qx.tool.cli.watch.watchError", err);
          });
        });
      },

      async stop() {
        this.__P_6_8 = true;

        this._watcher.close();

        if (this.__P_6_7) {
          await this.__P_6_7;
        }
      },

      __P_6_12() {
        if (this.__P_6_7) {
          this.__P_6_13 = true;
          return this.__P_6_7;
        }

        this.fireEvent("making");
        var t = this;
        var Console = qx.tool.compiler.Console;

        function make() {
          Console.print("qx.tool.cli.watch.makingApplications");
          var startTime = new Date().getTime();
          t.__P_6_1.classesCompiled = 0;
          t.__P_6_9 = false;
          return t.__P_6_0.make().then(() => {
            if (t.__P_6_8) {
              Console.print("qx.tool.cli.watch.makeStopping");
              return null;
            }

            if (t.__P_6_9) {
              return new qx.Promise(resolve => {
                setImmediate(function () {
                  Console.print("qx.tool.cli.watch.restartingMake");
                  t.fireEvent("remaking");
                  make().then(resolve);
                });
              });
            }

            var analyser = t.__P_6_0.getAnalyser();

            var db = analyser.getDatabase();
            var promises = [];

            t.__P_6_5.forEach(data => {
              data.dependsOn = {};
              var deps = data.application.getDependencies();
              deps.forEach(function (classname) {
                var info = db.classInfo[classname];
                var lib = analyser.findLibrary(info.libraryName);
                var parts = [lib.getRootDir(), lib.getSourcePath()].concat(classname.split("."));
                var filename = path.resolve.apply(path, parts) + ".js";
                data.dependsOn[filename] = true;
              });
              var filename = path.resolve(data.application.getLoaderTemplate());
              promises.push(qx.tool.utils.files.Utils.correctCase(filename).then(filename => data.dependsOn[filename] = true));
            });

            return Promise.all(promises).then(() => {
              var endTime = new Date().getTime();
              Console.print("qx.tool.cli.watch.compiledClasses", t.__P_6_1.classesCompiled, qx.tool.utils.Utils.formatTime(endTime - startTime));
              t.fireEvent("made");
            });
          }).then(() => {
            t.__P_6_7 = null;
          }).catch(err => {
            Console.print("qx.tool.cli.watch.compileFailed", err);
            t.__P_6_7 = null;
            t.fireEvent("made");
          });
        }

        const runIt = () => {
          return make().then(() => {
            if (this.__P_6_13) {
              delete this.__P_6_13;
              return runIt();
            }
          });
        };

        return this.__P_6_7 = runIt();
      },

      __P_6_14() {
        if (this.__P_6_7) {
          this.__P_6_13 = true;
          return this.__P_6_7;
        }

        if (this.__P_6_10) {
          clearTimeout(this.__P_6_10);
        }

        this.__P_6_10 = setTimeout(() => this.__P_6_12());
      },

      __P_6_11(type, filename) {
        const Console = qx.tool.compiler.Console;

        if (!this.__P_6_6) {
          return null;
        }

        filename = path.normalize(filename);

        const handleFileChange = async () => {
          var outOfDate = false;

          if (this.__P_6_3.find(str => str == filename)) {
            if (this.isDebug()) {
              Console.debug(`DEBUG: onFileChange: configChanged`);
            }

            this.fireEvent("configChanged");
            return;
          }

          let outOfDateApps = {};

          this.__P_6_5.forEach(data => {
            if (data.dependsOn[filename]) {
              outOfDateApps[data.application.getName()] = data.application;
              outOfDate = true;
            } else {
              var boot = data.application.getBootPath();

              if (boot) {
                boot = path.resolve(boot);

                if (filename.startsWith(boot)) {
                  outOfDateApps[data.application.getName()] = true;
                  outOfDate = true;
                }
              }
            }
          });

          let outOfDateAppNames = Object.keys(outOfDateApps);

          if (this.isDebug()) {
            if (outOfDateAppNames.length) {
              Console.debug(`DEBUG: onFileChange: ${filename} impacted applications: ${JSON.stringify(outOfDateAppNames)}`);
            }
          }

          let analyser = this.__P_6_0.getAnalyser();

          let fName = "";
          let isResource = analyser.getLibraries().some(lib => {
            var dir = path.resolve(path.join(lib.getRootDir(), lib.getResourcePath()));

            if (filename.startsWith(dir)) {
              fName = path.relative(dir, filename);
              return true;
            }

            dir = path.resolve(path.join(lib.getRootDir(), lib.getThemePath()));

            if (filename.startsWith(dir)) {
              fName = path.relative(dir, filename);
              return true;
            }

            return false;
          });

          if (isResource) {
            let rm = analyser.getResourceManager();

            let target = this.__P_6_0.getTarget();

            if (this.isDebug()) {
              Console.debug(`DEBUG: onFileChange: ${filename} is a resource`);
            }

            let asset = rm.getAsset(fName, type != "unlink");

            if (asset && type != "unlink") {
              await asset.sync(target);
              let dota = asset.getDependsOnThisAsset();

              if (dota) {
                await qx.Promise.all(dota.map(asset => asset.sync(target)));
              }
            }
          }

          if (outOfDate) {
            this.__P_6_9 = true;

            this.__P_6_14();
          }
        };

        const runIt = dbc => {
          return handleFileChange().then(() => {
            if (dbc.restart) {
              delete dbc.restart;
              return runIt(dbc);
            }
          });
        };

        let dbc = this.__P_6_2[filename];

        if (!dbc) {
          dbc = this.__P_6_2[filename] = {
            types: {}
          };
        }

        dbc.types[type] = true;

        if (dbc.promise) {
          if (this.isDebug()) {
            Console.debug(`DEBUG: onFileChange: seen '${filename}', but restarting promise`);
          }

          dbc.restart = 1;
          return dbc.promise;
        }

        if (dbc.timerId) {
          clearTimeout(dbc.timerId);
          dbc.timerId = null;
        }

        if (this.isDebug()) {
          Console.debug(`DEBUG: onFileChange: seen '${filename}', queuing`);
        }

        dbc.timerId = setTimeout(() => {
          dbc.promise = runIt(dbc).then(() => delete this.__P_6_2[filename]);
        }, 150);
        return null;
      },

      __P_6_15: function () {
        this.__P_6_4.resolve();
      }
    },
    defer: function () {
      qx.tool.compiler.Console.addMessageIds({
        "qx.tool.cli.watch.makingApplications": ">>> Making the applications...",
        "qx.tool.cli.watch.restartingMake": ">>> Code changed during make, restarting...",
        "qx.tool.cli.watch.makeStopping": ">>> Not restarting make because make is stopping...",
        "qx.tool.cli.watch.compiledClasses": ">>> Compiled %1 classes in %2"
      });
      qx.tool.compiler.Console.addMessageIds({
        "qx.tool.cli.watch.compileFailed": ">>> Fatal error during compile: %1",
        "qx.tool.cli.watch.enospcError": ">>> ENOSPC error occured - try increasing fs.inotify.max_user_watches",
        "qx.tool.cli.watch.watchError": ">>> Error occured while watching files - file modifications may not be detected; error: %1"
      }, "error");
    }
  });
  qx.tool.cli.Watch.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.Promise": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /**
   * This is used to add an test case for qx test
   */
  qx.Class.define("qx.tool.cli.api.Test", {
    extend: qx.core.Object,
    construct: function (name, testFunction) {
      qx.core.Object.constructor.call(this);
      this.setName(name);

      if (testFunction) {
        this.setTestFunction(testFunction);
      }
    },
    properties: {
      /**
       * Name of the process
       */
      name: {
        check: "String"
      },

      /**
       * A description of the test. 
       * For documentation purpose
       */
      description: {
        check: "String",
        event: "changeDescription"
      },

      /**
       * The exit code of the test.
       *
       */
      exitCode: {
        check: "Number",
        event: "changeExitCode",
        nullable: true,
        init: null
      },

      /**
       * Is the webserver instance needed for this test?
       */
      needsServer: {
        check: "Boolean",
        nullable: false,
        init: true
      },

      /**
       * The test function called by qx test
       * 
       */
      testFunction: {
        check: "Function",
        nullable: false,
        init: () => {}
      }
    },
    members: {
      /**
       * Execute the test
       * 
       * @returns: Promise
       * 
       * Can be overriden
       */
      execute: function () {
        let f = this.getTestFunction();
        return qx.Promise.resolve(f.call(this, this));
      }
    }
  });
  qx.tool.cli.api.Test.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.tool.cli.commands.Command": {
        "require": true
      },
      "qx.tool.cli.Cli": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2017 Christian Boulanger
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Boulanger (info@bibliograph.org, @cboulanger)
  
  ************************************************************************ */

  /**
   * Adds scripts, classes, etc. to the projects
   */
  qx.Class.define("qx.tool.cli.commands.Add", {
    extend: qx.tool.cli.commands.Command,
    statics: {
      getYargsCommand: function () {
        return {
          command: "add <command> [options]",
          desc: "adds new elements to an existing qooxdoo application/library",
          builder: function (yargs) {
            qx.tool.cli.Cli.addYargsCommands(yargs, ["Class", "Script"], "qx.tool.cli.commands.add");
            return yargs.demandCommand().showHelpOnFail().help();
          },
          handler: function (argv) {}
        };
      }
    },
    members: {// place for common methods.
    }
  });
  qx.tool.cli.commands.Add.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.tool.cli.commands.Command": {
        "require": true
      },
      "qx.tool.config.Compile": {},
      "qx.tool.cli.commands.Package": {},
      "qx.tool.compiler.Console": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2017 Christian Boulanger and others
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Boulanger (info@bibliograph.org, @cboulanger)
       * Henner Kollmann (hkollmann)
  
  ************************************************************************ */
  const fs = require("fs");

  const process = require("process");

  const path = require("upath");

  const rimraf = require("rimraf");
  /**
   * Cleans generated and cache files
   */


  qx.Class.define("qx.tool.cli.commands.Clean", {
    extend: qx.tool.cli.commands.Command,
    statics: {
      getYargsCommand: function () {
        return {
          command: "clean",
          describe: "cleans generated files and caches.",
          builder: {
            "verbose": {
              alias: "v",
              describe: "Verbose logging"
            }
          }
        };
      }
    },
    members: {
      /**
       * Deletes all generated and cache files
       */
      process: async function () {
        let compileConfig = await qx.tool.config.Compile.getInstance().load();

        for (let target of compileConfig.getValue("targets")) {
          await this.__P_8_0(path.join(process.cwd(), target.outputPath));

          if (target.deployPath) {
            await this.__P_8_0(path.join(process.cwd(), target.deployPath));
          }
        }

        await this.__P_8_0(path.join(process.cwd(), qx.tool.cli.commands.Package.cache_dir));
      },
      __P_8_0: async function (pathToRemove) {
        if (await fs.existsAsync(pathToRemove)) {
          if (this.argv.verbose) {
            qx.tool.compiler.Console.info(`Removing ${pathToRemove}...`);
          }

          await new Promise((resolve, reject) => {
            rimraf(pathToRemove, {}, err => {
              if (err) {
                reject(err);
              } else {
                resolve();
              }
            });
          });
        }
      }
    }
  });
  qx.tool.cli.commands.Clean.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.tool.utils.Promisify": {
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.tool.cli.commands.Command": {
        "require": true
      },
      "qx.tool.cli.ConfigDb": {},
      "qx.tool.compiler.Version": {},
      "qx.tool.compiler.Console": {
        "defer": "runtime"
      },
      "qx.tool.cli.Cli": {},
      "qx.tool.utils.Utils": {},
      "qx.Promise": {},
      "qx.tool.utils.files.Utils": {},
      "qx.tool.compiler.targets.BuildTarget": {},
      "qx.tool.cli.Watch": {},
      "qx.lang.Array": {},
      "qx.tool.compiler.app.Library": {},
      "qx.tool.compiler.makers.AppMaker": {},
      "qx.lang.Object": {},
      "qx.tool.compiler.app.Application": {},
      "qx.lang.String": {},
      "qx.tool.compiler.app.Part": {},
      "qx.tool.compiler.ClassFile": {},
      "qx.tool.cli.commands.package.Install": {},
      "qx.tool.compiler.targets.SourceTarget": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2017 Zenesis Ltd
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * John Spackman (john.spackman@zenesis.com, @johnspackman)
  
  ************************************************************************ */
  const process = require("process");

  const Gauge = require("gauge");

  const semver = require("semver");

  const path = require("upath");

  const consoleControl = require("console-control-strings");

  const fs = qx.tool.utils.Promisify.fs;

  require("app-module-path").addPath(process.cwd() + "/node_modules");
  /**
   * Handles compilation of the project
   */


  qx.Class.define("qx.tool.cli.commands.Compile", {
    extend: qx.tool.cli.commands.Command,
    statics: {
      YARGS_BUILDER: {
        "target": {
          alias: "t",
          describe: "Set the target type: source or build or class name. Default is first target in config file",
          requiresArg: true,
          type: "string"
        },
        "output-path-prefix": {
          describe: "Sets a prefix for the output path of the target - used to compile a version into a non-standard directory",
          type: "string"
        },
        "download": {
          alias: "d",
          describe: "Whether to automatically download missing libraries",
          type: "boolean",
          default: true
        },
        "locale": {
          alias: "l",
          describe: "Compile for a given locale",
          nargs: 1,
          requiresArg: true,
          type: "string",
          array: true
        },
        "update-po-files": {
          alias: "u",
          describe: "enables detection of translations and writing them out into .po files",
          type: "boolean",
          default: false
        },
        "library-po": {
          describe: "The policy for updating translations in libraries",
          type: ["ignore", "untranslated", "all"],
          default: "ignore"
        },
        "write-all-translations": {
          describe: "enables output of all translations, not just those that are explicitly referenced",
          type: "boolean"
        },
        "app-class": {
          describe: "sets the application class",
          nargs: 1,
          requiresArg: true,
          type: "string"
        },
        "app-theme": {
          describe: "sets the theme class for the current application",
          nargs: 1,
          requiresArg: true,
          type: "string"
        },
        "app-name": {
          describe: "sets the name of the current application",
          nargs: 1,
          requiresArg: true,
          type: "string"
        },
        "watch": {
          describe: "enables watching for changes and continuous compilation",
          type: "boolean",
          alias: "w"
        },
        "watch-debug": {
          describe: "enables debug messages for watching",
          type: "boolean"
        },
        "machine-readable": {
          alias: "M",
          describe: "output compiler messages in machine-readable format",
          type: "boolean"
        },
        "minify": {
          alias: "m",
          describe: "disables minification (build targets only)",
          choices: ["off", "minify", "mangle", "beautify"],
          default: "mangle"
        },
        "mangle-privates": {
          describe: "Whether to mangle private variables",
          default: true,
          type: "boolean"
        },
        "save-source-in-map": {
          describe: "Saves the source code in the map file (build target only)",
          type: "boolean",
          default: false
        },
        "save-unminified": {
          alias: "u",
          describe: "Saves a copy of the unminified version of output files (build target only)",
          type: "boolean",
          default: false
        },
        "inline-external-scripts": {
          describe: "Inlines external Javascript",
          type: "boolean"
        },
        "erase": {
          alias: "e",
          describe: "Enabled automatic deletion of the output directory when compiler version or environment variables change",
          type: "boolean",
          default: true
        },
        "feedback": {
          describe: "Shows gas-gauge feedback",
          type: "boolean",
          default: null,
          alias: "f"
        },
        "typescript": {
          alias: "T",
          describe: "Outputs typescript definitions in qooxdoo.d.ts",
          type: "boolean"
        },
        "add-created-at": {
          describe: "Adds code to populate object's $$createdAt",
          type: "boolean"
        },
        "clean": {
          alias: "D",
          describe: "Deletes the target dir before compile",
          type: "boolean"
        },
        "warn-as-error": {
          alias: "E",
          describe: "Handle compiler warnings as error",
          type: "boolean",
          default: false
        },
        "write-compile-info": {
          describe: "Write compiler information to the target",
          type: "boolean",
          default: false
        },
        "write-library-info": {
          alias: "I",
          describe: "Write library information to the script, for reflection",
          type: "boolean",
          default: true
        },
        "write-compile-info": {
          describe: "Write application summary information to the script, used mostly for unit tests",
          type: "boolean",
          default: false
        },
        "bundling": {
          alias: "b",
          describe: "Whether bundling is enabled",
          type: "boolean",
          default: true
        }
      },
      getYargsCommand: function () {
        return {
          command: "compile",
          describe: "compiles the current application, using compile.json",
          builder: qx.tool.cli.commands.Compile.YARGS_BUILDER
        };
      }
    },
    events: {
      /**
       * Fired when application writing starts 
       */
      "writingApplications": "qx.event.type.Event",

      /** 
       * Fired when writing of single application starts; data is an object containing:
       *   maker {qx.tool.compiler.makers.Maker}
       *   target {qx.tool.compiler.targets.Target}
       *   appMeta {qx.tool.compiler.targets.meta.ApplicationMeta}
       */
      "writingApplication": "qx.event.type.Data",

      /** 
       * Fired when writing of single application is complete; data is an object containing:
       *   maker {qx.tool.compiler.makers.Maker}
       *   target {qx.tool.compiler.targets.Target}
       *   appMeta {qx.tool.compiler.targets.meta.ApplicationMeta}
       *
       * Note that target.getAppMeta() will return null after this event has been fired 
       */
      "writtenApplication": "qx.event.type.Data",

      /**
       * Fired after writing of all applications; data is an object containing an array, 
       * each of which has previously been passed with `writeApplication`:
       
       *   maker {qx.tool.compiler.makers.Maker}
       *   target {qx.tool.compiler.targets.Target}
       *   appMeta {qx.tool.compiler.targets.meta.ApplicationMeta}
       *
       * Note that target.getAppMeta() will return null after this event has been fired 
       */
      "writtenApplications": "qx.event.type.Data",

      /**
       * Fired when a class is about to be compiled.
       *
       * The event data is an object with the following properties: 
       *
       * dbClassInfo: {Object} the newly populated class info
       * oldDbClassInfo: {Object} the previous populated class info
       * classFile - {ClassFile} the qx.tool.compiler.ClassFile instance
       */
      "compilingClass": "qx.event.type.Data",

      /**
       * Fired when a class is compiled.
       * 
       * The event data is an object with the following properties: 
       * dbClassInfo: {Object} the newly populated class info
       * oldDbClassInfo: {Object} the previous populated class info
       * classFile - {ClassFile} the qx.tool.compiler.ClassFile instance
       */
      "compiledClass": "qx.event.type.Data",

      /**
       * Fired when the database is been saved
       * 
       *  data: 
       * database: {Object} the database to save
       */
      "saveDatabase": "qx.event.type.Data",

      /**
       * Fired after all enviroment data is collected
       * 
       * The event data is an object with the following properties: 
       *  application {qx.tool.compiler.app.Application} the app
       *  enviroment: {Object} enviroment data
       */
      "checkEnvironment": "qx.event.type.Data",

      /**
       * Fired when making of apps begins
      */
      "making": "qx.event.type.Event",

      /**
       * Fired when making of apps is done.
      */
      "made": "qx.event.type.Event",

      /**
       * Fired when minification begins.
       * 
       * The event data is an object with the following properties: 
       *  application {qx.tool.compiler.app.Application} the app being minified
       *  part: {String} the part being minified
       *  filename: {String} the part filename
       */
      "minifyingApplication": "qx.event.type.Data",

      /**
       * Fired when minification is done.
       * 
       * The event data is an object with the following properties: 
       *  application {qx.tool.compiler.app.Application} the app being minified
       *  part: {String} the part being minified
       *  filename: {String} the part filename
       */
      "minifiedApplication": "qx.event.type.Data"
    },
    members: {
      __P_9_0: null,
      __P_9_1: null,
      __P_9_2: null,
      __P_9_3: null,
      __P_9_4: false,

      /*
       * @Override
       */
      process: async function () {
        await qx.tool.cli.commands.Compile.prototype.process.base.call(this);
        let configDb = await qx.tool.cli.ConfigDb.getInstance();

        if (this.argv["feedback"] === null) {
          this.argv["feedback"] = configDb.db("qx.default.feedback", true);
        }

        if (this.argv.verbose) {
          console.log(`
Compiler:  v${qx.tool.compiler.Version.VERSION} in ${require.main.filename}
Framework: v${await this.getUserQxVersion()} in ${await this.getUserQxPath()}`);
        }

        if (this.argv["machine-readable"]) {
          qx.tool.compiler.Console.getInstance().setMachineReadable(true);
        } else {
          let configDb = await qx.tool.cli.ConfigDb.getInstance();
          let color = configDb.db("qx.default.color", null);

          if (color) {
            let colorOn = consoleControl.color(color.split(" "));
            process.stdout.write(colorOn + consoleControl.eraseLine());
            let colorReset = consoleControl.color("reset");
            process.on("exit", () => process.stdout.write(colorReset + consoleControl.eraseLine()));
            let Console = qx.tool.compiler.Console.getInstance();
            Console.setColorOn(colorOn);
          }

          if (this.argv["feedback"]) {
            var themes = require("gauge/themes");

            var ourTheme = themes.newTheme(themes({
              hasUnicode: true,
              hasColor: true
            }));
            let colorOn = qx.tool.compiler.Console.getInstance().getColorOn();
            ourTheme.preProgressbar = colorOn + ourTheme.preProgressbar;
            ourTheme.preSubsection = colorOn + ourTheme.preSubsection;
            ourTheme.progressbarTheme.postComplete += colorOn;
            ourTheme.progressbarTheme.postRemaining += colorOn;
            this.__P_9_0 = new Gauge();

            this.__P_9_0.setTheme(ourTheme);

            this.__P_9_0.show("Compiling", 0);

            const TYPES = {
              "error": "ERROR",
              "warning": "Warning"
            };
            qx.tool.compiler.Console.getInstance().setWriter((str, msgId) => {
              msgId = qx.tool.compiler.Console.MESSAGE_IDS[msgId];

              if (!msgId || msgId.type !== "message") {
                this.__P_9_0.hide();

                qx.tool.compiler.Console.log(colorOn + TYPES[(msgId || {}).type || "error"] + ": " + str);

                this.__P_9_0.show();
              } else {
                this.__P_9_0.show(colorOn + str);
              }
            });
          }
        }

        if (this.__P_9_0) {
          this.addListener("writingApplications", () => this.__P_9_0.show("Writing Applications", 0));
          this.addListener("writtenApplications", () => this.__P_9_0.show("Writing Applications", 1));
          this.addListener("writingApplication", evt => this.__P_9_0.pulse("Writing Application " + evt.getData().appMeta.getApplication().getName()));
          this.addListener("compilingClass", evt => this.__P_9_0.pulse("Compiling " + evt.getData().classFile.getClassName()));
          this.addListener("minifyingApplication", evt => this.__P_9_0.pulse("Minifying " + evt.getData().application.getName() + " " + evt.getData().filename));
        } else {
          this.addListener("writingApplication", evt => {
            let appInfo = evt.getData();
            qx.tool.compiler.Console.print("qx.tool.cli.compile.writingApplication", appInfo.appMeta.getApplication().getName());
          });
          this.addListener("minifyingApplication", evt => qx.tool.compiler.Console.print("qx.tool.cli.compile.minifyingApplication", evt.getData().application.getName(), evt.getData().filename));
        }

        this.addListener("making", evt => {
          if (this.__P_9_0) {
            this.__P_9_0.show("Compiling", 1);
          } else {
            qx.tool.compiler.Console.print("qx.tool.cli.compile.makeBegins");
          }
        });
        this.addListener("made", evt => {
          if (this.__P_9_0) {
            this.__P_9_0.show("Compiling", 1);
          } else {
            qx.tool.compiler.Console.print("qx.tool.cli.compile.makeEnds");
          }
        });
        this.addListener("writtenApplications", e => {
          if (this.argv.verbose) {
            qx.tool.compiler.Console.log("\nCompleted all applications, libraries used are:");
            Object.values(this.__P_9_3).forEach(lib => qx.tool.compiler.Console.log(`   ${lib.getNamespace()} (${lib.getRootDir()})`));
          }
        });
        await this._loadConfigAndStartMaking();

        if (!this.argv.watch) {
          let success = this.__P_9_1.every(maker => maker.getSuccess());

          let hasWarnings = this.__P_9_1.every(maker => maker.getHasWarnings());

          if (success && hasWarnings && this.argv.warnAsError) {
            success = false;
          }

          if (!this.argv.deploying && !this.argv["machine-readable"] && this.argv["feedback"] && this.__P_9_4 && this.argv.target === "build") {
            qx.tool.compiler.Console.warn("   *******************************************************************************************\n   **                                                                                       **\n   **  Your compilation will include temporary files that are only necessary during         **\n   **  development; these files speed up the compilation, but take up space that you would  **\n   **  probably not want to put on a production server.                                     **\n   **                                                                                       **\n   **  When you are ready to deploy, try running `qx deploy` to get a minimised version     **\n   **                                                                                       **\n   *******************************************************************************************");
          }

          process.exitCode = success ? 0 : 1;
        }
      },

      /**
       * Loads the configuration and starts the make
       * 
       * @return {Boolean} true if all makers succeeded
       */
      async _loadConfigAndStartMaking() {
        var config = this.__P_9_2 = await qx.tool.cli.Cli.getInstance().getParsedArgs();

        if (!config) {
          throw new qx.tool.utils.Utils.UserError("Error: Cannot find any configuration");
        }

        var makers = this.__P_9_1 = await this.createMakersFromConfig(config);

        if (!makers || !makers.length) {
          throw new qx.tool.utils.Utils.UserError("Error: Cannot find anything to make");
        }

        let countMaking = 0;

        const collateDispatchEvent = evt => {
          if (countMaking == 1) {
            this.dispatchEvent(evt.clone());
          }
        };

        await qx.Promise.all(makers.map(async maker => {
          var analyser = maker.getAnalyser();
          let cfg = await qx.tool.cli.ConfigDb.getInstance();
          analyser.setWritePoLineNumbers(cfg.db("qx.translation.strictPoCompatibility", false));

          if (!(await fs.existsAsync(maker.getOutputDir()))) {
            this.__P_9_4 = true;
          }

          if (this.argv["clean"]) {
            await maker.eraseOutputDir();
            await qx.tool.utils.files.Utils.safeUnlink(analyser.getDbFilename());
            await qx.tool.utils.files.Utils.safeUnlink(analyser.getResDbFilename());
          }

          if (config.ignores) {
            analyser.setIgnores(config.ignores);
          }

          var target = maker.getTarget();
          analyser.addListener("compilingClass", e => this.dispatchEvent(e.clone()));
          analyser.addListener("compiledClass", e => this.dispatchEvent(e.clone()));
          analyser.addListener("saveDatabase", e => this.dispatchEvent(e.clone()));
          target.addListener("checkEnvironment", e => this.dispatchEvent(e.clone()));
          let appInfos = [];
          target.addListener("writingApplication", async () => {
            let appInfo = {
              maker,
              target,
              appMeta: target.getAppMeta()
            };
            appInfos.push(appInfo);
            await this.fireDataEventAsync("writingApplication", appInfo);
          });
          target.addListener("writtenApplication", async () => {
            await this.fireDataEventAsync("writingApplication", {
              maker,
              target,
              appMeta: target.getAppMeta()
            });
          });
          maker.addListener("writingApplications", collateDispatchEvent);
          maker.addListener("writtenApplications", async () => {
            await this.fireDataEventAsync("writtenApplications", appInfos);
          });

          if (target instanceof qx.tool.compiler.targets.BuildTarget) {
            target.addListener("minifyingApplication", e => this.dispatchEvent(e.clone()));
            target.addListener("minifiedApplication", e => this.dispatchEvent(e.clone()));
          }

          let stat = await qx.tool.utils.files.Utils.safeStat("source/index.html");

          if (stat) {
            qx.tool.compiler.Console.print("qx.tool.cli.compile.legacyFiles", "source/index.html");
          } // Simple one of make


          if (!this.argv.watch) {
            maker.addListener("making", () => {
              countMaking++;

              if (countMaking == 1) {
                this.fireEvent("making");
              }
            });
            maker.addListener("made", () => {
              countMaking--;

              if (countMaking == 0) {
                this.fireEvent("made");
              }
            });
            return await maker.make();
          } // Continuous make


          let watch = new qx.tool.cli.Watch(maker);

          if (this.argv["watch-debug"]) {
            watch.setDebug(true);
          }

          watch.addListener("making", () => {
            countMaking++;

            if (countMaking == 1) {
              this.fireEvent("making");
            }
          });
          watch.addListener("made", () => {
            countMaking--;

            if (countMaking == 0) {
              this.fireEvent("made");
            }
          });
          watch.addListener("configChanged", async () => {
            await watch.stop();
            setImmediate(() => this._loadConfigAndStartMaking());
          });
          let arr = [this._compileJsFilename, this._compileJsonFilename].filter(str => Boolean(str));
          watch.setConfigFilenames(arr);
          return await watch.start();
        }));
      },

      /**
       * Processes the configuration from a JSON data structure and creates a Maker
       *
       * @param data {Map}
       * @return {Maker}
       */
      createMakersFromConfig: async function (data) {
        const Console = qx.tool.compiler.Console.getInstance();
        var t = this;

        if (data.babelOptions) {
          if (!data.babelConfig) {
            data.babelConfig = {
              options: data.babelOptions
            };
            qx.tool.compiler.Console.print("qx.tool.cli.compile.deprecatedBabelOptions");
          } else {
            qx.tool.compiler.Console.print("qx.tool.cli.compile.deprecatedBabelOptionsConflicting");
          }

          delete data.babelOptions;
        }

        var argvAppNames = null;

        if (t.argv["app-name"]) {
          argvAppNames = t.argv["app-name"].split(",");
        }
        /*
         * Calculate the the list of targets and applications; this is a many to many list, where an
         * application can be compiled for many targets, and each target has many applications.
         *
         * Each target configuration is updated to have `appConfigs[]` and each application configuration
         * is updated to have `targetConfigs[]`.
         */


        data.targets.forEach((targetConfig, index) => targetConfig.index = index);
        let targetConfigs = [];
        let defaultTargetConfig = null;
        data.targets.forEach(targetConfig => {
          if (targetConfig.type === data.targetType) {
            if (!targetConfig["application-names"] && !targetConfig["application-types"]) {
              if (defaultTargetConfig) {
                qx.tool.compiler.Console.print("qx.tool.cli.compile.multipleDefaultTargets");
              } else {
                defaultTargetConfig = targetConfig;
              }
            } else {
              targetConfigs.push(targetConfig);
            }
          }
        });
        let allAppNames = {};
        data.applications.forEach((appConfig, index) => {
          if (appConfig.name) {
            if (allAppNames[appConfig.name]) {
              throw new qx.tool.utils.Utils.UserError(`Multiple applications with the same name '${appConfig.name}'`);
            }

            allAppNames[appConfig.name] = appConfig;
          }

          appConfig.index = index;
          let appType = appConfig.type || "browser";
          let appTargetConfigs = targetConfigs.filter(targetConfig => {
            let appTypes = targetConfig["application-types"];

            if (appTypes && !qx.lang.Array.contains(appTypes, appType)) {
              return false;
            }

            let appNames = targetConfig["application-names"];

            if (appConfig.name && appNames && !qx.lang.Array.contains(appNames, appConfig.name)) {
              return false;
            }

            return true;
          });

          if (appTargetConfigs.length == 0) {
            if (defaultTargetConfig) {
              appTargetConfigs = [defaultTargetConfig];
            } else {
              throw new qx.tool.utils.Utils.UserError(`Cannot find any suitable targets for application #${index} (named ${appConfig.name || "unnamed"})`);
            }
          }

          appTargetConfigs.forEach(targetConfig => {
            if (!targetConfig.appConfigs) {
              targetConfig.appConfigs = [];
            }

            targetConfig.appConfigs.push(appConfig);

            if (!appConfig.targetConfigs) {
              appConfig.targetConfigs = [];
            }

            appConfig.targetConfigs.push(targetConfig);
          });
        });

        if (defaultTargetConfig && defaultTargetConfig.appConfigs) {
          targetConfigs.push(defaultTargetConfig);
        }

        let libraries = this.__P_9_3 = {};
        await qx.Promise.all(data.libraries.map(async libPath => {
          var library = await qx.tool.compiler.app.Library.createLibrary(libPath);
          libraries[library.getNamespace()] = library;
        })); // Search for Qooxdoo library if not already provided

        var qxLib = libraries["qx"];

        if (!qxLib) {
          var library = await qx.tool.compiler.app.Library.createLibrary(await this.getGlobalQxPath());
          libraries[library.getNamespace()] = library;
          qxLib = libraries["qx"];
        }

        if (this.argv.verbose) {
          Console.log("QooxDoo found in " + qxLib.getRootDir());
        }

        let errors = await this.__P_9_5(Object.values(libraries), data.packages);

        if (errors.length > 0) {
          if (this.argv.warnAsError) {
            throw new qx.tool.utils.Utils.UserError(errors.join("\n"));
          } else {
            qx.tool.compiler.Console.log(errors.join("\n"));
          }
        }
        /*
         * Figure out which will be the default application; this will need some work for situations
         * where there are multiple browser based targets
         */


        targetConfigs.forEach(targetConfig => {
          let hasExplicitDefaultApp = false;
          targetConfig.defaultAppConfig = null;

          if (targetConfig.appConfigs) {
            targetConfig.appConfigs.forEach(appConfig => {
              if (appConfig.type && appConfig.type != "browser") {
                return;
              }

              let setDefault;

              if (appConfig.writeIndexHtmlToRoot !== undefined) {
                qx.tool.compiler.Console.print("qx.tool.cli.compile.deprecatedCompileSeeOther", "application.writeIndexHtmlToRoot", "application.default");
                setDefault = appConfig.writeIndexHtmlToRoot;
              } else if (appConfig["default"] !== undefined) {
                setDefault = appConfig["default"];
              }

              if (setDefault !== undefined) {
                if (setDefault) {
                  if (hasExplicitDefaultApp) {
                    throw new qx.tool.utils.Utils.UserError("Error: Can only set one application to be the default application!");
                  }

                  hasExplicitDefaultApp = true;
                  targetConfig.defaultAppConfig = appConfig;
                }
              } else if (!targetConfig.defaultAppConfig) {
                targetConfig.defaultAppConfig = appConfig;
              }
            });

            if (!hasExplicitDefaultApp && targetConfig.appConfigs.length > 1) {
              targetConfig.defaultAppConfig = targetConfig.appConfigs[0];
            }
          }
        });
        /*
         * There is still only one target per maker, so convert our list of targetConfigs into an array of makers
         */

        let makers = [];
        targetConfigs.forEach(targetConfig => {
          if (!targetConfig.appConfigs) {
            qx.tool.compiler.Console.print("qx.tool.cli.compile.unusedTarget", targetConfig.type, targetConfig.index);
            return;
          }

          let appConfigs = targetConfig.appConfigs.filter(appConfig => !appConfig.name || !argvAppNames || qx.lang.Array.contains(argvAppNames, appConfig.name));

          if (!appConfigs.length) {
            return;
          }

          var outputPath = targetConfig.outputPath;

          if (this.argv.outputPathPrefix) {
            outputPath = path.join(this.argv.outputPathPrefix, outputPath);
          }

          if (!outputPath) {
            throw new qx.tool.utils.Utils.UserError("Missing output-path for target " + targetConfig.type);
          }

          var maker = new qx.tool.compiler.makers.AppMaker();

          if (!this.argv["erase"]) {
            maker.setNoErase(true);
          }

          var targetClass = targetConfig.targetClass ? this.resolveTargetClass(targetConfig.targetClass) : null;

          if (!targetClass && targetConfig.type) {
            targetClass = this.resolveTargetClass(targetConfig.type);
          }

          if (!targetClass) {
            throw new qx.tool.utils.Utils.UserError("Cannot find target class: " + (targetConfig.targetClass || targetConfig.type));
          }
          /* eslint-disable new-cap */


          var target = new targetClass(outputPath);
          /* eslint-enable new-cap */

          if (targetConfig.uri) {
            qx.tool.compiler.Console.print("qx.tool.cli.compile.deprecatedUri", "target.uri", targetConfig.uri);
          }

          if (targetConfig.writeCompileInfo || this.argv.writeCompileInfo) {
            target.setWriteCompileInfo(true);
          }

          if (data.i18nAsParts) {
            target.setI18nAsParts(true);
          }

          target.setWriteLibraryInfo(this.argv.writeLibraryInfo);
          target.setUpdatePoFiles(this.argv.updatePoFiles);
          target.setLibraryPoPolicy(this.argv.libraryPo); // Take the command line for `minify` as most precedent only if provided

          var minify;

          if (process.argv.indexOf("--minify") > -1) {
            minify = t.argv["minify"];
          }

          minify = minify || targetConfig["minify"] || t.argv["minify"];

          if (typeof minify == "boolean") {
            minify = minify ? "minify" : "off";
          }

          if (!minify) {
            minify = "mangle";
          }

          if (typeof target.setMinify == "function") {
            target.setMinify(minify);
          }

          function chooseValue(...args) {
            for (let i = 0; i < args.length; i++) {
              if (args[i] !== undefined) {
                return args[i];
              }
            }

            return undefined;
          } // Take the command line for `saveSourceInMap` as most precedent only if provided


          var saveSourceInMap = chooseValue(targetConfig["save-source-in-map"], t.argv["saveSourceInMap"]);

          if (typeof saveSourceInMap == "boolean" && typeof target.setSaveSourceInMap == "function") {
            target.setSaveSourceInMap(saveSourceInMap);
          }

          var saveUnminified = chooseValue(targetConfig["save-unminified"], t.argv["save-unminified"]);

          if (typeof saveUnminified == "boolean" && typeof target.setSaveUnminified == "function") {
            target.setSaveUnminified(saveUnminified);
          }

          var inlineExternal = chooseValue(targetConfig["inline-external-scripts"], t.argv["inline-external-scripts"]);

          if (typeof inlineExternal == "boolean") {
            target.setInlineExternalScripts(inlineExternal);
          } else if (target instanceof qx.tool.compiler.targets.BuildTarget) {
            target.setInlineExternalScripts(true);
          }

          var deployDir = targetConfig["deployPath"];

          if (deployDir && typeof target.setDeployDir == "function") {
            target.setDeployDir(deployDir);
          }

          var deployMap = targetConfig["deploy-source-maps"];

          if (typeof deployMap == "boolean" && typeof target.setDeployDir == "function") {
            target.setDeployMap(deployMap);
          }

          maker.setTarget(target);
          maker.setLocales(data.locales || ["en"]);

          if (data.writeAllTranslations) {
            maker.setWriteAllTranslations(data.writeAllTranslations);
          }

          if (typeof targetConfig.typescript == "string") {
            maker.set({
              outputTypescript: true,
              outputTypescriptTo: targetConfig.typescript
            });
          } else if (typeof targetConfig.typescript == "boolean") {
            maker.set({
              outputTypescript: true
            });
          }

          if (this.argv["typescript"]) {
            maker.set({
              outputTypescript: true
            });
          }

          if (data.environment) {
            maker.setEnvironment(data.environment);
          }

          if (targetConfig.environment) {
            target.setEnvironment(targetConfig.environment);
          }

          if (data["path-mappings"]) {
            for (var from in data["path-mappings"]) {
              var to = data["path-mappings"][from];
              target.addPathMapping(from, to);
            }
          }

          function mergeArray(dest, ...srcs) {
            srcs.forEach(function (src) {
              if (src) {
                src.forEach(function (elem) {
                  if (!qx.lang.Array.contains(dest, src)) {
                    dest.push(elem);
                  }
                });
              }
            });
            return dest;
          }

          let babelConfig = qx.lang.Object.clone(data.babel || {}, true);
          babelConfig.options = babelConfig.options || {};
          qx.lang.Object.mergeWith(babelConfig.options, targetConfig.babelOptions || {});
          maker.getAnalyser().setBabelConfig(babelConfig);
          var addCreatedAt = targetConfig["addCreatedAt"] || t.argv["addCreatedAt"];

          if (addCreatedAt) {
            maker.getAnalyser().setAddCreatedAt(true);
          }

          for (let ns in libraries) {
            maker.getAnalyser().addLibrary(libraries[ns]);
          }

          if (this.argv["mangle-privates"]) {
            maker.getAnalyser().setManglePrivates(target instanceof qx.tool.compiler.targets.BuildTarget ? "unreadable" : "readable");
          } else {
            maker.getAnalyser().setManglePrivates("off");
          }

          let allApplicationTypes = {};
          appConfigs.forEach(appConfig => {
            var app = appConfig.app = new qx.tool.compiler.app.Application(appConfig["class"]);
            app.setTemplatePath(t.getTemplateDir());
            ["type", "theme", "name", "environment", "outputPath", "bootPath", "loaderTemplate", "publish", "deploy", "standalone"].forEach(name => {
              if (appConfig[name] !== undefined) {
                var fname = "set" + qx.lang.String.firstUp(name);
                app[fname](appConfig[name]);
              }
            });
            allApplicationTypes[app.getType()] = true;

            if (appConfig.uri) {
              qx.tool.compiler.Console.print("qx.tool.cli.compile.deprecatedUri", "application.uri", appConfig.uri);
            }

            if (appConfig.title) {
              app.setTitle(appConfig.title);
            }

            if (appConfig.description) {
              app.setDescription(appConfig.description);
            }

            var parts = appConfig.parts || targetConfig.parts || data.parts;

            if (parts) {
              if (!parts.boot) {
                throw new qx.tool.utils.Utils.UserError("Cannot determine a boot part for application " + (appConfig.index + 1) + " " + (appConfig.name || ""));
              }

              for (var partName in parts) {
                var partData = parts[partName];
                var include = typeof partData.include == "string" ? [partData.include] : partData.include;
                var exclude = typeof partData.exclude == "string" ? [partData.exclude] : partData.exclude;
                var part = new qx.tool.compiler.app.Part(partName, include, exclude).set({
                  combine: Boolean(partData.combine),
                  minify: Boolean(partData.minify)
                });
                app.addPart(part);
              }
            }

            if (target.getType() == "source" && t.argv.bundling) {
              var bundle = appConfig.bundle || targetConfig.bundle || data.bundle;

              if (bundle) {
                if (bundle.include) {
                  app.setBundleInclude(bundle.include);
                }

                if (bundle.exclude) {
                  app.setBundleExclude(bundle.exclude);
                }
              }
            }

            app.set({
              exclude: mergeArray([], data.exclude, targetConfig.exclude, appConfig.exclude),
              include: mergeArray([], data.include, targetConfig.include, appConfig.include)
            });
            maker.addApplication(app);
          });
          const CF = qx.tool.compiler.ClassFile;
          let globalSymbols = [];
          qx.lang.Array.append(globalSymbols, CF.QX_GLOBALS);
          qx.lang.Array.append(globalSymbols, CF.COMMON_GLOBALS);

          if (allApplicationTypes["browser"]) {
            qx.lang.Array.append(globalSymbols, CF.BROWSER_GLOBALS);
          }

          if (allApplicationTypes["node"]) {
            qx.lang.Array.append(globalSymbols, CF.NODE_GLOBALS);
          }

          if (allApplicationTypes["rhino"]) {
            qx.lang.Array.append(globalSymbols, CF.RHINO_GLOBALS);
          }

          maker.getAnalyser().setGlobalSymbols(globalSymbols);

          if (targetConfig.defaultAppConfig && targetConfig.defaultAppConfig.app && (targetConfig.defaultAppConfig.type || "browser") === "browser") {
            targetConfig.defaultAppConfig.app.setWriteIndexHtmlToRoot(true);
          } else {
            qx.tool.utils.files.Utils.safeUnlink(target.getOutputDir() + "index.html");
          }

          const showMarkers = (classname, markers) => {
            if (markers) {
              markers.forEach(function (marker) {
                var str = qx.tool.compiler.Console.decodeMarker(marker);
                Console.warn(classname + ": " + str);
              });
            }
          }; // Note - this will cause output multiple times, once per maker/target; but this is largely unavoidable
          //  because different targets can cause different warnings for the same code due to different compilation
          //  options (eg node vs browser)


          maker.getAnalyser().addListener("compiledClass", evt => {
            var data = evt.getData();
            showMarkers(data.classFile.getClassName(), data.dbClassInfo.markers);
          });
          maker.getAnalyser().addListener("alreadyCompiledClass", evt => {
            var data = evt.getData();
            showMarkers(data.className, data.dbClassInfo.markers);
          });
          makers.push(maker);
        });
        return makers;
      },

      /**
       * Checks the dependencies of the current library
       * @param  {qx.tool.compiler.app.Library[]} libs
       *    The list of libraries to check
       * @param {Object|*} packages
       *    If given, an object mapping library uris to library paths
       * @return {Promise<Array>} Array of error messages
       * @private
       */
      async __P_9_5(libs, packages) {
        const Console = qx.tool.compiler.Console.getInstance();
        let errors = [];
        const SDK_VERSION = await this.getUserQxVersion(); // check all requires

        for (let lib of libs) {
          let requires = lib.getRequires();

          if (!requires) {
            requires = {};
          }

          if (!packages) {
            packages = {};
          } // check for qooxdoo-range


          let range = lib.getLibraryInfo()["qooxdoo-range"];

          if (range) {
            if (this.argv.verbose) {
              Console.warn(`${lib.getNamespace()}: The configuration setting "qooxdoo-range" in Manifest.json has been deprecated in favor of "requires.@qooxdoo/framework".`);
            }

            if (!requires["@qooxdoo/framework"]) {
              requires["@qooxdoo/framework"] = range;
            }
          } // Find the libraries that we need, not including the libraries which we have been given explicitly 
          //  in the compile.json's `libraries` property


          let requires_uris = Object.getOwnPropertyNames(requires).filter(uri => !libs.find(lib => lib.getLibraryInfo().name == uri));
          let urisToInstall = requires_uris.filter(name => !name.startsWith("qooxdoo-") && name !== "@qooxdoo/framework" && name !== "@qooxdoo/compiler");
          let pkg_libs = Object.getOwnPropertyNames(packages);

          if (urisToInstall.length > 0 && pkg_libs.length === 0) {
            // if we don't have package data
            if (this.argv.download) {
              // but we're instructed to download the libraries
              if (this.argv.verbose) {
                Console.info(`>>> Installing latest compatible version of required libraries...`);
              }

              const installer = new qx.tool.cli.commands.package.Install({
                verbose: this.argv.verbose,
                save: false // save to lockfile only, not to manifest

              });
              await installer.process();
              throw new qx.tool.utils.Utils.UserError("Added missing library information from Manifest. Please restart the compilation.");
            } else {
              throw new qx.tool.utils.Utils.UserError("No library information available. Try 'qx compile --download'");
            }
          }

          for (let reqUri of requires_uris) {
            let requiredRange = requires[reqUri];
            const rangeIsCommitHash = /^[0-9a-f]{40}$/.test(requiredRange);

            switch (reqUri) {
              // npm release only
              case "qooxdoo-compiler":
              case "@qooxdoo/compiler":
                {
                  let compilerVersion = qx.tool.compiler.Version.VERSION;
                  let satifiesRange = semver.satisfies(compilerVersion, requiredRange, {
                    loose: true,
                    includePrerelease: true
                  }) || Number(semver.major(compilerVersion)) === 0 && semver.gtr(compilerVersion, requiredRange, true);

                  if (!satifiesRange) {
                    errors.push(`${lib.getNamespace()}: Needs @qooxdoo/compiler version ${requiredRange}, found ${compilerVersion}`);
                  }

                  break;
                }
              // npm release only

              case "qooxdoo-sdk":
              case "@qooxdoo/framework":
                {
                  let qxVersion = SDK_VERSION;

                  if (!semver.satisfies(qxVersion, requiredRange, {
                    loose: true
                  })) {
                    errors.push(`${lib.getNamespace()}: Needs @qooxdoo/framework version ${requiredRange}, found ${qxVersion}`);
                  }

                  break;
                }
              // github repository release or commit-ish identifier

              default:
                {
                  let l = libs.find(entry => path.relative("", entry.getRootDir()) === packages[reqUri]);

                  if (!l) {
                    errors.push(`${lib.getNamespace()}: Cannot find required library '${reqUri}'`);
                    break;
                  } // github release of a package


                  let libVersion = l.getLibraryInfo().version;

                  if (!semver.valid(libVersion, {
                    loose: true
                  })) {
                    if (!this.argv.quiet) {
                      Console.warn(`${reqUri}: Version is not valid: ${libVersion}`);
                    }
                  } else if (rangeIsCommitHash) {
                    if (!this.argv.quiet) {
                      Console.warn(`${reqUri}: Cannot check whether commit hash ${requiredRange} corresponds to version ${libVersion}`);
                    }
                  } else if (!semver.satisfies(libVersion, requiredRange, {
                    loose: true
                  })) {
                    errors.push(`${lib.getNamespace()}: Needs ${reqUri} version ${requiredRange}, found ${libVersion}`);
                  }

                  break;
                }
            }
          }
        }

        return errors;
      },

      /**
       * Resolves the target class instance from the type name; accepts "source" or "build" or
       * a class name
       * @param type {String}
       * @returns {Maker}
       */
      resolveTargetClass: function (type) {
        if (!type) {
          return null;
        }

        if (type.$$type == "Class") {
          return type;
        }

        if (type == "build") {
          return qx.tool.compiler.targets.BuildTarget;
        }

        if (type == "source") {
          return qx.tool.compiler.targets.SourceTarget;
        }

        if (type == "typescript") {
          throw new qx.tool.utils.Utils.UserError("Typescript targets are no longer supported - please use `typescript: true` in source target instead");
        }

        if (type) {
          var targetClass;

          if (type.indexOf(".") < 0) {
            targetClass = qx.Class.getByName("qx.tool.compiler.targets." + type);
          } else {
            targetClass = qx.Class.getByName(type);
          }

          return targetClass;
        }

        return null;
      },

      /**
       * Returns the list of makers to make
       *
       * @return  {Maker[]}
       */
      getMakers() {
        return this.__P_9_1;
      },

      /**
       * Returns the one maker; this is for backwards compatibility with the compiler API, because it is
       * possible to define multiple targets and therefore have multiple makers.  This method will return
       * the one maker, when there is only one maker defined (ie one target), which is fine for any existing
       * configurations.
       *
       * @deprected
       * @return {Maker}
       */
      getMaker() {
        if (this.__P_9_1.length == 1) {
          return this.__P_9_1[0];
        }

        throw new Error("Cannot get a single maker - there are " + this.__P_9_1.length + " available");
      },

      /**
       * Returns the makers for a given application name
       *
       * @param appName {String} the name of the application
       * @return {Maker}
       */
      getMakersForApp(appName) {
        return this.__P_9_1.filter(maker => {
          let res = maker.getApplications().find(app => app.getName() == appName);
          return res;
        });
      },

      /**
       * Returns the configuration object being compiled
       */
      _getConfig() {
        return this.__P_9_2;
      },

      /**
       * Returns a list of libraries which are used
       *
       * @return {Library[]}
       */
      getLibraries() {
        return this.__P_9_3;
      }

    },
    defer: function (statics) {
      qx.tool.compiler.Console.addMessageIds({
        "qx.tool.cli.compile.writingApplication": "Writing application %1",
        "qx.tool.cli.compile.minifyingApplication": "Minifying %1 %2",
        "qx.tool.cli.compile.compilingClass": "Compiling class %1",
        "qx.tool.cli.compile.compiledClass": "Compiled class %1 in %2s",
        "qx.tool.cli.compile.makeBegins": "Making applications...",
        "qx.tool.cli.compile.makeEnds": "Applications are made"
      });
      qx.tool.compiler.Console.addMessageIds({
        "qx.tool.cli.compile.multipleDefaultTargets": "Multiple default targets found!",
        "qx.tool.cli.compile.unusedTarget": "Target type %1, index %2 is unused",
        "qx.tool.cli.compile.selectingDefaultApp": "You have multiple applications, none of which are marked as 'default'; the first application named %1 has been chosen as the default application",
        "qx.tool.cli.compile.legacyFiles": "File %1 exists but is no longer used",
        "qx.tool.cli.compile.deprecatedCompile": "The configuration setting %1 in compile.json is deprecated",
        "qx.tool.cli.compile.deprecatedCompileSeeOther": "The configuration setting %1 in compile.json is deprecated (see %2)",
        "qx.tool.cli.compile.deprecatedUri": "URIs are no longer set in compile.json, the configuration setting %1=%2 in compile.json is ignored (it's auto detected)",
        "qx.tool.cli.compile.deprecatedProvidesBoot": "Manifest.Json no longer supports provides.boot - only Applications can have boot; specified in %1",
        "qx.tool.cli.compile.deprecatedBabelOptions": "Deprecated use of `babelOptions` - these should be moved to `babel.options`",
        "qx.tool.cli.compile.deprecatedBabelOptionsConflicting": "Conflicting use of `babel.options` and the deprecated `babelOptions` (ignored)"
      }, "warning");
    }
  });
  qx.tool.cli.commands.Compile.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.tool.utils.Promisify": {
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.tool.compiler.targets.meta.ApplicationMeta": {},
      "qx.tool.utils.Utils": {},
      "qx.tool.compiler.targets.meta.BootJs": {},
      "qx.tool.compiler.targets.meta.PolyfillJs": {},
      "qx.tool.compiler.app.Application": {},
      "qx.tool.compiler.targets.meta.Javascript": {},
      "qx.tool.compiler.Console": {},
      "qx.Promise": {},
      "qx.tool.compiler.app.Cldr": {},
      "qx.tool.utils.files.Utils": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
   *
   *    qooxdoo-compiler - node.js based replacement for the Qooxdoo python
   *    toolchain
   *
   *    https://github.com/qooxdoo/qooxdoo-compiler
   *
   *    Copyright:
   *      2011-2017 Zenesis Limited, http://www.zenesis.com
   *
   *    License:
   *      MIT: https://opensource.org/licenses/MIT
   *
   *      This software is provided under the same licensing terms as Qooxdoo,
   *      please see the LICENSE file in the Qooxdoo project's top-level directory
   *      for details.
   *
   *    Authors:
   *      * John Spackman (john.spackman@zenesis.com, @johnspackman)
   *
   * ************************************************************************/
  const fs = qx.tool.utils.Promisify.fs;

  const path = require("upath");
  /**
   * A target for building an application, instances of Target control the generation of transpiled
   * source and collection into an application, including minifying etc
   */


  qx.Class.define("qx.tool.compiler.targets.Target", {
    extend: qx.core.Object,

    /**
     * Constructor
     * @param outputDir {String} output directory
     */
    construct: function (outputDir) {
      qx.core.Object.constructor.call(this);
      this.setOutputDir(outputDir);
    },
    properties: {
      /** Type of compilation */
      type: {
        init: "source",
        nullable: false,
        check: ["source", "build"]
      },

      /** Output directory (guaranteed to have a trailing slash) */
      outputDir: {
        init: "output",
        nullable: false,
        check: "String",
        transform: "_transformOutputDir"
      },

      /**
       * Whether to generate the index.html
       */
      generateIndexHtml: {
        init: true,
        check: "Boolean"
      },

      /**
       * Environment property map
       */
      environment: {
        init: null,
        nullable: true
      },

      /**
       * Target type default environment property map
       */
      defaultEnvironment: {
        init: null,
        inheritable: true,
        nullable: true
      },

      /**
       * The analyser being generated
       */
      analyser: {
        nullable: false
      },

      /**
       * Whether to inline external scripts
       */
      inlineExternalScripts: {
        init: false,
        check: "Boolean"
      },

      /** Locales being generated */
      locales: {
        nullable: false,
        init: ["en"],
        transform: "_transformLocales"
      },

      /** Whether to break locale & translation data out into separate parts */
      i18nAsParts: {
        init: false,
        nullable: false,
        check: "Boolean"
      },

      /** Whether to write all translation strings (as opposed to just those used by the classes) */
      writeAllTranslations: {
        init: false,
        nullable: false,
        check: "Boolean"
      },

      /** Whether to update the source .po files with new strings */
      updatePoFiles: {
        init: false,
        nullable: false,
        check: "Boolean"
      },

      /** What to do with library transation strings */
      libraryPoPolicy: {
        init: "ignore",
        check: ["ignore", "untranslated", "all"]
      },

      /** Whether to write a summary of the compile info to disk, ie everything about dependencies and
       * resources that are used to create the index.js file, but stored as pure JSON for third party code
       * to use.
       */
      writeCompileInfo: {
        init: false,
        nullable: false,
        check: "Boolean"
      },

      /**
       * Whether to write information about the libraries into the boot script
       */
      writeLibraryInfo: {
        init: true,
        nullable: false,
        check: "Boolean"
      }
    },
    events: {
      /**
       * Fired after all enviroment data is collected, but before compilation begins; this
       * is an  opportunity to adjust the environment for the target.  The event data contains:
       *  application {qx.tool.compiler.app.Application} the app
       *  enviroment: {Object} enviroment data
       */
      "checkEnvironment": "qx.event.type.Data",

      /** 
       * Fired when an application is about to be serialized to disk; the appMeta is fully
       * populated, and this is an opportunity to amend the meta data before it is serialized
       * into files on disk 
       */
      "writingApplication": "qx.event.type.Event",

      /** 
       * Fired when an application has been serialized to disk
       */
      "writtenApplication": "qx.event.type.Event"
    },
    members: {
      /** @type {Map} maps filenames to uris */
      __P_38_0: null,

      /** @type {qx.tool.compiler.targets.meta.ApplicationMeta} for the current application */
      __P_38_1: null,

      /**
       * Initialises the target, creating directories etc
       */
      open: async function () {},

      /**
       * Transforms outputDir so that it always includes a trailing slash
       *
       * @param value
       * @returns {*}
       * @private
       */
      _transformOutputDir: function (value) {
        if (value) {
          if (value[value.length - 1] != "/") {
            value += "/";
          }
        }

        return value;
      },

      /**
       * Returns the root for applications
       */
      getApplicationRoot: function (application) {
        return path.join(this.getOutputDir(), this.getProjectDir(application)) + "/";
      },

      /**
       * Returns the project dir
       *
       * @returns String
       */
      getProjectDir: function (application) {
        return application.getOutputPath() || application.getName();
      },

      /**
       * Returns the URI for the root of the output, relative to the application
       */
      _getOutputRootUri: function (application) {
        var dir = this.getApplicationRoot(application);
        var targetUri = path.relative(dir, this.getOutputDir()) + "/";
        return targetUri;
      },

      /**
       * Adds a path mapping, where any reference to a file in `fromFile` is remapped to be
       * loaded via the `toUri.
       *
       * @param fromFile {String} the directory (or filename) to map
       * @param toUri {String} the URI to map to
       */
      addPathMapping: function (fromFile, toUri) {
        fromFile = path.resolve(fromFile);

        if (this.__P_38_0 === null) {
          this.__P_38_0 = {};
        }

        this.__P_38_0[fromFile] = toUri;
      },

      /**
       * Converts a filename to a URI, taking into account mappings added via `addMapping`.  If there is
       * no mapping, null is returned
       *
       * @param filename {String} the filename to map
       * @return {String} the URI for the file, null if not found
       */
      getPathMapping: function (filename) {
        if (this.__P_38_0) {
          var absFilename = path.resolve(filename); // Search

          for (var fromFile in this.__P_38_0) {
            if (absFilename.startsWith(fromFile)) {
              var toUri = this.__P_38_0[fromFile];
              filename = toUri + absFilename.substring(fromFile.length);
              return filename;
            }
          }
        }

        return null;
      },

      /**
       * Converts a filename to a URI, taking into account mappings added via `addMapping`.  If there is
       * no mapping, the filename can be modified to be relative to a given path (ie the directory where
       * the index.html is located)
       *
       * @param filename {String} the filename to map
       * @param relativeTo {String?} optional path that the filename needs to be relative to if there is no mapping
       * @return {String} the URI for the file
       */
      mapToUri(filename, relativeTo) {
        var mapTo = this.getPathMapping(filename);

        if (mapTo !== null) {
          return mapTo;
        }

        if (relativeTo) {
          filename = path.relative(relativeTo, filename);
        }

        return filename;
      },

      _copyClassesToFile: function (classes, outputFilename) {
        let transpiledDir = path.join(this.getOutputDir(), "transpiled");
        let allCode = [];
        return qx.tool.utils.Promisify.eachOfSeries(classes, filename => fs.readFileAsync(path.join(transpiledDir, filename), "utf8").then(code => allCode.push(code))).then(() => fs.writeFileAsync(outputFilename, allCode.join("\n")));
      },

      /**
       * Generates the application
       *
       * @param application {Application} the application
       * @param environment {Object} the environment
       */
      async generateApplication(application, environment) {
        var t = this;
        var analyser = application.getAnalyser();
        var rm = analyser.getResourceManager();
        let appMeta = this.__P_38_1 = new qx.tool.compiler.targets.meta.ApplicationMeta(this, application);
        /*      
        if (!appMeta.getAppLibrary()) {
          qx.tool.compiler.Console.print("qx.tool.compiler.target.missingAppLibrary", application.getClassName());
          return;
        }
        */

        let targetUri = t._getOutputRootUri(application);

        var appRootDir = this.getApplicationRoot(application);
        let mapTo = this.getPathMapping(path.join(appRootDir, this.getOutputDir(), "transpiled/"));
        appMeta.setSourceUri(mapTo ? mapTo : targetUri + "transpiled/");
        mapTo = this.getPathMapping(path.join(appRootDir, this.getOutputDir(), "resource"));
        appMeta.setResourceUri(mapTo ? mapTo : targetUri + "resource");
        const requiredLibs = application.getRequiredLibraries();
        await qx.tool.utils.Utils.makeDirs(appRootDir);
        appMeta.setEnvironment({
          "qx.application": application.getClassName(),
          "qx.revision": "",
          "qx.theme": application.getTheme(),
          "qx.version": analyser.getQooxdooVersion()
        });
        let externals = {};

        const addExternal = (arr, type) => {
          if (arr) {
            arr.forEach(filename => {
              if (externals[filename.toLowerCase()]) {
                return;
              }

              externals[filename.toLowerCase()] = true;
              let actualType = type || (filename.endsWith(".js") ? "urisBefore" : "cssBefore");

              if (filename.match(/^https?:/)) {
                appMeta.addExternal(actualType, filename);
              } else {
                let asset = rm.getAsset(filename);

                if (asset) {
                  let str = asset.getDestFilename(t);
                  str = path.relative(appRootDir, str);
                  appMeta.addPreload(actualType, str);
                }
              }
            });
          }
        };

        requiredLibs.forEach(libnamespace => {
          var library = analyser.findLibrary(libnamespace);
          appMeta.addLibrary(library);

          if (this.isWriteLibraryInfo()) {
            let libraryInfoMap = appMeta.getEnvironmentValue("qx.libraryInfoMap", {});
            libraryInfoMap[libnamespace] = library.getLibraryInfo();
          }

          addExternal(library.getAddScript(), "urisBefore");
          addExternal(library.getAddCss(), "cssBefore");
        });
        /*
         * Environment
         */

        for (let name in environment) {
          appMeta.setEnvironmentValue(name, environment[name]);
        }

        await t.fireDataEventAsync("checkEnvironment", {
          application: application,
          environment: appMeta.getEnvironment()
        });
        /*
         * Boot files
         */

        let bootJs = new qx.tool.compiler.targets.meta.BootJs(appMeta);
        let bootPackage = appMeta.createPackage();
        appMeta.setBootMetaJs(bootJs);
        bootPackage.addJavascriptMeta(new qx.tool.compiler.targets.meta.PolyfillJs(appMeta));
        /*
         * Assemble the Parts
         */

        var partsData = application.getPartsDependencies();
        let matchBundle = qx.tool.compiler.app.Application.createWildcardMatchFunction(application.getBundleInclude(), application.getBundleExclude());
        let lastPackage = bootPackage;
        let packages = {
          boot: bootPackage
        };
        partsData.forEach((partData, index) => {
          let partMeta = appMeta.createPart(partData.name);

          if (index == 0) {
            partMeta.addPackage(bootPackage);
          }

          partData.classes.forEach(classname => {
            let classFilename = classname.replace(/\./g, "/") + ".js";
            let transpiledClassFilename = path.join(this.getOutputDir(), "transpiled", classFilename);
            let db = analyser.getDatabase();
            let dbClassInfo = db.classInfo[classname];
            let library = analyser.findLibrary(dbClassInfo.libraryName);
            let sourcePath = library.getFilename(classFilename);
            let jsMeta = new qx.tool.compiler.targets.meta.Javascript(appMeta, transpiledClassFilename, sourcePath);
            let packageName = matchBundle(classname) ? "__bundle" : partData.name;
            let pkg = packages[packageName];

            if (!pkg || pkg !== lastPackage) {
              pkg = packages[packageName] = appMeta.createPackage();

              if (packageName == "__bundle") {
                pkg.setEmbedAllJavascript(true);
              }

              partMeta.addPackage(pkg);
            }

            if (dbClassInfo.externals) {
              addExternal(dbClassInfo.externals);
            }

            pkg.addJavascriptMeta(jsMeta);
            pkg.addClassname(classname);
            lastPackage = pkg;
          });
        });
        var assetUris = application.getAssetUris(t, rm, appMeta.getEnvironment()); // Save any changes that getAssets collected

        await rm.saveDatabase();
        var assets = {};
        rm.getAssetsForPaths(assetUris).forEach(asset => {
          bootPackage.addAsset(asset);
          assets[asset] = true;
        });
        var promises = [analyser.getCldr("en").then(cldr => bootPackage.addLocale("C", cldr)), t._writeTranslations()];
        var fontCntr = 0;
        requiredLibs.forEach(libnamespace => {
          var library = analyser.findLibrary(libnamespace);
          var fonts = library.getWebFonts();

          if (!fonts) {
            return;
          }

          const loadFont = async font => {
            try {
              // check if font is asset somewhere
              let res = font.getResources().filter(res => {
                let s = library.getNamespace() + ":" + res;
                return assets[s];
              });

              if (res.length === 0) {
                return;
              }

              font.setResources(res);
              var p = await font.generateForTarget(t);
              let resources = await font.generateForApplication(t, application);

              for (var key in resources) {
                appMeta.addResource(key, resources[key]);
              }

              var code = font.getBootstrapCode(t, application, fontCntr++ == 0);

              if (code) {
                appMeta.addPreBootCode(code);
              }
            } catch (ex) {
              qx.tool.compiler.Console.print("qx.tool.compiler.webfonts.error", font.toString(), ex.toString());
            }

            promises.push(p);
          };

          fonts.forEach(font => promises.push(loadFont(font)));
        });
        await qx.Promise.all(promises);
        await t._writeApplication();
        this.__P_38_1 = null;
      },

      /**
       * Handles the output of translations and locales
       */
      async _writeTranslations() {
        let appMeta = this.getAppMeta();
        const analyser = appMeta.getAnalyser();

        if (this.isUpdatePoFiles()) {
          let policy = this.getLibraryPoPolicy();

          if (policy != "ignore") {
            await analyser.updateTranslations(appMeta.getAppLibrary(), this.getLocales(), appMeta.getLibraries(), policy == "all");
          } else {
            await analyser.updateTranslations(appMeta.getAppLibrary(), this.getLocales(), null, false);
          }
        }

        await this._writeLocales();

        if (this.getWriteAllTranslations()) {
          await this._writeAllTranslations();
        } else {
          await this._writeRequiredTranslations();
        }
      },

      /**
       * Transform method for locales property; ensures that all locales are case correct, ie
       * have the form aa_BB (for example "en_GB" is correct but "en_gb" is invalid)
       *
       * @param value {String[]} array of locale IDs
       * @return {String[]} the modified array
       */
      _transformLocales: function (value) {
        if (!value) {
          return value;
        }

        return value.map(localeId => {
          localeId = localeId.toLowerCase();
          var pos = localeId.indexOf("_");

          if (pos > -1) {
            localeId = localeId.substring(0, pos) + localeId.substring(pos).toUpperCase();
          }

          return localeId;
        });
      },

      /**
       * Writes the required locale CLDR data, incorporating inheritance.  Note that locales in CLDR can
       * have a "parent locale", where the locale inherits all settings from the parent except where explicitly
       * set in the locale.  This is in addition to the inheritance between language and locale, eg where "en_GB"
       * overrides settings from "en".  Qooxdoo client understands that if a setting is not provided in
       * "en_GB" it must look to "en", but it does not understand the "parent locale" inheritance, so this
       * method must flatten the "parent locale" inheritance.
       */
      async _writeLocales() {
        var t = this;
        let appMeta = this.getAppMeta();
        var analyser = appMeta.getAnalyser();
        let bootPackage = appMeta.getPackages()[0];

        function loadLocaleData(localeId) {
          var combinedCldr = null;

          function accumulateCldr(localeId) {
            return analyser.getCldr(localeId).then(cldr => {
              if (!combinedCldr) {
                combinedCldr = cldr;
              } else {
                for (var name in cldr) {
                  var value = combinedCldr[name];

                  if (value === null || value === undefined) {
                    combinedCldr[name] = cldr[name];
                  }
                }
              }

              var parentLocaleId = qx.tool.compiler.app.Cldr.getParentLocale(localeId);

              if (parentLocaleId) {
                return accumulateCldr(parentLocaleId);
              }

              return combinedCldr;
            });
          }

          return accumulateCldr(localeId);
        }

        var promises = t.getLocales().map(async localeId => {
          let cldr = await loadLocaleData(localeId);
          let pkg = this.isI18nAsParts() ? appMeta.getLocalePackage(localeId) : bootPackage;
          pkg.addLocale(localeId, cldr);
        });
        await qx.Promise.all(promises);
      },

      /**
       * Writes all translations
       */
      async _writeAllTranslations() {
        var t = this;
        let appMeta = this.getAppMeta();
        var analyser = appMeta.getAnalyser();
        let bootPackage = appMeta.getPackages()[0];
        var translations = {};
        var promises = [];
        t.getLocales().forEach(localeId => {
          let pkg = this.isI18nAsParts() ? appMeta.getLocalePackage(localeId) : bootPackage;

          function addTrans(library, localeId) {
            return analyser.getTranslation(library, localeId).then(translation => {
              var id = library.getNamespace() + ":" + localeId;
              translations[id] = translation;
              var entries = translation.getEntries();

              for (var msgid in entries) {
                pkg.addTranslationEntry(localeId, entries[msgid]);
              }
            });
          }

          appMeta.getLibraries().forEach(function (library) {
            if (library === appMeta.getAppLibrary()) {
              return;
            }

            promises.push(addTrans(library, localeId));
          }); // translation from main app should overwrite package translations 

          promises.push(addTrans(appMeta.getAppLibrary(), localeId));
        });
        await qx.Promise.all(promises);
      },

      /**
       * Writes only those translations which are actually required
       */
      async _writeRequiredTranslations() {
        var t = this;
        let appMeta = this.getAppMeta();
        var analyser = appMeta.getAnalyser();
        var db = analyser.getDatabase();
        let bootPackage = appMeta.getPackages()[0];
        var translations = {};
        var promises = [];
        t.getLocales().forEach(localeId => {
          let pkg = this.isI18nAsParts() ? appMeta.getLocalePackage(localeId) : bootPackage;
          appMeta.getLibraries().forEach(function (library) {
            promises.push(analyser.getTranslation(library, localeId).then(translation => {
              var id = library.getNamespace() + ":" + localeId;
              translations[id] = translation;
              let entry = translation.getEntry("");

              if (entry) {
                pkg.addTranslationEntry(localeId, entry);
              }
            }));
          });
        });
        await qx.Promise.all(promises);
        appMeta.getPackages().forEach(pkg => {
          pkg.getClassnames().forEach(classname => {
            var dbClassInfo = db.classInfo[classname];

            if (!dbClassInfo.translations) {
              return;
            }

            t.getLocales().forEach(localeId => {
              let localePkg = this.isI18nAsParts() ? appMeta.getLocalePackage(localeId) : pkg;
              dbClassInfo.translations.forEach(transInfo => {
                let entry;
                let id = appMeta.getAppLibrary().getNamespace() + ":" + localeId; // search in main app first

                let translation = translations[id];

                if (translation) {
                  entry = translation.getEntry(transInfo.msgid);
                }

                let idLib = dbClassInfo.libraryName + ":" + localeId;

                if (!entry && id !== idLib) {
                  let translation = translations[idLib];

                  if (translation) {
                    entry = translation.getEntry(transInfo.msgid);
                  }
                }

                if (entry) {
                  localePkg.addTranslationEntry(localeId, entry);
                }
              });
            });
          });
        });
      },

      /**
       * Writes the application
       */
      async _writeApplication() {
        var t = this;
        await this.fireEventAsync("writingApplication");
        let appMeta = this.getAppMeta();
        var application = appMeta.getApplication();
        var appRootDir = appMeta.getApplicationRoot();
        let bootMeta = appMeta.getBootMetaJs();

        for (let arr = appMeta.getPackages(), i = 0; i < arr.length; i++) {
          let pkg = arr[i];

          if (pkg.isEmpty()) {
            pkg.setNeedsWriteToDisk(false);
            bootMeta.addEmbeddedJs(pkg.getJavascript());
          }

          await pkg.getJavascript().unwrap().writeToDisk();
        }

        await appMeta.getBootMetaJs().unwrap().writeToDisk();
        await this._writeIndexHtml();

        if (!t.isWriteCompileInfo()) {
          return;
        }

        let bootPackage = appMeta.getPackages()[0];
        let appSummary = {
          appClass: application.getClassName(),
          libraries: appMeta.getLibraries().map(lib => lib.getNamespace()),
          parts: [],
          resources: bootPackage.getAssets().map(asset => asset.getFilename()),
          locales: this.getLocales(),
          environment: appMeta.getEnvironment(),
          urisBefore: appMeta.getPreloads().urisBefore,
          cssBefore: appMeta.getPreloads().cssBefore
        };
        application.getPartsDependencies().forEach(partData => {
          appSummary.parts.push({
            classes: partData.classes,
            include: partData.include,
            exclude: partData.exclude,
            minify: partData.minify,
            name: partData.name
          });
        });
        await fs.writeFileAsync(appRootDir + "/compile-info.json", JSON.stringify(appSummary, null, 2) + "\n", {
          encoding: "utf8"
        });
        await this.fireEventAsync("writtenApplication");
      },

      /**
       * Called to generate index.html
       */
      async _writeIndexHtml() {
        var t = this;
        let appMeta = this.getAppMeta();
        var application = appMeta.getApplication();

        if (!application.isBrowserApp()) {
          return;
        }

        if (!this.isGenerateIndexHtml()) {
          return;
        }

        var resDir = this.getApplicationRoot(application);
        let pathToTarget = path.relative(path.join(t.getOutputDir(), t.getProjectDir(application)), t.getOutputDir()) + "/";
        let TEMPLATE_VARS = {
          "resourcePath": pathToTarget + "resource/",
          "targetPath": pathToTarget,
          "appPath": "",
          "preBootJs": "",
          "appTitle": application.getTitle() || "Qooxdoo Application"
        };

        function replaceVars(code) {
          for (let varName in TEMPLATE_VARS) {
            code = code.replace(new RegExp(`\\$\{${varName}\}`, "g"), TEMPLATE_VARS[varName]);
          }

          return code;
        }
        /* eslint-disable no-template-curly-in-string */


        let defaultIndexHtml = "<!DOCTYPE html>\n<html>\n<head>\n  <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />\n  <title>${appTitle}</title>\n</head>\n<body>\n  <!-- This index.html can be customised by creating a boot/index.html (do not include Qooxdoo application script tags like\n       the one below because they will be added automatically)\n    -->\n${preBootJs}\n  <script type=\"text/javascript\" src=\"${appPath}index.js\"></script>\n</body>\n</html>\n";
        /* eslint-enable no-template-curly-in-string */

        var bootDir = application.getBootPath();
        let indexHtml = null;

        if (bootDir) {
          bootDir = path.join(appMeta.getAppLibrary().getRootDir(), application.getBootPath());
          var stats = await qx.tool.utils.files.Utils.safeStat(bootDir);

          if (stats && stats.isDirectory()) {
            await qx.tool.utils.files.Utils.sync(bootDir, resDir, async (from, to) => {
              if (!from.endsWith(".html")) {
                return true;
              }

              let data = await fs.readFileAsync(from, "utf8");

              if (path.basename(from) == "index.html") {
                if (!data.match(/\$\{\s*preBootJs\s*\}/)) {
                  /* eslint-disable no-template-curly-in-string */
                  data = data.replace("</body>", "\n${preBootJs}\n</body>");
                  /* eslint-enable no-template-curly-in-string */

                  qx.tool.compiler.Console.print("qx.tool.compiler.target.missingPreBootJs", from);
                }

                if (!data.match(/\s*index.js\s*/)) {
                  /* eslint-disable no-template-curly-in-string */
                  data = data.replace("</body>", "\n  <script type=\"text/javascript\" src=\"${appPath}index.js\"></script>\n</body>");
                  /* eslint-enable no-template-curly-in-string */

                  qx.tool.compiler.Console.print("qx.tool.compiler.target.missingBootJs", from);
                }

                indexHtml = data;
              }

              data = replaceVars(data);
              await fs.writeFileAsync(to, data, "utf8");
              return false;
            });
          }
        }

        if (!indexHtml) {
          indexHtml = defaultIndexHtml;
          await fs.writeFileAsync(resDir + "index.html", replaceVars(indexHtml), {
            encoding: "utf8"
          });
        }

        if (application.getWriteIndexHtmlToRoot()) {
          pathToTarget = "";
          TEMPLATE_VARS = {
            "resourcePath": "resource/",
            "targetPath": "",
            "appPath": t.getProjectDir(application) + "/",
            "preBootJs": "",
            "appTitle": application.getTitle() || "Qooxdoo Application"
          };
          await fs.writeFileAsync(t.getOutputDir() + "index.html", replaceVars(indexHtml), {
            encoding: "utf8"
          });
        }
      },

      getAppMeta() {
        return this.__P_38_1;
      }

    }
  });
  qx.tool.compiler.targets.Target.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.tool.compiler.targets.Target": {
        "require": true
      },
      "qx.tool.compiler.targets.meta.Uglify": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
   *
   *    qooxdoo-compiler - node.js based replacement for the Qooxdoo python
   *    toolchain
   *
   *    https://github.com/qooxdoo/qooxdoo-compiler
   *
   *    Copyright:
   *      2011-2017 Zenesis Limited, http://www.zenesis.com
   *
   *    License:
   *      MIT: https://opensource.org/licenses/MIT
   *
   *      This software is provided under the same licensing terms as Qooxdoo,
   *      please see the LICENSE file in the Qooxdoo project's top-level directory
   *      for details.
   *
   *    Authors:
   *      * John Spackman (john.spackman@zenesis.com, @johnspackman)
   *
   * ************************************************************************/

  /**
   * Compiles a "build" application, minified and self contained application
   */
  qx.Class.define("qx.tool.compiler.targets.BuildTarget", {
    extend: qx.tool.compiler.targets.Target,
    properties: {
      /** Whether to minify the output */
      minify: {
        init: "mangle",
        check: ["off", "minify", "mangle", "beautify"],
        nullable: false
      },

      /** Whether to preserve unminified output */
      saveUnminified: {
        init: false,
        check: "Boolean",
        nullable: false
      },

      /** Whether to save the source in the map file */
      saveSourceInMap: {
        init: false,
        check: "Boolean",
        nullable: false
      },

      /** Deploy directory (guaranteed to have a trailing slash) */
      deployDir: {
        init: null,
        nullable: true,
        check: "String",
        transform: "_transformOutputDir"
      },

      /** Whether to deploy the source maps */
      deployMap: {
        init: false,
        check: "Boolean",
        nullable: false
      },
      defaultEnvironment: {
        init: {
          "qx.debug": false
        },
        refine: true
      }
    },
    events: {
      /**
       * Fired when minification begins, data is a map containing:
       *  application {qx.tool.compiler.app.Application} the app being minified
       *  part: {String} the part being minified
       *  filename: {String} the part filename
       */
      "minifyingApplication": "qx.event.type.Data",

      /**
       * Fired when minification is done, data is a map containing:
       *  application {qx.tool.compiler.app.Application} the app being minified
       *  part: {String} the part being minified
       *  filename: {String} the part filename
       */
      "minifiedApplication": "qx.event.type.Data"
    },
    members: {
      /*
       * @Override
       */
      async _writeApplication() {
        let appMeta = this.getAppMeta();
        appMeta.setSourceUri(".");
        await appMeta.syncAssets();
        let doUglify = appMeta.getTarget().getMinify() != "off";
        let bootMeta = appMeta.getBootMetaJs();
        let bootPart = appMeta.getParts()[0];
        appMeta.getPackages().forEach(pkg => {
          pkg.setEmbedAllJavascript(true);

          if (bootPart.hasPackage(pkg)) {
            pkg.setNeedsWriteToDisk(false);
            bootMeta.addEmbeddedJs(pkg.getJavascript());
          }

          if (doUglify && pkg.isNeedsWriteToDisk()) {
            pkg.getJavascript().wrap(new qx.tool.compiler.targets.meta.Uglify(appMeta, pkg.getJavascript()));
          }
        });

        if (doUglify) {
          appMeta.getBootMetaJs().wrap(new qx.tool.compiler.targets.meta.Uglify(appMeta, bootMeta));
        }

        return await qx.tool.compiler.targets.BuildTarget.prototype._writeApplication.base.call(this);
      },

      /*
       * @Override
       */
      toString: function () {
        return "Build Target: " + this.getOutputDir();
      }
    }
  });
  qx.tool.compiler.targets.BuildTarget.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.tool.utils.LogManager": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
   *
   *    qooxdoo-compiler - node.js based replacement for the Qooxdoo python
   *    toolchain
   *
   *    https://github.com/qooxdoo/qooxdoo-compiler
   *
   *    Copyright:
   *      2011-2017 Zenesis Limited, http://www.zenesis.com
   *
   *    License:
   *      MIT: https://opensource.org/licenses/MIT
   *
   *      This software is provided under the same licensing terms as Qooxdoo,
   *      please see the LICENSE file in the Qooxdoo project's top-level directory
   *      for details.
   *
   *    Authors:
   *      * John Spackman (john.spackman@zenesis.com, @johnspackman)
   *
   * *********************************************************************** */
  qx.Class.define("qx.tool.utils.Logger", {
    extend: qx.core.Object,
    construct: function (id, minLevel) {
      qx.core.Object.constructor.call(this);
      this.set({
        id: id,
        minLevel: minLevel
      });
    },
    properties: {
      id: {
        check: "String"
      },
      minLevel: {
        check: "Integer"
      }
    },
    members: {
      is: function (level) {
        if (typeof level == "string") {
          level = qx.tool.utils.LogManager.getInstance()._levels[level];
        }

        return this.getMinLevel() <= level;
      },
      log: function (level, msg) {
        if (this.is(level)) {
          this._output(level, msg);
        }
      },
      _output: function (level, msg) {
        qx.tool.utils.LogManager.getInstance().output(this, level, msg);
      },
      trace: function (msg) {
        return this.log("trace", msg);
      },
      debug: function (msg) {
        return this.log("debug", msg);
      },
      info: function (msg) {
        return this.log("info", msg);
      },
      warn: function (msg) {
        return this.log("warn", msg);
      },
      error: function (msg) {
        return this.log("error", msg);
      },
      fatal: function (msg) {
        return this.log("fatal", msg);
      }
    }
  });
  qx.tool.utils.Logger.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.tool.utils.Logger": {
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.tool.utils.Json": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
   *
   *    qooxdoo-compiler - node.js based replacement for the Qooxdoo python
   *    toolchain
   *
   *    https://github.com/qooxdoo/qooxdoo-compiler
   *
   *    Copyright:
   *      2011-2017 Zenesis Limited, http://www.zenesis.com
   *
   *    License:
   *      MIT: https://opensource.org/licenses/MIT
   *
   *      This software is provided under the same licensing terms as Qooxdoo,
   *      please see the LICENSE file in the Qooxdoo project's top-level directory
   *      for details.
   *
   *    Authors:
   *      * John Spackman (john.spackman@zenesis.com, @johnspackman)
   *
   * 
   * *********************************************************************** */

  /**
   * @require(qx.tool.utils.Logger)
   */
  var LEVELS = ["trace", "debug", "info", "warn", "error", "fatal"];

  function zeropad2(val) {
    if (val < 10) {
      return "0" + val;
    }

    return String(val);
  }

  function zeropad3(val) {
    if (val < 10) {
      return "00" + val;
    }

    if (val < 100) {
      return "0" + val;
    }

    return String(val);
  }

  var PADDING = "";

  function padding(minLen) {
    while (PADDING.length < minLen) {
      PADDING += "     ";
    }

    return PADDING;
  }

  function rpad(str, len) {
    str = String(str);

    if (str.length < len) {
      str = (str + padding(len)).substring(0, len);
    }

    return str;
  }

  qx.Class.define("qx.tool.utils.LogManager", {
    extend: qx.core.Object,
    construct: function () {
      qx.core.Object.constructor.call(this);
      var t = this;
      this._loggers = {};
      this._levels = {};
      this._sinks = [];
      this._config = {};
      this._defaultSink = qx.tool.utils.LogManager.consoleSink;
      this.addSink(this._defaultSink);
      LEVELS.forEach(function (levelId, index) {
        t._levels[levelId] = index;
      });
      this._defaultLevel = this._levels.info;
    },
    statics: {
      __P_49_0: null,

      /**
       * create a logger for a specified category
       * 
       * @param {*} categoryName 
       */
      createLog: function (categoryName) {
        if (!categoryName) {
          categoryName = "generic";
        }

        return this.getInstance().getLogger(categoryName);
      },

      /**
       * Returns the global instance
       * @returns {null}
       */
      getInstance: function () {
        if (!this.__P_49_0) {
          this.__P_49_0 = new qx.tool.utils.LogManager();
        }

        return this.__P_49_0;
      },
      nullSink: function (logger, level, msg) {// Nothing
      },
      consoleSink: function (logger, level, msg) {
        var dt = new Date();
        var str = dt.getFullYear() + "-" + zeropad2(dt.getMonth() + 1) + "-" + zeropad2(dt.getDate()) + " " + zeropad2(dt.getHours()) + ":" + zeropad2(dt.getMinutes()) + ":" + zeropad2(dt.getSeconds()) + "." + zeropad3(dt.getMilliseconds());
        console.log(str + " [" + rpad(level, 5) + "] " + rpad(logger.getId(), 15, true) + " " + msg);
      }
    },
    members: {
      loadConfig: async function (config) {
        if (typeof config == "string") {
          config = await qx.tool.utils.Json.loadJsonAsync(config);
        }

        var t = this;
        this._config = config;
        this._defaultLevel = this.getLoggerLevel("__default__", "info");

        for (var id in this._loggers) {
          var logger = this._loggers[id];
          logger.setMinLevel(t.getLoggerLevel(logger.getId()));
        }
      },
      getLogger: function (id) {
        var logger = this._loggers[id];

        if (!logger) {
          logger = this._loggers[id] = new qx.tool.utils.Logger(id, this.getLoggerLevel(id));
        }

        return logger;
      },
      getLoggerLevel: function (id, defaultLevel) {
        var cat = this._config && this._config.categories && this._config.categories[id];
        var level = cat && cat.level;

        if (level) {
          level = this._levels[level];
        }

        if (typeof level == "number") {
          return level;
        }

        if (defaultLevel) {
          return this._levels[defaultLevel];
        }

        return this._defaultLevel;
      },
      addSink: function (sink) {
        this._sinks.push(sink);
      },
      removeSink: function (sink) {
        var index = this._sinks.indexOf(sink);

        if (index > -1) {
          this._sinks.splice(index, 1);
        }
      },
      output: function (logger, level, msg) {
        if (typeof level != "string") {
          level = LEVELS[level];
        }

        this._sinks.forEach(function (sink) {
          sink.call(this, logger, level, msg);
        });
      },
      setDefaultSink: function (sink) {
        var oldSink = this._defaultSink;

        if (this._defaultSink) {
          this.removeSink(this._defaultSink);
        }

        this._defaultSink = sink;

        if (sink) {
          this.addSink(sink);
        }

        return oldSink;
      }
    }
  });
  qx.tool.utils.LogManager.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.tool.utils.LogManager": {
        "usage": "dynamic",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.tool.compiler.Console": {},
      "qx.tool.utils.files.Utils": {},
      "qx.tool.utils.Json": {},
      "qx.Promise": {},
      "qx.tool.compiler.app.WebFont": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
   *
   *    qooxdoo-compiler - node.js based replacement for the Qooxdoo python
   *    toolchain
   *
   *    https://github.com/qooxdoo/qooxdoo-compiler
   *
   *    Copyright:
   *      2011-2017 Zenesis Limited, http://www.zenesis.com
   *
   *    License:
   *      MIT: https://opensource.org/licenses/MIT
   *
   *      This software is provided under the same licensing terms as Qooxdoo,
   *      please see the LICENSE file in the Qooxdoo project's top-level directory
   *      for details.
   *
   *    Authors:
   *      * John Spackman (john.spackman@zenesis.com, @johnspackman)
   *
   * *********************************************************************** */
  var path = require("path");

  var fs = require("fs");

  var async = require("async");

  var log = qx.tool.utils.LogManager.createLog("library");
  /**
   * A Qooxdoo Library or application; typical usage is to call .loadManifest to configure from
   * the library itself
   */

  qx.Class.define("qx.tool.compiler.app.Library", {
    extend: qx.core.Object,
    construct: function () {
      qx.core.Object.constructor.call(this);
      this.__P_26_0 = {};
      this.__P_26_1 = {};
      this.__P_26_2 = {};
    },
    properties: {
      /** The namespace of the library */
      namespace: {
        check: "String"
      },

      /** The version of the library */
      version: {
        check: "String"
      },

      /** The directory; transformed into an absolute path */
      rootDir: {
        check: "String",
        transform: "_transformRootDir"
      },

      /** The path to source files, relative to rootDir */
      sourcePath: {
        init: "source/class",
        check: "String"
      },

      /** The path to generated transpiled files, relative to rootDir */
      transpiledPath: {
        init: "source/transpiled",
        check: "String"
      },

      /** The info section form the Manifest */
      libraryInfo: {
        check: "Map"
      },

      /** The path to resource files, relative to rootDir */
      resourcePath: {
        init: "source/resource",
        check: "String"
      },

      /** The path to resource files, relative to rootDir */
      themePath: {
        init: "source/theme",
        check: "String"
      },

      /** The path to translation files, relative to rootDir */
      translationPath: {
        init: "source/translation",
        check: "String"
      },

      /** {WebFont[]} List of webfonts provided */
      webFonts: {
        init: null,
        nullable: true,
        check: "Array"
      },

      /** Array of external scripts required by the library */
      addScript: {
        init: null
      },

      /** Array of external stylesheets required by the library */
      addCss: {
        init: null
      },

      /**  Array of requires resources of the library */
      requires: {
        init: null
      }
    },
    members: {
      __P_26_0: null,
      __P_26_1: null,
      __P_26_3: null,
      __P_26_2: null,

      /**
       * Transform for rootDir; converts it to an absolute path
       * @param value
       * @returns {*}
       * @private
       */
      _transformRootDir: function (value) {
        //      if (value)
        //        value = path.resolve(value);
        return value;
      },

      /**
       * Loads the Manifest.json from the directory and uses it to configure
       * properties
       * @param loadFromDir {String} directory
       */
      loadManifest: function (loadFromDir) {
        if (this.__P_26_3) {
          return this.__P_26_3;
        }

        return this.__P_26_3 = this.__P_26_4(loadFromDir);
      },

      __P_26_4(loadFromDir) {
        var Console = qx.tool.compiler.Console.getInstance();
        var t = this;
        let rootDir = loadFromDir;
        return qx.tool.utils.files.Utils.correctCase(path.resolve(loadFromDir)).then(tmp => this.setRootDir(rootDir = tmp)).then(() => qx.tool.utils.Json.loadJsonAsync(rootDir + "/Manifest.json")).then(data => {
          if (!data) {
            throw new Error(Console.decode("qx.tool.compiler.library.emptyManifest", rootDir));
          }

          t.setNamespace(data.provides.namespace);
          t.setVersion(data.info.version);

          if (data.provides.environmentChecks) {
            for (var key in data.provides.environmentChecks) {
              let check = data.provides.environmentChecks[key];
              let pos = key.indexOf("*");

              if (pos > -1) {
                this.__P_26_2[key] = {
                  matchString: key.substring(0, pos),
                  startsWith: true,
                  className: check
                };
              } else {
                this.__P_26_2[key] = {
                  matchString: key,
                  className: check
                };
              }
            }
          }

          function fixLibraryPath(dir) {
            let d = path.resolve(rootDir, dir);

            if (!fs.existsSync(d)) {
              t.warn(Console.decode("qx.tool.compiler.library.cannotFindPath", t.getNamespace(), dir));
              return qx.Promise.resolve(dir);
            }

            return qx.tool.utils.files.Utils.correctCase(d).then(correctedDir => {
              if (correctedDir.substring(0, rootDir.length + 1) != rootDir + path.sep) {
                t.warn(Console.decode("qx.tool.compiler.library.cannotCorrectCase", rootDir));
                return dir;
              }

              correctedDir = correctedDir.substring(rootDir.length + 1);
              return correctedDir;
            });
          }

          return fixLibraryPath(data.provides["class"]).then(sourcePath => t.setSourcePath(sourcePath)).then(() => fixLibraryPath(data.provides.resource)).then(resourcePath => t.setResourcePath(data.provides.resource)).then(() => {
            t.setLibraryInfo(data.info);

            if (data.provides.transpiled) {
              t.setTranspiledPath(data.provides.transpiled);
            } else {
              let sourcePath = t.getSourcePath();
              var m = sourcePath.match(/^(.*)\/([^/]+)$/);

              if (m && m.length == 3) {
                t.setTranspiledPath(m[1] + "/transpiled");
              } else {
                t.setTranspiledPath("transpiled");
              }
            }

            if (data.provides.translation) {
              t.setTranslationPath(data.provides.translation);
            }

            if (data.provides.webfonts) {
              var fonts = [];
              data.provides.webfonts.forEach(wf => {
                var font = new qx.tool.compiler.app.WebFont(t).set(wf);
                fonts.push(font);
              });
              t.setWebFonts(fonts);
            }

            if (data.externalResources) {
              if (data.externalResources.script) {
                t.setAddScript(data.externalResources.script);
              }

              if (data.externalResources.css) {
                t.setAddCss(data.externalResources.css);
              }
            }

            if (data.requires) {
              t.setRequires(data.requires);
            }

            if (data.provides && data.provides.boot) {
              qx.tool.compiler.Console.print("qx.tool.cli.compile.deprecatedProvidesBoot", rootDir);
            }
          });
        });
      },

      /**
       * Scans the filing system looking for classes; there are occasions (ie Qooxdoo's qxWeb module)
       * where the class name does not comply with the namespace, this method is used to find those
       * files and also to prepopulate the known symbols list
       * @param cb {Function} (err, classes) returns an array of class names
       */
      scanForClasses: function (cb) {
        var t = this;
        var classes = [];

        function scanDir(folder, packageName, cb) {
          fs.readdir(folder, function (err, filenames) {
            if (err) {
              cb(err);
              return;
            }

            async.each(filenames, function (filename, cb) {
              if (filename[0] == ".") {
                cb();
                return;
              }

              fs.stat(path.join(folder, filename), function (err, stat) {
                if (err || !stat) {
                  cb(err);
                  return;
                }

                if (stat.isDirectory()) {
                  var tmp = packageName;

                  if (tmp.length) {
                    tmp += ".";
                  }

                  tmp += filename;
                  scanDir(path.join(folder, filename), tmp, cb);
                  return;
                } // Make sure it looks like a file


                var match = filename.match(/(.*)(\.\w+)$/);

                if (!match) {
                  log.trace("Skipping file " + folder + "/" + filename);
                  cb();
                  return;
                } // Class name


                var className = match[1];
                var extension = match[2];

                if (packageName.length) {
                  className = packageName + "." + className;
                }

                if (className.match(/__init__/)) {
                  cb();
                  return;
                }

                if (extension == ".js" || extension == ".ts") {
                  t.__P_26_0[className] = "class";
                  t.__P_26_1[className] = extension;
                  classes.push(className);
                } else {
                  t.__P_26_0[filename] = "resource";
                }

                if (Boolean(packageName) && !t.__P_26_0[packageName]) {
                  t.__P_26_0[packageName] = "package";
                  var pos;
                  tmp = packageName;

                  while ((pos = tmp.lastIndexOf(".")) > -1) {
                    tmp = tmp.substring(0, pos);
                    t.__P_26_0[tmp] = "package";
                  }
                }

                cb();
              });
            }, cb);
          });
        }

        let rootDir = path.join(t.getRootDir(), t.getSourcePath());

        if (!fs.existsSync(rootDir)) {
          let Console = qx.tool.compiler.Console.getInstance();
          this.warn(Console.decode("qx.tool.compiler.library.cannotFindPath", t.getNamespace(), rootDir));
          cb(null, []);
          return;
        }

        scanDir(rootDir, "", function (err) {
          cb(err, classes);
        });
      },

      /**
       * Detects the type of a symbol, "class", "resource", "package", "environment", or null if not found
       *
       * @param {String} name
       * @return {{symbolType,name,className}?}
       */
      getSymbolType: function (name) {
        if (!name.length) {
          return null;
        }

        var t = this;
        var type = this.__P_26_0[name];

        if (type) {
          return {
            symbolType: t.__P_26_0[name],
            className: type == "class" ? name : null,
            name: name
          };
        }

        function testEnvironment(check) {
          if (!check) {
            return null;
          }

          let match = false;

          if (check.startsWith) {
            match = name.startsWith(check.matchString);
          } else {
            match = name == check.matchString;
          }

          if (match) {
            return {
              symbolType: "environment",
              className: check.className,
              name: name
            };
          }
        }

        let result = testEnvironment(this.__P_26_2[name]);

        if (result) {
          return result;
        }

        for (let key in this.__P_26_2) {
          let check = this.__P_26_2[key];

          if (check.startsWith) {
            result = testEnvironment(check);
            if (result != null) return result;
          }
        }

        var tmp = name;
        var pos;

        while ((pos = tmp.lastIndexOf(".")) > -1) {
          tmp = tmp.substring(0, pos);
          type = this.__P_26_0[tmp];

          if (type) {
            if (type == "class") {
              return {
                symbolType: "member",
                className: tmp,
                name: name
              };
            }

            return null;
          }
        }

        return null;
      },

      /**
       * Checks whether the classname is an actual class, in this library
       * 
       * @param classname {String} classname to look for
       * @return {Boolean}
       */
      isClass(classname) {
        var type = this.__P_26_0[classname];
        return type === "class";
      },

      /**
       * Returns all known symbols as a map indexed by symbol name
       */
      getKnownSymbols: function () {
        return this.__P_26_0;
      },

      /**
       * Returns the original extension of the class file that implemented the
       * given class name.
       *
       * @param {String} className
       */
      getSourceFileExtension: function (className) {
        return this.__P_26_1[className];
      },

      /**
       * Returns the full filename for the file within this library
       *
       * @param filename {String} the filename relative to this library
       * @return {String} the full filename
       */
      getFilename: function (filename) {
        return path.join(this.getRootDir(), this.getSourcePath(), filename);
      },

      /**
       * Returns the full filename for the file within this library's resources
       *
       * @param filename {String} the filename relative to this library
       * @return {String} the full filename
       */
      getResourceFilename: function (filename) {
        return path.join(this.getRootDir(), this.getResourcePath(), filename);
      },

      /**
       * Returns the full filename for the file within this library's theme
       *
       * @param filename {String} the filename relative to this library
       * @return {String} the full filename
       */
      getThemeFilename: function (filename) {
        return path.join(this.getRootDir(), this.getThemePath(), filename);
      }
    },
    statics: {
      /**
       * Helper method to create a Library instance and load it's manifest
       * 
       * @param rootDir {String} directory of the library (must contain a Manifest.json)
       * @return {Library}
       */
      async createLibrary(rootDir) {
        let lib = new qx.tool.compiler.app.Library();
        await lib.loadManifest(rootDir);
        return lib;
      }

    }
  });
  qx.tool.compiler.app.Library.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.tool.utils.files.Utils": {},
      "qx.tool.compiler.Analyser": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
   *
   *    qooxdoo-compiler - node.js based replacement for the Qooxdoo python
   *    toolchain
   *
   *    https://github.com/qooxdoo/qooxdoo-compiler
   *
   *    Copyright:
   *      2011-2017 Zenesis Limited, http://www.zenesis.com
   *
   *    License:
   *      MIT: https://opensource.org/licenses/MIT
   *
   *      This software is provided under the same licensing terms as Qooxdoo,
   *      please see the LICENSE file in the Qooxdoo project's top-level directory
   *      for details.
   *
   *    Authors:
   *      * John Spackman (john.spackman@zenesis.com, @johnspackman)
   *
   * *********************************************************************** */
  var path = require("upath");
  /**
   * Base class for makers; does not include anything about targets, locales, etc (see AbstractAppMaker)
   */


  qx.Class.define("qx.tool.compiler.makers.Maker", {
    extend: qx.core.Object,
    type: "abstract",
    construct: function () {
      qx.core.Object.constructor.call(this);
      this._compiledClasses = {};
    },
    properties: {
      /** Database filename relative to the target's output directory; if null, defaults to db.json; absolute paths can be used */
      dbFilename: {
        init: null,
        nullable: true,
        check: "String",
        apply: "__P_32_0"
      },

      /** Map of environment settings */
      environment: {
        init: null,
        nullable: true
      },

      /** Whether to write a typescript .d.ts file for all classes */
      outputTypescript: {
        init: false,
        nullable: false,
        check: "Boolean"
      },

      /** Filename for the typescript, if `outputTypescript == true` */
      outputTypescriptTo: {
        init: "qooxdoo.d.ts",
        nullable: false,
        check: "String"
      },

      /** Blocks automatic deleting of the output directory */
      noErase: {
        init: false,
        check: "Boolean"
      },

      /** Whether the make has succeeded, null during/before make */
      success: {
        init: null,
        nullable: true,
        check: "Boolean"
      },

      /** Whether the make has any warnings, null during/before make */
      hasWarnings: {
        init: null,
        nullable: true,
        check: "Boolean"
      }
    },
    events: {
      "making": "qx.event.type.Event",
      "made": "qx.event.type.Event",
      "writingApplications": "qx.event.type.Event",
      "writingApplication": "qx.event.type.Data",
      "writtenApplication": "qx.event.type.Data",
      "writtenApplications": "qx.event.type.Event"
    },
    members: {
      /** {Analyser} current analyser (created on demand) */
      _analyser: null,

      /** Lookup of classes which have been compiled this session; this is a map where the keys are
       * the class name and the value is `true`, it is erased periodically
       */
      _compiledClasses: null,

      /**
       * Makes the application
       *
       * @abstract
       */
      make: async function () {
        throw new Error("No implementation for " + this.classname + ".make");
      },

      /**
       * Returns the output directory, with a trailing slash
       *
       * @returns {String}
       * @abstract
       */
      getOutputDir: function () {
        throw new Error("No implementation for " + this.classname + ".getOutputDir");
      },

      /**
       * Erases the output directory
       */
      eraseOutputDir: async function () {
        var dir = path.resolve(this.getOutputDir());
        var pwd = path.resolve(process.cwd());

        if (pwd.startsWith(dir) && dir.length <= pwd.length) {
          throw new Error("Output directory (" + dir + ") is a parent directory of PWD");
        }

        await qx.tool.utils.files.Utils.deleteRecursive(this.getOutputDir());
      },

      /**
       * Apply for databaseName property
       * @param value
       * @param oldValue
       * @private
       */
      __P_32_0: function (value, oldValue) {
        if (this._analyser) {
          throw new Error("Cannot change the database filename once an Analyser has been created");
        }
      },

      /**
       * Gets the analyser, creating it if necessary
       * @returns {Analyser}
       */
      getAnalyser: function () {
        if (this._analyser) {
          return this._analyser;
        }

        this._analyser = this._createAnalyser();

        this._analyser.addListener("compiledClass", evt => {
          let data = evt.getData();
          this._compiledClasses[data.classFile.getClassName()] = true;
        });

        return this._analyser;
      },

      /**
       * Returns a list of classes which have been compiled in this session
       *
       * @param eraseAfter {Boolean?} if true, the list is reset after returning
       * @return {Map} list of class names that have been compiled
       */
      getRecentlyCompiledClasses(eraseAfter) {
        let classes = this._compiledClasses;

        if (eraseAfter) {
          this._compiledClasses = {};
        }

        return classes;
      },

      /**
       * Creates the analyser
       * @returns {Analyser}
       * @protected
       */
      _createAnalyser: function () {
        var analyser = this._analyser = new qx.tool.compiler.Analyser(path.join(this.getOutputDir(), this.getDbFilename() || "db.json"));
        analyser.setOutputDir(this.getOutputDir());
        return analyser;
      }
    }
  });
  qx.tool.compiler.makers.Maker.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.tool.compiler.makers.Maker": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
   *
   *    qooxdoo-compiler - node.js based replacement for the Qooxdoo python
   *    toolchain
   *
   *    https://github.com/qooxdoo/qooxdoo-compiler
   *
   *    Copyright:
   *      2011-2017 Zenesis Limited, http://www.zenesis.com
   *
   *    License:
   *      MIT: https://opensource.org/licenses/MIT
   *
   *      This software is provided under the same licensing terms as Qooxdoo,
   *      please see the LICENSE file in the Qooxdoo project's top-level directory
   *      for details.
   *
   *    Authors:
   *      * John Spackman (john.spackman@zenesis.com, @johnspackman)
   *
   * *********************************************************************** */

  /**
   * Base class for application makers, add targets, locales etc
   */
  qx.Class.define("qx.tool.compiler.makers.AbstractAppMaker", {
    extend: qx.tool.compiler.makers.Maker,
    type: "abstract",
    properties: {
      /** Target for the compiled application */
      target: {
        nullable: false,
        check: "qx.tool.compiler.targets.Target",
        apply: "__P_30_0"
      },

      /** Supported Locales */
      locales: {
        nullable: false,
        init: ["en"],
        apply: "_applyLocales"
      },

      /** Whether to write all translation strings (as opposed to just those used by the classes) */
      writeAllTranslations: {
        init: false,
        nullable: false,
        check: "Boolean",
        apply: "__P_30_1"
      }
    },
    members: {
      /*
       * @Override
       */
      getOutputDir: function () {
        return this.getTarget().getOutputDir();
      },

      /**
       * Apply for target property
       * @param value
       * @param oldValue
       * @private
       */
      __P_30_0: function (value, oldValue) {
        if (this._analyser) {
          this._analyser.setOutputDir(value ? value.getOutputDir() : null);
        }

        if (value) {
          value.set({
            locales: this.getLocales(),
            writeAllTranslations: this.getWriteAllTranslations()
          });
        }
      },

      /**
       * Apply for writeAllTranslations
       * @param value
       * @param oldValue
       * @private
       */
      __P_30_1: function (value, oldValue) {
        if (this.getTarget()) {
          this.getTarget().setWriteAllTranslations(value);
        }
      },

      /**
       * Apply for locales property
       * @param value
       * @param oldValue
       * @private
       */
      _applyLocales: function (value, oldValue) {
        if (this.getTarget()) {
          this.getTarget().setLocales(value);
        }
      }
    }
  });
  qx.tool.compiler.makers.AbstractAppMaker.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.tool.utils.LogManager": {
        "usage": "dynamic",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.tool.compiler.makers.AbstractAppMaker": {
        "construct": true,
        "require": true
      },
      "qx.tool.compiler.app.Application": {
        "construct": true
      },
      "qx.tool.utils.Values": {},
      "qx.tool.compiler.ClassFile": {},
      "qx.tool.compiler.Version": {},
      "qx.tool.utils.Utils": {},
      "qx.tool.compiler.Console": {},
      "qx.tool.compiler.targets.TypeScriptWriter": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
   *
   *    qooxdoo-compiler - node.js based replacement for the Qooxdoo python
   *    toolchain
   *
   *    https://github.com/qooxdoo/qooxdoo-compiler
   *
   *    Copyright:
   *      2011-2017 Zenesis Limited, http://www.zenesis.com
   *
   *    License:
   *      MIT: https://opensource.org/licenses/MIT
   *
   *      This software is provided under the same licensing terms as Qooxdoo,
   *      please see the LICENSE file in the Qooxdoo project's top-level directory
   *      for details.
   *
   *    Authors:
   *      * John Spackman (john.spackman@zenesis.com, @johnspackman)
   *
   * *********************************************************************** */
  var log = qx.tool.utils.LogManager.createLog("analyser");
  /**
   * Application maker; supports multiple applications to compile against a single
   * target
   */

  qx.Class.define("qx.tool.compiler.makers.AppMaker", {
    extend: qx.tool.compiler.makers.AbstractAppMaker,

    /**
     * Constructor
     * @param className {String|String[]} classname(s) to generate
     * @param theme {String} the theme classname
     */
    construct: function (className, theme) {
      qx.tool.compiler.makers.AbstractAppMaker.constructor.call(this);
      this.__P_31_0 = [];

      if (className) {
        var app = new qx.tool.compiler.app.Application(className);

        if (theme) {
          app.setTheme(theme);
        }

        this.addApplication(app);
      }
    },
    members: {
      __P_31_0: null,

      /**
       * Adds an Application to be made
       * @param app
       */
      addApplication: function (app) {
        this.__P_31_0.push(app);
      },

      /**
       * Returns the array of applications
       * @returns {Application[]}
       */
      getApplications: function () {
        return this.__P_31_0;
      },

      /*
       * @Override
       */
      async make() {
        var analyser = this.getAnalyser();
        await this.fireEventAsync("making");
        this.setSuccess(null);
        this.setHasWarnings(null);
        let success = true;
        let hasWarnings = false; // merge all environment settings for the analyser

        const compileEnv = qx.tool.utils.Values.merge({}, qx.tool.compiler.ClassFile.ENVIRONMENT_CONSTANTS, {
          "qx.compiler": true,
          "qx.compiler.version": qx.tool.compiler.Version.VERSION
        }, this.getEnvironment(), this.getTarget().getDefaultEnvironment(), this.getTarget().getEnvironment());
        let appEnvironments = {};
        this.getApplications().forEach(app => {
          appEnvironments[app.toHashCode()] = qx.tool.utils.Values.merge({}, compileEnv, app.getCalculatedEnvironment());
        }); // Analyze the list of environment variables, detect which are shared between all apps

        let allAppEnv = {};
        this.getApplications().forEach(app => {
          let env = appEnvironments[app.toHashCode()];
          Object.keys(env).forEach(key => {
            if (!allAppEnv[key]) {
              allAppEnv[key] = {
                value: env[key],
                same: true
              };
            } else if (allAppEnv[key].value !== env[key]) {
              allAppEnv[key].same = false;
            }
          });
        }); // If an env setting is the same for all apps, move it to the target for code elimination; similarly,
        //  if it varies between apps, then remove it from the target and make each app specify it individually

        this.getApplications().forEach(app => {
          let env = appEnvironments[app.toHashCode()];
          Object.keys(allAppEnv).forEach(key => {
            if (allAppEnv[key].same) {
              delete env[key];
            } else if (env[key] === undefined) {
              env[key] = compileEnv[key];
            }
          });
        }); // Cleanup to remove env that have been moved to the app 

        Object.keys(allAppEnv).forEach(key => {
          if (allAppEnv[key].same) {
            compileEnv[key] = allAppEnv[key].value;
          } else {
            delete compileEnv[key];
          }
        });
        await analyser.open();
        analyser.setEnvironment(compileEnv);

        if (!this.isNoErase() && analyser.isContextChanged()) {
          log.log("enviroment changed - delete output dir");
          await this.eraseOutputDir();
          await qx.tool.utils.Utils.makeParentDir(this.getOutputDir());
          await analyser.resetDatabase();
        }

        await qx.tool.utils.Utils.promisifyThis(analyser.initialScan, analyser);
        await analyser.updateEnvironmentData();
        this.getTarget().setAnalyser(analyser);

        this.__P_31_0.forEach(app => app.setAnalyser(analyser));

        await this.getTarget().open();

        if (this.isOutputTypescript()) {
          analyser.getLibraries().forEach(library => {
            var symbols = library.getKnownSymbols();

            for (var name in symbols) {
              var type = symbols[name];

              if (type === "class" && name !== "q" && name !== "qxWeb") {
                analyser.addClass(name);
              }
            }
          });
        }

        this.__P_31_0.forEach(function (app) {
          app.getRequiredClasses().forEach(function (className) {
            analyser.addClass(className);
          });

          if (app.getTheme()) {
            analyser.addClass(app.getTheme());
          }
        });

        await analyser.analyseClasses();
        await analyser.saveDatabase();
        var target = this.getTarget();
        await this.fireEventAsync("writingApplications"); // Detect which applications need to be recompiled by looking for classes recently compiled
        //  which is on the application's dependency list.  The first time `.make()` is called there
        //  will be no dependencies so we just compile anyway, but `qx compile --watch` will call it
        //  multiple times

        let compiledClasses = this.getRecentlyCompiledClasses(true);

        var appsThisTime = this.__P_31_0.filter(app => {
          let loadDeps = app.getDependencies();

          if (!loadDeps || !loadDeps.length) {
            return true;
          }

          return loadDeps.some(name => Boolean(compiledClasses[name]));
        });

        let allAppInfos = [];
        let db = analyser.getDatabase();

        for (let i = 0; i < appsThisTime.length; i++) {
          let application = appsThisTime[i];

          if (application.getType() != "browser" && !compileEnv["qx.headless"]) {
            qx.tool.compiler.Console.print("qx.tool.compiler.maker.appNotHeadless", application.getName());
          }

          var appEnv = qx.tool.utils.Values.merge({}, compileEnv, appEnvironments[application.toHashCode()]);
          application.calcDependencies();

          if (application.getFatalCompileErrors()) {
            qx.tool.compiler.Console.print("qx.tool.compiler.maker.appFatalError", application.getName());
            success = false;
            continue;
          }

          if (!hasWarnings) {
            application.getDependencies().forEach(classname => {
              if (!db.classInfo[classname] || !db.classInfo[classname].markers) {
                return;
              }

              db.classInfo[classname].markers.forEach(marker => {
                let type = qx.tool.compiler.Console.getInstance().getMessageType(marker.msgId);

                if (type == "warning") {
                  hasWarnings = true;
                }
              });
            });
          }

          let appInfo = {
            application,
            analyser,
            maker: this
          };
          allAppInfos.push(appInfo);
          await this.fireDataEventAsync("writingApplication", appInfo);
          await target.generateApplication(application, appEnv);
          await this.fireDataEventAsync("writtenApplication", appInfo);
        }

        await this.fireDataEventAsync("writtenApplications", allAppInfos);

        if (this.isOutputTypescript()) {
          await new qx.tool.compiler.targets.TypeScriptWriter(target).set({
            outputTo: this.getOutputTypescriptTo()
          }).run();
        }

        await analyser.saveDatabase();
        await this.fireEventAsync("made");
        this.setSuccess(success);
        this.setHasWarnings(hasWarnings);
      }

    }
  });
  qx.tool.compiler.makers.AppMaker.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.lang.Array": {
        "construct": true
      },
      "qx.lang.Type": {
        "construct": true
      },
      "qx.tool.compiler.Console": {},
      "qx.tool.utils.IndexedArray": {},
      "qx.core.Assert": {},
      "qx.tool.utils.Values": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
   *
   *    qooxdoo-compiler - node.js based replacement for the Qooxdoo python
   *    toolchain
   *
   *    https://github.com/qooxdoo/qooxdoo-compiler
   *
   *    Copyright:
   *      2011-2017 Zenesis Limited, http://www.zenesis.com
   *
   *    License:
   *      MIT: https://opensource.org/licenses/MIT
   *
   *      This software is provided under the same licensing terms as Qooxdoo,
   *      please see the LICENSE file in the Qooxdoo project's top-level directory
   *      for details.
   *
   *    Authors:
   *      * John Spackman (john.spackman@zenesis.com, @johnspackman)
   *
   * *********************************************************************** */
  const path = require("upath");

  qx.Class.define("qx.tool.compiler.app.Application", {
    extend: qx.core.Object,

    /**
     * Constructor
     * @param classname {String|String[]} [, classname...]
     */
    construct: function (classname) {
      qx.core.Object.constructor.call(this);
      this.initType();
      var args = qx.lang.Array.fromArguments(arguments);
      var t = this;
      this.__P_25_0 = [];
      args.forEach(function (arg) {
        if (qx.lang.Type.isArray(arg)) {
          qx.lang.Array.append(t.__P_25_0, arg);
        } else {
          t.__P_25_0.push(arg);
        }
      });
      this.set({
        include: [],
        exclude: []
      });
    },
    properties: {
      /**
       * The type of application to generate; note that changing this will change the `loaderTemplate`
       * and `theme` properties
       */
      type: {
        init: "browser",
        check: ["browser", "rhino", "node"],
        apply: "_applyType"
      },

      /**
       * Environment property map
       */
      environment: {
        init: null,
        nullable: true
      },

      /**
       * The Analyser instance
       */
      analyser: {
        init: null,
        nullable: true
      },

      /**
       * Application theme (class name)
       */
      theme: {
        init: "qx.theme.Simple",
        check: "String"
      },

      /**
       * The name of the application, used for script directory file unless outputPath is set
       */
      name: {
        init: "index",
        nullable: false,
        check: "String"
      },

      /**
       * The human readable, customer facing title of the application - it's used to customise the title
       * of the index.html page
       */
      title: {
        init: null,
        nullable: true,
        check: "String"
      },

      /**
       * The human readable, customer facing description of the application - it's used to list applications
       * in `qx serve`
       */
      description: {
        init: null,
        nullable: true,
        check: "String"
      },

      /**
       * Output path, relative to the target's output path
       */
      outputPath: {
        init: null,
        nullable: true,
        check: "String"
      },

      /**
       * Boot path, relative to the target's output path
       */
      bootPath: {
        init: null,
        nullable: true,
        check: "String"
      },

      /**
       * template path
       */
      templatePath: {
        init: "",
        nullable: false,
        check: "String",
        apply: "_applyType"
      },

      /**
       * Whether this app is to be published (e.g. in the PackageBrowser).
       * Default is true.
       */
      publish: {
        check: "Boolean",
        init: true
      },

      /**
       * Whether this app is to be deployed
       * Default is true.
       */
      deploy: {
        check: "Boolean",
        init: true
      },

      /**
       * Whether this app can run on its own (true, default) or is part of another
       * application (false)
       */
      standalone: {
        check: "Boolean",
        init: true
      },

      /**
       * Classes to include with the build
       */
      include: {
        nullable: false,
        check: "Array",
        transform: "__P_25_1"
      },

      /**
       * Classes to exclude when building
       */
      exclude: {
        nullable: false,
        check: "Array",
        transform: "__P_25_1"
      },

      /**
       * Classes to bundle together for delivery to the client
       */
      bundleInclude: {
        init: null,
        nullable: true,
        check: "Array",
        transform: "__P_25_1"
      },

      /**
       * Classes to exclude from bundling together for delivery to client
       */
      bundleExclude: {
        init: null,
        nullable: true,
        check: "Array",
        transform: "__P_25_1"
      },

      /**
       * Template file used to create index.js; note that this is changed when the `type` property
       * is changed
       */
      loaderTemplate: {
        nullable: false,
        check: "String"
      },

      /**
       * Writes the index.html into root instead of app dir
       */
      writeIndexHtmlToRoot: {
        init: false,
        check: "Boolean"
      }
    },
    members: {
      __P_25_2: null,
      __P_25_3: null,
      __P_25_4: null,
      __P_25_5: null,
      __P_25_0: null,
      __P_25_6: null,

      /**
       * Checks if the application is for browser
       *
       * @returns boolean
       */
      isBrowserApp: function () {
        return this.getType() === "browser";
      },

      /**
       * Calculates the dependencies of the classes to create a load order
       */
      calcDependencies: function () {
        var t = this;
        var Console = qx.tool.compiler.Console.getInstance();
        var analyser = this.getAnalyser();
        var db = analyser.getDatabase();
        var allDeps = new qx.tool.utils.IndexedArray();
        var exclude = {};
        var fatalCompileErrors = [];
        this.__P_25_2 = null;
        var partsByName = {};
        var parts = [];
        var bootPart = null;
        var classDataByClassname = {};

        if (this.__P_25_3 && this.__P_25_3.length) {
          parts = [];

          t.__P_25_3.forEach(part => {
            if (partsByName[part.getName()]) {
              throw new Error(Console.decode("qx.tool.compiler.application.duplicatePartNames", part.getName()));
            }

            var partData = {
              name: part.getName(),
              include: part.getInclude(),
              exclude: part.getExclude(),
              classes: [],
              dependsOn: {},
              combine: part.getCombine(),
              minify: part.getMinify()
            };
            partData.match = qx.tool.compiler.app.Application.createWildcardMatchFunction(part.getInclude(), part.getExclude());
            partsByName[part.getName()] = partData;
            parts.push(partData);
          });

          bootPart = partsByName.boot;

          if (!bootPart) {
            throw new Error(Console.decode("qx.tool.compiler.application.noBootPart"));
          }
        } else {
          bootPart = {
            name: "boot",
            include: ["*"],
            exclude: [],
            classes: [],
            dependsOn: {},
            combine: false,
            minify: false,
            match: function () {
              return true;
            }
          };
          partsByName.boot = bootPart;
          parts.push(bootPart);
        }

        function createClassData(classname) {
          if (classDataByClassname[classname]) {
            return classDataByClassname[classname];
          }

          var classData = classDataByClassname[classname] = {
            classname: classname,
            parts: {},
            best: null,
            actual: null
          };
          parts.forEach(part => {
            if (part === bootPart) {
              return;
            }

            var result = part.match(classname);

            if (result !== null) {
              classData.parts[part.name] = result;
              var lastMatch = classData.best && classData.parts[classData.best.name];

              if (lastMatch === undefined || lastMatch === null) {
                classData.best = part; // Exact
              } else if (lastMatch === "exact") {
                if (result === "exact") {
                  Console.print("qx.tool.compiler.application.conflictingExactPart", classname, part.name, classData.best.name);
                } // Wildcard

              } else {
                qx.core.Assert.assertTrue(typeof lastMatch == "number");

                if (result === "exact") {
                  classData.best = part;
                  classData.exact = true;
                } else {
                  qx.core.Assert.assertTrue(typeof result == "number");

                  if (lastMatch === result) {
                    Console.print("qx.tool.compiler.application.conflictingBestPart", classname, part.name, classData.best.name);
                  } else if (lastMatch < result) {
                    classData.best = part;
                  }
                }
              }
            }
          });
          return classData;
        }

        var needed = new qx.tool.utils.IndexedArray();
        var neededIndex = 0;
        var stack = new qx.tool.utils.IndexedArray();
        /*
         * We could say that when a class is `.require`d, then we treat any of it's `construct:true` dependencies as `require:true`
         * The problem is given this example:
         *    qx.core.Init.defer()
         *      qx.event.Registration.addListener
         *        qx.event.Registration.getManager
         *          qx.event.Manager.construct
         *            new qx.util.DeferredCall
         *
         *    new qx.util.DeferredCall is a runtime only dependency so is not available.
         *
         * So the theory is that deferred calls tend to be about initialisation, so prioritising constructor dependencies
         * may be helpful
         */

        /*
         * Recursively finds all the dependencies for a class which have not already been added
         * to the list of classes to load.
         *
         *  @param classname {String}
         *  @param deps {String[]} array to modify
         */

        function compileAllRemainingDeps(classname, deps) {
          var checked = {};
          var depNames = {};
          depNames[classname] = true;

          function search(classname) {
            if (checked[classname]) {
              return;
            }

            checked[classname] = true;
            var info = db.classInfo[classname];

            if (info && info.dependsOn) {
              for (var depName in info.dependsOn) {
                var dd = info.dependsOn[depName];

                if (dd.load || dd.require || dd.defer || dd.construct) {
                  if (!allDeps.contains(depName)) {
                    depNames[depName] = true;
                  }

                  search(depName);
                }
              }
            }
          }

          search(classname);

          for (var depName in depNames) {
            deps.push(depName);
          }
        }

        var addDepDepth = 0;

        function addDep(classname) {
          if (exclude[classname]) {
            return;
          }

          if (allDeps.contains(classname) || stack.contains(classname)) {
            return;
          }

          var info = db.classInfo[classname];

          if (!info) {
            return;
          }

          if (info.fatalCompileError) {
            fatalCompileErrors.push(classname);
          }

          addDepDepth++;
          var environmentLoadDeps = {};

          if (info.environment && info.environment.required) {
            for (var key in info.environment.required) {
              var envInfo = info.environment.required[key];

              if (envInfo.defer) {
                environmentLoadDeps[envInfo.className] = true;
              }
            }
          }

          var deferDeps = [];

          if (info.dependsOn) {
            stack.push(classname);

            for (var depName in info.dependsOn) {
              var dd = info.dependsOn[depName];

              if (dd.load || dd.require || environmentLoadDeps[depName]) {
                addDep(depName);
              } else if (dd.defer) {
                deferDeps.push(depName);
              } else if (!allDeps.contains(depName)) {
                needed.push(depName);
              }
            }

            stack.remove(classname);
          }

          if (parts && !allDeps.contains(classname)) {
            var classData = createClassData(classname);
            var part = classData.best || bootPart;
            part.classes.push(classname);
            classData.actual = part;

            if (info.externals) {
              if (part.externals === undefined) {
                part.externals = [];
              }

              info.externals.forEach(external => {
                if (part.externals.indexOf(external) < 0) {
                  part.externals.push(external);
                }
              });
            }
          }

          allDeps.push(classname);
          deferDeps.forEach(function (depName) {
            var deps = [];
            compileAllRemainingDeps(depName, deps);
            deps.forEach(addDep);
          });

          if (addDepDepth === 1) {
            while (neededIndex < needed.getLength()) {
              classname = needed.getItem(neededIndex++);
              addDep(classname);
            }
          }

          addDepDepth--;
        }

        exclude = {};

        t.__P_25_7(t.getExclude()).forEach(name => exclude[name] = true); // Start the ball rolling


        addDep("qx.core.Object");
        t.getRequiredClasses().forEach(function (classname) {
          addDep(classname);
        });

        if (t.getTheme()) {
          addDep(t.getTheme());
        }
        /*
        parts.forEach((part) => {
          if (part !== bootPart) {
            t.__expandClassnames(part.include).forEach((name) => addDep(name));
          }
        });
        */


        while (neededIndex < needed.length) {
          var classname = needed[neededIndex++];
          addDep(classname);
        }

        if (parts && parts.length > 1) {
          // Calculate inter-part dependencies
          parts.forEach(part => {
            var checked = {};

            function check(classname) {
              if (checked[classname]) {
                return;
              }

              checked[classname] = true;
              var classData = classDataByClassname[classname];

              if (classData.actual !== part) {
                part.dependsOn[classData.actual.name] = true;
              }

              for (var depName in db.classInfo.dependsOn) {
                check(depName);
              }
            }

            part.classes.forEach(check);
            part.dependsOn = Object.keys(part.dependsOn);
          }); // Check for recursive dependencies

          parts.forEach(part => {
            var checked = {};

            function check(partname) {
              if (checked[partname]) {
                return false;
              }

              checked[partname] = true;
              var checkPart = partsByName[partname];

              if (checkPart === part) {
                return true;
              }

              return part.dependsOn.some(check);
            }

            if (part.dependsOn.some(check)) {
              Console.print("qx.tool.compiler.application.partRecursive", part.name);
            }
          });
        }
        /*
         * Done
         */


        this.__P_25_2 = allDeps.toArray();
        var requiredLibs = {};

        this.__P_25_2.forEach(classname => {
          let classInfo = db.classInfo[classname];

          if (classInfo.assets) {
            classInfo.assets.forEach(asset => {
              var pos = asset.indexOf("/");

              if (pos > -1) {
                var ns = asset.substring(0, pos);

                if (analyser.findLibrary(ns)) {
                  requiredLibs[ns] = true;
                }
              }
            });
          }

          requiredLibs[classInfo.libraryName] = true;
        });

        this.__P_25_4 = [];

        for (let ns in requiredLibs) {
          if (analyser.findLibrary(ns)) {
            this.__P_25_4.push(ns);
          } else {
            Console.print("qx.tool.compiler.application.missingRequiredLibrary", ns);
          }
        }

        this.__P_25_6 = parts;
        this.__P_25_5 = fatalCompileErrors.length ? fatalCompileErrors : null;
      },

      /**
       * Gets a list of class names that this Application requires which have fatal compile errors
       *
       * @return {String[]}
       */
      getFatalCompileErrors: function () {
        return this.__P_25_5;
      },

      /**
       * Gets a list of URIs for classes that are required, in load order
       *
       * @returns {String[]}
       */
      getUris: function () {
        var uris = [];
        var db = this.getAnalyser().getDatabase();

        function add(classname) {
          var def = db.classInfo[classname];
          uris.push(def.libraryName + ":" + classname.replace(/\./g, "/") + ".js");
        }

        this.__P_25_2.forEach(add);

        return uris;
      },

      /**
       * Gets a list of classnames that are required, in load order
       *
       * @returns {String[]}
       */
      getDependencies: function () {
        return this.__P_25_2;
      },

      /**
       * Gets the parts dependencies structures
       *
       * @returns {Object[]}
       */
      getPartsDependencies: function () {
        return this.__P_25_6;
      },

      /**
       * Returns a list of library names which are required by the application
       *
       * @returns {String[]}
       */
      getRequiredLibraries: function () {
        return this.__P_25_4;
      },

      /**
       * Returns a list of all of the assets required by all classes
       * @param target {Target} the current target
       * @param resManager  {qx.tool.compiler.resources.Manager} the resource manager
       * @param environment {Map} environment
       */
      getAssetUris: function (target, resManager, environment) {
        var assets = [];
        var analyser = this.getAnalyser();
        var db = analyser.getDatabase(); // Compile theme resource aliases

        var aliases = {};

        function getAliases(classname) {
          var tmp = db.classInfo[classname];

          if (tmp) {
            if (tmp.aliases) {
              for (var alias in tmp.aliases) {
                aliases[alias] = tmp.aliases[alias];
              }
            }

            if (tmp.extends) {
              getAliases(tmp.extends);
            }
          }
        }

        var themeInfo = db.classInfo[this.getTheme()];

        if (themeInfo && themeInfo.themeMeta) {
          for (let name in themeInfo.themeMeta) {
            getAliases(themeInfo.themeMeta[name]);
          }
        } // Get a list of libraries used


        var libraryLookup = {}; // Check all the classes

        var classNames = this.__P_25_2.slice();

        for (let i = 0; i < classNames.length; i++) {
          var classname = classNames[i];
          var classInfo = db.classInfo[classname];
          var tmp = classInfo.assets;

          if (tmp) {
            tmp.forEach(function (uri) {
              var pos = uri.indexOf("/");

              if (pos > -1) {
                var prefix = uri.substring(0, pos);
                var mappedPrefix = aliases[prefix];

                if (mappedPrefix) {
                  uri = mappedPrefix + uri.substring(pos);
                }
              }

              resManager.findLibrariesForResource(uri).forEach(library => assets.push(library.getNamespace() + ":" + uri));
            });
          }

          if (!libraryLookup[classInfo.libraryName]) {
            libraryLookup[classInfo.libraryName] = analyser.findLibrary(classInfo.libraryName);
          }
        }

        var rm = analyser.getResourceManager();

        function addExternalAssets(arr, msgId) {
          if (arr) {
            arr.forEach(filename => {
              if (!filename.match(/^https?:/)) {
                let asset = rm.getAsset(filename);

                if (asset) {
                  let str = asset.getDestFilename(target);
                  str = path.relative(path.join(target.getOutputDir(), "resource"), str);
                  assets.push(asset.getLibrary().getNamespace() + ":" + str);
                } else {
                  qx.tool.compiler.Console.print(msgId, filename);
                }
              }
            });
          }
        }

        for (let name in libraryLookup) {
          var lib = libraryLookup[name];

          if (lib) {
            addExternalAssets(lib.getAddScript(), "qx.tool.compiler.application.missingScriptResource");
            addExternalAssets(lib.getAddCss(), "qx.tool.compiler.application.missingCssResource");
          }
        } // Expand variables


        for (let i = 0; i < assets.length; i++) {
          let asset = assets[i];
          var m = asset.match(/\$\{([^}]+)\}/);

          if (m) {
            var match = m[0];
            var capture = m[1];
            var pos = asset.indexOf(match);
            var left = asset.substring(0, pos);
            var right = asset.substring(pos + match.length);
            var value = environment[capture];

            if (value !== undefined) {
              if (qx.lang.Type.isArray(value)) {
                value.forEach(function (value) {
                  assets.push(left + value + right);
                });
              } else {
                assets.push(left + value + right);
              }
            }

            qx.lang.Array.removeAt(assets, i--);
          }
        } // Remove duplicates and overlapping path wildcards


        assets.sort();

        for (let i = 1; i < assets.length; i++) {
          let asset = assets[i];
          var lastAsset = assets[i - 1];

          if (asset == lastAsset) {
            assets.splice(i--, 1);
            continue;
          }

          if (lastAsset[lastAsset.length - 1] == "*") {
            var filename = lastAsset.substring(0, lastAsset.length - 1);

            if (asset.substring(0, filename.length) == filename) {
              assets.splice(i--, 1);
              continue;
            }
          }
        }

        return assets;
      },

      /**
       * Returns the class name for the application
       * @returns {String}
       */
      getClassName: function () {
        return this.__P_25_0[0];
      },

      /**
       * Returns the classes required for the application
       * @returns {String[]}
       */
      getRequiredClasses: function () {
        var result = {};

        this.__P_25_0.forEach(name => result[name] = true);

        this.__P_25_7(this.getInclude()).forEach(name => result[name] = true);

        this.__P_25_7(this.getExclude()).forEach(name => delete result[name]); // We sort the result so that we can get a consistent ordering for loading classes, otherwise the order in
        //  which the filing system returns the files can cause classes to be loaded in a lightly different sequence;
        //  that would not cause a problem, except that the build is not 100% repeatable.


        return Object.keys(result).sort();
      },

      /**
       * Adds a part
       * @param part {Part} the part to add
       */
      addPart: function (part) {
        if (!this.__P_25_3) {
          this.__P_25_3 = [];
        }

        this.__P_25_3.push(part);
      },

      /**
       * Returns the parts, or null if there are none defined
       * @return {Part[]}
       */
      getParts: function () {
        return this.__P_25_3 || [];
      },

      /**
       * Returns a dynamically calculated version of the application environment, which
       * is defaults or dynamic values plus the `environment` property
       * 
       * @return {Map} The environment settings
       */
      getCalculatedEnvironment() {
        return qx.tool.utils.Values.merge({
          "qx.headless": this.getType() != "browser"
        }, this.getEnvironment());
      },

      /**
       * Expands a list of class names including wildcards (eg "qx.ui.*") into an
       * exhaustive list without wildcards
       * @param names {String[]}
       * @return String[]
       */
      __P_25_7: function (names) {
        var t = this;
        var result = {};
        names.forEach(function (name) {
          var pos = name.indexOf("*");

          if (pos < 0) {
            result[name] = true;
          } else {
            var prefix = name.substring(0, pos);

            if (prefix) {
              t.getAnalyser().getLibraries().forEach(function (lib) {
                var symbols = lib.getKnownSymbols();

                for (var symbol in symbols) {
                  if (symbols[symbol] == "class" && symbol.startsWith(prefix)) {
                    result[symbol] = true;
                  }
                }
              });
            }

            var postfix = name.substring(pos + 1);

            if (postfix) {
              t.getAnalyser().getLibraries().forEach(function (lib) {
                var symbols = lib.getKnownSymbols();

                for (var symbol in symbols) {
                  if (symbols[symbol] == "class" && symbol.endsWith(postfix)) {
                    result[symbol] = true;
                  }
                }
              });
            }
          }
        });
        return Object.keys(result);
      },

      /**
       * Apply for `type` property
       */
      _applyType: function (value, oldValue) {
        var loader = path.join(this.getTemplatePath(), "loader", "loader-" + this.getType() + ".tmpl.js");
        this.setLoaderTemplate(loader);
      },

      /**
       * Transforms values to make sure that they are an array (and never null)
       */
      __P_25_1: function (value) {
        if (!value) {
          return null;
        }

        if (!qx.lang.Type.isArray(value)) {
          return [value];
        }

        return value;
      }
    },
    statics: {
      /**
       * Creates a function that can perform a wildcard match to compare against a function;
       * the function returns `null` if no match, `"exact"` for an exact match, or a number
       * to indicating the number of segments in the package (eg `qx.util.*` will match
       * `qx.util.format.DateFormat` will return 2 because there is `qx` and `util`)
       *
       * @param include {String[]} the wildcard specs to include
       * @param exclude {String[]} the wildcard specs to exclude
       * @return {Function}
       */
      createWildcardMatchFunction: function (include, exclude) {
        var code = [];

        if (exclude) {
          exclude.forEach(spec => {
            var pos;

            if ((pos = spec.indexOf("*")) > -1) {
              code.push("  if (value.startsWith(\"" + spec.substring(0, pos) + "\"))\n    return null; // " + spec);
            } else {
              code.push("  if (value === \"" + spec + "\")\n  return null;");
            }
          });
        }

        if (include) {
          include.forEach(spec => {
            var pos;
            pos = -1;
            var nsDepth = 0;

            while ((pos = spec.indexOf(".", pos + 1)) > -1) {
              nsDepth++;
            }

            if ((pos = spec.indexOf("*")) > -1) {
              code.push("  if (value.startsWith(\"" + spec.substring(0, pos) + "\"))\n    return " + nsDepth + "; // " + spec);
            } else {
              code.push("  if (value === \"" + spec + "\")\n  return \"exact\";");
            }
          });
        }

        code.push("  return null;");
        return new Function("value", code.join("\n"));
      }
    }
  });
  qx.tool.compiler.app.Application.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
   *
   *    qooxdoo-compiler - node.js based replacement for the Qooxdoo python
   *    toolchain
   *
   *    https://github.com/qooxdoo/qooxdoo-compiler
   *
   *    Copyright:
   *      2011-2017 Zenesis Limited, http://www.zenesis.com
   *
   *    License:
   *      MIT: https://opensource.org/licenses/MIT
   *
   *      This software is provided under the same licensing terms as Qooxdoo,
   *      please see the LICENSE file in the Qooxdoo project's top-level directory
   *      for details.
   *
   *    Authors:
   *      * John Spackman (john.spackman@zenesis.com, @johnspackman)
   *
   * *********************************************************************** */

  /**
   * Code is divided up into Parts, where each is a non-overlapping set of URIs for segmented
   * loading; the Part can support specific attributes, such as whether to be combined into
   * one file for the boot loader, whether to be minified, etc 
   */
  qx.Class.define("qx.tool.compiler.app.Part", {
    extend: qx.core.Object,
    construct: function (name, include, exclude) {
      qx.core.Object.constructor.call(this);
      this.set({
        name: name,
        include: include,
        exclude: exclude || []
      });
    },
    properties: {
      name: {
        nullable: false,
        check: "String"
      },
      combine: {
        init: false,
        nullable: false,
        check: "Boolean"
      },
      minify: {
        init: false,
        nullable: false,
        check: "Boolean"
      },
      include: {
        nullable: false,
        check: "Array"
      },
      exclude: {
        nullable: false,
        check: "Array"
      }
    }
  });
  qx.tool.compiler.app.Part.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.tool.utils.LogManager": {
        "usage": "dynamic",
        "require": true
      },
      "qx.lang.Type": {},
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.lang.Object": {},
      "qx.tool.compiler.Console": {},
      "qx.tool.utils.Utils": {},
      "qx.lang.Array": {},
      "qx.tool.compiler.jsdoc.Parser": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
   *
   *    qooxdoo-compiler - node.js based replacement for the Qooxdoo python
   *    toolchain
   *
   *    https://github.com/qooxdoo/qooxdoo-compiler
   *
   *    Copyright:
   *      2011-2017 Zenesis Limited, http://www.zenesis.com
   *
   *    License:
   *      MIT: https://opensource.org/licenses/MIT
   *
   *      This software is provided under the same licensing terms as Qooxdoo,
   *      please see the LICENSE file in the Qooxdoo project's top-level directory
   *      for details.
   *
   *    Authors:
   *      * John Spackman (john.spackman@zenesis.com, @johnspackman)
   *
   * *********************************************************************** */

  /* eslint-disable padded-blocks */
  var fs = require("fs");

  var babelCore = require("@babel/core");

  var types = require("@babel/types");

  var babylon = require("@babel/parser");

  var async = require("async");

  var pathModule = require("upath");

  var log = qx.tool.utils.LogManager.createLog("analyser");
  /**
   * Helper method that collapses the MemberExpression into a string
   * @param node
   * @returns {string}
   */

  function collapseMemberExpression(node) {
    var done = false;

    function doCollapse(node) {
      if (node.type == "ThisExpression") {
        return "this";
      }

      if (node.type == "Identifier") {
        return node.name;
      }

      if (node.type == "ArrayExpression") {
        var result = [];
        node.elements.forEach(element => result.push(doCollapse(element)));
        return result;
      }

      if (node.type != "MemberExpression") {
        return "(" + node.type + ")";
      }

      if (types.isIdentifier(node.object)) {
        let str = node.object.name;

        if (node.property.name) {
          str += "." + node.property.name;
        } else {
          done = true;
        }

        return str;
      }

      var str;

      if (node.object.type == "ArrayExpression") {
        str = "[]";
      } else {
        str = doCollapse(node.object);
      }

      if (done) {
        return str;
      } // `computed` is set if the expression is a subscript, eg `abc[def]`


      if (node.computed) {
        done = true;
      } else if (node.property.name) {
        str += "." + node.property.name;
      } else {
        done = true;
      }

      return str;
    }

    return doCollapse(node);
  }

  function isCollapsibleLiteral(node) {
    let nodeType = node.type;
    return nodeType === "Literal" || nodeType === "StringLiteral" || nodeType === "NumericLiteral" || nodeType === "BooleanLiteral" || nodeType === "BigIntLiteral";
  }
  /**
   * Helper method that expands a dotted string into MemberExpression
   * @param str
   * @returns {*}
   */


  function expandMemberExpression(str) {
    var segs = str.split(".");
    var expr = types.memberExpression(types.identifier(segs[0]), types.identifier(segs[1]));

    for (var i = 2; i < segs.length; i++) {
      expr = types.memberExpression(expr, types.identifier(segs[i]));
    }

    return expr;
  }

  function literalValueToExpression(value) {
    if (value === null || value === undefined) {
      return types.nullLiteral();
    }

    if (typeof value == "boolean") {
      return types.booleanLiteral(value);
    }

    if (typeof value == "number") {
      return types.numericLiteral(value);
    }

    if (typeof value == "string") {
      return types.stringLiteral(value);
    }

    if (qx.lang.Type.isRegExp(value)) {
      return types.regExpLiteral(value.toString());
    }

    if (qx.lang.Type.isDate(value)) {
      return types.stringLiteral(value.toString());
    }

    if (qx.lang.Type.isArray(value)) {
      var arr = [];
      value.forEach(function (item) {
        arr.push(literalValueToExpression(item));
      });
      return types.arrayExpression(arr);
    }

    if (typeof value != "object") {
      log.error("Cannot serialise value " + value + " into AST");
      return types.nullLiteral();
    }

    var properties = [];

    for (var key in value) {
      var expr = literalValueToExpression(value[key]);
      var prop = types.objectProperty(types.stringLiteral(key), expr);
      properties.push(prop);
    }

    return types.objectExpression(properties);
  }

  function formatValueAsCode(value) {
    if (value === undefined) {
      return "undefined";
    }

    if (value === null) {
      return "null";
    }

    if (typeof value === "string") {
      return JSON.stringify(value);
    }

    if (typeof value === "object" && value instanceof Date) {
      return "new Date(" + value.getTime() + ")";
    }

    return value.toString();
  }
  /**
   * A class file is parsed and anaysed into an instance of ClassFile; it is
   * connected to the Analyser that found the class so that dependencies can be
   * identified.
   */


  qx.Class.define("qx.tool.compiler.ClassFile", {
    extend: qx.core.Object,

    /**
     * Constructor
     *
     * @param analyser {Analyser} the Analyser that found the file
     * @param className {String} the full name of the class
     * @param library {Library} the Library the class belongs to (note that the class name is
     *  not always enough to identify the library, eg private source files such as qxWeb.js)
     */
    construct: function (analyser, className, library) {
      qx.core.Object.constructor.call(this);
      this.__P_22_0 = analyser;
      this.__P_22_1 = className;
      this.__P_22_2 = [];
      this.__P_22_3 = {};
      this.__P_22_4 = library;
      this.__P_22_5 = qx.tool.compiler.ClassFile.getSourcePath(library, className);
      this.__P_22_6 = {};
      this.__P_22_7 = {
        provided: {},
        required: {}
      };
      this.__P_22_8 = [];
      this.__P_22_9 = [];
      this.__P_22_10 = [];
      this.__P_22_11 = {};
      this.__P_22_12 = {
        parent: null,
        vars: {},
        unresolved: {}
      };
      this.__P_22_13 = [];
      this.__P_22_14 = [];
      this.__P_22_15 = async.queue(function (task, cb) {
        task(cb);
      });
      this.__P_22_15.drain = this._onTaskQueueDrain;

      this.__P_22_15.error = err => {
        this.error(err.stack || err);
      };

      analyser.getIgnores().forEach(s => this.addIgnore(s));
      this.__P_22_16 = {};
      this.__P_22_17 = {};
      this.__P_22_18 = {};
      this.__P_22_19 = analyser.getManglePrivates();
      const CF = qx.tool.compiler.ClassFile;

      const addSymbols = arr => arr.forEach(s => this.__P_22_16[s] = true);

      if (analyser.getGlobalSymbols().length) {
        addSymbols(analyser.getGlobalSymbols());
      } else {
        addSymbols(CF.QX_GLOBALS);
        addSymbols(CF.COMMON_GLOBALS);
        addSymbols(CF.BROWSER_GLOBALS);
      }
    },
    members: {
      __P_22_0: null,
      __P_22_1: null,
      __P_22_20: 0,
      __P_22_4: null,
      __P_22_6: null,
      __P_22_7: null,
      __P_22_8: null,
      __P_22_21: null,
      __P_22_12: null,
      __P_22_22: false,
      __P_22_23: false,
      __P_22_15: null,
      __P_22_14: null,
      __P_22_10: null,
      __P_22_11: null,
      __P_22_24: null,
      __P_22_2: null,
      __P_22_3: null,
      __P_22_25: false,
      __P_22_9: null,
      __P_22_26: null,
      __P_22_27: null,
      __P_22_28: null,
      __P_22_5: null,
      __P_22_29: null,
      __P_22_16: null,
      __P_22_17: null,
      __P_22_18: null,
      __P_22_13: null,
      _onTaskQueueDrain: function () {
        var cbs = this.__P_22_29;
        this.__P_22_29 = [];
        cbs.forEach(function (cb) {
          cb();
        });
      },
      _waitForTaskQueueDrain: function (cb) {
        if (this.__P_22_15.length() == 0) {
          cb();
        } else {
          this.__P_22_14.push(cb);
        }
      },
      _queueTask: function (cb) {
        this.__P_22_15.push(cb);
      },

      /**
       * Returns the absolute path to the class file
       * @returns {string}
       */
      getSourcePath: function () {
        return this.__P_22_5;
      },

      /**
       * Returns the path to the rewritten class file
       * @returns {string}
       */
      getOutputPath: function () {
        return qx.tool.compiler.ClassFile.getOutputPath(this.__P_22_0, this.__P_22_1);
      },

      /**
       * Loads the source, transpiles and analyses the code, storing the result in outputPath
       *
       * @param callback
       *          {Function} callback for when the load is completed
       */
      load: function (callback) {
        var t = this;
        var className = this.__P_22_1;
        t.__P_22_25 = false;
        t.__P_22_20 = 0;
        fs.readFile(this.getSourcePath(), {
          encoding: "utf-8"
        }, function (err, src) {
          if (err) {
            callback(err);
            return;
          }

          var result;

          try {
            let babelConfig = t.__P_22_0.getBabelConfig() || {};
            let options = qx.lang.Object.clone(babelConfig.options || {}, true);
            options.modules = false;
            let extraPreset = [{
              plugins: []
            }];

            if (babelConfig.plugins) {
              for (let key in babelConfig.plugins) {
                if (babelConfig.plugins[key] === true) {
                  extraPreset[0].plugins.push(require.resolve(key));
                } else if (babelConfig.plugins[key]) {
                  extraPreset[0].plugins.push([require.resolve(key), babelConfig.plugins[key]]);
                }
              }
            }

            let myPlugins = t._babelClassPlugins();

            var config = {
              babelrc: false,
              sourceFileName: t.getSourcePath(),
              filename: t.getSourcePath(),
              sourceMaps: true,
              "presets": [[{
                plugins: [myPlugins.CodeElimination]
              }], [{
                plugins: [myPlugins.Compiler]
              }], [require.resolve("@babel/preset-env"), options], [require.resolve("@babel/preset-typescript")], [require.resolve("@babel/preset-react"), qx.tool.compiler.ClassFile.JSX_OPTIONS]],
              parserOpts: {
                sourceType: "script"
              },
              passPerPreset: true
            };

            if (extraPreset[0].plugins.length) {
              config.presets.push(extraPreset);
            }

            if (this.__P_22_19 == "unreadable") {
              config.blacklist = ["spec.functionName"];
            }

            result = babelCore.transform(src, config);
          } catch (ex) {
            qx.tool.compiler.Console.log(ex);
            t.addMarker("compiler.syntaxError", ex.loc, ex.message);
            t.__P_22_25 = true;

            t._compileDbClassInfo();

            callback();
            return;
          }

          if (!t.__P_22_20) {
            t.addMarker("compiler.missingClassDef");
            t.__P_22_25 = true;

            t._compileDbClassInfo();

            callback();
            return;
          }

          if (!t.__P_22_3[className]) {
            t.addMarker("compiler.wrongClassName", null, className, Object.keys(t.__P_22_3).join(", "));

            t._compileDbClassInfo();
          }

          var pos = className.lastIndexOf(".");
          var name = pos > -1 ? className.substring(pos + 1) : className;
          var outputPath = t.getOutputPath();
          qx.tool.utils.Utils.mkParentPath(outputPath, function (err) {
            if (err) {
              callback(err);
              return;
            }

            fs.writeFile(outputPath, result.code + "\n\n//# sourceMappingURL=" + name + ".js.map?dt=" + new Date().getTime(), {
              encoding: "utf-8"
            }, function (err) {
              if (err) {
                callback(err);
                return;
              }

              fs.writeFile(outputPath + ".map", JSON.stringify(result.map, null, 2), {
                encoding: "utf-8"
              }, function (err) {
                if (err) {
                  callback(err);
                  return;
                }

                t._waitForTaskQueueDrain(function () {
                  callback();
                });
              });
            });
          });
        });
      },

      /**
       * Writes the data for the database; updates the record, which may have been previously
       * used (so needs to be zero'd out)
       * @param dbClassInfo {Map}
       */
      writeDbInfo: function (dbClassInfo) {
        delete dbClassInfo.unresolved;
        delete dbClassInfo.dependsOn;
        delete dbClassInfo.assets;
        delete dbClassInfo.translations;
        delete dbClassInfo.markers;
        delete dbClassInfo.fatalCompileError;

        for (var key in this.__P_22_26) {
          dbClassInfo[key] = this.__P_22_26[key];
        }
      },

      /**
       * Compiles the DbInfo POJO to be stored in the database about this class
       * */
      _compileDbClassInfo: function () {
        var t = this;
        var dbClassInfo = this.__P_22_26 = {}; // Collect the dependencies on other classes

        var deps = this.getRequiredClasses();

        if (t.__P_22_30) {
          let JSX = qx.tool.compiler.ClassFile.JSX_OPTIONS;
          let classname = JSX.pragma;
          let pos = classname.lastIndexOf(".");
          classname = classname.substring(0, pos);

          if (!deps[classname]) {
            deps[classname] = {};
          }
        }

        for (var name in deps) {
          var dep = deps[name];

          if (!dep.ignore) {
            if (!dbClassInfo.dependsOn) {
              dbClassInfo.dependsOn = {};
            }

            dbClassInfo.dependsOn[name] = dep;
          }
        }

        function fixAnnos(section) {
          if (!section) {
            return;
          }

          Object.keys(section).forEach(name => {
            if (name[0] == "@") {
              var value = section[name];
              delete section[name];
              name = name.substring(1);
              var meta = section[name];

              if (meta) {
                if (!meta.annotations) {
                  meta.annotations = [];
                }

                meta.annotations.push(value);
              }
            }
          });
        }

        var meta = this.getOuterClassMeta();

        if (meta) {
          fixAnnos(meta.events);
          fixAnnos(meta.members);
          fixAnnos(meta.statics);

          if (meta.properties && meta.members) {
            Object.keys(meta.properties).forEach(name => {
              let pm = meta.properties[name];

              if (pm.apply) {
                let fm = meta.members[pm.apply];

                if (fm) {
                  if (!fm.applyFor) {
                    fm.applyFor = [];
                  }

                  fm.applyFor.push(name);
                }
              }
            });
          } // Class heirararchy


          dbClassInfo.extends = meta.superClass;
          dbClassInfo.include = meta.mixins.slice(0);
          dbClassInfo.implement = meta.interfaces.slice(0);
        } // Environment Checks


        if (Object.keys(this.__P_22_7.provided).length || Object.keys(this.__P_22_7.required).length) {
          dbClassInfo.environment = {
            provided: [],
            required: {}
          };

          for (let key in this.__P_22_7.provided) {
            dbClassInfo.environment.provided.push(key);
          }

          for (let key in this.__P_22_7.required) {
            dbClassInfo.environment.required[key] = this.__P_22_7.required[key];
          }
        } // Save whether the class has a defer method


        dbClassInfo.hasDefer = this.hasDefer(); // Unresolved symbols

        dbClassInfo.unresolved = [];

        for (let name in this.__P_22_12.unresolved) {
          let item = this.__P_22_12.unresolved[name]; // item is undefined if it has already been removed from the list

          if (item === undefined) {
            continue;
          } // One of multiple classes defined in this file


          if (this.__P_22_3[name]) {
            continue;
          }

          var info = t.__P_22_0.getSymbolType(name);

          if (info && info.className) {
            t._requireClass(info.className, {
              load: item.load,
              defer: item.defer
            });
          } else if (info && info.symbolType == "package") {
            t.deleteReference(name);
          } else {
            dbClassInfo.unresolved.push(item);

            for (var j = 0; j < item.locations.length; j++) {
              t.addMarker("symbol.unresolved#" + name, item.locations[j].start, name);
            }
          }
        }

        if (!dbClassInfo.unresolved.length) {
          delete dbClassInfo.unresolved;
        } // Assets


        var assets = this.getAssets();

        if (assets.length) {
          dbClassInfo.assets = assets;
        }

        if (meta) {
          if (meta.aliases) {
            dbClassInfo.aliases = {};

            for (let name in meta.aliases.aliasMap) {
              dbClassInfo.aliases[name] = meta.aliases.aliasMap[name];
            }
          }

          if (meta.themeMeta) {
            dbClassInfo.themeMeta = {};

            for (let name in meta.themeMeta.themeMetaMap) {
              dbClassInfo.themeMeta[name] = meta.themeMeta.themeMetaMap[name];
            }
          }
        }

        if (this.__P_22_13.length) {
          dbClassInfo.externals = this.__P_22_13;
        } // Translation


        if (this.__P_22_9.length) {
          dbClassInfo.translations = this.__P_22_9.slice(0);
        } // Markers


        if (this.__P_22_10.length) {
          dbClassInfo.markers = qx.lang.Array.clone(this.__P_22_10);
        } // Errors


        if (this.__P_22_25) {
          dbClassInfo.fatalCompileError = true;
        }

        return dbClassInfo;
      },

      /**
       * Returns the loaded meta data
       */
      getOuterClassMeta: function () {
        let src = this.__P_22_3[this.__P_22_1] || null;

        if (!src) {
          return src;
        }

        let dest = {};
        Object.keys(src).filter(key => key[0] != "_").forEach(key => dest[key] = src[key]);
        return dest;
      },

      /**
       * Babel plugin
       */
      _babelClassPlugins: function () {
        var t = this;

        function getKeyName(key) {
          var keyName = key.type == "StringLiteral" ? key.value : key.name;
          return keyName;
        }

        function checkNodeJsDocDirectives(node) {
          var jsdoc = getJsDoc(node.leadingComments);

          if (jsdoc) {
            checkJsDocDirectives(jsdoc, node.loc);
          }

          return jsdoc;
        }

        function checkJsDocDirectives(jsdoc, loc) {
          if (!jsdoc) {
            return jsdoc;
          }

          if (jsdoc["@use"]) {
            jsdoc["@use"].forEach(function (elem) {
              t._requireClass(elem.body, {
                where: "use",
                load: false,
                location: loc
              });
            });
          }

          if (jsdoc["@require"]) {
            jsdoc["@require"].forEach(function (elem) {
              t._requireClass(elem.body, {
                where: "require",
                load: false,
                location: loc
              });
            });
          }

          if (jsdoc["@optional"]) {
            jsdoc["@optional"].forEach(function (elem) {
              t.addIgnore(elem.body);
            });
          }

          if (jsdoc["@ignore"]) {
            jsdoc["@ignore"].forEach(function (elem) {
              t.addIgnore(elem.body);
            });
          }

          if (jsdoc["@external"]) {
            jsdoc["@external"].forEach(function (elem) {
              t.addExternal(elem.body);

              t._requireAsset(elem.body);
            });
          }

          if (jsdoc["@asset"]) {
            jsdoc["@asset"].forEach(function (elem) {
              t._requireAsset(elem.body);
            });
          }

          return jsdoc;
        }

        function enterFunction(path, node, idNode) {
          node = node || path.node;
          idNode = idNode || node.id || null;
          let isClassMember = t.__P_22_24 && t.__P_22_24._topLevel && t.__P_22_24._topLevel.keyName == "members" && path.parentPath.parentPath.parentPath == t.__P_22_24._topLevel.path;

          if (idNode) {
            t.addDeclaration(idNode.name);
          }

          t.pushScope(idNode ? idNode.name : null, node, isClassMember);

          function addDecl(param) {
            if (param.type == "AssignmentPattern") {
              addDecl(param.left);
            } else if (param.type == "RestElement") {
              t.addDeclaration(param.argument.name);
            } else if (param.type == "Identifier") {
              t.addDeclaration(param.name);
            } else if (param.type == "ArrayPattern") {
              param.elements.forEach(elem => addDecl(elem));
            } else if (param.type == "ObjectPattern") {
              param.properties.forEach(prop => addDecl(prop.value));
            } else {
              t.addMarker("testForFunctionParameterType", node.loc, param.type);
            }
          }

          node.params.forEach(param => {
            addDecl(param);
          });
          checkNodeJsDocDirectives(node);
        }

        function exitFunction(path, node) {
          node = node || path.node;
          t.popScope(node);
        }

        var FUNCTION_DECL_OR_EXPR = {
          enter: path => enterFunction(path),
          exit: path => exitFunction(path)
        };

        function getJsDoc(comment) {
          if (!comment) {
            return null;
          }

          if (!qx.lang.Type.isArray(comment)) {
            comment = [comment];
          }

          var result = {};
          comment.forEach(comment => {
            var tmp = qx.tool.compiler.jsdoc.Parser.parseComment(comment.value);

            for (var key in tmp) {
              var value = tmp[key];

              if (!result[key]) {
                result[key] = value;
              } else {
                qx.lang.Array.append(result[key], value);
              }
            }
          });
          return result;
        }

        function makeMeta(sectionName, functionName, node) {
          var meta;

          if (functionName) {
            var section = t.__P_22_24[sectionName];

            if (section === undefined) {
              section = t.__P_22_24[sectionName] = {};
            }

            meta = section[functionName];

            if (meta === undefined) {
              meta = section[functionName] = {};
            }
          } else {
            meta = t.__P_22_24[sectionName];

            if (meta === undefined) {
              meta = t.__P_22_24[sectionName] = {};
            }
          }

          meta.location = node.loc;

          if (node.leadingComments) {
            let jsdoc = checkNodeJsDocDirectives(node);

            if (jsdoc) {
              meta.jsdoc = jsdoc;
            }
          }

          if (sectionName === "members" || sectionName === "statics") {
            if (node.type == "ObjectMethod" || node.value.type === "FunctionExpression") {
              meta.type = "function";
            } else {
              meta.type = "variable";
            }

            if (functionName.startsWith("__")) {
              meta.access = "private";
            } else if (functionName.startsWith("_")) {
              meta.access = "protected";
            } else {
              meta.access = "public";
            }
          }

          return meta;
        }

        var needsQxCoreEnvironment = false;
        var COLLECT_CLASS_NAMES_VISITOR = {
          MemberExpression(path) {
            var self = this;
            var str = collapseMemberExpression(path.node);

            t._requireClass(str, {
              location: path.node.loc
            });

            var info = t.__P_22_0.getSymbolType(str);

            if (info && info.symbolType == "class") {
              self.collectedClasses.push(str);
            }
          }

        };
        const CODE_ELIMINATION_VISITOR = {
          CallExpression(path) {
            const name = collapseMemberExpression(path.node.callee);

            if ((name === "qx.core.Environment.select" || name === "qx.core.Environment.get") && types.isLiteral(path.node.arguments[0])) {
              const arg = path.node.arguments[0];

              const env = t.__P_22_0.getEnvironment();

              const envValue = env[arg.value];

              if (envValue !== undefined) {
                if (name === "qx.core.Environment.get") {
                  path.skip();
                  path.replaceWithSourceString(formatValueAsCode(envValue));
                  return;
                } else if (name === "qx.core.Environment.select") {
                  const subPath = path.get("arguments.1");
                  let option = subPath.node.properties.find(prop => prop.key.value === envValue.toString());

                  if (!option) {
                    // try to find default value
                    option = subPath.node.properties.find(prop => prop.key.value === "default");
                  }

                  if (option) {
                    // path.skip();
                    path.replaceWith(option.value);
                    return;
                  }
                }
              }

              needsQxCoreEnvironment = path.node.loc;
            }
          },

          IfStatement: {
            exit(path) {
              let node = path.node; // If it's a literal value, we can eliminate code because we can resolve it now.  This
              //  is really important for anything wrapped in `if (qx.core.Environment.get("qx.debug")) ...`
              //  because the `qx.core.Environment.get` is replaced with a literal value and we need to
              //  use this to remove the unwanted code.

              if (types.isLiteral(node.test)) {
                if (node.test.value) {
                  path.replaceWith(node.consequent);
                } else if (node.alternate) {
                  path.replaceWith(node.alternate);
                } else {
                  path.remove();
                }
              }
            }

          },
          LogicalExpression: {
            exit(path) {
              let node = path.node;

              if (types.isLiteral(node.left) && types.isLiteral(node.right)) {
                let result = node.operator == "&&" && node.left.value && node.right.value || node.operator == "||" && (node.left.value || node.right.value);
                path.replaceWith(literalValueToExpression(result));
              }
            }

          },
          BinaryExpression: {
            exit(path) {
              let node = path.node;

              if (isCollapsibleLiteral(node.left) && isCollapsibleLiteral(node.right)) {
                if ("+-*/".indexOf(node.operator) > -1) {
                  let result;

                  switch (node.operator) {
                    case "+":
                      result = node.left.value + node.right.value;
                      break;

                    case "-":
                      result = node.left.value - node.right.value;
                      break;

                    case "/":
                      result = node.left.value / node.right.value;
                      break;

                    case "*":
                      result = node.left.value * node.right.value;
                      break;
                  }

                  path.skip();
                  path.replaceWithSourceString(formatValueAsCode(result));
                } else {
                  let result;

                  switch (node.operator) {
                    case "==":
                      result = node.left.value == node.right.value;
                      break;

                    case "===":
                      result = node.left.value === node.right.value;
                      break;

                    case "!=":
                      result = node.left.value != node.right.value;
                      break;

                    case "!==":
                      result = node.left.value !== node.right.value;
                      break;
                  }

                  if (result !== undefined) {
                    path.replaceWith(types.booleanLiteral(Boolean(result)));
                  }
                }
              }
            }

          },
          UnaryExpression: {
            exit(path) {
              if (path.node.operator === "!" && types.isLiteral(path.node.argument)) {
                path.replaceWith(types.booleanLiteral(!path.node.argument.value));
              }
            }

          }
        };

        function collectJson(node, isProperties, jsonPath) {
          var result;

          if (node.type == "ObjectExpression") {
            result = {};
            let nextJsonPath = jsonPath ? jsonPath + "." : "";
            node.properties.forEach(function (prop) {
              var key = prop.key.name;
              var value = collectJson(prop.value, isProperties, nextJsonPath + key);
              result[key] = value;
            });
          } else if (node.type == "Literal" || node.type == "StringLiteral" || node.type == "BooleanLiteral" || node.type == "NumericLiteral" || node.type == "NullLiteral") {
            if (typeof node.value == "string") {
              let isIdentifier = false;
              if (isProperties && (jsonPath === "apply" || jsonPath === "transform")) isIdentifier = true;
              node.value = t.encodePrivate(node.value, isIdentifier, node.loc);
            }

            result = node.value;
          } else if (node.type == "ArrayExpression") {
            result = [];
            node.elements.forEach(function (elem) {
              result.push(collectJson(elem, isProperties));
            });
          } else if (node.type == "Identifier") {
            node.name = t.encodePrivate(node.name, true, node.loc);
            result = node.name;
          } else if (node.type == "CallExpression" || node.type == "FunctionExpression" || node.type == "ArrowFunctionExpression") {
            result = new Function("[[ Function ]]");
          } else if (node.type == "MemberExpression") {
            result = collapseMemberExpression(node);
          } else if (node.type == "UnaryExpression") {
            if (node.operator == "-") {
              let tmp = collectJson(node.argument, isProperties);

              if (typeof tmp == "number") {
                return tmp * -1;
              }
            } else if (node.operator == "!") {
              let tmp = collectJson(node.argument, isProperties);

              if (typeof tmp == "boolean") {
                return !tmp;
              }
            }

            result = "[[ UnaryExpression ]]";
          } else if (node.type == "NewExpression" || node.type == "BinaryExpression") {
            result = "[[ " + node.type + " ]]";
          } else {
            t.warn("Cannot interpret AST " + node.type + " at " + t.__P_22_1 + (node.loc ? " [" + node.loc.start.line + "," + node.loc.start.column + "]" : ""));
            result = null;
          }

          return result;
        }

        const ALLOWED_KEYS = {
          "class": {
            "static": {
              "@": "object",
              "type": "string",
              // String
              "statics": "object",
              // Map
              "environment": "object",
              // Map
              "defer": "function" // Function

            },
            "normal": {
              "@": "object",
              "@construct": "object",
              "@destruct": "object",
              "type": "string",
              // String
              "extend": "function",
              // Function
              "implement": "object",
              // Interface[]
              "include": "object",
              // Mixin[]
              "construct": "function",
              // Function
              "statics": "object",
              // Map
              "properties": "object",
              // Map
              "members": "object",
              // Map
              "environment": "object",
              // Map
              "events": "object",
              // Map
              "defer": "function",
              // Function
              "destruct": "function" // Function

            }
          },
          "interface": {
            "extend": "object",
            // Interface | Interface[]
            "statics": "object",
            // Map
            "members": "object",
            // Map
            "properties": "object",
            // Map
            "events": "object" // Map

          },
          "mixin": {
            "include": "object",
            // Mixin | Mixin[]
            "statics": "object",
            // Map
            "members": "object",
            // Map
            "properties": "object",
            // Map
            "events": "object",
            // Map
            "destruct": "function",
            // Function
            "construct": "function" // Function

          },
          "theme": {
            "title": "string",
            // String
            "aliases": "object",
            // Map
            "type": "string",
            // String
            "extend": "object",
            // Theme
            "colors": "object",
            // Map
            "borders": "object",
            // Map
            "decorations": "object",
            // Map
            "fonts": "object",
            // Map
            "icons": "object",
            // Map
            "widgets": "object",
            // Map
            "appearances": "object",
            // Map
            "meta": "object",
            // Map
            "include": "object",
            // Array
            "patch": "object",
            // Array
            "boot": "function" // Function

          }
        };

        function isValidExtendClause(prop) {
          if (prop.value.type == "MemberExpression" || prop.value.type == "Identifier" || prop.value.type == "NullLiteral") {
            return true;
          }

          if (t.__P_22_24.type === "class") {
            return false;
          }

          if (prop.value.type == "ArrayExpression") {
            return prop.value.elements.every(elem => elem.type == "MemberExpression" || elem.type == "Identifier");
          }

          return false;
        }

        const FUNCTION_NAMES = {
          construct: "$$constructor",
          destruct: "$$destructor",
          defer: null
        };

        function checkValidTopLevel(path) {
          var prop = path.node;
          var keyName = getKeyName(prop.key);
          let allowedKeys = ALLOWED_KEYS[t.__P_22_24.type];

          if (t.__P_22_24.type === "class") {
            allowedKeys = allowedKeys[t.__P_22_24.isStatic ? "static" : "normal"];
          }

          if (allowedKeys[keyName] === undefined) {
            t.addMarker("compiler.invalidClassDefinitionEntry", prop.loc, t.__P_22_24.type, keyName);
          }
        }

        function handleTopLevelMethods(path, keyName, functionNode) {
          if (keyName == "defer") {
            t.__P_22_27 = true;
            t.__P_22_22 = true;
          }

          t.__P_22_24.functionName = FUNCTION_NAMES[keyName] || keyName;

          if (FUNCTION_NAMES[keyName] !== undefined) {
            makeMeta(keyName, null, functionNode);
          }

          enterFunction(path, functionNode);
          path.traverse(VISITOR);
          exitFunction(path, functionNode);
          path.skip();
          t.__P_22_24.functionName = null;
        }

        var CLASS_DEF_VISITOR = {
          ObjectMethod(path) {
            if (path.parentPath.parentPath != this.classDefPath) {
              path.skip();
              path.traverse(VISITOR);
              return;
            }

            var keyName = getKeyName(path.node.key);
            checkValidTopLevel(path);
            handleTopLevelMethods(path, keyName, path.node);
          },

          ObjectProperty(path) {
            if (path.parentPath.parentPath != this.classDefPath) {
              path.skip();
              path.traverse(VISITOR);
              return;
            }

            var prop = path.node;
            var keyName = getKeyName(prop.key);
            checkValidTopLevel(path);

            if (FUNCTION_NAMES[keyName] !== undefined) {
              let val = path.node.value;
              val.leadingComments = (path.node.leadingComments || []).concat(val.leadingComments || []);
              handleTopLevelMethods(path, keyName, val);
              return;
            }

            if (keyName == "extend") {
              if (!isValidExtendClause(prop)) {
                t.addMarker("compiler.invalidExtendClause", prop.value.loc);
                t.__P_22_25 = true;
              } else {
                t.__P_22_24.superClass = collapseMemberExpression(prop.value);

                t._requireClass(t.__P_22_24.superClass, {
                  location: path.node.loc
                });
              }
            } else if (keyName == "type") {
              var type = prop.value.value;
              t.__P_22_24.isAbstract = type === "abstract";
              t.__P_22_24.isStatic = type === "static";
              t.__P_22_24.isSingleton = type === "singleton";
            } else if (keyName == "implement") {
              path.skip();
              path.traverse(COLLECT_CLASS_NAMES_VISITOR, {
                collectedClasses: t.__P_22_24.interfaces
              });
            } else if (keyName == "include") {
              path.skip();
              path.traverse(COLLECT_CLASS_NAMES_VISITOR, {
                collectedClasses: t.__P_22_24.mixins
              });
            } else if (keyName == "members" || keyName == "statics" || keyName == "@") {
              t.__P_22_24._topLevel = {
                path,
                keyName
              };
              path.skip();
              path.traverse(VISITOR);
              t.__P_22_24._topLevel = null;
            } else if (keyName == "properties") {
              path.skip();

              if (!prop.value.properties) {
                t.addMarker("class.invalidProperties", prop.loc || null);
              } else {
                prop.value.properties.forEach(function (pdNode) {
                  var propName = getKeyName(pdNode.key);
                  var meta = makeMeta("properties", propName, pdNode);
                  var data = collectJson(pdNode.value, true);
                  meta.name = propName;
                  meta.propertyType = "new";
                  ["refine", "themeable", "event", "inheritable", "apply", "async", "group", "nullable", "init", "transform"].forEach(name => meta[name] = data[name]);

                  if (data.nullable !== undefined) {
                    meta.allowNull = data.nullable;
                  }

                  if (data.check !== undefined) {
                    if (qx.lang.Type.isArray(data.check)) {
                      meta.possibleValues = data.check;
                    } else {
                      meta.check = data.check;
                    }
                  }

                  if (data.init !== undefined) {
                    meta.defaultValue = data.init;
                  }
                });
              }

              path.traverse(VISITOR);
            } else if (keyName == "events") {
              path.skip();

              if (prop.value.properties) {
                prop.value.properties.forEach(function (eventNode) {
                  var eventName = getKeyName(eventNode.key);
                  var meta = makeMeta("events", eventName, eventNode);
                  meta.name = eventName;
                  meta.type = collectJson(eventNode.value);
                });
              }

              path.traverse(VISITOR);
            } else if (keyName == "aliases") {
              path.skip();

              if (!prop.value.properties) {
                t.addMarker("class.invalidAliases", prop.loc || null);
              } else {
                var meta = makeMeta("aliases", null, prop);
                meta.aliasMap = {};
                prop.value.properties.forEach(function (aliasNode) {
                  var aliasName = getKeyName(aliasNode.key);
                  var aliasValue = getKeyName(aliasNode.value);
                  meta.aliasMap[aliasName] = aliasValue;
                });
              }
            } else if (keyName == "meta") {
              path.skip();

              if (!prop.value.properties) {
                t.addMarker("class.invalidThemeMeta", prop.loc || null);
              } else {
                let meta = makeMeta("themeMeta", null, prop);
                meta.themeMetaMap = {};
                prop.value.properties.forEach(function (node) {
                  var key = getKeyName(node.key);
                  var value = collapseMemberExpression(node.value);
                  meta.themeMetaMap[key] = value;
                });
              }

              path.traverse(VISITOR);
            }
          }

        };
        const TYPE = {
          "qx.Class.define": "class",
          "qx.Mixin.define": "mixin",
          "qx.Theme.define": "theme",
          "qx.Interface.define": "interface",
          "qx.Bootstrap.define": "class"
        };
        var VISITOR = {
          NewExpression: {
            enter(path) {
              var str = collapseMemberExpression(path.node.callee);

              t._requireClass(str, {
                usage: "dynamic",
                location: path.node.loc
              });
            },

            exit(path) {
              if (t.__P_22_0.isAddCreatedAt()) {
                var fn = types.memberExpression(types.identifier("qx"), types.identifier("$$createdAt"));
                var tmp = types.callExpression(fn, [path.node, types.stringLiteral(t.__P_22_1.replace(/\./g, "/") + ".js"), types.numericLiteral(path.node.loc ? path.node.loc.start.line : 0), types.numericLiteral(path.node.loc ? path.node.loc.start.column : 0)]);
                path.replaceWith(tmp);
                path.skip();
              }
            }

          },
          ExpressionStatement: {
            enter: path => {
              checkNodeJsDocDirectives(path.node);
            },
            exit: path => {
              checkNodeJsDocDirectives(path.node);
            }
          },
          EmptyStatement: path => {
            checkNodeJsDocDirectives(path.node);
          },

          JSXElement(path) {
            t.__P_22_30 = true;
          },

          Program: {
            exit(path) {
              let dbClassInfo = t._compileDbClassInfo();

              let copyInfo = {};
              let hasLoadDeps = false;

              if (dbClassInfo.dependsOn) {
                copyInfo.dependsOn = {};
                Object.keys(dbClassInfo.dependsOn).forEach(key => {
                  let tmp = copyInfo.dependsOn[key] = Object.assign({}, dbClassInfo.dependsOn[key]);

                  if (tmp.load) {
                    delete tmp.load;
                    tmp.require = true;
                    hasLoadDeps = true;
                  }
                });
              }

              if (dbClassInfo.environment) {
                copyInfo.environment = dbClassInfo.environment;
                let required = dbClassInfo.environment.required;

                if (required) {
                  for (let key in required) {
                    if (required[key].load) {
                      hasLoadDeps = true;
                      break;
                    }
                  }
                }
              }

              let tmp = types.variableDeclaration("var", [types.variableDeclarator(types.identifier("$$dbClassInfo"), literalValueToExpression(copyInfo))]);
              let inject = [tmp];

              if (hasLoadDeps) {
                tmp = babylon.parse("qx.Bootstrap.executePendingDefers($$dbClassInfo);").program.body;
                inject.push(tmp[0]);
              }

              path.node.body.forEach(node => inject.push(node));
              tmp = babylon.parse(t.__P_22_1 + ".$$dbClassInfo = $$dbClassInfo;").program.body;
              inject.push(tmp[0]);
              let block = types.blockStatement(inject);
              let rootFn = types.expressionStatement(types.callExpression(types.functionExpression(null, [], block), []));
              path.node.body.splice(0, path.node.body.length, rootFn);
            }

          },

          Literal(path) {
            if (typeof path.node.value == "string") {
              path.node.value = t.encodePrivate(path.node.value, false, path.loc);
            }
          },

          Identifier(path) {
            path.node.name = t.encodePrivate(path.node.name, true, path.loc); // These are AST node types which do not cause undefined references for the identifier,
            // eg ObjectProperty could be `{ abc: 1 }`, and `abc` is not undefined, it is an identifier

            const CHECK_FOR_UNDEFINED = {
              ObjectProperty: 1,
              ObjectMethod: 1,
              FunctionExpression: 1,
              FunctionStatement: 1,
              ArrowFunctionExpression: 1,
              VariableDeclarator: 1,
              FunctionDeclaration: 1,
              CatchClause: 1,
              AssignmentPattern: 1,
              RestElement: 1,
              ArrayPattern: 1,
              SpreadElement: 1,
              ClassDeclaration: 1,
              ClassMethod: 1,
              LabeledStatement: 1,
              BreakStatement: 1
            }; // These are AST node types we expect to find at the root of the identifier, and which will
            //  not trigger a warning.  The idea is that all of the types in CHECK_FOR_UNDEFINED are types
            //  that cause references to variables, everything else is in DO_NOT_WARN_TYPES.  But, if anything
            //  has been missed and is not in either of these lists, throw a warning so that it can be checked

            const DO_NOT_WARN_TYPES = {
              AssignmentExpression: 1,
              BooleanExpression: 1,
              CallExpression: 1,
              BinaryExpression: 1,
              UnaryExpression: 1,
              WhileStatement: 1,
              IfStatement: 1,
              NewExpression: 1,
              ReturnStatement: 1,
              ConditionalExpression: 1,
              LogicalExpression: 1,
              ForInStatement: 1,
              ArrayExpression: 1,
              SwitchStatement: 1,
              SwitchCase: 1,
              ThrowStatement: 1,
              ExpressionStatement: 1,
              UpdateExpression: 1,
              SequenceExpression: 1,
              ContinueStatement: 1,
              ForStatement: 1,
              TemplateLiteral: 1,
              AwaitExpression: 1,
              DoWhileStatement: 1,
              ForOfStatement: 1,
              TaggedTemplateExpression: 1,
              ClassExpression: 1,
              OptionalCallExpression: 1
            };
            let root = path;

            while (root) {
              let parentType = root.parentPath.node.type;

              if (parentType == "MemberExpression" || parentType == "OptionalMemberExpression") {
                root = root.parentPath;
                continue;
              }

              if (CHECK_FOR_UNDEFINED[parentType]) {
                return;
              }

              if (!DO_NOT_WARN_TYPES[parentType]) {
                t.addMarker("testForUnresolved", path.node.loc, parentType);
              }

              break;
            }

            let name = collapseMemberExpression(root.node);

            if (name.startsWith("(")) {
              return;
            }

            let members = name.split(".");
            t.addReference(members, root.node.loc);
          },

          CallExpression: {
            enter: function (path) {
              function getStringArg(index) {
                if (index >= path.node.arguments.length) {
                  return null;
                }

                let arg = path.node.arguments[index];

                if (arg.type == "StringLiteral") {
                  return arg.value;
                }

                return null;
              }

              function addTranslation(entry) {
                let lineNo = path.node.loc ? path.node.loc.start.line : 0;
                let cur = t.__P_22_9[entry.msgid];

                if (cur) {
                  if (!qx.lang.Type.isArray(cur.lineNo)) {
                    cur.lineNo = [cur.lineNo];
                  }

                  cur.lineNo.push(lineNo);
                } else {
                  entry.lineNo = lineNo;

                  t.__P_22_9.push(entry);
                }
              }

              if (types.isMemberExpression(path.node.callee)) {
                let name = collapseMemberExpression(path.node.callee);
                let thisAlias = null; // Try and translate aliases for "this"; this is a really simplistic implementation
                //  because static code path analysis is way out of scope for the compiler, so we're
                //  only trying to handle code like:
                //    ```
                //    var that = this, args = arguments;
                //    (function() { that.base(args); })();
                //    ```

                if (path.node.callee.object.type == "Identifier") {
                  let originalAlias = path.node.callee.object.name;
                  let alias = originalAlias;
                  let aliasIsThis = false;

                  for (let scope = t.__P_22_12; scope; scope = scope.parent) {
                    while (!aliasIsThis) {
                      let tmp = scope.vars[alias];

                      if (tmp === "this") {
                        aliasIsThis = true;
                        break;
                      }

                      if (typeof tmp == "string") {
                        alias = tmp;
                      } else {
                        break;
                      }
                    }

                    if (aliasIsThis || scope.isClassMember) {
                      break;
                    }
                  }

                  if (aliasIsThis) {
                    name = "this" + name.substring(originalAlias.length);
                    thisAlias = originalAlias;
                  }
                } // Class definition?  EG `qx.Class.define(...`


                if (TYPE[name]) {
                  t.__P_22_28 = name.match(/\.([a-zA-Z]+)\./)[1];
                  let node = path.node;
                  let className = node.arguments[0].value;
                  let classDef = node.arguments[1]; // We can only parse objects (eg qx.data.marshal.Json.__toClass creates objects on the fly that we cannot scan)

                  if (classDef.type != "ObjectExpression") {
                    return;
                  } // Create new meta


                  t.__P_22_31(className);

                  if (needsQxCoreEnvironment) {
                    t._requireClass("qx.core.Environment", {
                      location: needsQxCoreEnvironment,
                      defer: true
                    });
                  }

                  let meta = makeMeta("clazz", null, path.parent);
                  t.__P_22_24.type = TYPE[name];

                  if (t.__P_22_28 == "Class" || t.__P_22_28 == "Bootstrap") {
                    let typeProp = classDef.properties.find(prop => prop.key.type == "Identifier" && prop.key.value == "type");

                    if (typeProp) {
                      t.__P_22_24.isStatic == typeProp.value.type == "Literal" && typeProp.value.value === "static";
                    }
                  }

                  checkJsDocDirectives(meta.jsdoc, path.node.loc);

                  t._requireClass(name, {
                    usage: "dynamic",
                    location: path.node.loc
                  });

                  path.skip();
                  path.traverse(CLASS_DEF_VISITOR, {
                    classDefPath: path
                  });

                  t.__P_22_32(className);
                } else if (name == "qx.core.Environment.add") {
                  let arg = path.node.arguments[0];

                  if (types.isLiteral(arg)) {
                    if (typeof arg.value != "string") {
                      log.error("Invalid argument to qx.core.Environment.add: " + arg.value);
                    } else {
                      t.__P_22_7.provided[arg.value] = true;

                      if (!arg.value.startsWith(t.__P_22_1) && !qx.tool.compiler.ClassFile.ENVIRONMENT_CONSTANTS.hasOwnProperty(arg.value)) {
                        let symbol = t.__P_22_4.getSymbolType(arg.value);

                        if (!symbol || symbol.symbolType != "environment") {
                          t.addMarker("environment.unreachable", path.node.loc, arg.value);
                        }
                      }
                    }
                  }

                  t._requireClass("qx.core.Environment", {
                    usage: "dynamic",
                    location: path.node.loc
                  });
                } else if (name == "qx.core.Environment.get") {
                  let arg = path.node.arguments[0];

                  if (types.isLiteral(arg)) {
                    if (typeof arg.value != "string") {
                      log.error("Invalid argument to qx.core.Environment.get: " + arg.value);
                    } else {
                      t.addEnvCheck(arg.value, path.node.loc);
                    }
                  }

                  t._requireClass("qx.core.Environment", {
                    usage: "dynamic",
                    location: path.node.loc
                  });

                  path.skip();
                  path.traverse(VISITOR);
                } else if (name == "qx.core.Environment.select") {
                  let arg = path.node.arguments[0];

                  if (types.isLiteral(arg)) {
                    if (typeof arg.value != "string") {
                      log.error("Invalid argument to qx.core.Environment.select: " + arg.value);
                    } else {
                      t.addEnvCheck(arg.value, path.node.loc);
                    }
                  }

                  t._requireClass("qx.core.Environment", {
                    usage: "dynamic",
                    location: path.node.loc
                  });

                  path.skip();
                  path.traverse(VISITOR);
                } else if (name == "this.base") {
                  let expr; // For mixins, there is never a valid time to call this.base() in the constructor; but it is
                  //  OK in methods - but we have to refer to superclass.methodName directly.  For ordinary
                  //  classes, we need to use constructor.methodName.base.

                  if (t.__P_22_28 == "Mixin") {
                    expr = types.callExpression(expandMemberExpression("qx.Mixin.baseClassMethod"), [expandMemberExpression("this.constructor"), types.identifier(t.__P_22_24.className), types.stringLiteral(t.__P_22_24.functionName)]);
                    expr = types.memberExpression(expr, types.identifier("call")); //expr = expandMemberExpression("qx.Mixin.baseClassMethod(this.constructor, " + t.__classMeta.className + ", \"" + t.__classMeta.functionName + "\").call");
                    //expr = expandMemberExpression(t.__classMeta.className + ".$$members." + t.__classMeta.functionName + ".base.call");
                  } else if (t.__P_22_24.functionName == "$$constructor") {
                    expr = expandMemberExpression(t.__P_22_24.superClass + ".constructor.call");
                  } else {
                    expr = expandMemberExpression(t.__P_22_24.className + ".prototype." + t.__P_22_24.functionName + ".base.call");
                  }

                  if (thisAlias) {
                    path.node.arguments[0] = types.identifier(thisAlias);
                  } else {
                    path.node.arguments[0] = types.thisExpression();
                  }

                  let callExpr = types.callExpression(expr, path.node.arguments);
                  path.replaceWith(callExpr);
                } else if (name == "this.base.apply" || name == "this.base.call") {
                  let methodName = name == "this.base.apply" ? "apply" : "call";
                  let expr;

                  if (t.__P_22_28 == "Mixin") {
                    expr = expandMemberExpression("this.constructor.superclass.prototype." + t.__P_22_24.functionName + ".call");
                  } else if (t.__P_22_24.functionName == "$$constructor") {
                    expr = expandMemberExpression(t.__P_22_24.superClass + ".constructor." + methodName);
                  } else {
                    expr = expandMemberExpression(t.__P_22_1 + ".prototype." + t.__P_22_24.functionName + ".base." + methodName);
                  } // Original call to this.base.apply would have included arguments in the first element of the array
                  //  here we remove that because it's not needed, specifically changing
                  //    `this.base.apply(this, args)` to
                  //    `this.base.apply(this, args.slice().shift())`


                  let exprSplice = types.callExpression(types.memberExpression(path.node.arguments[1], types.identifier("slice")), []);
                  let exprUnshift = types.callExpression(types.memberExpression(exprSplice, types.identifier("shift")), []);
                  let callExpr = types.callExpression(expr, [path.node.arguments[0], exprUnshift]);
                  path.replaceWith(callExpr);
                } else if (name == "this.self") {
                  let expr = expandMemberExpression(t.__P_22_1);
                  path.replaceWith(expr);
                } else if (name == "this.tr" || name == "this.marktr" || name == "qx.locale.Manager.tr" || name == "qx.locale.Manager.marktr") {
                  let arg0 = getStringArg(0);

                  if (!arg0) {
                    t.addMarker("translate.invalidMessageId", path.node.loc, arg0);
                  } else {
                    addTranslation({
                      msgid: arg0
                    });
                  }
                } else if (name == "this.trn" || name == "qx.locale.Manager.trn") {
                  let arg0 = getStringArg(0);
                  let arg1 = getStringArg(1);

                  if (!arg0 || !arg1) {
                    t.addMarker("translate.invalidMessageIds", path.node.loc, arg0, arg1);
                  } else {
                    addTranslation({
                      msgid: arg0,
                      msgid_plural: arg1
                    });
                  }
                } else if (name == "this.trc" || name == "qx.locale.Manager.trc") {
                  let arg0 = getStringArg(0);
                  let arg1 = getStringArg(1);

                  if (!arg0 || !arg1) {
                    t.addMarker("translate.invalidMessageIds", path.node.loc, arg0, arg1);
                  } else {
                    addTranslation({
                      msgid: arg1,
                      comment: arg0
                    });
                  }
                } else if (name == "this.trnc" || name == "qx.locale.Manager.trnc") {
                  let arg0 = getStringArg(0);
                  let arg1 = getStringArg(1);
                  let arg2 = getStringArg(2);

                  if (!arg0 || !arg1 || !arg2) {
                    t.addMarker("translate.invalidMessageIds3", path.node.loc, arg0, arg1, arg2);
                  } else {
                    addTranslation({
                      msgid: arg1,
                      msgid_plural: arg2,
                      comment: arg0
                    });
                  }
                } else {
                  let pos = name.lastIndexOf("."); // name can be ".concat" when used with "[].concat"

                  if (pos > 0) {
                    let str = name.substring(0, pos);

                    if (!t.hasDeclaration(str)) {
                      t._requireClass(str, {
                        usage: "dynamic",
                        location: path.node.loc
                      });
                    }
                  }
                }
              }
            }
          },
          MemberExpression: {
            exit(path) {
              // regular expression or string property (eg "aa".charCodeAt())
              if (path.node.object.type == "Literal") {
                return;
              } // Handle `[ 123 ].blah()` by visiting


              if (path.node.object.type == "ArrayExpression") {
                return;
              } // Handle `[ 123 ].blah()` by visiting


              if (path.node.object.type == "MemberExpression" && path.node.object.object.type == "ArrayExpression") {
                return;
              }

              let name = collapseMemberExpression(path.node);

              if (name.startsWith("(")) {
                return;
              }

              let members = name.split("."); // Ignore 'this' references

              if (members[0] === "this") {
                return;
              } // Global variable or a local variable?


              if (t.__P_22_16[members[0]] || t.hasDeclaration(members[0])) {
                return;
              }

              let info = t._requireClass(name, {
                location: path.node.loc
              });

              if (!info || !info.className) {
                // The code `abc.def.ghi()` will produce a member expression for both `abc.def` (two Identifier's)
                //  and another for `abc.def` and `.ghi` (MemberExpression + Identifier).  Our logic for detecting
                //  references and unresolved symbols expects the full `abc.def.ghi` so by excluding MemberExpression's
                //  where the container is also a MemberExpression means that we skip the incomplete `abc.def`
                if (path.container.type == "MemberExpression") {
                  return;
                }

                t.addReference(members, path.node.loc);
              }
            }

          },
          ObjectProperty: {
            exit(path) {
              if (this.__P_22_19 == "readable") {
                if (path.node.value.type == "FunctionExpression" && path.node.value.id === null) {
                  let functionName = typeof path.node.key.value == "string" ? path.node.key.value : path.node.key.name;

                  if (!qx.tool.compiler.ClassFile.RESERVED_WORDS[functionName]) {
                    path.node.value.id = types.identifier(functionName);
                  }
                }
              }
            }

          },

          Property(path) {
            if (t.__P_22_24 && t.__P_22_24._topLevel && t.__P_22_24._topLevel.path == path.parentPath.parentPath) {
              t.__P_22_24.functionName = getKeyName(path.node.key);
              makeMeta(t.__P_22_24._topLevel.keyName, t.__P_22_24.functionName, path.node);
              path.skip();
              let functionId = null;

              if (this.__P_22_19 == "readable") {
                if (path.node.value.type == "FunctionExpression" && path.node.value.id === null) {
                  let functionName = typeof path.node.key.value == "string" ? path.node.key.value : path.node.key.name;

                  if (!qx.tool.compiler.ClassFile.RESERVED_WORDS[functionName]) {
                    functionId = types.identifier(functionName);
                  }
                }
              }

              path.traverse(VISITOR);

              if (functionId) {
                path.node.value.id = functionId;
              }

              t.__P_22_24.functionName = null;
            }
          },

          ObjectMethod(path) {
            if (t.__P_22_24) {
              // Methods within a top level object (ie "members" or "statics"), record the method name and meta data
              if (t.__P_22_24._topLevel && t.__P_22_24._topLevel.path == path.parentPath.parentPath) {
                t.__P_22_24.functionName = getKeyName(path.node.key);
                makeMeta(t.__P_22_24._topLevel.keyName, t.__P_22_24.functionName, path.node);
                path.skip();
                enterFunction(path);
                path.traverse(VISITOR);
                exitFunction(path);
                t.__P_22_24.functionName = null; // Otherwise traverse method as normal
              } else {
                path.skip();
                enterFunction(path);
                path.traverse(VISITOR);
                exitFunction(path);
              }
            }
          },

          FunctionDeclaration: FUNCTION_DECL_OR_EXPR,
          FunctionExpression: FUNCTION_DECL_OR_EXPR,
          ArrowFunctionExpression: FUNCTION_DECL_OR_EXPR,
          VariableDeclaration: {
            exit(path) {
              checkNodeJsDocDirectives(path.node);
              path.node.declarations.forEach(decl => {
                // Simple `var x` form
                if (decl.id.type == "Identifier") {
                  let value = null; //decl.id.name = t.encodePrivate(decl.id.name, true, decl.loc);

                  if (decl.init) {
                    if (decl.init.type == "Identifier") {
                      value = decl.init.name;
                    } else if (decl.init.type == "ThisExpression") {
                      value = "this";
                    }
                  }

                  t.addDeclaration(decl.id.name, value); // Object destructuring `var {a,b} = {...}`
                } else if (decl.id.type == "ObjectPattern") {
                  decl.id.properties.forEach(prop => {
                    if (prop.value.type == "AssignmentPattern") {
                      t.addDeclaration(prop.value.left.name);
                    } else {
                      t.addDeclaration(prop.value.name);
                    }
                  }); // Array destructuring `var [a,b] = [...]`
                } else if (decl.id.type == "ArrayPattern") {
                  decl.id.elements.forEach(prop => {
                    if (prop) {
                      if (prop.type == "AssignmentPattern") {
                        t.addDeclaration(prop.left.name);
                      } else if (prop.type == "RestElement") {
                        t.addDeclaration(prop.argument.name);
                      } else {
                        t.addDeclaration(prop.name);
                      }
                    }
                  });
                }
              });
            }

          },

          ClassDeclaration(path) {
            t.addDeclaration(path.node.id.name);
          },

          // Note that AST Explorer calls this MethodDefinition, not ClassMethod
          ClassMethod: {
            enter(path) {
              enterFunction(path, path.node.value, path.node.key);
            },

            exit(path) {
              exitFunction(path, path.node.value, path.node.key);
            }

          },
          CatchClause: {
            enter(path) {
              t.pushScope(null, path.node);
              t.addDeclaration(path.node.param.name);
            },

            exit(path) {
              t.popScope(path.node);
            }

          }
        };
        return {
          CodeElimination: {
            visitor: CODE_ELIMINATION_VISITOR
          },
          Compiler: {
            visitor: VISITOR
          }
        };
      },

      /**
       * Pushes new meta data onto the stack - each meta represents a class being defined,
       * we operate a stack so that we can handle inner classes
       *
       * @param className {String} name of the class being defined
       */
      __P_22_31: function (className) {
        var pos = (className || "").lastIndexOf(".");
        var meta = {
          className: className,
          packageName: pos > -1 ? className.substring(0, pos) : null,
          name: pos > -1 ? className.substring(pos + 1) : className,
          superClass: null,
          interfaces: [],
          mixins: [],
          functionName: null
        };

        this.__P_22_2.push(meta);

        this.__P_22_24 = meta;
        this.__P_22_3[className] = meta;
        this.__P_22_20++;
      },

      /**
       * Pops the current meta off the stack, optionally checking that the classname is correct
       */
      __P_22_32: function (className) {
        if (!this.__P_22_2.length) {
          throw new Error("No __metaStack entries to pop");
        }

        let meta = this.__P_22_2[this.__P_22_2.length - 1];

        if (className && meta.className != className) {
          throw new Error("Wrong __metaStack entries to pop, expected " + className + " found " + meta.className);
        }

        this.__P_22_2.pop();

        meta = this.__P_22_2[this.__P_22_2.length - 1] || null;
        this.__P_22_24 = meta;
      },

      /**
       * Pushes a new scope on the stack
       */
      pushScope: function (functionName, node, isClassMember) {
        this.__P_22_12 = {
          functionName: functionName,
          parent: this.__P_22_12,
          loc: node.loc,
          vars: {},
          unresolved: {},
          isClassMember: Boolean(isClassMember)
        };
      },

      /**
       * Pops a scope from the stack
       */
      popScope: function (node) {
        var old = this.__P_22_12;
        var scope = this.__P_22_12 = this.__P_22_12.parent;
        var unresolved = scope.unresolved;

        for (var name in old.unresolved) {
          if (scope.vars[name]) {
            continue;
          }

          var entry = unresolved[name];

          if (!entry) {
            entry = unresolved[name] = {
              name: name,
              locations: []
            };
          }

          entry.locations.push.apply(entry.locations, old.unresolved[name].locations);
        }
      },

      /**
       * Tests whether the current scope is load-time scope
       *
       * @returns {Boolean}
       */
      isLoadScope: function () {
        return !this.__P_22_12.parent;
      },

      /**
       * Tests whether this class has a defer method
       *
       * @returns {Boolean}
       */
      hasDefer: function () {
        return this.__P_22_27;
      },

      /**
       * Adds a variable declaration to the current scope; if the symbol was
       * previously "unresolved" it is removed from the unresolved list
       *
       * @param name {String} the name of the variabvle being declared
       * @param valueName {String} the value to assign to the variable
       */
      addDeclaration: function (name, valueName) {
        if (this.__P_22_12.vars[name] === undefined) {
          this.__P_22_12.vars[name] = valueName || true;
          var unresolved = this.__P_22_12.unresolved;
          delete unresolved[name];
          var re = new RegExp(name + "\\.");

          for (var tmp in unresolved) {
            if (re.test(tmp)) {
              delete unresolved[tmp];
            }
          }
        }
      },

      /**
       * Tests whether there is a variable declaration accessible to the current
       * scope, ie including parent scope
       *
       * @param name
       * @returns {Boolean}
       */
      hasDeclaration: function (name) {
        var pos = name.indexOf(".");

        if (pos > -1) {
          name = name.substring(0, pos);
        }

        for (var tmp = this.__P_22_12; tmp; tmp = tmp.parent) {
          if (tmp.vars[name] !== undefined) {
            return true;
          }
        }

        return false;
      },

      /**
       * Adds a reference to a symbol; unknown symbols are marked as unresolved
       * @param name
       * @param loc
       */
      addReference: function (name, loc) {
        if (!qx.lang.Type.isArray(name)) {
          name = name.split(".");
        }

        var scope = this.__P_22_12;

        if (scope.vars[name[0]] !== undefined) {
          return;
        } // Global variable or a local variable?


        if (name[0] === "this" || name[0] === "[]" || this.__P_22_16[name[0]] || this.hasDeclaration(name[0])) {
          return;
        }

        let str = "";

        for (var i = 0; i < name.length; i++) {
          if (i) {
            str += ".";
          }

          str += name[i];

          if (this.__P_22_16[str] || this.isIgnored(str)) {
            return;
          }
        }

        name = str;

        if (name == this.__P_22_1 || name.startsWith(this.__P_22_1 + ".") || name.startsWith("(")) {
          return;
        }

        if (!scope.unresolved[name]) {
          scope.unresolved[name] = {
            name: name,
            locations: loc ? [loc] : [],
            load: this.isLoadScope(),
            defer: this.__P_22_22
          };
        } else if (loc) {
          scope.unresolved[name].locations.push(loc);
        }
      },

      /**
       * Repeatably encodes a private symbol name, caching the result; ignores non-private symbols
       * 
       * @param name {String} symbol name
       * @param isIdentifier {boolean} whether this is usage as an identifier (and not in a string literal)
       * @param location {Location} the location of the symbol
       * @return {String} the encoded name if private, the original name if not private
       */
      encodePrivate: function (name, isIdentifier, location) {
        const DO_NOT_ENCODE = {
          "__proto__": 1,
          "__iterator__": 1,
          "__dirname": 1,
          "__filename": 1
        };

        if (DO_NOT_ENCODE[name] || this.__P_22_19 == "off" || !name.startsWith("__") || !name.match(/^[0-9a-z_$]+$/i)) {
          return name;
        }

        if (name.indexOf("__P_") > -1) {
          return name;
        }

        let coded = this.__P_22_17[name];

        if (!coded) {
          // Strings have to be handled differently - we need to mangle them, but only if we
          //  know for sure that they are private members; to do this, we need to see a symbol
          //  (identifier) first, to know that the string needs to be mangled
          if (!isIdentifier) {
            this.__P_22_18[name] = true;
            return name;
          }

          if (this.__P_22_18[name]) {
            this.addMarker("class.blockedMangle", location, name);
            return name;
          }

          let db = this.__P_22_0.getDatabase();

          if (!db.manglePrefixes) {
            db.manglePrefixes = {
              nextPrefix: 1,
              classPrefixes: {}
            };
          }

          let prefixes = db.manglePrefixes;
          let prefix = prefixes.classPrefixes[this.__P_22_1];

          if (!prefix) {
            prefix = "__P_" + ++prefixes.nextPrefix + "_";
            prefixes.classPrefixes[this.__P_22_1] = prefix;
          }

          if (this.__P_22_19 == "readable") {
            coded = this.__P_22_17[name] = name + prefix + Object.keys(this.__P_22_17).length;
          } else {
            coded = this.__P_22_17[name] = prefix + Object.keys(this.__P_22_17).length;
          }
        }

        return coded;
      },

      /**
       * Removes a reference from scope; this should only really be used after scanning is complete
       * @param name
       */
      deleteReference: function (name) {
        delete this.__P_22_12.unresolved[name];
        var stub = name + ".";

        for (var id in this.__P_22_12.unresolved) {
          if (id.startsWith(stub)) {
            delete this.__P_22_12.unresolved[id];
          }
        }
      },

      /**
       * Adds an external resource which needs to be loaded early
       *
       * @param name {String} name of the symbol
       */
      addExternal: function (name) {
        if (this.__P_22_13.indexOf(name) < 0) {
          this.__P_22_13.push(name);
        }
      },

      /**
       * Adds an ignored symbol
       * @param name {String} name of the symbol
       */
      addIgnore: function (name) {
        var scope = this.__P_22_12;

        if (!scope.ignore) {
          scope.ignore = {};
        }

        var segs = name.split(",");
        segs.forEach(name => {
          name = name.trim();

          if (name.length) {
            if (name.endsWith(".*")) {
              scope.ignore[name] = name.substring(0, name.length - 2);
            } else if (name.endsWith("*")) {
              scope.ignore[name] = name.substring(0, name.length - 1);
            } else {
              scope.ignore[name] = true;
            }
          }
        });
      },

      /**
       * Tests whether a symbol has already been marked as ignore
       * @param name {String} symbol name
       * @return {Boolean} true if ignored
       */
      isIgnored: function (name) {
        for (var tmp = this.__P_22_12; tmp; tmp = tmp.parent) {
          if (tmp.ignore) {
            if (tmp.ignore[name]) {
              return true;
            }

            for (var key in tmp.ignore) {
              if (tmp.ignore[key] !== true) {
                if (name.startsWith(tmp.ignore[key])) {
                  return true;
                }
              }
            }
          }
        }

        return false;
      },

      /**
       * Removes an ignored symbol
       * @param name {String} name of the symbol
       */
      removeIgnore: function (name) {
        var scope = this.__P_22_12;

        if (!scope) {
          return;
        }

        var segs = name.split(",");
        segs.forEach(name => delete scope.ignore[name]);
      },

      /**
       * Adds an environment check made by the class
       *
       * @param name
       * @param location {Object?} see _requireClass
       */
      addEnvCheck: function (name, location) {
        var t = this;
        var requiredOpts = {
          load: t.isLoadScope(),
          defer: t.__P_22_22,
          construct: t.__P_22_24 && t.__P_22_24.functionName == "$$constructor",
          location: location
        };
        var dest = t.__P_22_7.required[name];

        if (!dest) {
          dest = t.__P_22_7.required[name] = {};
        }

        if (requiredOpts.load) {
          dest.load = true;
        }

        if (requiredOpts.defer) {
          dest.defer = true;
        }

        if (requiredOpts.construct) {
          dest.construct = true;
        }

        t._requireClass("qx.core.Environment", {
          location: location
        });

        let info = t.__P_22_0.getSymbolType(name);

        if (!qx.tool.compiler.ClassFile.ENVIRONMENT_CONSTANTS.hasOwnProperty(name)) {
          // Generally speaking, we try to have as few load dependencies as possible, and this
          // means that in a class' `.defer()` we will still allow for runtime loading.  However,
          // we pull environment checks up as this is a common use case; the problem this is trying
          // to solve is instances where the feature detection class is loaded after the class which
          // implements the polyfill, and the polyfill's defer method is then installing a polyfill
          // when it does not need to (and should not do so).  For example, `qx.bom.client.EcmaScript`
          // *must* load and have its defer called before the `qx.lang.normalize.Object` class has
          // it's defer called. 
          let load = dest.load;

          if (info && info.symbolType == "environment") {
            load = true;
          }

          t._requireClass(name, {
            load: load,
            location: location
          });

          if (info && info.symbolType == "environment") {
            dest.className = info.className;
          }
        }
      },

      /**
       * Adds a marker (eg warning or error)
       *
       * @param msgId {String} the marker message ID (@see qx.tool.compiler.Marker)
       * @param pos {Object||null} position map; may contain a Map containing
       *  {line,column?}, or a Map {start:{line,column}, end: {line,column}}.
       */
      addMarker: function (msgId, pos) {
        msgId = "qx.tool.compiler." + msgId;
        let key = msgId;
        let fragment = msgId.indexOf("#");

        if (fragment > -1) {
          msgId = msgId.substring(0, fragment);
        } else {
          // Give each marker a unique key based on msgId and the line; use this to suppress
          //  multiple markers
          key += "#";

          if (pos) {
            if (pos.line) {
              key += pos.line;
            } else if (pos.start && pos.start.line) {
              key += pos.start.line;
            }
          }
        }

        if (this.__P_22_11[key]) {
          return;
        }

        this.__P_22_11[key] = true;
        let marker = {
          msgId: msgId
        }; // Extract position

        if (pos) {
          if (pos.line) {
            pos = {
              start: pos
            };
          }

          if (pos.start) {
            let tmp = {
              line: pos.start.line
            };

            if (pos.start.column) {
              tmp.column = pos.start.column;
            }

            marker.pos = {
              start: tmp
            };

            if (pos.end && pos.end.line) {
              let tmp = {
                line: pos.end.line
              };

              if (pos.end.column) {
                tmp.column = pos.end.column;
              }

              marker.pos.end = tmp;
            }
          }
        }

        let args = qx.lang.Array.fromArguments(arguments, 2);

        if (args.length) {
          marker.args = args;
        }

        this.__P_22_10.push(marker);
      },

      /**
       * Adds a required class
       *
       * @param name {String} the name of the class
       * @param opts {Map?} which is:
       *  where {"ignore"|"require"|"use"|null} where it's mentioned
       *  load {Boolean?} whether it is a load-time dependency or not
       *  defer {Boolean?} whether the dependency is in defer or not
       *  location {Map?} location of the token that caused the reference
       * @return {Map?} info about the symbol type of the named class, @see {Analyser.getSymbolType}
       */
      _requireClass: function (name, opts) {
        if (qx.lang.Type.isArray(name)) {
          name.forEach(name => this._requireClass(name));
          return null;
        }

        let t = this;

        if (name == this.__P_22_1) {
          return null;
        }

        if (!name) {
          throw new Error("No classname");
        }

        if (this.isIgnored(name)) {
          return null;
        }

        let requireOpts = {
          load: t.isLoadScope(),
          defer: t.__P_22_22,
          construct: t.__P_22_24 && t.__P_22_24.functionName == "$$constructor"
        };

        if (opts) {
          for (let key in opts) {
            requireOpts[key] = opts[key];
          }
        }

        let info = t.__P_22_0.getSymbolType(name);

        let symbolType = info ? info.symbolType : null;
        let className = info ? info.className : null;

        if (symbolType != "package" && className && className != t.__P_22_1) {
          // Re-check the class name as ignored if this is a member
          if (symbolType == "member" && t.isIgnored(className)) {
            return null;
          }

          let data = t.__P_22_6[className];

          if (!data) {
            data = t.__P_22_6[className] = {};
          }

          if (requireOpts.where !== undefined) {
            if (requireOpts.where == "ignore") {
              data.ignore = true;
            } else if (requireOpts.where == "require") {
              data.require = true;
            }
          }

          if (requireOpts.load) {
            data.load = true;

            if (requireOpts.usage === "dynamic") {
              if (data.usage !== "static") {
                data.usage = "dynamic";
              }

              data.load = true;
            } else if (!data.load) {
              data.load = true;
              data.usage = "static";
            }
          }

          if (requireOpts.defer) {
            if (requireOpts.load) {
              data.defer = "load";
            } else if (data.defer !== "load") {
              data.defer = "runtime";
            }

            if (!name.startsWith(t.__P_22_1)) {
              if (!qx.tool.compiler.ClassFile.DEFER_SAFE_SYMBOLS.some(function (symbol) {
                return name.startsWith(symbol);
              })) {// Temporarily disabled until Qooxdoo framework catches up
                // t.addMarker("defer.unsafe", (opts && opts.location)||null, name);
              }
            }
          }

          if (requireOpts.construct) {
            data.construct = true;
          }

          t.deleteReference(className);
        }

        return info;
      },

      /**
       * Adds a required asset
       * @param path
       */
      _requireAsset: function (path) {
        if (path.indexOf("/") < 0 && path.indexOf(".") > -1) {
          path = path.replace(/\./g, "/");
        }

        if (!qx.lang.Array.contains(this.__P_22_8, path)) {
          this.__P_22_8.push(path);
        }
      },

      /**
       * Returns the assets required by the class
       * @returns
       */
      getAssets: function () {
        return this.__P_22_8;
      },

      /**
       * Finds an object property in a node tree (not a Qooxdoo property, an
       * object property)
       *
       * @param props
       * @param name
       * @returns
       */
      __P_22_33: function (props, name) {
        for (let i = 0; i < props.length; i++) {
          let prop = props[i];

          if (prop.type == "Property") {
            if (prop.key.type == "Identifier" && prop.key.name == name) {
              return prop;
            }

            if (prop.key.type == "StringLiteral" && prop.key.value == name) {
              return prop;
            }
          }
        }

        return null;
      },

      /**
       * Returns the list of required classes (dependencies)
       *
       * @returns
       */
      getRequiredClasses: function () {
        return this.__P_22_6;
      },

      /**
       * Returns a list of unresolved symbols
       *
       * @returns
       */
      getUnresolvedSymbols: function () {
        return this.__P_22_12.unresolved;
      },

      /**
       * Returns the name of the class being compiled
       * @returns {null}
       */
      getClassName: function () {
        return this.__P_22_1;
      }
    },

    defer(statics) {
      statics.RESERVED_WORDS = {};
      let str = "abstract  arguments await  boolean break byte  case  catch char  class  const continue debugger  default delete  do double  else  enum eval export extends  false final finally float for function goto  if  implements  import in  instanceof  int interface let  long  native  new null  package private protected public  return  short static super  switch  synchronized  this throw throws  transient true try typeof  var void volatile  while with  yield";
      str.split(/\s+/).forEach(word => statics.RESERVED_WORDS[word] = true);
    },

    statics: {
      /**
       * Returns the absolute path to the class file
       *
       * @param library  {qx.tool.compiler.app.Library}
       * @param className {String}
       * @returns {String}
       */
      getSourcePath: function (library, className) {
        return pathModule.join(library.getRootDir(), library.getSourcePath(), className.replace(/\./g, pathModule.sep) + library.getSourceFileExtension(className));
      },

      /**
       * Returns the path to the rewritten class file
       *
       * @param analyser {qx.tool.compiler.Analyser}
       * @param className {String}
       * @returns {String}
       */
      getOutputPath: function (analyser, className) {
        var filename = pathModule.join(analyser.getOutputDir(), "transpiled", className.replace(/\./g, pathModule.sep) + ".js");
        return filename;
      },

      /**
       * Returns the root namespace from the classname, or null if it cannot be determined
       * @param className
       * @returns {*|null}
       */
      getNamespace: function (className) {
        var m = className.match(/^([^.]+)\./);
        return m && m[1] || null;
      },

      /**
       * These options are passed to Babel for JSX compilation; they can be changed by the CLI etc
       * as needed.
       * 
       * Note that at the moment they use a class that does not exist!  `qx.html.Jsx` is coming soon
       * to a PR near you, but in the mean time you could use the compile.json `jsx` setting to
       * change these to something else, eg `{ pragma: "jsx.dom", pragmaFrag: "jsx.Fragment }` and
       * use https://github.com/alecsgone/jsx-render in your application's code. 
       */
      JSX_OPTIONS: {
        "pragma": "qx.html.Jsx.createElement",
        "pragmaFrag": "qx.html.Jsx.FRAGMENT"
      },

      /**
       * Classes which are safe to access from defer methods (in addition to the class being defined)
       */
      DEFER_SAFE_SYMBOLS: ["qx.core.Environment", "qx.Bootstrap", "qx.core.Aspect"],

      /**
       * List of global symbols to be ignored
       */
      QX_GLOBALS: ["qx.$$domReady", "qx.$$environment", "qx.$$libraries", "qx.$$loader", "qx.$$locales", "qx.$$namespaceRoot", "qx.$$resources", "qx.$$packageData", "qx.$$start", "qx.$$translations"],
      COMMON_GLOBALS: ["Array", "ArrayBuffer", "Boolean", "Date", "DataView", "EvalError", "Error", "Float32Array", "Float64Array", "Function", "GeneratorFunction", "Generator", "Infinity", "Int8Array", "Int16Array", "Int32Array", "JSON", "Map", "Math", "NaN", "Number", "Object", "Proxy", "Promise", "RangeError", "ReferenceError", "Reflect", "RegExp", "Set", "String", "Symbol", "SyntaxError", "TypedArray", "TypeError", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "URIError", "WeakMap", "WeakSet", "arguments", "atob", "btoa", "console", "clearInterval", "clearTimeout", "decodeURI", "decodeURIComponent", "document", "encodeURI", "encodeURIComponent", "escape", "error", "eval", "isNaN", "isFinite", "navigator", "parseInt", "parseFloat", "setInterval", "setTimeout", "undefined", "unescape", "window"],
      BROWSER_GLOBALS: ["ActiveXObject", "Blob", "CustomEvent", "DOMParser", "DOMException", "Event", "FileReader", "FormData", "Image", "MutationObserver", "XPathResult", "XMLHttpRequest", "XMLSerializer", "XPathEvaluator", "alert", "document", "history", "location", "navigator", "performance", "getComputedStyle", "localStorage"],
      NODE_GLOBALS: ["Module", "require", "module", "process", "setImmediate", "__dirname", "__filename"],
      RHINO_GLOBALS: ["Packages", "java"],
      RESERVED_WORDS: null,

      /**
       * These are the constants which are answered by Qooxdoo qx.core.Environment; we use out own copy here and
       * not the one available in qx.core.Environment._defaults because we need to use the version which is appropriate
       * for the version of Qooxdoo being compiled, not the one that this CLI is compiled with
       */
      ENVIRONMENT_CONSTANTS: {
        // an always-true key (e.g. for use in qx.core.Environment.filter() calls)
        "true": true,
        // old settings retTrue
        "qx.allowUrlSettings": false,
        "qx.allowUrlVariants": false,
        "qx.debug.property.level": 0,
        // old variants
        // make sure to reflect all changes to qx.debug here in the bootstrap class!
        "qx.debug": true,
        "qx.debug.ui.queue": true,
        "qx.debug.touchpad.detection": false,
        "qx.aspects": false,
        "qx.dynlocale": true,
        "qx.dyntheme": true,
        "qx.blankpage": "qx/static/blank.html",
        "qx.debug.databinding": false,
        "qx.debug.dispose": false,
        "qx.nativeScrollBars": undefined,
        // generator optimization vectors
        "qx.optimization.basecalls": false,
        "qx.optimization.comments": false,
        "qx.optimization.privates": false,
        "qx.optimization.strings": false,
        "qx.optimization.variables": false,
        "qx.optimization.variants": false,
        // qooxdoo modules
        "module.databinding": true,
        "module.logger": true,
        "module.property": true,
        "module.events": true,
        "qx.nativeScrollBars": false,
        "qx.automaticMemoryManagement": true,
        "qx.promise": true,
        "qx.promise.warnings": true,
        "qx.promise.longStackTraces": true
      }
    }
  });
  qx.tool.compiler.ClassFile.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.tool.compiler.targets.Target": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
   *
   *    qooxdoo-compiler - node.js based replacement for the Qooxdoo python
   *    toolchain
   *
   *    https://github.com/qooxdoo/qooxdoo-compiler
   *
   *    Copyright:
   *      2011-2017 Zenesis Limited, http://www.zenesis.com
   *
   *    License:
   *      MIT: https://opensource.org/licenses/MIT
   *
   *      This software is provided under the same licensing terms as Qooxdoo,
   *      please see the LICENSE file in the Qooxdoo project's top-level directory
   *      for details.
   *
   *    Authors:
   *      * John Spackman (john.spackman@zenesis.com, @johnspackman)
   *
   * ************************************************************************/

  /**
   * Compiles a target where source files and resources are loaded in place
   */
  qx.Class.define("qx.tool.compiler.targets.SourceTarget", {
    extend: qx.tool.compiler.targets.Target,
    properties: {
      /**
       * Whether to copy resources in source builds.
       */
      copyResources: {
        check: "Boolean",
        init: true
      }
    },
    members: {
      /*
       * @Override
       */
      async _writeApplication() {
        if (this.getCopyResources()) {
          let appMeta = this.getAppMeta();
          await appMeta.syncAssets();
        }

        return await qx.tool.compiler.targets.SourceTarget.prototype._writeApplication.base.call(this);
      },

      /*
       * @Override
       */
      toString: function () {
        return "Source Target: " + this.getOutputDir();
      }
    }
  });
  qx.tool.compiler.targets.SourceTarget.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.tool.utils.Promisify": {},
      "qx.tool.compiler.targets.meta.Part": {},
      "qx.tool.compiler.targets.meta.Package": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /**
   * ApplicationMeta collects all the data about an application being compiled by a target, 
   * in a form easily navigated and well documented.  
   * 
   * It provides an abstraction where the target can choose to restructure and reorganise the 
   * output as it progresses - for example, a target may start by assembling a number of 
   * javascript files, and then bundle them together, effectively replacing several files 
   * with just one intermediate file; the target can then replace the intermediate file with 
   * a minified file etc.
   */
  qx.Class.define("qx.tool.compiler.targets.meta.ApplicationMeta", {
    extend: qx.core.Object,

    construct(target, application) {
      qx.core.Object.constructor.call(this);
      this.__P_41_0 = target;
      this.__P_41_1 = application;
      this.__P_41_2 = [];
      this.__P_41_3 = {
        urisBefore: [],
        cssBefore: []
      };
      this.__P_41_4 = [];
      this.__P_41_5 = {};
      this.__P_41_6 = [];
      this.__P_41_7 = [];
      this.__P_41_8 = {};
    },

    properties: {
      /** The environment for the build */
      environment: {// Any object
      },
      appLibrary: {
        check: "qx.tool.compiler.app.Library"
      },
      bootMetaJs: {
        check: "qx.tool.compiler.targets.meta.AbstractJavascriptMeta"
      },
      sourceUri: {
        check: "String"
      },
      resourceUri: {
        check: "String"
      }
    },
    members: {
      /** {qx.tool.compiler.targets.Target} the target */
      __P_41_0: null,

      /** {qx.tool.compiler.app.Application} the application */
      __P_41_1: null,

      /** {qx.tool.compiler.app.Libary[]} the libraries */
      __P_41_2: null,

      /** {Map} uris and CSS to load */
      __P_41_3: null,

      /** {String[]} code to run before boot */
      __P_41_4: null,

      /** {Map} list of resource paths, indexed by resource id */
      __P_41_5: null,

      /** {Package[]} list of packages */
      __P_41_6: null,

      /** {Part[]} list of parts */
      __P_41_7: null,

      /**
       * Sets an environment variable
       *
       * @param key {String} the name of the variable
       * @param value {Object} the value 
       */
      setEnvironmentValue(key, value) {
        let env = this.getEnvironment();

        if (value === undefined) {
          delete env[key];
        } else {
          env[key] = value;
        }
      },

      /**
       * Returns an environment value
       *
       * @param key {String} the key to lookup
       * @param defaultValue {Object?} optional default value to use if the key is not found
       * @return {Object} the value, or undefined if not found
       */
      getEnvironmentValue(key, defaultValue) {
        let env = this.getEnvironment();
        let value = env[key];

        if (value === undefined) {
          if (defaultValue !== undefined) {
            env[key] = defaultValue;
          }

          value = defaultValue;
        }

        return value;
      },

      /**
       * Returns the application
       *
       * @return {qx.tool.compiler.app.Application} 
       */
      getApplication() {
        return this.__P_41_1;
      },

      /**
       * Returns the target
       *
       * @return {qx.tool.compiler.targets.Target}
       */
      getTarget() {
        return this.__P_41_0;
      },

      /**
       * Returns the application root
       *
       * @return {String} the folder
       */
      getApplicationRoot() {
        return this.__P_41_0.getApplicationRoot(this.__P_41_1);
      },

      /**
       * Returns the Analyser
       *
       * @return {qx.tool.compiler.Analyser}
       */
      getAnalyser() {
        return this.__P_41_1.getAnalyser();
      },

      /**
       * Syncs all assets into the output directory
       */
      async syncAssets() {
        for (let i = 0; i < this.__P_41_6.length; i++) {
          let pkg = this.__P_41_6[i];
          await qx.tool.utils.Promisify.poolEachOf(pkg.getAssets(), 10, asset => asset.sync(this.__P_41_0));
        }
      },

      /**
       * Adds a library
       *
       * @param library {qx.tool.compiler.app.Library}
       */
      addLibrary(library) {
        this.__P_41_2.push(library);
      },

      /**
       * Returns the library that contains the application class
       *
       * @return {qx.tool.compiler.app.Library}
       */
      getAppLibrary() {
        let appLibrary = this.__P_41_1.getAnalyser().getLibraryFromClassname(this.__P_41_1.getClassName());

        return appLibrary;
      },

      /**
       * Returns the list of libraries
       *
       * @return {qx.tool.compiler.app.Library[]}
       */
      getLibraries() {
        return this.__P_41_2;
      },

      /**
       * Adds an external resource (JS or CSS) to be loaded which is a http[s] URL
       *
       * @param type {String} either "urisBefore" or "cssBefore"
       * @param uri {String} uri to load
       */
      addExternal(type, uri) {
        this.__P_41_3[type].push("__external__:" + uri);
      },

      /**
       * Adds an external resource (JS or CSS) to be loaded, which is a resource path
       *
       * @param type {String} either "urisBefore" or "cssBefore"
       * @param uri {String} uri to load
       */
      addPreload(type, uri) {
        this.__P_41_3[type].push(uri);
      },

      /**
       * Returns the list of preloads, which is a map by type
       * 
       * @return {Map}
       */
      getPreloads() {
        return this.__P_41_3;
      },

      /**
       * Adds code to be run before the boot code is run
       *
       * @param code {String} the code to run
       */
      addPreBootCode(code) {
        this.__P_41_4.push(code);
      },

      /**
       * Returns the code to be run before the boot code
       *
       * @return {String} the code
       */
      getPreBootCode() {
        return this.__P_41_4.join("\n");
      },

      /**
       * Creates a new Part and adds it
       * 
       * @param name {String} identifier
       * @return {Part}
       */
      createPart(name) {
        let part = new qx.tool.compiler.targets.meta.Part(this.getTarget(), name, this.__P_41_7.length);

        this.__P_41_7.push(part);

        this.__P_41_8[name] = part;
        return part;
      },

      /**
       * Returns a list of all parts
       * 
       * @return {Part[]}
       */
      getParts() {
        return this.__P_41_7;
      },

      /**
       * Returns a part with a given name
       * 
       * @param name {String} the name to look for
       */
      getPart(name) {
        return this.__P_41_8[name] || null;
      },

      /**
       * Returns a list of all packages
       * 
       * @return {Package[]}
       */
      getPackages() {
        return this.__P_41_6;
      },

      /**
       * Creates a package and adds it
       * 
       * @return {Package}
       */
      createPackage() {
        let pkg = new qx.tool.compiler.targets.meta.Package(this, this.__P_41_6.length);

        this.__P_41_6.push(pkg);

        return pkg;
      },

      /**
       * Gets a package for specific locale, creating a part with the name set to the localeId
       * if there isn't one already.  Used for when i18nAsParts == true
       * 
       * @param localeId {String} the locale to look for
       * @return {Package}
       */
      getLocalePackage(localeId) {
        let part = this.getPart(localeId);

        if (!part) {
          part = this.createPart(localeId);
          part.addPackage(this.createPackage());
        }

        let pkg = part.getDefaultPackage();
        return pkg;
      },

      /**
       * Adds a resource
       * 
       * @param key {String} the resource identifier
       * @param path {String} the path to the resource
       */
      addResource(key, path) {
        this.__P_41_5[key] = path;
      },

      /**
       * Returns all of the resources
       * 
       * @return {Map}
       */
      getResources() {
        return this.__P_41_5;
      }

    }
  });
  qx.tool.compiler.targets.meta.ApplicationMeta.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.tool.utils.Promisify": {
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.tool.utils.Utils": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);
  const fs = qx.tool.utils.Promisify.fs;

  const sourceMap = require("source-map");
  /**
   * An AbstractJavascriptMeta provides an abstraction of some source code, and might be
   * compromised of a number of input files which are merged together as required.
   * 
   * This object could represent a file which already exists on disk (eg a transpiled
   * source file), or something that is generated on the fly (such as a index.js), or
   * a compilation of files (eg a part)
   */


  qx.Class.define("qx.tool.compiler.targets.meta.AbstractJavascriptMeta", {
    extend: qx.core.Object,

    /**
     * Constructor
     * 
     * @param appMeta {qx.tool.compiler.targets.meta.ApplicationMeta}
     * @param filename {String} the sourcefile
     * @param originalSourceFile {String?} the URI to give to the source map
     */
    construct(appMeta, filename, originalSourceFile) {
      qx.core.Object.constructor.call(this);
      this._appMeta = appMeta;
      this.__filename = filename;
      this.__P_40_0 = originalSourceFile;
    },

    properties: {
      /** If true, this is generated on the fly and needs to be output */
      needsWriteToDisk: {
        init: false,
        check: "Boolean"
      }
    },
    members: {
      _appMeta: null,
      __filename: null,
      __P_40_0: null,
      __P_40_1: null,

      /**
       * Returns the ApplicationMeta
       *  
       * @return {ApplicationMeta}
       */
      getAppMeta() {
        return this._appMeta;
      },

      /**
       * Returns the filename for the output of this JS
       * 
       * @return {String}
       */
      getFilename() {
        return this.__filename;
      },

      wrap(jsMeta) {
        this.__P_40_1 = jsMeta;
      },

      getWrapper() {
        return this.__P_40_1;
      },

      unwrap() {
        if (this.__P_40_1) {
          return this.__P_40_1.unwrap();
        }

        return this;
      },

      /**
       * Writes the file to disk, if appropriate
       */
      async writeToDisk() {
        if (this.isNeedsWriteToDisk()) {
          let ws = new qx.tool.utils.Utils.LineCountingTransform();
          ws.pipe(fs.createWriteStream(this.__filename, "utf8"));
          await new Promise(async resolve => {
            ws.on("finish", resolve);
            await this.writeSourceCodeToStream(ws);
            ws.end();
          });
          let map = await this.getSourceMap();

          if (map) {
            await fs.writeFileAsync(this.__filename + ".map", JSON.stringify(map, null, 2), "utf8");
          }
        }
      },

      /**
       * Writes the source code as a stream, merging source files etc
       * as necessary
       * 
       * @param ws {WriteStream} the stream to write to
       */
      async writeSourceCodeToStream(ws) {
        throw new Error(`No implementation for ${this.classname}.writeSourceCodeToStream`);
      },

      /**
       * Reads the source map as a string
       */
      async getSourceMap() {
        return null;
      },

      /**
       * Utility method that merges multiple source maps
       */
      async _copySourceMap(jsMetas, lineOffsets) {
        let generator = new sourceMap.SourceMapGenerator({
          file: this.getFilename() + ".map"
        });

        for (let i = 0; i < jsMetas.length; i++) {
          let js = jsMetas[i];
          let lineOffset = lineOffsets[i];
          let data = await js.getSourceMap();

          if (data) {
            var map = new sourceMap.SourceMapConsumer(data);
            map.eachMapping(mapping => {
              mapping = {
                generated: {
                  line: mapping.generatedLine + lineOffset,
                  column: mapping.generatedColumn
                },
                original: {
                  line: mapping.originalLine || 1,
                  column: mapping.originalColumn || 1
                },
                source: mapping.source || js.getFilename()
              };
              generator.addMapping(mapping);
            });

            if (this._appMeta.getTarget().getSaveSourceInMap && this._appMeta.getTarget().getSaveSourceInMap()) {
              map.sources.forEach(source => generator.setSourceContent(source, map.sourceContentFor(source)));
            }
          }
        }

        return JSON.parse(generator.toString());
      }

    }
  });
  qx.tool.compiler.targets.meta.AbstractJavascriptMeta.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.tool.utils.Promisify": {
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.tool.compiler.targets.meta.AbstractJavascriptMeta": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);
  const fs = qx.tool.utils.Promisify.fs;

  const path = require("upath");
  /**
   * Represents a "index.js" that is generated as part of a compile 
   */


  qx.Class.define("qx.tool.compiler.targets.meta.BootJs", {
    extend: qx.tool.compiler.targets.meta.AbstractJavascriptMeta,

    construct(appMeta) {
      qx.tool.compiler.targets.meta.AbstractJavascriptMeta.constructor.call(this, appMeta, `${appMeta.getApplicationRoot()}index.js`);
      this.__P_42_0 = [];
      this.__P_42_1 = {};
    },

    properties: {
      needsWriteToDisk: {
        init: true,
        refine: true
      }
    },
    members: {
      __P_42_0: null,
      __P_42_2: null,

      /**
       * Adds Javascript which is to be added to the end of the index.js, just before the app
       * is finalised
       * 
       * @param jsMeta {AbstractJavascriptMeta} the jaavscript to add
       */
      addEmbeddedJs(jsMeta) {
        if (!this.__P_42_1[jsMeta.toHashCode()]) {
          this.__P_42_0.push(jsMeta);

          this.__P_42_1[jsMeta.toHashCode()] = jsMeta;
        }
      },

      /*
       * @Override
       */
      async writeSourceCodeToStream(ws) {
        let appMeta = this._appMeta;
        let application = appMeta.getApplication();
        let target = appMeta.getTarget();
        let appRootDir = appMeta.getApplicationRoot();
        let urisBefore = [];

        if (!target.isInlineExternalScripts()) {
          urisBefore = appMeta.getPreloads().urisBefore;
        } else {
          let inlines = [];
          urisBefore = appMeta.getPreloads().urisBefore.filter(uri => {
            // This is a http url, we cannot inline it
            if (uri.startsWith("__external__:")) {
              return true;
            }

            inlines.push(uri);
            return false;
          });

          for (let i = 0; i < inlines.length; i++) {
            let uri = inlines[i];
            let filename = path.join(target.getOutputDir(), "resources", uri);

            try {
              var data = await fs.readFileAsync(filename, {
                encoding: "utf-8"
              });
              ws.write(data);
              ws.write("\n");
            } catch (ex) {
              if (ex.code != "ENOENT") {
                throw ex;
              }
            }
          }
        }

        var MAP = {
          EnvSettings: appMeta.getEnvironment(),
          Libraries: appMeta.getLibraries().map(library => library.getNamespace()),
          SourceUri: appMeta.getSourceUri(),
          ResourceUri: appMeta.getResourceUri(),
          Resources: appMeta.getResources(),
          Translations: {
            "C": null
          },
          Locales: {
            "C": null
          },
          Parts: {},
          Packages: {},
          UrisBefore: urisBefore,
          CssBefore: appMeta.getPreloads().cssBefore,
          Boot: "boot",
          ClosureParts: {},
          BootIsInline: false,
          NoCacheParam: false,
          DecodeUrisPlug: undefined,
          BootPart: undefined,
          TranspiledPath: undefined,
          PreBootCode: appMeta.getPreBootCode()
        };
        appMeta.getParts().forEach(part => part.serializeInto(MAP.Parts));
        appMeta.getPackages().forEach(pkg => pkg.serializeInto(MAP.Packages));

        if (application.getType() !== "browser") {
          MAP.TranspiledPath = path.relative(appRootDir, path.join(target.getOutputDir(), "transpiled"));
        }

        appMeta.getTarget().getLocales().forEach(localeId => {
          MAP.Translations[localeId] = null;
          MAP.Locales[localeId] = null;
        });
        this.__P_42_2 = [];
        data = await fs.readFileAsync(application.getLoaderTemplate(), {
          encoding: "utf-8"
        });
        var lines = data.split("\n");

        for (let i = 0; i < lines.length; i++) {
          var line = lines[i];
          var match;

          while (match = line.match(/\%\{([^}]+)\}/)) {
            var keyword = match[1];
            var replace = "";

            if (keyword == "BootPart") {
              for (let j = 0; j < this.__P_42_0.length; j++) {
                this.__P_42_2.push(ws.getLineNumber());

                await this.__P_42_0[j].unwrap().writeSourceCodeToStream(ws);
                ws.write("\n");
              }
            } else if (MAP[keyword] !== undefined) {
              if (keyword == "PreBootCode") {
                replace = MAP[keyword];
              } else {
                replace = JSON.stringify(MAP[keyword], null, 2);
              }
            }

            var newLine = line.substring(0, match.index) + replace + line.substring(match.index + keyword.length + 3);
            line = newLine;
          }

          if (line.match(/^\s*delayDefer:\s*false\b/)) {
            line = line.replace(/false/, "true");
          }

          ws.write(line + "\n");
        }
      },

      /*
       * @Override
       */
      async getSourceMap() {
        if (this.__P_42_2 === null) {
          throw new Error(`Cannot get the source map for ${this} until the stream has been written`);
        }

        let res = await this._copySourceMap(this.__P_42_0, this.__P_42_2);

        let target = this._appMeta.getTarget();

        for (let i = 0; i < res.sources.length; i++) {
          res.sources[i] = path.relative("", res.sources[i]);
          let mapTo = target.getPathMapping(res.sources[i]);
          res.sources[i] = mapTo ? mapTo : res.sources[i];
        }

        return res;
      }

    }
  });
  qx.tool.compiler.targets.meta.BootJs.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.tool.utils.Promisify": {
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.tool.compiler.targets.meta.AbstractJavascriptMeta": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);
  const fs = qx.tool.utils.Promisify.fs;

  const path = require("upath");
  /**
   * Represents a "polyfill.js" that is generated as part of a compile 
   */


  qx.Class.define("qx.tool.compiler.targets.meta.PolyfillJs", {
    extend: qx.tool.compiler.targets.meta.AbstractJavascriptMeta,

    construct(appMeta) {
      qx.tool.compiler.targets.meta.AbstractJavascriptMeta.constructor.call(this, appMeta, `${appMeta.getApplicationRoot()}polyfill.js`);
    },

    properties: {
      needsWriteToDisk: {
        init: true,
        refine: true
      }
    },
    members: {
      /*
       * @Override
       */
      async writeSourceCodeToStream(ws) {
        const srcFilename = path.join(require.resolve("@babel/polyfill"), "../../dist/polyfill.js");
        let rs = fs.createReadStream(srcFilename, "utf8");
        await new Promise((resolve, reject) => {
          rs.on("end", resolve);
          rs.on("error", reject);
          rs.pipe(ws, {
            end: false
          });
        });
      },

      /*
       * @Override
       */
      async getSourceMap() {
        return null;
      }

    }
  });
  qx.tool.compiler.targets.meta.PolyfillJs.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.tool.utils.Promisify": {
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.tool.compiler.targets.meta.AbstractJavascriptMeta": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);
  const fs = qx.tool.utils.Promisify.fs;
  /**
   * An implementation of IJavascriptMeta for plain old javascript files
   */

  qx.Class.define("qx.tool.compiler.targets.meta.Javascript", {
    extend: qx.tool.compiler.targets.meta.AbstractJavascriptMeta,

    /**
     * Constructor
     * 
     * @param appMeta {qx.tool.compiler.targets.meta.ApplicationMeta}
     * @param filename {String} the sourcefile
     * @param originalSourceFile {String?} the URI to give to the source map
     */
    construct(appMeta, filename, originalSourceFile) {
      qx.tool.compiler.targets.meta.AbstractJavascriptMeta.constructor.call(this, appMeta, filename, originalSourceFile);
    },

    members: {
      /*
       * @Override
       */
      compile() {// Nothing
      },

      /*
       * @Override
       */
      async writeSourceCodeToStream(ws) {
        let rs = fs.createReadStream(this.getFilename(), "utf8");
        await new Promise((resolve, reject) => {
          rs.on("end", resolve);
          rs.on("error", reject);
          rs.pipe(ws, {
            end: false
          });
        });
      },

      /*
       * @Override
       */
      async getSourceMap() {
        if (!fs.existsSync(this.getFilename() + ".map")) {
          return null;
        }

        return await fs.readFileAsync(this.getFilename() + ".map", "utf8");
      }

    }
  });
  qx.tool.compiler.targets.meta.Javascript.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.tool.utils.LogManager": {
        "usage": "dynamic",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "require": true
      },
      "qx.tool.utils.Utils": {},
      "qx.lang.Type": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
   *
   *    qooxdoo-compiler - node.js based replacement for the Qooxdoo python
   *    toolchain
   *
   *    https://github.com/qooxdoo/qooxdoo-compiler
   *
   *    Copyright:
   *      2011-2017 Zenesis Limited, http://www.zenesis.com
   *
   *    License:
   *      MIT: https://opensource.org/licenses/MIT
   *
   *      This software is provided under the same licensing terms as Qooxdoo,
   *      please see the LICENSE file in the Qooxdoo project's top-level directory
   *      for details.
   *
   *    Authors:
   *      * John Spackman (john.spackman@zenesis.com, @johnspackman)
   *
   * *********************************************************************** */

  /* eslint no-inner-declarations: 0 */
  var fs = require("fs");

  var path = require("path");

  var xml2js = require("xml2js");

  const CLDR = require("cldr");

  const {
    promisify
  } = require("util");

  const readFile = promisify(fs.readFile);
  var log = qx.tool.utils.LogManager.createLog("cldr");
  qx.Class.define("qx.tool.compiler.app.Cldr", {
    extend: qx.core.Object,
    statics: {
      /**
       * Returns the parent locale for a given locale
       */
      getParentLocale: function (locale) {
        return CLDR.resolveParentLocaleId(locale.toLowerCase());
      },

      /**
       * Loads CLDR data from the Qx framework
       *
       * @param locale
       * @async
       */
      loadCLDR: function (locale) {
        var parser = new xml2js.Parser();
        let cldrPath = path.dirname(require.resolve("cldr"));
        const data_path = "../3rdparty/cldr/common/main";

        if (!cldrPath) {
          throw new Error("Cannot find cldr path");
        }

        log.debug("Loading CLDR " + cldrPath);
        return readFile(path.join(cldrPath, data_path, locale + ".xml"), {
          encoding: "utf-8"
        }).then(data => qx.tool.utils.Utils.promisifyThis(parser.parseString, parser, data)).then(src => {
          function find(arr, name, value, cb) {
            if (!arr) {
              return null;
            }

            for (var i = 0; i < arr.length; i++) {
              var row = arr[i];

              if (row["$"] && row["$"][name] == value) {
                if (typeof cb == "function") {
                  return cb(row);
                }

                return row;
              }
            }

            return null;
          }

          function get(path, node) {
            if (node === undefined) {
              node = src;
            }

            var segs = path.split(".");

            for (var i = 0; i < segs.length; i++) {
              var seg = segs[i];
              var pos = seg.indexOf("[");
              var index = null;

              if (pos > -1) {
                index = seg.substring(pos + 1, seg.length - 1);
                seg = seg.substring(0, pos);
              }

              var next = node[seg];

              if (!next) {
                return null;
              }

              if (index !== null) {
                if (!qx.lang.Type.isArray(next)) {
                  return null;
                }

                next = next[index];

                if (next === undefined) {
                  return null;
                }
              }

              node = next;
            }

            return node;
          }

          function getValue(path, node) {
            let result = get(path, node);

            if (result && typeof result != "string" && result["_"] !== undefined) {
              return result["_"];
            }

            return result;
          }

          var cal = find(get("ldml.dates[0].calendars[0].calendar"), "type", "gregorian");
          var cldr = {};
          cldr.alternateQuotationEnd = get("ldml.delimiters[0].alternateQuotationEnd[0]");
          cldr.alternateQuotationStart = get("ldml.delimiters[0].alternateQuotationStart[0]");
          cldr.quotationEnd = get("ldml.delimiters[0].quotationEnd[0]");
          cldr.quotationStart = get("ldml.delimiters[0].quotationStart[0]");

          function getText(row) {
            if (typeof row == "string") {
              return row;
            }

            if (row && row["_"] !== undefined) {
              return row["_"];
            }

            return "";
          }

          function getDateFormatPattern(row) {
            return row.dateFormat[0].pattern[0];
          }

          if (cal !== null) {
            find(get("dayPeriods[0].dayPeriodContext[0].dayPeriodWidth", cal), "type", "wide", function (row) {
              cldr.cldr_am = find(row.dayPeriod, "type", "am", getText);
              cldr.cldr_pm = find(row.dayPeriod, "type", "pm", getText); // "PM";
            });
            var dateFormatLength = get("dateFormats[0].dateFormatLength", cal);
            var dateFormatItem = get("dateTimeFormats[0].availableFormats[0].dateFormatItem", cal);
            cldr.cldr_date_format_full = find(dateFormatLength, "type", "full", getDateFormatPattern); // "EEEE, MMMM d, y";

            cldr.cldr_date_format_long = find(dateFormatLength, "type", "long", getDateFormatPattern); // "MMMM d, y";

            cldr.cldr_date_format_medium = find(dateFormatLength, "type", "medium", getDateFormatPattern); // "MMM d, y";

            cldr.cldr_date_format_short = find(dateFormatLength, "type", "short", getDateFormatPattern); // "M/d/yy";

            cldr.cldr_date_time_format_Ed = find(dateFormatItem, "id", "Ed", getText); // "d E";

            cldr.cldr_date_time_format_Hm = find(dateFormatItem, "id", "Hm", getText); // "HH:mm";

            cldr.cldr_date_time_format_Hms = find(dateFormatItem, "id", "Hms", getText); // "HH:mm:ss";

            cldr.cldr_date_time_format_M = find(dateFormatItem, "id", "M", getText); // "L";

            cldr.cldr_date_time_format_MEd = find(dateFormatItem, "id", "MEd", getText); // "E, M/d";

            cldr.cldr_date_time_format_MMM = find(dateFormatItem, "id", "MMM", getText); // "LLL";

            cldr.cldr_date_time_format_MMMEd = find(dateFormatItem, "id", "MMMEd", getText); // "E, MMM d";

            cldr.cldr_date_time_format_MMMd = find(dateFormatItem, "id", "MMMd", getText); // "MMM d";

            cldr.cldr_date_time_format_Md = find(dateFormatItem, "id", "Md", getText); // "M/d";

            cldr.cldr_date_time_format_d = find(dateFormatItem, "id", "d", getText); // "d";

            cldr.cldr_date_time_format_hm = find(dateFormatItem, "id", "hm", getText); // "h:mm a";

            cldr.cldr_date_time_format_hms = find(dateFormatItem, "id", "hms", getText); // "h:mm:ss a";

            cldr.cldr_date_time_format_ms = find(dateFormatItem, "id", "ms", getText); // "mm:ss";

            cldr.cldr_date_time_format_y = find(dateFormatItem, "id", "y", getText); // "y";

            cldr.cldr_date_time_format_yM = find(dateFormatItem, "id", "yM", getText); // "M/y";

            cldr.cldr_date_time_format_yMEd = find(dateFormatItem, "id", "yMEd", getText); // "E, M/d/y";

            cldr.cldr_date_time_format_yMMM = find(dateFormatItem, "id", "yMMM", getText); // "MMM y";

            cldr.cldr_date_time_format_yMMMEd = find(dateFormatItem, "id", "yMMMEd", getText); // "E, MMM d, y";

            cldr.cldr_date_time_format_yMMMd = find(dateFormatItem, "id", "yMMMd", getText); // "MMM d, y";

            cldr.cldr_date_time_format_yMd = find(dateFormatItem, "id", "yMd", getText); // "M/d/y";

            cldr.cldr_date_time_format_yQ = find(dateFormatItem, "id", "yQ", getText); // "Q y";

            cldr.cldr_date_time_format_yQQQ = find(dateFormatItem, "id", "yQQQ", getText); // "QQQ y";

            var dayContext = get("days[0].dayContext", cal);
            find(dayContext, "type", "format", function (row) {
              find(row.dayWidth, "type", "abbreviated", function (row) {
                cldr.cldr_day_format_abbreviated_fri = find(row.day, "type", "fri", getText); // "Fri";

                cldr.cldr_day_format_abbreviated_mon = find(row.day, "type", "mon", getText); // "Mon";

                cldr.cldr_day_format_abbreviated_sat = find(row.day, "type", "sat", getText); // "Sat";

                cldr.cldr_day_format_abbreviated_sun = find(row.day, "type", "sun", getText); // "Sun";

                cldr.cldr_day_format_abbreviated_thu = find(row.day, "type", "thu", getText); // "Thu";

                cldr.cldr_day_format_abbreviated_tue = find(row.day, "type", "tue", getText); // "Tue";

                cldr.cldr_day_format_abbreviated_wed = find(row.day, "type", "wed", getText); // "Wed";
              });
            });
            find(dayContext, "type", "format", function (row) {
              find(row.dayWidth, "type", "wide", function (row) {
                cldr.cldr_day_format_wide_fri = find(row.day, "type", "fri", getText); // "Friday";

                cldr.cldr_day_format_wide_mon = find(row.day, "type", "mon", getText); // "Monday";

                cldr.cldr_day_format_wide_sat = find(row.day, "type", "sat", getText); // "Saturday";

                cldr.cldr_day_format_wide_sun = find(row.day, "type", "sun", getText); // "Sunday";

                cldr.cldr_day_format_wide_thu = find(row.day, "type", "thu", getText); // "Thursday";

                cldr.cldr_day_format_wide_tue = find(row.day, "type", "tue", getText); // "Tuesday";

                cldr.cldr_day_format_wide_wed = find(row.day, "type", "wed", getText); // "Wednesday";
              });
            });
            find(dayContext, "type", "stand-alone", function (row) {
              cldr["cldr_day_stand-alone_narrow_fri"] = find(row.dayWidth[0].day, "type", "fri", getText); // "F";

              cldr["cldr_day_stand-alone_narrow_mon"] = find(row.dayWidth[0].day, "type", "mon", getText); // "M";

              cldr["cldr_day_stand-alone_narrow_sat"] = find(row.dayWidth[0].day, "type", "sat", getText); // "S";

              cldr["cldr_day_stand-alone_narrow_sun"] = find(row.dayWidth[0].day, "type", "sun", getText); // "S";

              cldr["cldr_day_stand-alone_narrow_thu"] = find(row.dayWidth[0].day, "type", "thu", getText); // "T";

              cldr["cldr_day_stand-alone_narrow_tue"] = find(row.dayWidth[0].day, "type", "tue", getText); // "T";

              cldr["cldr_day_stand-alone_narrow_wed"] = find(row.dayWidth[0].day, "type", "wed", getText); // "W";
            });
            var monthContext = get("months[0].monthContext", cal);
            find(monthContext, "type", "format", function (row) {
              find(row.monthWidth, "type", "abbreviated", function (row) {
                for (var i = 0; i < row.month.length; i++) {
                  var m = row.month[i];
                  cldr["cldr_month_format_abbreviated_" + m["$"].type] = getText(m);
                }
              });
            });
            find(monthContext, "type", "format", function (row) {
              find(row.monthWidth, "type", "wide", function (row) {
                for (var i = 0; i < row.month.length; i++) {
                  var m = row.month[i];
                  cldr["cldr_month_format_wide_" + m["$"].type] = getText(m);
                }
              });
            });
            find(monthContext, "type", "stand-alone", function (row) {
              for (var i = 0; i < row.monthWidth[0].month.length; i++) {
                var m = row.monthWidth[0].month[i];
                cldr["cldr_month_stand-alone_narrow_" + m["$"].type] = getText(m);
              }
            });

            function getTimeFormatPattern(row) {
              return row.timeFormat.pattern;
            }

            var timeFormatLength = get("timeFormats[0].timeFormatLength", cal);
            cldr.cldr_time_format_full = find(timeFormatLength, "type", "full", getTimeFormatPattern); // "h:mm:ss a zzzz";

            cldr.cldr_time_format_long = find(timeFormatLength, "type", "long", getTimeFormatPattern); // "h:mm:ss a z";

            cldr.cldr_time_format_medium = find(timeFormatLength, "type", "medium", getTimeFormatPattern); // "h:mm:ss a";

            cldr.cldr_time_format_short = find(timeFormatLength, "type", "short", getTimeFormatPattern); // "h:mm a";
          }

          var numberingSystem = getText(get("ldml.numbers[0].defaultNumberingSystem[0]"));

          if (numberingSystem) {
            find(get("ldml.numbers[0].symbols"), "numberSystem", numberingSystem, function (row) {
              cldr.cldr_number_decimal_separator = row.decimal[0];
              cldr.cldr_number_group_separator = row.group[0];
            });
          } else {
            cldr.cldr_number_decimal_separator = getValue("ldml.numbers[0].symbols[0].decimal[0]"); // ".";

            cldr.cldr_number_group_separator = getValue("ldml.numbers[0].symbols[0].group[0]"); // ",";
          }

          cldr.cldr_number_percent_format = getValue("ldml.numbers[0].percentFormats[0].percentFormatLength[0].percentFormat[0].pattern[0]"); // "#,##0%";

          function getDisplayName(row) {
            if (qx.lang.Type.isArray(row.displayName)) {
              return row.displayName.map(elem => getText(elem));
            }

            return getText(row.displayName);
          }

          var field = get("ldml.dates[0].fields[0].field");
          cldr.day = find(field, "type", "day", getDisplayName); // "Day"

          cldr.dayperiod = find(field, "type", "dayperiod", getDisplayName); // "AM/PM";

          cldr.era = find(field, "type", "era", getDisplayName); // "Era";

          cldr.hour = find(field, "type", "hour", getDisplayName); // "Hour";

          cldr.minute = find(field, "type", "minute", getDisplayName); // "Minute";

          cldr.month = find(field, "type", "month", getDisplayName); // "Month";

          cldr.second = find(field, "type", "second", getDisplayName); // "Second";

          cldr.week = find(field, "type", "week", getDisplayName); // "Week";

          cldr.weekday = find(field, "type", "weekday", getDisplayName); // "Day of the Week";

          cldr.year = find(field, "type", "year", getDisplayName); // "Year";

          cldr.zone = find(field, "type", "zone", getDisplayName); // "Time Zone";

          return cldr;
        });
      }
    }
  });
  qx.tool.compiler.app.Cldr.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.tool.utils.Promisify": {
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.tool.compiler.targets.meta.AbstractJavascriptMeta": {
        "construct": true,
        "require": true
      },
      "qx.tool.utils.Utils": {},
      "qx.tool.utils.files.Utils": {},
      "qx.tool.compiler.Console": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);
  const fs = qx.tool.utils.Promisify.fs;

  const path = require("upath");

  const UglifyJS = require("uglify-es");

  qx.Class.define("qx.tool.compiler.targets.meta.Uglify", {
    extend: qx.tool.compiler.targets.meta.AbstractJavascriptMeta,

    /**
     * Constructor
     * 
     * @param appMeta {qx.tool.compiler.targets.meta.ApplicationMeta}
     * @param jsMeta {AbstractJavascriptMeta} the source
     */
    construct(appMeta, jsMeta) {
      qx.tool.compiler.targets.meta.AbstractJavascriptMeta.constructor.call(this, appMeta, jsMeta.getFilename());
      this.__P_46_0 = jsMeta;
    },

    properties: {
      needsWriteToDisk: {
        init: true,
        refine: true
      }
    },
    members: {
      __P_46_0: null,

      /*
       * @Override
       */
      async writeSourceCodeToStream(ws) {
        var uglifyOpts = {
          compress: {
            sequences: false
          },
          output: {
            comments: "some"
          }
        };

        switch (this._appMeta.getTarget().getMinify()) {
          case "off":
            return;

          case "minify":
            uglifyOpts.mangle = false;
            break;

          case "beautify":
            uglifyOpts.mangle = false;
            uglifyOpts.output.beautify = true;
            break;

          case "mangle":
            uglifyOpts.mangle = true;
            break;
        }

        var application = this._appMeta.getApplication();

        var outJsFilename = this.__P_46_0.getFilename();

        let baseJsFilename = path.basename(outJsFilename);
        let inSourceCode = await (async () => {
          let ss = new qx.tool.utils.Utils.ToStringWriteStream();
          let ws = new qx.tool.utils.Utils.LineCountingTransform();
          ws.pipe(ss);
          await new Promise(async resolve => {
            ws.on("finish", resolve);
            await this.__P_46_0.writeSourceCodeToStream(ws);
            ws.end();
          });
          return ss.toString();
        })();
        await qx.tool.utils.files.Utils.safeUnlink(outJsFilename + ".unminified");
        await qx.tool.utils.files.Utils.safeRename(outJsFilename, outJsFilename + ".unminified");
        let inSourceMap = await this.__P_46_0.getSourceMap();
        await qx.tool.utils.files.Utils.safeUnlink(outJsFilename + ".unminified.map");
        await qx.tool.utils.files.Utils.safeRename(outJsFilename + ".map", outJsFilename + ".unminified.map");
        this.fireDataEvent("minifyingApplication", {
          application: application,
          filename: baseJsFilename
        });
        uglifyOpts.sourceMap = {
          content: inSourceMap,
          url: baseJsFilename + ".map",
          includeSources: true
        };
        var result = UglifyJS.minify(inSourceCode, uglifyOpts);
        var err = result.error;

        if (err) {
          if (err.name == "SyntaxError") {
            qx.tool.compiler.Console.print("qx.tool.compiler.build.uglifyParseError", err.line, err.col, err.message, baseJsFilename);
          }

          throw new Error("UglifyJS failed to minimise: " + (err.message || err));
        }

        await fs.writeFileAsync(outJsFilename, result.code, {
          encoding: "utf8"
        });

        if (!this._appMeta.getTarget().isSaveUnminified()) {
          await qx.tool.utils.files.Utils.safeUnlink(outJsFilename + ".unminified");
          await qx.tool.utils.files.Utils.safeUnlink(outJsFilename + ".unminified.map");
        }

        await fs.writeFileAsync(outJsFilename + ".map", result.map, {
          encoding: "utf8"
        });
        this.fireDataEvent("minifiedApplication", {
          application: application,
          filename: baseJsFilename
        });
      }

    }
  });
  qx.tool.compiler.targets.meta.Uglify.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.tool.utils.LogManager": {
        "usage": "dynamic",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.tool.compiler.Console": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
   *
   *    qooxdoo-compiler - node.js based replacement for the Qooxdoo python
   *    toolchain
   *
   *    https://github.com/qooxdoo/qooxdoo-compiler
   *
   *    Copyright:
   *      2017 GONICUS GmbH, http://www.gonicus.de
   *
   *    License:
   *      MIT: https://opensource.org/licenses/MIT
   *
   *      This software is provided under the same licensing terms as Qooxdoo,
   *      please see the LICENSE file in the Qooxdoo project's top-level directory
   *      for details.
   *
   *    Authors:
   *      * Cajus Pollmeier (pollmeier@gonicus.de, @cajus)
   *
   * *********************************************************************** */
  const fs = require("fs");

  const path = require("path");

  const tmp = require("tmp");

  const http = require("http");

  const fontkit = require("fontkit");

  var log = qx.tool.utils.LogManager.createLog("font");
  /**
   * Represents a WebFont provided by a Library
   */

  qx.Class.define("qx.tool.compiler.app.WebFont", {
    extend: qx.core.Object,
    construct: function (library) {
      qx.core.Object.constructor.call(this);
      this.__P_28_0 = library;
    },
    properties: {
      /** The name of the webfont */
      name: {
        check: "String"
      },

      /** The default size */
      defaultSize: {
        check: "Integer",
        init: 40
      },

      /**
       * Optional mapping filename. The path is relative to the location of the
       * `Manifest.json` file. The mapping file is in json format and should contain
       * a map of icon name to code point in hex:
       * `{ "my_icon": "ef99", "my_other_icon": "483c"}`
       */
      mapping: {
        init: null,
        nullable: true,
        check: "String"
      },

      /**
       * Characters that are used to test if the font has loaded properly. These
       * default to "WEei" in `qx.bom.webfont.Validator` and can be overridden
       * for certain cases like icon fonts that do not provide the predefined
       * characters.
       */
      comparisonString: {
        init: null,
        nullable: true,
        check: "String"
      },

      /** {String[]} Resources that make up the font; an array of Strings, each of which can be a URL or a local file */
      resources: {
        check: "Array"
      }
    },
    members: {
      __P_28_0: null,
      __P_28_1: null,

      /**
       * Helper which triggers a local font analyze run.
       *
       * @param filename {String} Filename for the local font
       * @return {Promise}
       */
      _loadLocalFont: function (filename) {
        return new Promise((resolve, reject) => {
          let fontpath = path.join(this.__P_28_0.getRootDir(), path.join(this.__P_28_0.getResourcePath(), filename));

          this.__P_28_2(fontpath, resolve, reject);
        });
      },

      /**
       * Helper which loads a remote font to analyze the result.
       *
       * @param url {String} URL for the font download
       * @return {Promise}
       */
      _loadRemoteFont: function (url) {
        return new Promise(function (resolve, reject) {
          http.get(url, function (res) {
            let error;
            const {
              statusCode
            } = res;
            const contentType = res.headers["content-type"];

            if (statusCode !== 200) {
              error = new Error(`Request Failed.\nStatus Code: ${statusCode}`);
            } else if (!/^font\/(ttf|svg|eot|woff|woff2)$/.test(contentType)) {
              error = new Error("Invalid content-type.\n" + `Expected font/ttf, font/svg, font/eot, font/woff or font/woff2 but received ${contentType}`);
            }

            if (error) {
              res.resume();
              reject(error);
              return;
            }

            tmp.tmpName(function _tempNameGenerated(err, tmpFilename) {
              if (err) {
                reject(err);
                return;
              }

              let outFile = fs.createWriteStream(tmpFilename);
              outFile.on("close", function () {
                this.__P_28_2(tmpFilename, resolve, reject);

                fs.unlink(tmpFilename);
              }.bind(this));
              res.on("data", chunk => {
                outFile.write(chunk);
              });
              res.on("end", function () {
                outFile.end();
              });
            }.bind(this));
          }.bind(this)).on("error", e => {
            reject(e);
          });
        }.bind(this));
      },

      /**
       * Common code to extract the desired font information from a font file
       * on disk. It resolves the promises given by the calling stub (remote or
       * local font retrieval).
       *
       * @param filename {String} Path to font file
       * @param resolve {Function} External promise resolve
       * @param reject {Function} External promise reject
       */
      __P_28_2: function (filename, resolve, reject) {
        fontkit.open(filename, null, function (err, font) {
          if (err) {
            reject(err);
            return;
          }

          let resources = {}; // If we have a mapping file, take this information instead
          // of anaylzing the font.

          if (this.getMapping()) {
            let mapPath = path.join(this.__P_28_0.getRootDir(), path.join(this.__P_28_0.getResourcePath(), this.getMapping()));
            fs.readFile(mapPath, {
              encoding: "utf-8"
            }, (err, data) => {
              if (err) {
                log.error(`Cannot read mapping file '${mapPath}': ${err.code}`);
                reject(err);
                return;
              }

              let map = JSON.parse(data);
              Object.keys(map).forEach(key => {
                let codePoint = parseInt(map[key], 16);
                let glyph = font.glyphForCodePoint(codePoint);

                if (!glyph.id) {
                  qx.tool.compiler.Console.log(`WARN: no glyph found for ${font} ${key}: ${codePoint}`);
                  return;
                }

                resources["@" + this.getName() + "/" + key] = [Math.ceil(this.getDefaultSize() * glyph.advanceWidth / glyph.advanceHeight), // width
                this.getDefaultSize(), // height
                codePoint];
              }, this);
              resolve(resources);
              return;
            });
            return;
          } // some IconFonts (MaterialIcons for example) use ligatures
          // to name their icons. This code extracts the ligatures
          // hat tip to Jossef Harush https://stackoverflow.com/questions/54721774/extracting-ttf-font-ligature-mappings/54728584


          let ligatureName = {};
          let lookupList = font.GSUB.lookupList.toArray();
          let lookupListIndexes = font.GSUB.featureList[0].feature.lookupListIndexes;
          lookupListIndexes.forEach(index => {
            let subTable = lookupList[index].subTables[0];
            let leadingCharacters = [];
            subTable.coverage.rangeRecords.forEach(coverage => {
              for (let i = coverage.start; i <= coverage.end; i++) {
                let character = font.stringsForGlyph(i)[0];
                leadingCharacters.push(character);
              }
            });
            let ligatureSets = subTable.ligatureSets.toArray();
            ligatureSets.forEach((ligatureSet, ligatureSetIndex) => {
              let leadingCharacter = leadingCharacters[ligatureSetIndex];
              ligatureSet.forEach(ligature => {
                let character = font.stringsForGlyph(ligature.glyph)[0];

                if (!character) {
                  // qx.tool.compiler.Console.log(`WARN: ${this.getName()} no character ${ligature}`);
                  return;
                }

                let ligatureText = leadingCharacter + ligature.components.map(x => font.stringsForGlyph(x)[0]).join("");
                ligatureName[character.charCodeAt(0).toString(16)] = ligatureText;
              });
            });
          });
          font.characterSet.forEach(codePoint => {
            let glyph = font.glyphForCodePoint(codePoint);
            let gName = glyph.name || ligatureName[codePoint.toString(16)];

            if (!gName) {
              return;
            }

            if (glyph.path.commands.length > 0 || glyph.layers) {
              resources["@" + this.getName() + "/" + gName] = [Math.ceil(this.getDefaultSize() * glyph.advanceWidth / glyph.advanceHeight), // width
              this.getDefaultSize(), // height
              codePoint];
            }
          }, this);
          resolve(resources);
        }.bind(this));
      },

      /**
       * Return bootstrap code that is executed before the Application starts.
       *
       * @param target  {qx.tool.compiler.targets.Target} the target
       * @param application  {qx.tool.compiler.app.Application} the application being built
       * @param initial {Boolean} true if this is the first pass
       * @return {String}
       */
      getBootstrapCode: function (target, application, initial) {
        let res = "";

        if (initial) {
          res = "qx.$$fontBootstrap={};\n";
        }

        let font = {
          size: this.getDefaultSize(),
          lineHeight: 1,
          family: [this.getName()],
          sources: [{
            family: this.getName(),
            source: this.getResources()
          }]
        };

        if (this.getComparisonString()) {
          font.comparisonString = this.getComparisonString();
        }

        return res += "qx.$$fontBootstrap['" + this.getName() + "']=" + JSON.stringify(font) + ";";
      },

      /**
       * Called by {Target} to compile the fonts, called once per application build
       * (NOTE:: right now, this is called for each application - that is soon to be fixed)
       *
       * @param target  {qx.tool.compiler.targets.Target} the target
       * @return {Promise}
       */
      generateForTarget: function (target) {
        return new Promise((resolve, reject) => {
          for (let resource of this.getResources()) {
            // Search for the first supported extension
            let basename = resource.match(/^.*[/\\]([^/\\\?#]+).*$/)[1]; // fontkit knows about these font formats

            if (!basename.match(/\.(ttf|otf|woff|woff2)$/)) {
              continue;
            } // We support http/https and local files, check for URLs
            // first.


            if (resource.match(/^https?:\/\//)) {
              this._loadRemoteFont(resource).then(data => {
                this.__P_28_1 = data;
                resolve();
              }).catch(err => {
                reject(err);
              });

              return;
            } // handle local file


            this._loadLocalFont(resource).then(data => {
              this.__P_28_1 = data;
              resolve();
            }).catch(err => {
              reject(err);
            });

            return;
          }

          reject(`Failed to load/validate FontMap for webfont (expected ttf, otf, woff or woff2) ${this.getName()}`);
        });
      },

      /**
       * Called by Target to add fonts to an application
       *
       * @param target  {qx.tool.compiler.targets.Target} the target
       * @param application  {qx.tool.compiler.app.Application} the application being built
       * @return {Promise}
       */
      generateForApplication: async function (target, application) {
        return this.__P_28_1 || null;
      },

      /**
       * Returns a string representation of this for debugging
       *
       * @return {String} the name or resource of this font
       */
      toString: function () {
        var str = this.getName();

        if (!str) {
          str = JSON.stringify(this.getResources());
        }

        return str;
      }
    }
  });
  qx.tool.compiler.app.WebFont.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.tool.utils.LogManager": {
        "usage": "dynamic",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.tool.utils.IndexedArray": {
        "construct": true
      },
      "qx.tool.compiler.resources.Manager": {},
      "qx.tool.utils.Json": {},
      "qx.tool.utils.Promisify": {},
      "qx.tool.compiler.Console": {},
      "qx.tool.compiler.jsdoc.Parser": {},
      "qx.lang.Type": {},
      "qx.lang.String": {},
      "qx.lang.Array": {},
      "qx.tool.compiler.ClassFile": {},
      "qx.tool.utils.files.Utils": {},
      "qx.tool.compiler.app.Cldr": {},
      "qx.tool.compiler.app.Translation": {},
      "qx.Promise": {},
      "qx.tool.compiler.Version": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
   *
   *    qooxdoo-compiler - node.js based replacement for the Qooxdoo python
   *    toolchain
   *
   *    https://github.com/qooxdoo/qooxdoo-compiler
   *
   *    Copyright:
   *      2011-2017 Zenesis Limited, http://www.zenesis.com
   *
   *    License:
   *      MIT: https://opensource.org/licenses/MIT
   *
   *      This software is provided under the same licensing terms as Qooxdoo,
   *      please see the LICENSE file in the Qooxdoo project's top-level directory
   *      for details.
   *
   *    Authors:
   *      * John Spackman (john.spackman@zenesis.com, @johnspackman)
   *
   * *********************************************************************** */

  /* eslint no-nested-ternary: 0 */

  /* eslint no-inner-declarations: 0 */
  var fs = require("fs");

  var async = require("async");

  var jsonlint = require("jsonlint");

  var hash = require("object-hash");

  const {
    promisify
  } = require("util");

  const readFile = promisify(fs.readFile);
  const writeFile = promisify(fs.writeFile);
  var log = qx.tool.utils.LogManager.createLog("analyser");
  /**
   * Entry point for analysing source files; maintains a list of known libraries
   * (eg a qooxdoo application, packages, qooxdoo framework etc.), known classes
   * (and the files and library in which the class is defined, and environment
   * checks which have been used (env checks imply a dependency).
   */

  qx.Class.define("qx.tool.compiler.Analyser", {
    extend: qx.core.Object,

    /**
     * Constructor
     *
     * @param dbFilename
     *          {String} the name of the database, defaults to "db.json"
     */
    construct: function (dbFilename) {
      qx.core.Object.constructor.call(this);
      this.__P_21_0 = dbFilename || "db.json";
      this.__P_21_1 = [];
      this.__P_21_2 = {};
      this.__P_21_3 = new qx.tool.utils.IndexedArray();
      this.__P_21_4 = {};
      this.__P_21_5 = {};
      this.__P_21_6 = {};
      this.__P_21_7 = {};
    },
    properties: {
      /** Output directory for the compiled application */
      outputDir: {
        nullable: true,
        check: "String"
      },

      /** Whether to preserve line numbers */
      trackLineNumbers: {
        check: "Boolean",
        init: false,
        nullable: false
      },

      /** Whether to process resources */
      processResources: {
        init: true,
        nullable: false,
        check: "Boolean"
      },

      /** Whether to add `$$createdAt` to new objects */
      addCreatedAt: {
        init: false,
        nullable: false,
        check: "Boolean"
      },

      /** Environment during compile time */
      environment: {
        init: null,
        check: "Map",
        apply: "_applyEnvironment"
      },

      /** configuration of babel */
      babelConfig: {
        init: null,
        nullable: true,
        check: "Object"
      },

      /** list of global ignores */
      ignores: {
        init: [],
        nullable: false,
        check: "Array"
      },

      /** list of global symbols */
      globalSymbols: {
        init: [],
        nullable: false,
        check: "Array"
      },

      /** Whether and how to mangle private identifiers */
      manglePrivates: {
        init: "readable",
        check: ["off", "readable", "unreadable"]
      },

      /** Whether to write line numbers to .po files */
      writePoLineNumbers: {
        init: false,
        check: "Boolean"
      }
    },
    events: {
      /**
       * Fired when a class is about to be compiled; data is a map:
       *
       * dbClassInfo: {Object} the newly populated class info
       * oldDbClassInfo: {Object} the previous populated class info
       * classFile - {ClassFile} the qx.tool.compiler.ClassFile instance
       */
      "compilingClass": "qx.event.type.Data",

      /**
       * Fired when a class is compiled; data is a map:
       * dbClassInfo: {Object} the newly populated class info
       * oldDbClassInfo: {Object} the previous populated class info
       * classFile - {ClassFile} the qx.tool.compiler.ClassFile instance
       */
      "compiledClass": "qx.event.type.Data",

      /**
       * Fired when a class is already compiled (but needed for compilation); data is a map:
       * className: {String}
       * dbClassInfo: {Object} the newly populated class info
       */
      "alreadyCompiledClass": "qx.event.type.Data",

      /**
       * Fired when the database is been saved
       * database: {Object} the database to save
       */
      "saveDatabase": "qx.event.type.Data"
    },
    members: {
      __P_21_8: false,
      __P_21_9: null,
      __P_21_0: null,
      __P_21_10: null,

      /** {Library[]} All libraries */
      __P_21_1: null,

      /** {Map{String,Library}} Lookup of libraries, indexed by namespace */
      __P_21_2: null,
      __P_21_11: null,
      __P_21_3: null,
      __P_21_4: null,
      __P_21_5: null,
      __P_21_6: null,
      __P_21_7: null,
      __P_21_12: false,
      __P_21_13: null,
      __P_21_14: null,

      /**
       * Opens the analyser, loads database etc
       *
       * @async
       */
      open: function () {
        var p;

        if (!this.__P_21_8) {
          this.__P_21_8 = true;
          var resManager = null;

          if (this.isProcessResources()) {
            resManager = new qx.tool.compiler.resources.Manager(this);
          }

          this.__P_21_9 = resManager;
          p = Promise.all([this.loadDatabase(), resManager && resManager.loadDatabase()]);
        } else {
          p = Promise.resolve();
        }

        return p;
      },

      /**
       * Scans the source files for javascript class and resource references and
       * calculates the dependency tree
       *
       * @param cb
       */
      initialScan: function (cb) {
        var t = this;

        if (!this.__P_21_10) {
          this.__P_21_10 = {};
        }

        log.debug("Scanning source code");
        async.parallel([// Load Resources
        function (cb) {
          if (!t.__P_21_9) {
            cb(null);
            return;
          }

          t.__P_21_9.findAllResources().then(() => cb()).catch(cb);
        }, // Find all classes
        function (cb) {
          async.each(t.__P_21_1, function (library, cb) {
            library.scanForClasses(err => {
              log.debug("Finished scanning for " + library.getNamespace());
              cb(err);
            });
          }, err => {
            log.debug("Finished scanning for all libraries");
            cb(err);
          });
        }], function (err) {
          log.debug("processed source and resources");
          cb(err);
        });
      },

      /**
       * Loads the database if available
       */
      async loadDatabase() {
        this.__P_21_10 = (await qx.tool.utils.Json.loadJsonAsync(this.getDbFilename())) || {};
      },

      /**
       * Resets the database
       *
       * @return {Promise}
       */
      resetDatabase: function () {
        this.__P_21_10 = null;

        if (this.__P_21_9) {
          this.__P_21_9.dispose();

          this.__P_21_9 = null;
        }

        this.__P_21_8 = false;
        return this.open();
      },

      /**
       * Saves the database
       */
      async saveDatabase() {
        log.debug("saving generator database");
        await this.fireDataEventAsync("saveDatabase", this.__P_21_10);
        await qx.tool.utils.Json.saveJsonAsync(this.getDbFilename(), this.__P_21_10).then(() => this.__P_21_9 && this.__P_21_9.saveDatabase());
      },

      /**
       * Returns the loaded database
       *
       * @returns
       */
      getDatabase: function () {
        return this.__P_21_10;
      },

      /**
       * Parses all the source files recursively until all classes and all
       * dependent classes are loaded
       */
      async analyseClasses() {
        var t = this;

        if (!this.__P_21_10) {
          this.__P_21_10 = {};
        }

        var db = this.__P_21_10;
        var metaWrittenLog = {};
        var compiledClasses = {};
        var metaFixupDescendants = {};
        var listenerId = this.addListener("compiledClass", function (evt) {
          var data = evt.getData();

          if (data.oldDbClassInfo) {
            if (data.oldDbClassInfo.extends) {
              metaFixupDescendants[data.oldDbClassInfo.extends] = true;
            }

            if (data.oldDbClassInfo.implement) {
              data.oldDbClassInfo.implement.forEach(name => metaFixupDescendants[name] = true);
            }

            if (data.oldDbClassInfo.include) {
              data.oldDbClassInfo.include.forEach(name => metaFixupDescendants[name] = true);
            }
          }

          if (data.dbClassInfo.extends) {
            metaFixupDescendants[data.dbClassInfo.extends] = true;
          }

          if (data.dbClassInfo.implement) {
            data.dbClassInfo.implement.forEach(name => metaFixupDescendants[name] = true);
          }

          if (data.dbClassInfo.include) {
            data.dbClassInfo.include.forEach(name => metaFixupDescendants[name] = true);
          }

          compiledClasses[data.classFile.getClassName()] = data;
        }); // Note that it is important to pre-load the classes in all libraries - this is because
        //  Babel plugins MUST be synchronous (ie cannot afford an async lookup of files on disk
        //  in mid parse)

        await qx.tool.utils.Promisify.map(this.__P_21_1, async (library) => qx.tool.utils.Promisify.call(cb => library.scanForClasses(cb)));

        var classes = t.__P_21_11 = t.__P_21_3.toArray();

        function getConstructDependencies(className) {
          var deps = [];
          var info = t.__P_21_10.classInfo[className];

          if (info.dependsOn) {
            for (var depName in info.dependsOn) {
              if (info.dependsOn[depName].construct) {
                deps.push(depName);
              }
            }
          }

          return deps;
        }

        function getIndirectLoadDependencies(className) {
          var deps = [];
          var info = t.__P_21_10.classInfo[className];

          if (info && info.dependsOn) {
            for (var depName in info.dependsOn) {
              if (info.dependsOn[depName].load) {
                getConstructDependencies(depName).forEach(function (className) {
                  deps.push(className);
                });
              }
            }
          }

          return deps;
        }

        for (var classIndex = 0; classIndex < classes.length; classIndex++) {
          try {
            let dbClassInfo = await qx.tool.utils.Promisify.call(cb => t.getClassInfo(classes[classIndex], cb));

            if (dbClassInfo) {
              var deps = dbClassInfo.dependsOn;

              for (var depName in deps) {
                t._addRequiredClass(depName);
              }
            }
          } catch (err) {
            if (err.code === "ENOCLASSFILE") {
              qx.tool.compiler.Console.error(err.message);
            } else {
              throw err;
            }
          }
        }

        classes.forEach(function (className) {
          var info = t.__P_21_10.classInfo[className];
          var deps = getIndirectLoadDependencies(className);
          deps.forEach(function (depName) {
            if (!info.dependsOn) {
              info.dependsOn = {};
            }

            if (!info.dependsOn[depName]) {
              info.dependsOn[depName] = {};
            }

            info.dependsOn[depName].load = true;
          });
        });
        t.removeListenerById(listenerId);

        function fixupMetaData(classname, meta) {
          function fixupEntry(obj) {
            if (obj && obj.jsdoc) {
              qx.tool.compiler.jsdoc.Parser.parseJsDoc(obj.jsdoc, classname, t);
            }
          }

          function fixupSection(sectionName) {
            var section = meta[sectionName];

            if (section) {
              for (var name in section) {
                fixupEntry(section[name]);
              }
            }
          }

          fixupSection("properties");
          fixupSection("events");
          fixupSection("members");
          fixupSection("statics");
          fixupEntry(meta.clazz);
          fixupEntry(meta.construct);
          fixupEntry(meta.destruct);
          fixupEntry(meta.defer);
        }

        async function updateMetaData(classname, meta) {
          var classEntities = {
            members: {},
            properties: {},
            events: {}
          };

          async function analyseClassEntities(meta, first) {
            if (typeof meta == "string") {
              meta = await loadMetaData(meta);
            }

            if (!meta) {
              return;
            }

            ["members", "properties", "events"].forEach(entityTypeName => {
              if (!meta[entityTypeName]) {
                return;
              }

              for (let entityName in meta[entityTypeName]) {
                let entityMeta = meta[entityTypeName][entityName];

                if (entityMeta.type === "function" || entityTypeName === "properties" || entityTypeName === "events") {
                  var entityInfo = classEntities[entityTypeName][entityName];

                  if (!entityInfo) {
                    entityInfo = classEntities[entityTypeName][entityName] = {
                      appearsIn: {},
                      overriddenFrom: null,
                      jsdoc: null,
                      abstract: meta.type === "interface",
                      mixin: meta.type === "mixin" && !first,
                      inherited: !first,
                      access: entityName.startsWith("__") ? "private" : entityName.startsWith("_") ? "protected" : "public"
                    };
                  }

                  if (entityMeta.event) {
                    entityInfo.event = entityMeta.event;
                  }

                  if (entityMeta.property) {
                    entityInfo.property = entityMeta.property;
                  }

                  if (meta.type === "mixin" && entityInfo.abstract) {
                    entityInfo.mixin = true;
                  }

                  if (meta.type !== "interface") {
                    entityInfo.abstract = false;
                  } else {
                    entityInfo["interface"] = true;
                  }

                  if (!first) {
                    entityInfo.appearsIn[meta.className] = meta.type;
                  }

                  if (!first && !entityInfo.overriddenFrom) {
                    entityInfo.overriddenFrom = meta.className;
                  }

                  if (!entityInfo.jsdoc) {
                    entityInfo.jsdoc = entityMeta.jsdoc;
                  }
                }
              }
            });

            if (meta.interfaces) {
              for (let i = 0; i < meta.interfaces.length; i++) {
                await analyseClassEntities(meta.interfaces[i]);
              }
            }

            if (meta.mixins) {
              for (let i = 0; i < meta.mixins.length; i++) {
                await analyseClassEntities(meta.mixins[i]);
              }
            }

            if (meta.superClass) {
              // Arrays of superclass are allowed for interfaces
              if (qx.lang.Type.isArray(meta.superClass)) {
                for (var i = 0; i < meta.superClass.length; i++) {
                  await analyseClassEntities(meta.superClass[i]);
                }
              } else {
                await analyseClassEntities(meta.superClass);
              }
            }

            if (meta.properties) {
              function addPropertyAccessor(propertyMeta, methodName, accessorType, returnType, valueType, desc) {
                var entityInfo = classEntities.members[methodName];

                if (!entityInfo || entityInfo.abstract) {
                  var newInfo = classEntities.members[methodName] = {
                    appearsIn: entityInfo ? entityInfo.appearsIn : {},
                    overriddenFrom: entityInfo && entityInfo.appearsIn[0] || null,
                    jsdoc: {
                      "@description": [{
                        "name": "@description",
                        "body": desc
                      }]
                    },
                    property: accessorType,
                    inherited: !first,
                    mixin: propertyMeta.mixin,
                    access: "public"
                  };

                  if (returnType) {
                    newInfo.jsdoc["@return"] = [{
                      "name": "@return",
                      "type": returnType,
                      "desc": "Returns the value for " + propertyMeta.name
                    }];
                  }

                  if (valueType) {
                    newInfo.jsdoc["@param"] = [{
                      "name": "@param",
                      "type": valueType,
                      "paramName": "value",
                      "desc": "Value for " + propertyMeta.name
                    }];
                  }
                }
              }

              for (let propertyName in meta.properties) {
                let propertyMeta = meta.properties[propertyName];
                let upname = qx.lang.String.firstUp(propertyName);
                let type = propertyMeta.check || "any";

                if (!propertyMeta.group) {
                  let msg = "Gets the (computed) value of the property <code>" + propertyName + "</code>.\n" + "\n" + "For further details take a look at the property definition: {@link #" + propertyName + "}.";
                  addPropertyAccessor(propertyMeta, "get" + upname, "get", type, null, msg);

                  if (type == "Boolean") {
                    addPropertyAccessor(propertyMeta, "is" + upname, "is", type, null, msg);
                  }
                }

                addPropertyAccessor(propertyMeta, "set" + upname, "set", null, type, "Sets the user value of the property <code>" + propertyName + "</code>.\n" + "\n" + "For further details take a look at the property definition: {@link #" + propertyName + "}.");
                addPropertyAccessor(propertyMeta, "reset" + upname, "reset", null, null, "Resets the user value of the property <code>" + propertyName + "</code>.\n" + "\n" + "The computed value falls back to the next available value e.g. appearance, init or inheritance value " + "depending on the property configuration and value availability.\n" + "\n" + "For further details take a look at the property definition: {@link #" + propertyName + "}.");

                if (propertyMeta.async) {
                  var msg = "Returns a {@link qx.Promise} which resolves to the (computed) value of the property <code>" + propertyName + "</code>." + "\n" + "For further details take a look at the property definition: {@link #" + propertyName + "}.";
                  addPropertyAccessor(propertyMeta, "get" + upname + "Async", "getAsync", "Promise", null, msg);

                  if (type == "Boolean") {
                    addPropertyAccessor(propertyMeta, "is" + upname + "Async", "isAsync", "Promise", null, msg);
                  }

                  addPropertyAccessor(propertyMeta, "set" + upname + "Async", "setAsync", "Promise", type, "Sets the user value of the property <code>" + propertyName + "</code>, returns a {@link qx.Promise} " + "which resolves when the value change has fully completed (in the case where there are asynchronous apply methods or events).\n" + "\n" + "For further details take a look at the property definition: {@link #" + propertyName + "}.");
                }
              }
            }
          }

          function hasSignature(jsdoc) {
            return jsdoc && (jsdoc["@param"] && jsdoc["@param"].length || jsdoc["@return"] && jsdoc["@return"].length);
          }

          function mergeSignature(src, meta) {
            if (!src) {
              return;
            } // src has nothing?  ignore it.  meta already has a signature?  preserve it


            if (!hasSignature(src) || hasSignature(meta.jsdoc)) {
              return;
            }

            if (!meta.jsdoc) {
              meta.jsdoc = {};
            }

            if (src["@param"]) {
              meta.jsdoc["@param"] = qx.lang.Array.clone(src["@param"]);
            }

            if (src["@return"]) {
              meta.jsdoc["@return"] = qx.lang.Array.clone(src["@return"]);
            }
          }

          await analyseClassEntities(meta, true);

          for (let eventName in classEntities.events) {
            if (!meta.events) {
              meta.events = {};
            }

            let eventInfo = classEntities.events[eventName];

            if ((eventInfo.abstract || eventInfo.mixin) && !meta.events[eventInfo]) {
              let eventMeta = meta.events[eventName] = {
                type: "event",
                name: eventName,
                abstract: Boolean(eventInfo.abstract),
                mixin: Boolean(eventInfo.mixin),
                access: eventInfo.access,
                overriddenFrom: eventInfo.overriddenFrom
              };

              if (eventInfo.appearsIn.length) {
                eventMeta.appearsIn = Object.keys(eventInfo.appearsIn);
              }

              if (eventInfo.jsdoc) {
                eventMeta.jsdoc = eventInfo.jsdoc;
              }

              if (eventInfo.overriddenFrom) {
                eventMeta.overriddenFrom = eventInfo.overriddenFrom;
              }
            }
          }

          if (meta.properties) {
            for (let propertyName in meta.properties) {
              let propertyMeta = meta.properties[propertyName];

              if (propertyMeta.refine) {
                let result = classEntities.properties[propertyName];

                if (result) {
                  propertyMeta.overriddenFrom = result.overriddenFrom;
                  propertyMeta.appearsIn = result.appearsIn;
                  mergeSignature(result.jsdoc, propertyMeta);
                }
              }
            }

            for (let propertyName in classEntities.properties) {
              let propertyInfo = classEntities.properties[propertyName];

              if ((propertyInfo.abstract || propertyInfo.mixin) && !meta.properties[propertyName]) {
                let propertyMeta = meta.properties[propertyName] = {
                  type: "property",
                  name: propertyName,
                  abstract: Boolean(propertyInfo.abstract),
                  mixin: Boolean(propertyInfo.mixin),
                  access: propertyInfo.access,
                  overriddenFrom: propertyInfo.overriddenFrom,
                  event: propertyInfo.event
                };

                if (propertyInfo.appearsIn.length) {
                  propertyMeta.appearsIn = Object.keys(propertyInfo.appearsIn);
                }

                if (propertyMeta.appearsIn && !propertyMeta.appearsIn.length) {
                  delete propertyMeta.appearsIn;
                }

                if (propertyInfo.jsdoc) {
                  propertyMeta.jsdoc = propertyInfo.jsdoc;
                }

                if (propertyInfo.overriddenFrom) {
                  propertyMeta.overriddenFrom = propertyInfo.overriddenFrom;
                }

                if (!propertyMeta.overriddenFrom) {
                  delete propertyMeta.overriddenFrom;
                }
              }
            }
          }

          if (!meta.members) {
            meta.members = {};
          }

          for (let memberName in meta.members) {
            let memberMeta = meta.members[memberName];

            if (memberMeta.type === "function") {
              let result = classEntities.members[memberName];

              if (result) {
                memberMeta.overriddenFrom = result.overriddenFrom;
                memberMeta.appearsIn = Object.keys(result.appearsIn);
                mergeSignature(result.jsdoc, memberMeta);
              }
            }
          }

          for (let memberName in classEntities.members) {
            let memberInfo = classEntities.members[memberName];
            let memberMeta = meta.members[memberName];

            if (memberMeta && memberMeta.type === "variable" && memberInfo) {
              memberMeta.type = "function";
            }

            if ((memberInfo.abstract || memberInfo.mixin || memberInfo.property) && !memberMeta) {
              let memberMeta = meta.members[memberName] = {
                type: "function",
                name: memberName,
                abstract: Boolean(memberInfo.abstract),
                mixin: Boolean(memberInfo.mixin),
                inherited: Boolean(memberInfo.inherited),
                access: memberInfo.access,
                overriddenFrom: memberInfo.overriddenFrom
              };

              if (memberInfo.property) {
                memberMeta.property = memberInfo.property;
              }

              if (memberInfo.appearsIn.length) {
                memberMeta.appearsIn = Object.keys(memberInfo.appearsIn);
              }

              if (memberInfo.jsdoc) {
                memberMeta.jsdoc = memberInfo.jsdoc;
              }

              if (memberInfo.overriddenFrom) {
                memberMeta.overriddenFrom = memberInfo.overriddenFrom;
              }

              if (memberMeta.abstract) {
                meta.abstract = true;
              }
            }
          }

          for (let memberName in meta.members) {
            let memberMeta = meta.members[memberName];

            if (memberMeta.appearsIn && !memberMeta.appearsIn.length) {
              delete memberMeta.appearsIn;
            }

            if (!memberMeta.overriddenFrom) {
              delete memberMeta.overriddenFrom;
            }
          }

          if (Object.keys(meta.members).length == 0) {
            delete meta.members;
          }
        }

        var cachedMeta = {};

        async function saveMetaData(classname, meta) {
          if (metaWrittenLog[classname]) {
            qx.tool.compiler.Console.log(" *** ERROR *** Writing " + classname + " more than once");
            throw new Error(" *** ERROR *** Writing " + classname + " more than once");
          }

          metaWrittenLog[classname] = true;
          var filename = qx.tool.compiler.ClassFile.getOutputPath(t, classname) + "on";
          return writeFile(filename, JSON.stringify(meta, null, 2), {
            encoding: "utf-8"
          });
        }

        async function loadMetaData(classname) {
          if (classname == "Object" || classname == "Array" || classname == "Error") {
            return Promise.resolve(null);
          }

          if (cachedMeta[classname]) {
            return Promise.resolve(cachedMeta[classname]);
          }

          var filename = qx.tool.compiler.ClassFile.getOutputPath(t, classname) + "on";
          return readFile(filename, {
            encoding: "utf-8"
          }).then(str => jsonlint.parse(str)).then(meta => cachedMeta[classname] = meta).catch(err => {
            qx.tool.compiler.Console.error("Failed to load meta for " + classname + ": " + err);
          });
        }

        function calcDescendants(classname, meta) {
          meta.descendants = [];

          for (var name in db.classInfo) {
            var tmp = db.classInfo[name];

            if (tmp.extends == classname) {
              meta.descendants.push(name);
            }
          }
        }

        async function analyzeMeta() {
          var toSave = {};

          for (let classname in compiledClasses) {
            let meta = cachedMeta[classname] = compiledClasses[classname].classFile.getOuterClassMeta(); // Null meta means that the class didn't compile anything

            if (meta) {
              fixupMetaData(classname, meta);
            }
          }

          for (let classname in compiledClasses) {
            let meta = cachedMeta[classname];

            if (meta) {
              await updateMetaData(classname, meta);
              calcDescendants(classname, meta);
              toSave[classname] = meta;
            }
          }

          for (let classname in metaFixupDescendants) {
            if (!compiledClasses[classname] && db.classInfo[classname]) {
              let meta = await loadMetaData(classname);

              if (meta) {
                calcDescendants(classname, meta);
                toSave[classname] = meta;
              }
            }
          }

          await Promise.all(Object.keys(toSave).map(classname => saveMetaData(classname, toSave[classname])));
        }

        return await analyzeMeta();
      },

      /**
       * Called when a reference to a class is made
       * @param className
       * @private
       */
      _addRequiredClass: function (className) {
        let t = this; // __classes will be null if analyseClasses has not formally been called; this would be if the
        //  analyser is only called externally for getClass()

        if (!t.__P_21_11) {
          t.__P_21_11 = [];
        } // Add it


        if (t.__P_21_11.indexOf(className) == -1) {
          t.__P_21_11.push(className);
        }
      },

      /**
       * Returns the full list of required classes
       * @returns {null}
       */
      getDependentClasses: function () {
        return this.__P_21_11;
      },

      /**
       * Returns cached class info - returns null if not loaded or not in the database
       * @returb DbClassInfo
       */
      getCachedClassInfo: function (className) {
        return this.__P_21_10 ? this.__P_21_10.classInfo[className] : null;
      },

      /**
       * Loads a class
       * @param className {String} the name of the class
       * @param forceScan {Boolean?} true if the class is to be compiled whether it needs it or not (default false)
       * @param cb {Function} (err, DbClassInfo)
       */
      getClassInfo: function (className, forceScan, cb) {
        var t = this;

        if (!this.__P_21_10) {
          this.__P_21_10 = {};
        }

        var db = this.__P_21_10;

        if (typeof forceScan == "function") {
          cb = forceScan;
          forceScan = false;
        }

        if (!db.classInfo) {
          db.classInfo = {};
        }

        var library = t.getLibraryFromClassname(className);

        if (!library) {
          let err = new Error("Cannot find class file " + className);
          err.code = "ENOCLASSFILE";
          cb && cb(err);
          return;
        }

        var sourceClassFilename = qx.tool.compiler.ClassFile.getSourcePath(library, className);
        var outputClassFilename = qx.tool.compiler.ClassFile.getOutputPath(this, className);

        const scanFile = async () => {
          let sourceStat = await qx.tool.utils.files.Utils.safeStat(sourceClassFilename);

          if (!sourceStat) {
            throw new Error("Cannot find " + sourceClassFilename);
          }

          var dbClassInfo = db.classInfo[className];

          if (!forceScan) {
            let outputStat = await qx.tool.utils.files.Utils.safeStat(outputClassFilename);
            let outputJsonStat = await qx.tool.utils.files.Utils.safeStat(outputClassFilename + "on");

            if (dbClassInfo && outputStat && outputJsonStat) {
              var dbMtime = null;

              try {
                dbMtime = dbClassInfo.mtime && new Date(dbClassInfo.mtime);
              } catch (e) {}

              if (dbMtime && dbMtime.getTime() == sourceStat.mtime.getTime()) {
                if (outputStat.mtime.getTime() >= sourceStat.mtime.getTime()) {
                  await t.fireDataEventAsync("alreadyCompiledClass", {
                    className: className,
                    dbClassInfo: dbClassInfo
                  });
                  return dbClassInfo;
                }
              }
            }
          } // Add database entry


          var oldDbClassInfo = db.classInfo[className] ? Object.assign({}, db.classInfo[className]) : null;
          dbClassInfo = db.classInfo[className] = {
            mtime: sourceStat.mtime,
            libraryName: library.getNamespace()
          }; // Analyse it and collect unresolved symbols and dependencies

          var classFile = new qx.tool.compiler.ClassFile(t, className, library);
          await t.fireDataEventAsync("compilingClass", {
            dbClassInfo: dbClassInfo,
            oldDbClassInfo: oldDbClassInfo,
            classFile: classFile
          });
          await qx.tool.utils.Promisify.call(cb => classFile.load(cb)); // Save it

          classFile.writeDbInfo(dbClassInfo);
          await t.fireDataEventAsync("compiledClass", {
            dbClassInfo: dbClassInfo,
            oldDbClassInfo: oldDbClassInfo,
            classFile: classFile
          }); // Next!

          return dbClassInfo;
        };

        qx.tool.utils.Promisify.callback(scanFile(), cb);
      },

      /**
       * Returns the CLDR data for a given locale
       * @param locale {String} the locale string
       * @returns Promise({cldr})
       */
      getCldr: async function (locale) {
        var t = this;
        var cldr = this.__P_21_4[locale];

        if (cldr) {
          return cldr;
        }

        return qx.tool.compiler.app.Cldr.loadCLDR(locale).then(cldr => t.__P_21_4[locale] = cldr);
      },

      /**
       * Gets the translation for the locale and library, caching the result.
       * @param library
       * @param locale
       * @returns {translation}
       */
      getTranslation: async function (library, locale) {
        var t = this;
        var id = locale + ":" + library.getNamespace();
        var translation = t.__P_21_5[id];

        if (!translation) {
          translation = t.__P_21_5[id] = new qx.tool.compiler.app.Translation(library, locale);
          translation.setWriteLineNumbers(this.isWritePoLineNumbers());
          await translation.checkRead();
        }

        return translation;
      },

      /**
       * Updates all translations to include all msgids found in code
       * @param appLibrary {qx.tool.compiler.app.Library} the library to update
       * @param locales {String[]} locales
       * @param libraries {qx.tool.compiler.app.Library[]} all libraries
       * @param copyAllMsgs {Boolean} whether to copy everything, or just those that are required
       */
      async updateTranslations(appLibrary, locales, libraries, copyAllMsgs) {
        if (!libraries) {
          libraries = [];
        }

        libraries = libraries.filter(lib => lib != appLibrary);
        await qx.Promise.all(locales.map(async locale => {
          let libTranslations = {};
          await qx.Promise.all(libraries.map(async lib => {
            var translation = new qx.tool.compiler.app.Translation(lib, locale);
            await translation.read();
            libTranslations[lib.toHashCode()] = translation;
          }));
          var translation = new qx.tool.compiler.app.Translation(appLibrary, locale);
          translation.setWriteLineNumbers(this.isWritePoLineNumbers());
          await translation.read();
          let unusedEntries = {};

          for (let msgid in translation.getEntries()) {
            unusedEntries[msgid] = true;
          }

          await qx.Promise.all(this.__P_21_11.map(async classname => {
            let isAppClass = appLibrary.isClass(classname);
            let classLibrary = !isAppClass && libraries.find(lib => lib.isClass(classname)) || null;

            if (!isAppClass && !classLibrary) {
              return;
            }

            let dbClassInfo = await qx.tool.utils.Promisify.call(cb => this.getClassInfo(classname, cb));

            if (!dbClassInfo.translations) {
              return;
            }

            function isEmpty(entry) {
              if (!entry) {
                return true;
              }

              if (qx.lang.Type.isArray(entry.msgstr)) {
                return entry.msgstr.every(value => !value);
              }

              return !entry.msgstr;
            }

            dbClassInfo.translations.forEach(function (src) {
              delete unusedEntries[src.msgid];

              if (classLibrary) {
                let entry = translation.getEntry(src.msgid);

                if (!isEmpty(entry)) {
                  return;
                }

                let libTranslation = libTranslations[classLibrary.toHashCode()];
                let libEntry = libTranslation.getEntry(src.msgid);

                if (isEmpty(libEntry) || copyAllMsgs) {
                  if (!entry) {
                    entry = translation.getOrCreateEntry(src.msgid);
                  }

                  if (libEntry !== null) {
                    Object.assign(entry, libEntry);
                  }
                }

                return;
              }

              let entry = translation.getOrCreateEntry(src.msgid);

              if (src.msgid_plural) {
                entry.msgid_plural = src.msgid_plural;
              }

              if (!entry.comments) {
                entry.comments = {};
              }

              entry.comments.extracted = src.comment;
              entry.comments.reference = {};
              let ref = entry.comments.reference;
              const fileName = classname.replace(/\./g, "/") + ".js";

              const fnAddReference = lineNo => {
                let arr = ref[fileName];

                if (!arr) {
                  arr = ref[fileName] = [];
                }

                if (!arr.includes(src.lineNo)) {
                  arr.push(lineNo);
                }
              };

              if (qx.lang.Type.isArray(src.lineNo)) {
                src.lineNo.forEach(fnAddReference);
              } else {
                fnAddReference(src.lineNo);
              }
            });
          }));
          Object.keys(unusedEntries).forEach(msgid => {
            var entry = translation.getEntry(msgid);

            if (entry) {
              if (!entry.comments) {
                entry.comments = {};
              }

              if (Object.keys(entry.comments).length == 0 && entry.msgstr === "") {
                translation.deleteEntry(msgid);
              } else {
                entry.comments.extracted = "NO LONGER USED";
                entry.comments.reference = {};
              }
            }
          });
          await translation.write();
        }));
      },

      /**
       * Returns the path to the qooxdoo library
       *
       * @returns
       */
      getQooxdooPath: function () {
        var lib = this.findLibrary("qx");

        if (lib !== null) {
          return lib.getRootDir();
        }

        return null;
      },

      /**
       * Finds the library with a name(space)
       */
      findLibrary: function (name) {
        var lib = this.__P_21_2[name];
        return lib;
      },

      /**
       * Returns all libraries
       * @returns {null}
       */
      getLibraries: function () {
        return this.__P_21_1;
      },

      /**
       * Adds a library definition
       *
       * @param library
       */
      addLibrary: function (library) {
        this.__P_21_1.push(library);

        this.__P_21_2[library.getNamespace()] = library;
      },

      /**
       * Adds a required class to be analysed by analyseClasses()
       *
       * @param classname
       */
      addClass: function (classname) {
        this.__P_21_3.push(classname);
      },

      /**
       * Removes a class from the list of required classes to analyse
       * @param classname {String}
       */
      removeClass: function (classname) {
        this.__P_21_3.remove(classname);
      },

      /**
       * Detects the symbol type, ie class, package, member, etc
       * @param name
       * @returns {{symbolType,name,className}?}
       */
      getSymbolType: function (name) {
        var t = this;

        for (var j = 0; j < t.__P_21_1.length; j++) {
          var library = t.__P_21_1[j];
          var info = library.getSymbolType(name);

          if (info) {
            return info;
          }
        }

        return null;
      },

      /**
       * Returns the library for a given classname, supports private files
       * @param className
       * @returns {*}
       */
      getLibraryFromClassname: function (className) {
        var t = this;
        var info = this.__P_21_6[className];

        if (info) {
          return info.library;
        }

        for (var j = 0; j < t.__P_21_1.length; j++) {
          var library = t.__P_21_1[j];
          info = library.getSymbolType(className);

          if (info && (info.symbolType == "class" || info.symbolType == "member")) {
            return library;
          }
        }

        return null;
      },

      /**
       * Returns the classname
       * @param className
       * @returns {string}
       */
      getClassFilename: function (className) {
        var library = this.getLibraryFromClassname(className);

        if (!library) {
          return null;
        }

        var path = library.getRootDir() + "/" + library.getSourcePath() + "/" + className.replace(/\./g, "/") + ".js";
        return path;
      },

      /**
       * Sets an environment value as being checked for
       *
       * @param key
       * @param value
       */
      setEnvironmentCheck: function (key, value) {
        if (typeof key == "object") {
          var map = key;

          for (key in map) {
            this.__P_21_7[key] = map[key];
          }
        } else if (value === undefined) {
          delete this.__P_21_7[key];
        } else {
          this.__P_21_7[key] = value;
        }
      },

      /**
       * Tests whether an environment value is checked for
       *
       * @param key
       * @returns
       */
      getEnvironmentCheck: function (key) {
        return this.__P_21_7[key];
      },

      /**
       * Returns the resource manager
       */
      getResourceManager: function () {
        return this.__P_21_9;
      },

      /**
       * Returns the version of Qooxdoo
       * @returns {String}
       */
      getQooxdooVersion: function () {
        if (this.__P_21_13) {
          return this.__P_21_13;
        }

        if (!this.__P_21_13) {
          let lib = this.findLibrary("qx");

          if (lib) {
            this.__P_21_13 = lib.getVersion();
          }
        }

        return this.__P_21_13;
      },

      /**
       * Returns the database filename
       * @returns {null}
       */
      getDbFilename: function () {
        return this.__P_21_0;
      },

      /**
       * Returns the resource database filename
       * @returns {null}
       */
      getResDbFilename: function () {
        var m = this.__P_21_0.match(/(^.*)\/([^/]+)$/);

        var resDb;

        if (m && m.length == 3) {
          resDb = m[1] + "/resource-db.json";
        } else {
          resDb = "resource-db.json";
        }

        return resDb;
      },
      // property apply
      _applyEnvironment: function (value) {
        // Cache the hash because we will need it later
        this.__P_21_14 = hash(value);
      },

      /**
       * Whether the compilation context has changed since last analysis
       * e.g. compiler version, environment variables
       *
       * @return {Boolean}
       */
      isContextChanged: function () {
        var db = this.getDatabase(); // Check if environment is the same as the last time
        // If the environment hash is null, environment variables have
        // not been loaded yet. In that case don't consider the environment
        // changed

        if (this.__P_21_14 && this.__P_21_14 !== db.environmentHash) {
          return true;
        } // then check if compiler version is the same


        if (db.compilerVersion !== qx.tool.compiler.Version.VERSION) {
          return true;
        }

        return false;
      },

      /**
       * Sets the environment data in the __db.
       * The data beeing set are:
       *  * a hash of the current environment values
       *  * the compiler version
       *  * a list of the libraries used
       *
       */
      updateEnvironmentData: function () {
        const libraries = this.getLibraries().reduce((acc, library) => {
          acc[library.getNamespace()] = library.getVersion();
          return acc;
        }, {});
        const db = this.getDatabase();
        db.libraries = libraries;
        db.environmentHash = this.__P_21_14;
        db.compilerVersion = qx.tool.compiler.Version.VERSION;
      }
    }
  });
  qx.tool.compiler.Analyser.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
   *
   *    qooxdoo-compiler - node.js based replacement for the Qooxdoo python
   *    toolchain
   *
   *    https://github.com/qooxdoo/qooxdoo-compiler
   *
   *    Copyright:
   *      2011-2017 Zenesis Limited, http://www.zenesis.com
   *
   *    License:
   *      MIT: https://opensource.org/licenses/MIT
   *
   *      This software is provided under the same licensing terms as Qooxdoo,
   *      please see the LICENSE file in the Qooxdoo project's top-level directory
   *      for details.
   *
   *    Authors:
   *      * John Spackman (john.spackman@zenesis.com, @johnspackman)
   *
   * *********************************************************************** */
  qx.Class.define("qx.tool.utils.Values", {
    statics: {
      /**
       * Performs a binary search on the host array.
       *
       * Thanks to Oliver Caldwell for this snippet, https://oli.me.uk/2013/06/08/searching-javascript-arrays-with-a-binary-search/
       *
       * @param {*} array The array to search.
       * @param {*} searchElement The item to search for within the array.
       * @return {Number} The index of the element which defaults to -1 when not found.
       */
      binaryIndexOf: function (array, searchElement) {
        var minIndex = 0;
        var maxIndex = array.length - 1;
        var currentIndex;
        var currentElement;

        while (minIndex <= maxIndex) {
          currentIndex = (minIndex + maxIndex) / 2 | 0;
          currentElement = array[currentIndex];

          if (currentElement < searchElement) {
            minIndex = currentIndex + 1;
          } else if (currentElement > searchElement) {
            maxIndex = currentIndex - 1;
          } else {
            return currentIndex;
          }
        }

        return -1;
      },
      binaryStartsWith: function (array, searchElement) {
        var minIndex = 0;
        var maxIndex = array.length - 1;
        var currentIndex;
        var currentElement;

        while (minIndex <= maxIndex) {
          currentIndex = (minIndex + maxIndex) / 2 | 0;
          currentElement = array[currentIndex];

          if (currentElement.startsWith(searchElement)) {
            while (currentIndex > 0) {
              if (!array[currentIndex - 1].startsWith(searchElement)) {
                break;
              }

              currentIndex--;
            }

            return currentIndex;
          }

          if (currentElement < searchElement) {
            minIndex = currentIndex + 1;
          } else if (currentElement > searchElement) {
            maxIndex = currentIndex - 1;
          }
        }

        return -1;
      },

      merge(target, ...sources) {
        if (sources) {
          sources.forEach(src => {
            for (let key in src) {
              target[key] = src[key];
            }
          });
        }

        return target;
      }

    }
  });
  qx.tool.utils.Values.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.tool.utils.IndexedArray": {},
      "qx.lang.Type": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
   *
   *    qooxdoo-compiler - node.js based replacement for the Qooxdoo python
   *    toolchain
   *
   *    https://github.com/qooxdoo/qooxdoo-compiler
   *
   *    Copyright:
   *      2011-2017 Zenesis Limited, http://www.zenesis.com
   *
   *    License:
   *      MIT: https://opensource.org/licenses/MIT
   *
   *      This software is provided under the same licensing terms as Qooxdoo,
   *      please see the LICENSE file in the Qooxdoo project's top-level directory
   *      for details.
   *
   *    Authors:
   *      * JBaron (Peter, @jbaron)
   *      * John Spackman (john.spackman@zenesis.com, @johnspackman)
   *
   * *********************************************************************** */
  var path = require("path");

  var fs = require("fs");

  var jsonlint = require("jsonlint");

  const {
    promisify
  } = require("util");

  const readFile = promisify(fs.readFile);
  /**
   * Generates TypeScript .d.ts files
   */

  qx.Class.define("qx.tool.compiler.targets.TypeScriptWriter", {
    extend: qx.core.Object,
    construct: function (target) {
      qx.core.Object.constructor.call(this);
      this.__P_39_0 = target;
    },
    properties: {
      outputTo: {
        init: "qooxdoo.d.ts",
        check: "String"
      }
    },
    members: {
      __P_39_1: "    ",
      __P_39_2: null,
      __P_39_3: null,
      __P_39_0: null,
      __P_39_4: null,
      __dirname: null,
      __P_39_5: null,

      /**
       * Generates the .d.ts file
       *
       * @param application
       *          {qx.tool.compiler.app.Application?} the application; if not
       *          provided, all classes are output
       */
      run: async function (application) {
        this.__P_39_4 = {};
        await new Promise((resolve, reject) => {
          var time = new Date();
          this.__P_39_2 = fs.createWriteStream(path.join(this.__P_39_0.getOutputDir(), this.getOutputTo()));
          this.write(`// Generated declaration file at ${time}\n`);
          this.writeBase().then(async () => {
            var analyser = this.__P_39_0.getAnalyser();

            this.__P_39_3 = new qx.tool.utils.IndexedArray();

            if (application) {
              application.getDependencies().forEach(classname => {
                if (classname != "q" && classname != "qxWeb") {
                  this.__P_39_3.push(classname);
                }
              });
            } else {
              analyser.getLibraries().forEach(library => {
                var symbols = library.getKnownSymbols();

                for (var name in symbols) {
                  var type = symbols[name];

                  if (type === "class" && name !== "q" && name !== "qxWeb") {
                    this.__P_39_3.push(name);
                  }
                }
              });
            }

            this.__P_39_3.sort();

            var lastPackageName = null;
            var classIndex = 0;

            var next = () => {
              if (classIndex >= this.__P_39_3.getLength()) {
                return undefined;
              }

              var className = this.__P_39_3.getItem(classIndex++);

              var pos = className.lastIndexOf(".");
              var packageName = "";

              if (pos > -1) {
                packageName = className.substring(0, pos);
              }

              if (lastPackageName != packageName) {
                if (lastPackageName !== null) {
                  this.write("}\n");
                }

                if (packageName) {
                  this.write("declare module " + packageName + " {\n");
                } else {
                  this.write("declare {\n");
                }

                lastPackageName = packageName;
              }

              return this.loadAPIFile(className).then(meta => this.writeClass(meta)).then(() => next()).catch(err => this.error("Error while processing file: " + className + " error: " + err.stack));
            };

            return next().then(() => this.write("}\n")).then(() => this.__P_39_2.end());
          }).then(resolve).catch(reject);
        });
      },

      /**
       * Write a piece of code to the declaration file
       */
      write: function (msg) {
        this.__P_39_2.write(msg);
      },

      /**
       * Load a single API file
       * @async
       */
      loadAPIFile: function (classname) {
        if (classname === "Object" || classname === "Array" || classname === "Error") {
          return null;
        }

        if (this.__P_39_4[classname]) {
          return Promise.resolve(this.__P_39_4[classname]);
        }

        var fileName = path.join(this.__P_39_0.getOutputDir(), "transpiled", classname.replace(/\./g, "/") + ".json");
        return readFile(fileName, "UTF-8").then(content => this.__P_39_4[classname] = jsonlint.parse(content)).catch(err => this.error("Error parsing " + classname + ": " + err.stack));
      },

      /**
       * Write some util declarations out that will help with the rest
       * @async
       */
      writeBase: function () {
        return readFile(path.join(__dirname, "TypeScriptWriter-base_declaration.txt"), "UTF-8").then(content => this.write(content));
      },

      /**
       * Do the mapping of types from Qooxdoo to TypeScript
       */
      getType: function (t) {
        var defaultType = "any";

        if (!t || t == "[[ Function ]]") {
          return defaultType;
        }

        if (typeof t == "object") {
          t = t.name;
        } // Check if we have a mapping for this type


        var result = qx.tool.compiler.targets.TypeScriptWriter.TYPE_MAPPINGS[t];

        if (result) {
          return result;
        }

        if (this.__P_39_3.contains(t)) {
          return t;
        } // We don't know the type
        // this.error("Unknown type: " + t);


        return defaultType;
      },

      /**
       * Write a constructor
       */
      writeConstructor: function (methodMeta) {
        this.write(this.__P_39_1 + "constructor (" + this.serializeParameters(methodMeta, true) + ");\n");
      },

      /**
       * Write all the methods of a type
       */
      writeMethods: function (methods, classMeta, isStatic = false) {
        if (!methods || !Object.keys(methods).length) {
          return;
        }

        var IGNORE = qx.tool.compiler.targets.TypeScriptWriter.IGNORE[this.__P_39_5.className];
        var comment = isStatic ? "Statics" : "Members";

        for (var name in methods) {
          var methodMeta = methods[name];

          if (methodMeta.type == "function") {
            var hideMethod = IGNORE && IGNORE.indexOf(name) > -1;
            var decl = "";
            comment = "";

            if (methodMeta.access) {
              if (methodMeta.access === "protected") {
                decl += "protected ";
              }

              if (methodMeta.access === "private") {
                continue;
              }
            }

            if (isStatic) {
              decl += "static ";
            }

            if (classMeta.type != "interface" && methodMeta.abstract) {
              decl += "abstract ";
              comment += "Abstract ";
            }

            if (methodMeta.mixin) {
              comment += "Mixin ";
            }

            if (methodMeta.overriddenFrom) {
              comment += "Overridden from " + methodMeta.overriddenFrom + " ";
            }

            decl += this.__P_39_6(name) + "(";
            decl += this.serializeParameters(methodMeta);
            decl += ")";
            var returnType = "void";

            if (methodMeta.jsdoc && methodMeta.jsdoc["@return"]) {
              var tag = methodMeta.jsdoc["@return"][0];

              if (tag && tag.type) {
                returnType = this.getType(tag.type);
              }
            }

            decl += ": " + returnType;

            if (comment) {
              comment = " // " + comment;
            }

            let hasDescription = methodMeta.jsdoc && methodMeta.jsdoc["@description"] && methodMeta.jsdoc["@description"][0];

            if (hasDescription) {
              this.write(this.__P_39_1 + "/**\n");
              methodMeta.jsdoc["@description"][0].body.split("\n").forEach(line => {
                this.write(this.__P_39_1 + " * " + line + "\n");
              });
              this.write(this.__P_39_1 + " */\n");
            }

            this.write(this.__P_39_1 + (hideMethod ? "// " : "") + decl + ";" + comment + "\n");
          }
        }
      },

      /**
       * Escapes the name with quote marks, only if necessary
       *
       * @param name
       *          {String} the name to escape
       * @return {String} the escaped (if necessary) name
       */
      __P_39_6: function (name) {
        if (!name.match(/^[a-zA-Z_][a-zA-Z0-9_]*$/)) {
          return "\"" + name + "\"";
        }

        return name;
      },

      /**
       * Serializes all the arguments of a method. Once one parameter is optional,
       * the remaining ones are also optional (is a TypeScript requirement)
       *
       * @return {String}
       */
      serializeParameters: function (methodMeta, optional = false) {
        var result = "";

        if (methodMeta && methodMeta.jsdoc) {
          var params = methodMeta.jsdoc["@param"];

          if (params) {
            params.forEach((paramMeta, paramIndex) => {
              var type = "any";
              var paramName = paramMeta.paramName || "unnamed" + paramIndex;
              var decl = paramName;

              if (paramName == "varargs") {
                optional = true;
              }

              if (paramMeta.optional || optional) {
                decl += "?";
                optional = true;
              }

              decl += ": ";

              if (paramMeta.type) {
                var tmp = null;

                if (qx.lang.Type.isArray(paramMeta.type)) {
                  if (paramMeta.type.length == 1) {
                    tmp = paramMeta.type[0];
                  }
                } else {
                  tmp = paramMeta.type;
                }

                if (tmp) {
                  type = this.getType(tmp);

                  if (tmp.dimensions) {
                    type += "[]";
                  }
                }
              }

              decl += type;

              if (paramIndex > 0) {
                result += ", ";
              }

              result += decl;
            });
          }
        }

        return result;
      },

      /**
       * Write the class or interface declaration
       */
      writeClass: async function (meta) {
        this.__P_39_5 = meta; // this.info("Processing class " + meta.packageName + "." + meta.name);

        var extendsClause = "";

        if (meta.superClass && meta.superClass !== "Object" && meta.superClass !== "Array" && meta.superClass !== "Error") {
          let superType = this.getType(meta.superClass);

          if (superType != "any") {
            extendsClause = " extends " + superType;
          }
        }

        var type = "class "; // default for class and mixins

        if (meta.type === "interface") {
          type = "interface ";
        } else if (meta.abstract) {
          type = "abstract " + type;
        }

        this.write("  // " + meta.className + "\n");
        this.write("  " + type + meta.name + extendsClause);

        if (meta.interfaces && meta.interfaces.length) {
          this.write(" implements " + meta.interfaces.join(", "));
        }

        this.write(" {\n");

        if (meta.type == "class") {
          this.writeConstructor(meta.construct);
        }

        if (meta.isSingleton) {
          this.writeMethods({
            getInstance: {
              type: "function",
              access: "public",
              jsdoc: {
                "@return": [{
                  type: meta.className
                }]
              }
            }
          }, meta, true);
        }

        this.writeMethods(meta.statics, meta, true);
        this.writeMethods(meta.members, meta);
        this.write("\n  }\n");
        this.__P_39_5 = null;
      },

      /**
       * Write the module declaration if any.
       */
      writeModule: async function (meta) {
        var moduleName = meta.packageName;

        if (moduleName) {
          this.write("declare module " + moduleName + " {\n");
        } else {
          this.write("declare ");
        }

        await this.writeClass(meta);

        if (moduleName) {
          this.write("}\n");
        }
      }
    },
    statics: {
      IGNORE: {
        "qx.ui.virtual.core.CellEvent": ["init"],
        "qx.ui.table.columnmodel.resizebehavior.Default": ["set"],
        "qx.ui.progressive.renderer.table.Widths": ["set"],
        "qx.ui.table.columnmodel.resizebehavior": ["set"],
        "qx.ui.table.pane.CellEvent": ["init"],
        "qx.ui.mobile.dialog.Manager": ["error"],
        "qx.ui.mobile.container.Navigation": ["add"],
        "qx.ui.website.Table": ["filter", "sort"],
        "qx.ui.website.DatePicker": ["init", "sort"],
        "qx.event.type.Orientation": ["init"],
        "qx.event.type.KeySequence": ["init"],
        "qx.event.type.KeyInput": ["init"],
        "qx.event.type.GeoPosition": ["init"],
        "qx.event.type.Drag": ["init"],
        "qx.bom.request.SimpleXhr": ["addListener", "addListenerOnce"],
        "qx.event.dispatch.AbstractBubbling": ["dispatchEvent"],
        "qx.event.dispatch.Direct": ["dispatchEvent"],
        "qx.event.dispatch.MouseCapture": ["dispatchEvent"],
        "qx.event.type.Native": ["init"],
        "qx.html.Element": ["removeListener", "removeListenerById"],
        "qx.html.Flash": ["setAttribute"],
        "qx.util.LibraryManager": ["get", "set"]
      },
      TYPE_MAPPINGS: {
        "Widget": "qx.ui.core.Widget",
        "LayoutItem": "qx.ui.core.LayoutItem",
        "AbstractTreeItem": "qx.ui.tree.core.AbstractTreeItem",
        "ILayer": "qx.ui.virtual.core.ILayer",
        "Axis": "qx.ui.virtual.core.Axis",
        "DateFormat": "qx.util.format.DateFormat",
        "LocalizedString": "qx.locale.LocalizedString",
        "Decorator": "qx.ui.decoration.Decorator",
        "Event": "qx.event.type.Event",
        "CanvasRenderingContext2D": "CanvasRenderingContext2D",
        "MWidgetController": "qx.ui.list.core.MWidgetController",
        "IDesktop": "qx.ui.window.IDesktop",
        "IWindowManager": "qx.ui.window.IWindowManager",
        "Pane": "qx.ui.virtual.core.Pane",
        "Class": "qx.Class",
        "Interface": "qx.Interface",
        "Mixin": "qx.Mixin",
        "Theme": "qx.Theme",
        "Boolean": "boolean",
        "String": "string",
        "Color": "string",
        "Font": "string",
        "Function": "Function",
        "Date": "Date",
        "Window": "Window",
        "Document": "Document",
        "document": "Document",
        "Stylesheet": "StyleSheet",
        "Node": "Node",
        "Custom check function": "Custom check function",
        "Error": "ErrorImpl",
        "Element": "HTMLElement",
        "RegExp": "RegExp",
        "var": "any",
        "Array": "qx.data.Array",
        "Object": "any",
        "Map": "IMap",
        "Integer": "number",
        "Number": "number",
        "Double": "number",
        "Float": "number",
        "PositiveInteger": "number",
        "PositiveNumber": "number"
      }
    }
  });
  qx.tool.compiler.targets.TypeScriptWriter.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
   *
   *    qooxdoo-compiler - node.js based replacement for the Qooxdoo python
   *    toolchain
   *
   *    https://github.com/qooxdoo/qooxdoo-compiler
   *
   *    Copyright:
   *      2011-2017 Zenesis Limited, http://www.zenesis.com
   *
   *    License:
   *      MIT: https://opensource.org/licenses/MIT
   *
   *      This software is provided under the same licensing terms as Qooxdoo,
   *      please see the LICENSE file in the Qooxdoo project's top-level directory
   *      for details.
   *
   *    Authors:
   *      * John Spackman (john.spackman@zenesis.com, @johnspackman)
   *
   * *********************************************************************** */

  /**
   * Provides a simple, array like interface which uses a lookup to provide indexed
   * access.  Each element must be a string
   */
  qx.Class.define("qx.tool.utils.IndexedArray", {
    extend: qx.core.Object,
    construct: function () {
      qx.core.Object.constructor.call(this);
      this.__P_48_0 = [];
      this.__P_48_1 = {};
      this.__P_48_2 = false;
    },
    properties: {
      keepSorted: {
        init: false,
        nullable: false,
        check: "Boolean"
      }
    },
    members: {
      __P_48_3: false,
      __P_48_0: null,
      __P_48_1: null,
      __P_48_2: false,

      /**
       * Adds an entry
       *
       * @param name {String} the entry to add
       */
      push: function (name) {
        if (this.__P_48_1[name] === undefined) {
          this.__P_48_0.push(name);

          this.__P_48_1[name] = this.__P_48_0.length - 1;
          this.__P_48_3 = true;
        }
      },

      /**
       * Sort the array
       *
       * @param compareFn {Function} sort comparator, if null alphabetic is used
       */
      sort: function (compareFn) {
        this.__P_48_0.sort(compareFn); // Remove any undefined from the end of the array


        for (let arr = this.__P_48_0, len = arr.length, i = len - 1; i > -1; i--) {
          if (arr[i] !== undefined) {
            if (i < len - 1) {
              arr.splice(i + 1);
            }

            break;
          }
        } // Remove undefined from the start of the array


        for (let arr = this.__P_48_0, len = arr.length, i = 0; i < len; i++) {
          if (arr[i] !== undefined) {
            if (i > 0) {
              arr.splice(0, i);
            }

            break;
          }
        } // Rebuild the lookup


        this.__P_48_0.forEach((elem, index) => {
          this.__P_48_1[elem] = index;
        });

        this.__P_48_3 = false;
      },

      /**
       * Tests whether the entry exsts
       *
       * @param name {String} the entry to check for
       * @return {Boolean} true if found
       */
      contains: function (name) {
        return this.__P_48_1[name] !== undefined;
      },

      /**
       * Removes an entry
       *
       * @param name {String} the entry to remove
       */
      remove: function (name) {
        var index = this.__P_48_1[name];

        if (index !== undefined) {
          delete this.__P_48_0[index];
          delete this.__P_48_1[name];
          this.__P_48_2 = true;
        }
      },

      /**
       * Removes the last entry from the array and returns it
       *
       * @returns {String}
       */
      pop: function () {
        if (this.__P_48_0.length == 0) {
          return undefined;
        }

        if (this.__P_48_3 && this.isKeepSorted()) {
          this.sort();
        }

        do {
          var elem = this.__P_48_0.pop();

          if (elem !== undefined) {
            delete this.__P_48_1[elem];
            return elem;
          }
        } while (this.__P_48_0.length > 0);

        return undefined;
      },

      /**
       * Removes the first entry from the array and returns it
       *
       * @returns {String}
       */
      shift: function () {
        if (this.__P_48_0.length == 0) {
          return undefined;
        }

        if (this.__P_48_3 && this.isKeepSorted()) {
          this.sort();
        }

        do {
          var elem = this.__P_48_0.shift();

          if (elem !== undefined) {
            delete this.__P_48_1[elem];
            return elem;
          }
        } while (this.__P_48_0.length > 0);

        return undefined;
      },

      /**
       * Returns the length of the array
       *
       * @returns {Integer}
       */
      getLength: function () {
        return this.__P_48_0.length;
      },

      /**
       * Returns the indexed item of the array
       *
       * @returns {String}
       */
      getItem: function (index) {
        if (this.__P_48_3 && this.isKeepSorted()) {
          this.sort();
        }

        return this.__P_48_0[index];
      },

      /**
       * Detects whether the array is empty
       *
       * @returns {Boolean}
       */
      isEmpty: function () {
        return this.__P_48_0.length > 0;
      },

      /**
       * Returns a native array (a copy)
       *
       * @returns {String[]}
       */
      toArray: function () {
        if (this.__P_48_3 && this.isKeepSorted()) {
          this.sort();
        }

        if (this.__P_48_2) {
          var result = [];

          this.__P_48_0.forEach(function (value) {
            if (value) {
              result.push(value);
            }
          });

          return result;
        }

        return this.__P_48_0.slice();
      },

      /**
       * Returns a native object (a copy)
       *
       * @returns {Object}
       */
      toObject: function () {
        if (this.__P_48_3 && this.isKeepSorted()) {
          this.sort();
        }

        var result = {};

        this.__P_48_0.forEach(function (value) {
          result[value] = true;
        });

        return result;
      }
    }
  });
  qx.tool.utils.IndexedArray.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
   *
   *    qooxdoo-compiler - node.js based replacement for the Qooxdoo python
   *    toolchain
   *
   *    https://github.com/qooxdoo/qooxdoo-compiler
   *
   *    Copyright:
   *      2011-2017 Zenesis Limited, http://www.zenesis.com
   *
   *    License:
   *      MIT: https://opensource.org/licenses/MIT
   *
   *      This software is provided under the same licensing terms as Qooxdoo,
   *      please see the LICENSE file in the Qooxdoo project's top-level directory
   *      for details.
   *
   *    Authors:
   *      * John Spackman (john.spackman@zenesis.com, @johnspackman)
   *
   * *********************************************************************** */

  /**
   * Abstract base class for JSDoc command parsers
   */
  qx.Class.define("qx.tool.compiler.jsdoc.CommandParser", {
    extend: qx.core.Object,
    type: "abstract",
    members: {
      parseCommand: function (pdoc, classname, analyser) {
        throw new Error("No implementation for " + this.classname + ".parseCommand");
      },
      resolveType: function (type, classname, analyser) {
        if (type) {
          var pos = type.indexOf(".");

          if (pos < 0) {
            pos = classname.lastIndexOf(".");

            if (pos > -1) {
              var pkg = classname.substring(0, pos + 1);

              if (analyser) {
                var match = analyser.getCachedClassInfo(pkg + type);

                if (match) {
                  return pkg + type;
                }
              }
            }
          }
        }

        return type;
      }
    }
  });
  qx.tool.compiler.jsdoc.CommandParser.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.tool.compiler.jsdoc.CommandParser": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
   *
   *    qooxdoo-compiler - node.js based replacement for the Qooxdoo python
   *    toolchain
   *
   *    https://github.com/qooxdoo/qooxdoo-compiler
   *
   *    Copyright:
   *      2011-2017 Zenesis Limited, http://www.zenesis.com
   *
   *    License:
   *      MIT: https://opensource.org/licenses/MIT
   *
   *      This software is provided under the same licensing terms as Qooxdoo,
   *      please see the LICENSE file in the Qooxdoo project's top-level directory
   *      for details.
   *
   *    Authors:
   *      * John Spackman (john.spackman@zenesis.com, @johnspackman)
   *
   * *********************************************************************** */

  /**
   * Parser for JSDoc "@param"
   */
  qx.Class.define("qx.tool.compiler.jsdoc.ParamParser", {
    extend: qx.tool.compiler.jsdoc.CommandParser,
    members: {
      parseCommand: function (pdoc, classname, analyser) {
        var m = pdoc.body.match(/^([\S]+)(\s+\{([^}]+)\}([\s\S]+))??$/);
        var type;

        if (m) {
          pdoc.paramName = m[1].trim();
          type = this.resolveType((m[3] || "").trim(), classname, analyser);
          pdoc.description = m[4];
        } else {
          m = pdoc.body.match(/^(\{([^}]+)\}([\s]+))(\S+)(\s+[\s\S]*)$/);

          if (m) {
            pdoc.paramName = m[4].trim();
            type = this.resolveType((m[2] || "").trim(), classname, analyser);
            pdoc.description = m[5].trim();
          }
        }

        if (m) {
          var pos = type.indexOf("?");

          if (pos > -1) {
            pdoc.optional = true;
            var tmp = type.substring(pos + 1).trim();

            if (tmp) {
              pdoc.defaultValue = tmp;
            }

            type = type.substring(0, pos).trim();
          }

          var segs = type.split("|");

          if (segs.length > 1) {
            type = segs.map(str => {
              var result;
              str = str.trim();
              var pos = str.indexOf("[]");

              if (pos > -1) {
                var dims = str.substring(pos);
                result = {
                  type: str.substring(0, pos)
                };
                var count = 1;
                pos = 0;

                while (dims.length && dims.substring(pos, 2) == "[]") {
                  pos += 2;
                  count++;
                }

                result.dimensions = count;
              } else {
                result = str;
              }

              return result;
            });
          }

          pdoc.type = type;
        } else {
          delete pdoc.paramName;
          delete pdoc.type;
          delete pdoc.description;
        }
      }
    }
  });
  qx.tool.compiler.jsdoc.ParamParser.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.tool.compiler.jsdoc.CommandParser": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
   *
   *    qooxdoo-compiler - node.js based replacement for the Qooxdoo python
   *    toolchain
   *
   *    https://github.com/qooxdoo/qooxdoo-compiler
   *
   *    Copyright:
   *      2011-2017 Zenesis Limited, http://www.zenesis.com
   *
   *    License:
   *      MIT: https://opensource.org/licenses/MIT
   *
   *      This software is provided under the same licensing terms as Qooxdoo,
   *      please see the LICENSE file in the Qooxdoo project's top-level directory
   *      for details.
   *
   *    Authors:
   *      * John Spackman (john.spackman@zenesis.com, @johnspackman)
   *
   * *********************************************************************** */

  /**
   * Parser for JSDoc "@return"
   */
  qx.Class.define("qx.tool.compiler.jsdoc.ReturnParser", {
    extend: qx.tool.compiler.jsdoc.CommandParser,
    members: {
      parseCommand: function (pdoc, classname, analyser) {
        var m = pdoc.body.match(/^(\{([^}]+)\}([\s\S]+)?)?$/);

        if (m) {
          pdoc.type = this.resolveType((m[2] || "").trim(), classname, analyser);
          pdoc.description = m[3] || "";
        } else {
          delete pdoc.type;
          delete pdoc.description;
        }
      }
    }
  });
  qx.tool.compiler.jsdoc.ReturnParser.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.tool.compiler.jsdoc.CommandParser": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
   *
   *    qooxdoo-compiler - node.js based replacement for the Qooxdoo python
   *    toolchain
   *
   *    https://github.com/qooxdoo/qooxdoo-compiler
   *
   *    Copyright:
   *      2011-2017 Zenesis Limited, http://www.zenesis.com
   *
   *    License:
   *      MIT: https://opensource.org/licenses/MIT
   *
   *      This software is provided under the same licensing terms as Qooxdoo,
   *      please see the LICENSE file in the Qooxdoo project's top-level directory
   *      for details.
   *
   *    Authors:
   *      * John Spackman (john.spackman@zenesis.com, @johnspackman)
   *
   * *********************************************************************** */

  /**
   * Parser for JSDoc "@return"
   */
  qx.Class.define("qx.tool.compiler.jsdoc.ThrowsParser", {
    extend: qx.tool.compiler.jsdoc.CommandParser,
    members: {
      parseCommand: function (pdoc, classname, analyser) {
        var m = pdoc.body.match(/^(\{([^}]+)\}([\s\S]+)?)?$/);

        if (m) {
          pdoc.type = this.resolveType((m[2] || "").trim(), classname, analyser);
          pdoc.description = m[3] || "";
        } else {
          delete pdoc.type;
          delete pdoc.description;
        }
      }
    }
  });
  qx.tool.compiler.jsdoc.ThrowsParser.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.tool.compiler.jsdoc.CommandParser": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
   *
   *    qooxdoo-compiler - node.js based replacement for the Qooxdoo python
   *    toolchain
   *
   *    https://github.com/qooxdoo/qooxdoo-compiler
   *
   *    Copyright:
   *      2011-2017 Zenesis Limited, http://www.zenesis.com
   *
   *    License:
   *      MIT: https://opensource.org/licenses/MIT
   *
   *      This software is provided under the same licensing terms as Qooxdoo,
   *      please see the LICENSE file in the Qooxdoo project's top-level directory
   *      for details.
   *
   *    Authors:
   *      * John Spackman (john.spackman@zenesis.com, @johnspackman)
   *
   * *********************************************************************** */

  /**
   * Parser for JSDoc "@param"
   */
  qx.Class.define("qx.tool.compiler.jsdoc.ChildControlParser", {
    extend: qx.tool.compiler.jsdoc.CommandParser,
    members: {
      parseCommand: function (pdoc, classname, analyser) {
        var m = pdoc.body.match(/^([\S]+)(\s+\{([^}]+)\}([\s\S]+))??$/);

        if (m) {
          pdoc.controlName = m[1].trim();
          var type = this.resolveType((m[3] || "").trim(), classname, analyser);
          pdoc.description = (m[4] || "").trim();
          pdoc.type = type;
        } else {
          delete pdoc.controlName;
          delete pdoc.type;
          delete pdoc.description;
        }
      }
    }
  });
  qx.tool.compiler.jsdoc.ChildControlParser.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "require": true
      },
      "qx.tool.compiler.Console": {},
      "qx.tool.compiler.jsdoc.ParamParser": {
        "usage": "dynamic",
        "require": true
      },
      "qx.tool.compiler.jsdoc.ReturnParser": {
        "usage": "dynamic",
        "require": true
      },
      "qx.tool.compiler.jsdoc.ThrowsParser": {
        "usage": "dynamic",
        "require": true
      },
      "qx.tool.compiler.jsdoc.ChildControlParser": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
   *
   *    qooxdoo-compiler - node.js based replacement for the Qooxdoo python
   *    toolchain
   *
   *    https://github.com/qooxdoo/qooxdoo-compiler
   *
   *    Copyright:
   *      2011-2017 Zenesis Limited, http://www.zenesis.com
   *
   *    License:
   *      MIT: https://opensource.org/licenses/MIT
   *
   *      This software is provided under the same licensing terms as Qooxdoo,
   *      please see the LICENSE file in the Qooxdoo project's top-level directory
   *      for details.
   *
   *    Authors:
   *      * John Spackman (john.spackman@zenesis.com, @johnspackman)
   *
   * *********************************************************************** */
  const showdown = require("showdown");
  /**
   * JSDoc Parser
   */


  qx.Class.define("qx.tool.compiler.jsdoc.Parser", {
    extend: qx.core.Object,
    statics: {
      /**
       * Parses a JSDoc comment, returns an object where the keys are the name of the JSDoc (eg "@description")
       * and the value are an array of objects, one for each entry that was found.  The individual entries
       * consist of the name, the body of the JSDoc entry, and optional, key-specific parsed data (where supported)
       */
      parseComment: function (comment) {
        /* 
           JSDoc starts with /**
           babel parses this to * - the comment starting end ending is striped
           So whe have to test for valid JSDoc comment.
        */
        comment = comment.trim();

        if (!(comment.startsWith("* ") || comment.startsWith("*\n") || comment.startsWith("*\r"))) {
          return {};
        }

        var current = {
          name: "@description",
          body: ""
        };
        var cmds = [current]; // special handling for code section

        comment = comment.replace(/@([^@}\n\r]*)@/g, "<code>$1</code>"); // Strip optional leading * 

        comment = comment.replace(/^[ \t]*\*/mg, ""); // special handling for as markdown lists - * in qooxdoo

        comment = comment.replace(/^\s*\*/mg, "*");
        comment = comment.replace(/^\s*\*\*\*\*/mg, "\t\t\t*");
        comment = comment.replace(/^\s*\*\*\*/mg, "\t\t*");
        comment = comment.replace(/^\s*\*\*/mg, "\t*");
        comment = comment.split("\n");
        comment.forEach(function (line) {
          line = line.trimRight();

          if (!line) {
            return;
          } // Strip trailing single line comment


          let m = line.match(/(^.*)([^:]\/\/.*)$/);

          if (m) {
            line = m[1].trimRight();
          } // Look for command at the beginning of the line


          m = line.match(/^\s*(\@[a-zA-Z0-9_]+)(.*)$/);

          if (!m) {
            // Clean starting * as markdown lists
            if (current.body.length) {
              current.body += "\n";
            }

            current.body += line;
            return;
          }

          var name = m[1];
          var body = m[2]; // Patch common command names

          if (name == "@returns") {
            name = "@return";
          }

          if (name == "@throw") {
            name = "@throws";
          } // store it


          current = {
            name: name,
            body: body
          };
          cmds.push(current);
        });
        var result = {};
        let converter = new showdown.Converter();
        cmds.forEach(function (cmd) {
          if (cmd.name === "@description") {
            try {
              cmd.body = converter.makeHtml(cmd.body);
            } catch (e) {
              if (qx.tool.compiler.Console.getInstance().isVerbose()) {
                qx.tool.compiler.Console.info(`
              Markdown conversion problem: 
              Error "${e.message}" was thrown parsing 
              "${cmd.body.trim()}". 
              Please review your doc comments for compatibility with Markdown syntax.
              `);
              }
            }
          } else {
            // If the body is surrounded by parameters, remove them
            let m = cmd.body.match(/^\s*\(([\s\S]*)\)\s*$/m);

            if (m) {
              cmd.body = m[1];
            }

            cmd.body = cmd.body.trim();
          }

          if (result[cmd.name]) {
            result[cmd.name].push(cmd);
          } else {
            result[cmd.name] = [cmd];
          }
        });
        return result;
      },
      parseJsDoc: function (jsdoc, classname, analyser) {
        for (var key in jsdoc) {
          var parser = this.__P_29_0[key];

          if (parser) {
            jsdoc[key].forEach(pdoc => parser.parseCommand(pdoc, classname, analyser));
          }
        }
      },
      __P_29_0: {
        "@param": new qx.tool.compiler.jsdoc.ParamParser(),
        "@return": new qx.tool.compiler.jsdoc.ReturnParser(),
        "@throws": new qx.tool.compiler.jsdoc.ThrowsParser(),
        "@throw": new qx.tool.compiler.jsdoc.ThrowsParser(),
        "@childControl": new qx.tool.compiler.jsdoc.ChildControlParser()
      }
    }
  });
  qx.tool.compiler.jsdoc.Parser.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /**
   * A Part collects together all of the javascript files required for a single
   * part (load on demand) and merges them together as required.
   */
  qx.Class.define("qx.tool.compiler.targets.meta.Part", {
    extend: qx.core.Object,

    /**
     * Constructor
     * 
     * @param target {Target} the target doing the compilation
     * @param name {String} the name of the part
     * @param partIndex {Integer}
     */
    construct(target, name, partIndex) {
      qx.core.Object.constructor.call(this);
      this.__P_45_0 = target;
      this.__P_45_1 = name;
      this.__P_45_2 = partIndex;
      this.__P_45_3 = [];
      this.__P_45_4 = {};
    },

    members: {
      __P_45_0: null,
      __P_45_1: null,
      __P_45_2: -1,
      __P_45_3: null,
      __P_45_4: null,

      addPackage(pkg) {
        if (!this.__P_45_4[pkg.toHashCode()]) {
          this.__P_45_3.push(pkg);

          this.__P_45_4[pkg.toHashCode()] = pkg;
        }
      },

      hasPackage(pkg) {
        return Boolean(this.__P_45_4[pkg.toHashCode()]);
      },

      getDefaultPackage() {
        return this.__P_45_3[0] || null;
      },

      serializeInto(parts) {
        let arr = parts[this.__P_45_1] = [];

        this.__P_45_3.forEach(pkg => arr.push(String(pkg.getPackageIndex())));
      }

    }
  });
  qx.tool.compiler.targets.meta.Part.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.tool.compiler.targets.meta.PackageJavascript": {
        "construct": true
      },
      "qx.lang.Type": {},
      "qx.lang.Array": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  const path = require("upath");
  /**
   * A Package is a collection of files and resources, used by either the boot process
   * or by one or more Parts
   */


  qx.Class.define("qx.tool.compiler.targets.meta.Package", {
    extend: qx.core.Object,

    /**
     * Constructor
     */
    construct(appMeta, packageIndex) {
      qx.core.Object.constructor.call(this);
      this.__P_43_0 = appMeta;
      this.__P_43_1 = packageIndex;
      this.__P_43_2 = [];
      this.__P_43_3 = {};
      this.__P_43_4 = {};
      this.__P_43_5 = [];
      this.__P_43_6 = [];
      this.__P_43_7 = new qx.tool.compiler.targets.meta.PackageJavascript(this.__P_43_0, this);
    },

    properties: {
      /** Whether to embed all the javascript into the one, main package .js file */
      embedAllJavascript: {
        init: false,
        check: "Boolean"
      },

      /** If true, this is generated on the fly and needs to be output */
      needsWriteToDisk: {
        init: true,
        check: "Boolean",
        apply: "_applyNeedsWriteToDisk"
      }
    },
    members: {
      /** @type {AppMeta} the AppMeta instance */
      __P_43_0: null,

      /** @type {Integer} the package index, 0 == boot package */
      __P_43_1: -1,

      /** @type {qx.tool.compiler.resources.Asset[]} assets to be included in this package */
      __P_43_2: null,

      /** @type {Map} locale data, indexed by locale ID */
      __P_43_3: null,

      /** @type {Map} translations, indexed by message ID */
      __P_43_4: null,

      /** @type {String[]} array of class names loaded by this package */
      __P_43_6: null,

      /** @type {AbstractJavascriptMeta[]} array of Javascript sources loaded by this package */
      __P_43_5: null,

      /** @type {AbstractJavascriptMeta} the javascript generated by this package */
      __P_43_7: null,

      /**
       * Detects whether this package is empty; packages can be added for a number
       * of reasons, but sometimes they don't actually end up with anything in them.
       * 
       * Note that this is used to suppress the generation of an additional `package-*.js`
       * file in the output, and just means that the content of the file should be embedded
       * (or ignored) instead of written into that package file; however, there can still
       * be script files which need to be loaded by this package (and that is handled by
       * the index.js file) 
       * 
       * @return {Boolean}
       */
      isEmpty() {
        if (this.__P_43_2.length > 0) {
          return false;
        }

        for (let localeId in this.__P_43_3) {
          if (this.__P_43_3[localeId]) {
            return false;
          }
        }

        for (let localeId in this.__P_43_4) {
          if (this.__P_43_4[localeId]) {
            return false;
          }
        }

        if (this.isEmbedAllJavascript()) {
          if (this.__P_43_5.length > 0) {
            return false;
          }
        }

        return true;
      },

      /**
       * Returns the package index
       * 
       * @return {Integer}
       */
      getPackageIndex() {
        return this.__P_43_1;
      },

      /**
       * Adds an asset, expected to be unique
       * 
       * @param asset {qx.tool.compiler.resources.Asset}
       */
      addAsset(asset) {
        this.__P_43_2.push(asset);
      },

      /**
       * Returns the array of assets
       * 
       * @return {qx.tool.compiler.resources.Asset[]}
       */
      getAssets() {
        return this.__P_43_2;
      },

      /**
       * Adds locale data
       * 
       * @param localeId {String}
       * @param localeData {Object}
       */
      addLocale(localeId, localeData) {
        this.__P_43_3[localeId] = localeData;
      },

      /**
       * Returns locale data, as a map where the key is the locale ID
       * 
       * @return {Map}
       */
      getLocales() {
        return this.__P_43_3;
      },

      /**
       * Adds a translation
       * 
       * @param localeId {String} locale ID
       * @param entry {Object} translation
       */
      addTranslationEntry(localeId, entry) {
        let translations = this.__P_43_4[localeId];

        if (!translations) {
          this.__P_43_4[localeId] = translations = {};
        }

        var msgstr = entry.msgstr;

        if (!qx.lang.Type.isArray(msgstr)) {
          msgstr = [msgstr];
        }

        if (msgstr[0]) {
          translations[entry.msgid] = msgstr[0];
        }

        if (entry.msgid_plural && msgstr[1]) {
          translations[entry.msgid_plural] = msgstr[1];
        }
      },

      /**
       * Returns a map of all translations, indexed by Locale ID
       * 
       * @return {Object}
       */
      getTranslations() {
        return this.__P_43_4;
      },

      /**
       * Adds a Javascript to be loaded by this package.  You typically need to
       * call `addClassname` also.
       * 
       * @param jsMeta {AbstractJavascriptMeta}
       */
      addJavascriptMeta(jsMeta) {
        this.__P_43_5.push(jsMeta);
      },

      /**
       * Returns a list of all Javascripts to be loaded by this package
       * 
       * @return {AbstractJavascriptMeta[]}
       */
      getJavascriptMetas() {
        return this.__P_43_5;
      },

      /**
       * Removes a Javascript
       * 
       * @param jsMeta {AbstractJavascriptMeta} the javascript to remove
       */
      removeJavascriptMeta(jsMeta) {
        qx.lang.Array.remove(this.__P_43_5, jsMeta);
      },

      /**
       * Adds a classname to the list which is loaded by this package; this does not
       * cause the code to be loaded, @see {addJavascriptMeta}.
       * 
       * @param classname {String}
       */
      addClassname(classname) {
        this.__P_43_6.push(classname);
      },

      /**
       * Returns a list of all classnames
       * 
       * @return {String[]}
       */
      getClassnames() {
        return this.__P_43_6;
      },

      /**
       * Returns the AbstractJavascriptMeta for this Package
       * 
       * @return {AbstractJavascriptMeta}
       */
      getJavascript() {
        return this.__P_43_7;
      },

      /**
       * Writes the data into the configuration which is passed to the loader template
       * 
       * @param packages {Object} the `qx.$$packages` object data
       */
      serializeInto(packages) {
        let data = packages[String(this.__P_43_1)] = {
          uris: []
        };

        let appRoot = this.__P_43_0.getApplicationRoot();

        if (!this.isEmbedAllJavascript()) {
          data.uris = this.__P_43_5.map(js => path.relative(appRoot, js.getFilename()));
        }

        if (this.isNeedsWriteToDisk()) {
          data.uris.unshift(path.relative(appRoot, this.__P_43_7.getFilename()));
        }
      },

      /**
       * Apply for needsWriteToDisk property
       */
      _applyNeedsWriteToDisk(value) {
        this.__P_43_7.setNeedsWriteToDisk(value);
      }

    }
  });
  qx.tool.compiler.targets.meta.Package.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.tool.utils.LogManager": {
        "usage": "dynamic",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.tool.compiler.resources.ImageLoader": {
        "construct": true
      },
      "qx.tool.compiler.resources.MetaLoader": {
        "construct": true
      },
      "qx.tool.compiler.resources.ScssConverter": {
        "construct": true
      },
      "qx.tool.compiler.resources.ScssIncludeConverter": {
        "construct": true
      },
      "qx.tool.utils.Json": {},
      "qx.tool.utils.Values": {},
      "qx.lang.Type": {},
      "qx.Promise": {},
      "qx.tool.utils.files.Utils": {},
      "qx.tool.compiler.resources.Asset": {},
      "qx.tool.utils.Promisify": {},
      "qx.lang.Array": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
   *
   *    qooxdoo-compiler - node.js based replacement for the Qooxdoo python
   *    toolchain
   *
   *    https://github.com/qooxdoo/qooxdoo-compiler
   *
   *    Copyright:
   *      2011-2017 Zenesis Limited, http://www.zenesis.com
   *
   *    License:
   *      MIT: https://opensource.org/licenses/MIT
   *
   *      This software is provided under the same licensing terms as Qooxdoo,
   *      please see the LICENSE file in the Qooxdoo project's top-level directory
   *      for details.
   *
   *    Authors:
   *      * John Spackman (john.spackman@zenesis.com, @johnspackman)
   *
   * *********************************************************************** */

  /* eslint-disable @qooxdoo/qx/no-illegal-private-usage */
  var path = require("upath");

  var log = qx.tool.utils.LogManager.createLog("resource-manager");
  /**
   * Analyses library resources, collecting information into a cached database
   * file
   */

  qx.Class.define("qx.tool.compiler.resources.Manager", {
    extend: qx.core.Object,

    /**
     * Constructor
     *
     * @param analyser {qx.tool.compiler.Analyser}
     */
    construct: function (analyser) {
      qx.core.Object.constructor.call(this);
      this.__P_35_0 = analyser;
      this.__P_35_1 = analyser.getResDbFilename() || "resource-db.json";
      this.__P_35_2 = [new qx.tool.compiler.resources.ImageLoader(), new qx.tool.compiler.resources.MetaLoader()];
      this.__P_35_3 = [new qx.tool.compiler.resources.ScssConverter(), new qx.tool.compiler.resources.ScssIncludeConverter()];
    },
    members: {
      /** {String} filename of database */
      __P_35_1: null,

      /** {Object} Database */
      __P_35_4: null,

      /** the used analyser */
      __P_35_0: null,

      /** {Map{String,Library}} Lookup of libraries, indexed by resource URI */
      __P_35_5: null,

      /** {String[]} Array of all resource URIs, sorted alphabetically (ie these are the keys in __librariesByResourceUri) */
      __P_35_6: null,

      /** {ResourceLoader[]} list of resource loaders, used to add info to the database */
      __P_35_2: null,

      /** {ResourceConverter[]} list of resource converters, used to copy resources to the target */
      __P_35_3: null,

      /**
       * Loads the cached database
       */
      async loadDatabase() {
        this.__P_35_4 = (await qx.tool.utils.Json.loadJsonAsync(this.__P_35_1)) || {};
      },

      /**
       * Saves the database
       */
      async saveDatabase() {
        log.debug("saving resource manager database");
        return qx.tool.utils.Json.saveJsonAsync(this.__P_35_1, this.__P_35_4);
      },

      /**
       * Returns the loaded database
       *
       * @returns
       */
      getDatabase: function () {
        return this.__P_35_4;
      },

      /**
       * Finds the library needed for a resource, see `findLibrariesForResource`.  This reports
       * an error if more than one library is found.
       *
       * @param uri {String} URI
       * @return {Library[]} the libraries, empty list if not found
       */
      findLibraryForResource: function (uri) {
        let result = this.findLibrariesForResource(uri);

        if (result.length == 0) {
          return null;
        }

        if (result.length > 1) {
          this.error(`Cannot determine a single library for the URI '${uri}'; ` + `found ${result.map(l => l.getNamespace()).join(",")} returning first library`);
        }

        return result[0];
      },

      /**
       * Finds the libraries needed for a resource; this depends on `findAllResources` having
       * already been called.  `uri` can include optional explicit namespace (eg "qx:blah/blah.png"),
       * otherwise the library resource lookups are examined to find the library.
       * 
       * Note that there can be more than one directory because the lookup holds directory names (used
       * for wildcards) and they are allowed to be duplicated.
       *
       * @param uri {String} URI
       * @return {Library[]} the libraries, empty list if not found
       */
      findLibrariesForResource: function (uri) {
        const findLibrariesForResourceImpl = () => {
          var ns;
          var pos; // check for absolute path first, in windows c:/ is a valid absolute name

          if (path.isAbsolute(uri)) {
            let library = this.__P_35_0.getLibraries().find(lib => uri.startsWith(path.resolve(lib.getRootDir())));

            return library || null;
          } // Explicit library?


          pos = uri.indexOf(":");

          if (pos !== -1) {
            ns = uri.substring(0, pos);

            let library = this.__P_35_0.findLibrary(ns);

            return library || null;
          } // Non-wildcards are a direct lookup
          // check for $ and *. less pos wins
          // fix for https://github.com/qooxdoo/qooxdoo-compiler/issues/260


          var pos1 = uri.indexOf("$"); // Variable references are effectively a wildcard lookup

          var pos2 = uri.indexOf("*");

          if (pos1 === -1) {
            pos = pos2;
          } else if (pos2 === -1) {
            pos = pos1;
          } else {
            pos = Math.min(pos1, pos2);
          }

          if (pos === -1) {
            let library = this.__P_35_5[uri] || null;
            return library;
          } // Strip wildcard


          var isFolderMatch = uri[pos - 1] === "/";
          uri = uri.substring(0, pos - 1); // Fast folder match

          if (isFolderMatch) {
            let library = this.__P_35_5[uri] || null;
            return library;
          } // Slow scan


          if (!this.__P_35_6) {
            this.__P_35_6 = Object.keys(this.__P_35_5).sort();
          }

          var thisUriPos = qx.tool.utils.Values.binaryStartsWith(this.__P_35_6, uri);

          if (thisUriPos > -1) {
            let libraries = {};

            for (; thisUriPos < this.__P_35_6.length; thisUriPos++) {
              var thisUri = this.__P_35_6[thisUriPos];

              if (!thisUri.startsWith(uri)) {
                break;
              }

              pos = uri.indexOf(":");

              if (pos !== -1) {
                ns = uri.substring(0, pos);

                if (!libraries[ns]) {
                  libraries[ns] = this.__P_35_0.findLibrary(ns);
                }
              }
            }

            return Object.values(libraries);
          }

          return null;
        };

        let result = findLibrariesForResourceImpl();

        if (!result) {
          return [];
        }

        if (!qx.lang.Type.isArray(result)) {
          return [result];
        }

        return result;
      },

      /**
       * Scans all libraries looking for resources; this does not analyse the
       * files, simply compiles the list
       */
      async findAllResources() {
        var t = this;
        var db = this.__P_35_4;

        if (!db.resources) {
          db.resources = {};
        }

        t.__P_35_5 = {};
        this.__P_35_6 = null;
        this.__P_35_7 = {};
        await qx.Promise.all(t.__P_35_0.getLibraries().map(async library => {
          var resources = db.resources[library.getNamespace()];

          if (!resources) {
            db.resources[library.getNamespace()] = resources = {};
          }

          var unconfirmed = {};

          for (let relFile in resources) {
            unconfirmed[relFile] = true;
          }

          const scanResources = async resourcePath => {
            // If the root folder exists, scan it
            var rootDir = path.join(library.getRootDir(), library.get(resourcePath));
            await qx.tool.utils.files.Utils.findAllFiles(rootDir, async filename => {
              var relFile = filename.substring(rootDir.length + 1).replace(/\\/g, "/");
              var fileInfo = resources[relFile];
              delete unconfirmed[relFile];

              if (!fileInfo) {
                fileInfo = resources[relFile] = {};
              }

              fileInfo.resourcePath = resourcePath;
              fileInfo.mtime = await qx.tool.utils.files.Utils.safeStat(filename).mtime;
              let asset = new qx.tool.compiler.resources.Asset(library, relFile, fileInfo);

              this.__P_35_8(asset);
            });
          };

          await scanResources("resourcePath");
          await scanResources("themePath"); // Check the unconfirmed resources to make sure that they still exist;
          //  delete from the database if they don't

          await qx.Promise.all(Object.keys(unconfirmed).map(async filename => {
            let fileInfo = resources[filename];

            if (!fileInfo) {
              delete resources[filename];
            } else {
              let stat = await qx.tool.utils.files.Utils.safeStat(filename);

              if (!stat) {
                delete resources[filename];
              }
            }
          }));
        }));
        await qx.tool.utils.Promisify.poolEachOf(Object.values(this.__P_35_7), 10, async asset => {
          await asset.load();
          let fileInfo = asset.getFileInfo();

          if (fileInfo.meta) {
            for (var altPath in fileInfo.meta) {
              let lib = this.findLibraryForResource(altPath);

              if (!lib) {
                lib = asset.getLibrary();
              }

              let otherAsset = this.__P_35_7[lib.getNamespace() + ":" + altPath];

              if (otherAsset) {
                otherAsset.addMetaReferee(asset);
                asset.addMetaReferTo(otherAsset);
              } else {
                this.warn("Cannot find asset " + altPath + " referenced in " + asset);
              }
            }
          }

          if (fileInfo.dependsOn) {
            let dependsOn = [];
            fileInfo.dependsOn.forEach(str => {
              let otherAsset = this.__P_35_7[str];

              if (!otherAsset) {
                this.warn("Cannot find asset " + str + " depended on by " + asset);
              } else {
                dependsOn.push(otherAsset);
              }
            });

            if (dependsOn.length) {
              asset.setDependsOn(dependsOn);
            }
          }

          return null;
        });
      },

      /**
       * Adds an asset
       * 
       * @param asset {Asset} the asset to add
       */
      __P_35_8(asset) {
        this.__P_35_7[asset.toUri()] = asset;
        let library = asset.getLibrary();
        let filename = asset.getFilename();
        let tmp = "";
        filename.split("/").forEach((seg, index) => {
          if (index) {
            tmp += "/";
          }

          tmp += seg;
          let current = this.__P_35_5[tmp];

          if (current) {
            if (qx.lang.Type.isArray(current)) {
              if (!qx.lang.Array.contains(current, library)) {
                current.push(library);
              }
            } else if (current !== library) {
              current = this.__P_35_5[tmp] = [current, library];
            }
          } else {
            this.__P_35_5[tmp] = library;
          }
        });
        asset.setLoaders(this.__P_35_2.filter(loader => loader.matches(filename)));
        asset.setConverters(this.__P_35_3.filter(converter => converter.matches(filename)));
      },

      /**
       * Gets an individual asset
       * 
       * @param srcPath {String} the resource name, with or without a namespace prefix
       * @param create {Boolean?} if true the asset will be created if it does not exist
       * @return {Asset?} the asset, if found
       */
      getAsset(srcPath, create) {
        let library = this.findLibraryForResource(srcPath);

        if (!library) {
          this.warn("Cannot find library for " + srcPath);
          return null;
        }

        let resourceDir = path.join(library.getRootDir(), library.getResourcePath());
        srcPath = path.relative(resourceDir, path.isAbsolute(srcPath) ? srcPath : path.join(resourceDir, srcPath));

        let asset = this.__P_35_7[library.getNamespace() + ":" + srcPath];

        if (!asset && create) {
          asset = new qx.tool.compiler.resources.Asset(library, srcPath, {
            resourcePath: "resourcePath"
          });

          this.__P_35_8(asset);
        }

        return asset;
      },

      /**
       * Collects information about the assets listed in srcPaths;
       * 
       * @param srcPaths
       * @return {Asset[]}
       */
      getAssetsForPaths(srcPaths) {
        var db = this.__P_35_4; // Generate a lookup that maps the resource name to the meta file that
        //  contains the composite

        var metas = {};

        for (var libraryName in db.resources) {
          var libraryData = db.resources[libraryName];

          for (var resourcePath in libraryData) {
            var fileInfo = libraryData[resourcePath];

            if (!fileInfo.meta) {
              continue;
            }

            for (var altPath in fileInfo.meta) {
              metas[altPath] = resourcePath;
            }
          }
        }

        var assets = [];
        var assetPaths = {};
        srcPaths.forEach(srcPath => {
          let pos = srcPath.indexOf(":");
          let libraries = null;

          if (pos > -1) {
            let ns = srcPath.substring(0, pos);

            let tmp = this.__P_35_0.findLibrary(ns);

            libraries = tmp ? [tmp] : [];
            srcPath = srcPath.substring(pos + 1);
          } else {
            libraries = this.findLibrariesForResource(srcPath);
          }

          if (libraries.length == 0) {
            this.warn("Cannot find library for " + srcPath);
            return;
          }

          libraries.forEach(library => {
            let libraryData = db.resources[library.getNamespace()];
            pos = srcPath.indexOf("*");
            let resourceNames = [];

            if (pos > -1) {
              srcPath = srcPath.substring(0, pos);
              resourceNames = Object.keys(libraryData).filter(resourceName => resourceName.substring(0, srcPath.length) === srcPath);
            } else if (libraryData[srcPath]) {
              resourceNames = [srcPath];
            }

            resourceNames.forEach(resourceName => {
              if (assetPaths[resourceName] !== undefined) {
                return;
              }

              let asset = this.__P_35_7[library.getNamespace() + ":" + resourceName];

              let fileInfo = asset.getFileInfo();

              if (fileInfo.doNotCopy === true) {
                return;
              }

              (asset.getMetaReferees() || []).forEach(meta => {
                // Extract the fragment from the meta data for this particular resource
                var resMetaData = meta.getFileInfo().meta[resourceName];
                fileInfo.composite = resMetaData[3];
                fileInfo.x = resMetaData[4];
                fileInfo.y = resMetaData[5];
              });
              assets.push(asset);
              assetPaths[resourceName] = assets.length - 1;
            });
          });
        });
        return assets;
      }

    }
  });
  qx.tool.compiler.resources.Manager.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.tool.utils.LogManager": {
        "usage": "dynamic",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.tool.utils.files.Utils": {},
      "qx.lang.Type": {},
      "qx.tool.utils.Promisify": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
   *
   *    qooxdoo-compiler - node.js based replacement for the Qooxdoo python
   *    toolchain
   *
   *    https://github.com/qooxdoo/qooxdoo-compiler
   *
   *    Copyright:
   *      2011-2017 Zenesis Limited, http://www.zenesis.com
   *
   *    License:
   *      MIT: https://opensource.org/licenses/MIT
   *
   *      This software is provided under the same licensing terms as Qooxdoo,
   *      please see the LICENSE file in the Qooxdoo project's top-level directory
   *      for details.
   *
   *    Authors:
   *      * John Spackman (john.spackman@zenesis.com, @johnspackman)
   *
   * *********************************************************************** */
  var fs = require("fs");

  const {
    promisify
  } = require("util");

  const readFile = promisify(fs.readFile);
  var log = qx.tool.utils.LogManager.createLog("translation");
  /**
   * Reads and writes .po files for translation
   */

  qx.Class.define("qx.tool.compiler.app.Translation", {
    extend: qx.core.Object,

    /**
     * Constructor
     * @param library {Library}
     * @param locale {String}
     */
    construct: function (library, locale) {
      qx.core.Object.constructor.call(this);
      this.setLibrary(library);

      if (locale) {
        this.setLocale(locale);
      }

      this.__P_27_0 = {};
      this.__P_27_1 = {};
    },
    properties: {
      /** The library that this translation is for */
      library: {
        nullable: false,
        check: "qx.tool.compiler.app.Library"
      },

      /** The locale */
      locale: {
        init: "en",
        nullable: false,
        check: "String"
      },

      /** Whether to write line numbers to .po files */
      writeLineNumbers: {
        init: false,
        check: "Boolean"
      }
    },
    members: {
      __P_27_0: null,
      __P_27_1: null,
      __P_27_2: 0,
      __P_27_3: null,

      /**
       * Filename for the .po file
       * @returns {string}
       */
      getPoFilename: function () {
        var library = this.getLibrary();
        return library.getRootDir() + "/" + library.getTranslationPath() + "/" + this.getLocale() + ".po";
      },

      /**
       * Reads the .po file, but only if it has not been loaded or has changed
       *
       * @returns {Promise}|
       */
      checkRead: async function () {
        if (!this.__P_27_2) {
          return this.read();
        }

        var poFile = this.getPoFilename();
        let stat = await qx.tool.utils.files.Utils.safeStat(poFile);

        if (stat && this.__P_27_2 == stat.mtime) {
          return undefined;
        }

        return this.read();
      },

      /**
       * Reads the .po file
       */
      read: function () {
        var t = this;

        if (t.__P_27_3) {
          return t.__P_27_3;
        }

        return t.__P_27_3 = new Promise((resolve, reject) => {
          t.__P_27_0 = {};
          t.__P_27_1 = {};
          var poFile = this.getPoFilename();
          fs.stat(poFile, function (err, stat) {
            if (err) {
              if (err.code == "ENOENT") {
                resolve();
                return undefined;
              }

              reject(err);
              return undefined;
            }

            t.__P_27_2 = stat.mtime;
            return readFile(poFile, {
              encoding: "utf8"
            }).then(data => {
              var entry = null;
              var lastKey = null;

              function saveEntry() {
                if (entry) {
                  var key;

                  if (entry.msgctxt) {
                    key = entry.msgctxt + ":" + entry.msgid;
                  } else {
                    key = entry.msgid;
                  }

                  t.__P_27_0[key] = entry;
                }

                entry = null;
                lastKey = null;
              }

              function set(key, value, append) {
                var index = null;
                var m = key.match(/^([^[]+)\[([0-9]+)\]$/);
                value = value.replace(/\\t/g, "\t").replace(/\\r/g, "\r").replace(/\\n/g, "\n").replace(/\\"/g, "\"");

                if (m) {
                  key = m[1];
                  index = parseInt(m[2]);

                  if (entry[key] === undefined) {
                    entry[key] = [];
                  }

                  if (!append || typeof entry[key][index] !== "string") {
                    entry[key][index] = value;
                  } else {
                    entry[key][index] += value;
                  }
                } else if (!append || typeof entry[key] !== "string") {
                  entry[key] = value;
                } else {
                  entry[key] += value;
                }
              }

              data.split("\n").forEach(function (line, lineNo) {
                line = line.trim();

                if (!line) {
                  saveEntry();
                  return;
                }

                if (!entry) {
                  entry = {};
                } // Comment?


                var m = line.match(/^#([^ ]?) (.*)$/);

                if (m) {
                  var type = m[1];
                  var comment = m[2];
                  var key;

                  if (!entry.comments) {
                    entry.comments = {};
                  }

                  switch (type) {
                    case "":
                      entry.comments.translator = comment;
                      break;

                    case ".":
                      entry.comments.extracted = comment;
                      break;

                    case ":":
                      if (!entry.comments.reference) {
                        entry.comments.reference = {};
                      }

                      {
                        const ref = entry.comments.reference;
                        (comment && comment.match(/[\w/\.]+:\d+/g) || []).forEach(entry => {
                          const split = entry.split(":");
                          const classname = split[0];
                          const lineNo = parseInt(split[1], 10);

                          if (!ref[classname]) {
                            ref[classname] = [lineNo];
                          } else if (!ref[classname].includes(lineNo)) {
                            ref[classname].push(lineNo);
                          }
                        });
                      }
                      break;

                    case ",":
                      entry.comments.flags = comment.split(",");
                      break;

                    case "|":
                      m = comment.match(/^([^\s]+)\s+(.*)$/);

                      if (m) {
                        if (!entry.previous) {
                          entry.previous = {};
                        }

                        var tmp = m[1];

                        if (tmp == "msgctxt" || tmp == "msgid") {
                          entry[tmp] = m[2];
                        } else {
                          log.warn("Cannot interpret line " + (lineNo + 1));
                        }
                      } else {
                        log.warn("Cannot interpret line " + (lineNo + 1));
                      }

                      break;
                  }

                  return;
                }

                if (line[0] == "\"" && line[line.length - 1] == "\"") {
                  line = line.substring(1, line.length - 1);

                  if (!lastKey.match(/^.*\[\d+\]$/) && (lastKey === null || entry[lastKey] === undefined)) {
                    log.error("Cannot interpret line because there is no key to append to, line " + (lineNo + 1));
                  } else {
                    set(lastKey, line, true);
                  }

                  return;
                } // Part of the translation


                if (line == "#") {
                  return;
                }

                m = line.match(/^([^\s]+)\s+(.*)$/);

                if (!m) {
                  log.warn("Cannot interpret line " + (lineNo + 1));
                  return;
                }

                key = lastKey = m[1];
                var value = m[2];

                if (value.length >= 2 && value[0] == "\"" && value[value.length - 1] == "\"") {
                  value = value.substring(1, value.length - 1);
                  set(key, value);
                }
              });

              if (entry) {
                saveEntry();
              }

              resolve();
            });
          });
        });
      },

      /**
       * Writes the .po file
       */
      write: async function () {
        this.writeTo(this.getPoFilename());
      },

      /**
       * Writes the .po file to a specific filename
       * @param filename {String}
       */
      writeTo: function (filename, cb) {
        var t = this;
        var lines = [];

        function write(key, value) {
          if (value === undefined || value === null) {
            return;
          }

          value = value.replace(/\t/g, "\\t").replace(/\r/g, "\\r").replace(/\n/g, "\\n").replace(/"/g, "\\\"");
          lines.push(key + " \"" + value + "\"");
        }

        for (var msgid in t.__P_27_0) {
          var entry = t.__P_27_0[msgid];

          if (entry.comments) {
            if (entry.comments.translator) {
              lines.push("# " + entry.comments.translator);
            }

            if (entry.comments.extracted) {
              lines.push("#. " + entry.comments.extracted);
            }

            if (entry.comments.reference) {
              let refStr = "#:";
              const ref = entry.comments.reference;

              for (let classname in ref) {
                if (ref[classname]) {
                  if (this.isWriteLineNumbers()) {
                    for (let lineNo of ref[classname]) {
                      const addStr = " " + classname + ":" + lineNo;

                      if (refStr.length + addStr.length > 78) {
                        // 78 is default length in python po library
                        // line break
                        lines.push(refStr);
                        refStr = "#:" + addStr;
                      } else {
                        refStr += addStr;
                      }
                    }
                  } else {
                    const addStr = " " + classname;

                    if (refStr.length + addStr.length > 78) {
                      // 78 is default length in python po library
                      // line break
                      lines.push(refStr);
                      refStr = "#:" + addStr;
                    } else {
                      refStr += addStr;
                    }
                  }
                }
              }

              if (refStr.length > 3) {
                // write remaining refStr
                lines.push(refStr);
              }
            }

            if (entry.comments.flags) {
              lines.push("#, " + entry.comments.flags.join(","));
            }
          } else {
            lines.push("#");
          }

          if (entry.msgctxt) {
            lines.push("msgctxt \"" + entry.msgctxt + "\"");
          }

          write("msgid", entry.msgid);
          write("msgid_plural", entry.msgid_plural);

          if (qx.lang.Type.isArray(entry.msgstr)) {
            entry.msgstr.forEach(function (value, index) {
              write("msgstr[" + index + "]", value);
            });
          } else if (entry.msgid_plural) {
            write("msgstr[0]", "");
            write("msgstr[1]", "");
          } else {
            write("msgstr", entry.msgstr || "");
          }

          lines.push("");
        }

        var data = lines.join("\n");
        return qx.tool.utils.Promisify.fs.writeFileAsync(filename, data, {
          encoding: "utf8"
        });
      },

      /**
       * Tests whether an entry exists and has translation values
       * 
       * @param id {String} msgid
       * @return {Boolean}
       */
      hasEntryValue(id) {
        let entry = this.getEntry(id);

        if (!entry) {
          return false;
        }

        if (qx.lang.Type.isArray(entry.msgstr)) {
          return entry.msgstr.every(value => Boolean(value));
        }

        return Boolean(entry.msgstr);
      },

      /**
       * Returns the entry with the given msgid, null if it does not exist
       * @param id
       * @returns {*|null}
       */
      getEntry: function (id) {
        return this.__P_27_0[id] || null;
      },

      /**
       * Deletes the entry with the given msgid; return the deleted value, or null if it does not exist
       * @param id
       * @returns {*|null}
       */
      deleteEntry: function (id) {
        let entry = this.__P_27_0[id] || null;
        delete this.__P_27_0[id];
        return entry;
      },

      /**
       * Returns the entry with the given msgid, creating it if it does not exist
       * @param id
       * @returns {*|null}
       */
      getOrCreateEntry: function (id) {
        var t = this;
        var entry = t.__P_27_0[id];

        if (!entry) {
          entry = t.__P_27_0[id] = {
            msgid: id
          };
        }

        return entry;
      },

      /**
       * Returns all entries
       * @returns {null}
       */
      getEntries: function () {
        return this.__P_27_0;
      },

      /**
       * Returns the translation headers
       * @returns {null}
       */
      getHeaders: function () {
        return this.__P_27_1;
      }
    }
  });
  qx.tool.compiler.app.Translation.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.tool.compiler.targets.meta.AbstractJavascriptMeta": {
        "construct": true,
        "require": true
      },
      "qx.tool.utils.Utils": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  const path = require("upath");
  /**
   * A PackageJavascript is the serialisation of the javascript required to produce a package;
   * at the minimum, this is the locales and resources provided by the package, but also can be
   * the javascript code from loaded classes, all merged into one .js file for the browser. 
   */


  qx.Class.define("qx.tool.compiler.targets.meta.PackageJavascript", {
    extend: qx.tool.compiler.targets.meta.AbstractJavascriptMeta,

    /**
     * Constructor
     */
    construct(appMeta, pkg) {
      qx.tool.compiler.targets.meta.AbstractJavascriptMeta.constructor.call(this, appMeta, `${appMeta.getApplicationRoot()}package-${pkg.getPackageIndex()}.js`);
      this.__P_44_0 = pkg;
    },

    properties: {
      needsWriteToDisk: {
        init: true,
        refine: true
      }
    },
    members: {
      __P_44_1: null,

      /*
       * @Override
       */
      async writeSourceCodeToStream(ws) {
        let pkg = this.__P_44_0;
        let data = {
          "locales": pkg.getLocales(),
          "resources": {},
          "translations": pkg.getTranslations()
        };
        pkg.getAssets().forEach(asset => {
          let ext = path.extname(asset.getFilename());

          if (ext.length) {
            ext = ext.substring(1);
          }

          let fileInfo = asset.getFileInfo();
          var arr = data.resources[asset.getFilename()] = [fileInfo.width, fileInfo.height, ext, asset.getLibrary().getNamespace()];

          if (fileInfo.composite !== undefined) {
            arr.push(fileInfo.composite);
            arr.push(fileInfo.x);
            arr.push(fileInfo.y);
          }
        });

        if (pkg.isEmbedAllJavascript()) {
          this.__P_44_1 = [];
          let strip = new qx.tool.utils.Utils.StripSourceMapTransform();
          strip.pipe(ws);
          await new Promise(async resolve => {
            for (let i = 0; i < pkg.getJavascriptMetas().length; i++) {
              let js = pkg.getJavascriptMetas()[i];

              this.__P_44_1.push(ws.getLineNumber());

              await js.unwrap().writeSourceCodeToStream(strip);
              strip.write("\n");
            }

            resolve();
          });
          ws.write(`//# sourceMappingURL=${path.basename(this.getFilename())}.map?dt=${new Date().getTime()}\n`);
        }

        ws.write(`qx.$$packageData['${this.__P_44_0.getPackageIndex()}'] = ${JSON.stringify(data, null, 2)};\n`);
      },

      /*
       * @Override
       */
      async writeToDisk() {
        await qx.tool.compiler.targets.meta.PackageJavascript.prototype.writeToDisk.base.call(this);

        if (!this.__P_44_0.isEmbedAllJavascript()) {
          for (let i = 0; i < this.__P_44_0.getJavascriptMetas().length; i++) {
            await this.__P_44_0.getJavascriptMetas()[i].unwrap().writeToDisk();
          }
        }
      },

      /*
       * @Override
       */
      async getSourceMap() {
        if (!this.__P_44_0.isEmbedAllJavascript()) {
          return null;
        }

        if (this.__P_44_1 === null) {
          throw new Error(`Cannot get the source map for ${this} until the stream has been written`);
        }

        return this._copySourceMap(this.__P_44_0.getJavascriptMetas(), this.__P_44_1);
      }

    }
  });
  qx.tool.compiler.targets.meta.PackageJavascript.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.tool.compiler.resources.AbstractMatcher": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
   *
   *    qooxdoo-compiler - node.js based replacement for the Qooxdoo python
   *    toolchain
   *
   *    https://github.com/qooxdoo/qooxdoo-compiler
   *
   *    Copyright:
   *      2011-2017 Zenesis Limited, http://www.zenesis.com
   *
   *    License:
   *      MIT: https://opensource.org/licenses/MIT
   *
   *      This software is provided under the same licensing terms as Qooxdoo,
   *      please see the LICENSE file in the Qooxdoo project's top-level directory
   *      for details.
   *
   *    Authors:
   *      * John Spackman (john.spackman@zenesis.com, @johnspackman)
   *
   * *********************************************************************** */

  /**
   * Instances of Handler are used by the resource manager to handle different types of resources that 
   *  need compilation.
   */
  qx.Class.define("qx.tool.compiler.resources.ResourceLoader", {
    extend: qx.tool.compiler.resources.AbstractMatcher,
    type: "abstract",
    members: {
      /**
       * Detects whether the file needs to be recompiled/coverted/analysed/ etc; this should
       * not take any time or be asynchronous, if you need to do any real work it should be 
       * in `compile` because that is throttled.
       * 
       * @param filename {String} absolute path to the file
       * @param fileInfo {Map?} this is the object in the resource database, contains info about the resource;
       *  this will be null if not yet in the resource database
       * @param stat {fs.Stats} Stats object from fs.stat
       * 
       * @return {Boolean}
       */
      needsLoad(filename, fileInfo, stat) {
        var mtime = null;

        try {
          mtime = fileInfo.mtime && new Date(fileInfo.mtime);
        } catch (e) {}

        return !mtime || mtime.getTime() != stat.mtime.getTime();
      },

      /**
       * Allows a file to be loadeddata can be stored in the resource database by modifying the fileInfo
       * 
       * @param asset {Asset} the asset to load
       */
      async load(asset) {
        throw new Error("No implementation for " + this.classname + ".compile");
      }

    }
  });
  qx.tool.compiler.resources.ResourceLoader.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.tool.utils.Promisify": {
        "usage": "dynamic",
        "require": true
      },
      "qx.tool.utils.LogManager": {
        "usage": "dynamic",
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.tool.compiler.resources.ResourceLoader": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
   *
   *    qooxdoo-compiler - node.js based replacement for the Qooxdoo python
   *    toolchain
   *
   *    https://github.com/qooxdoo/qooxdoo-compiler
   *
   *    Copyright:
   *      2011-2017 Zenesis Limited, http://www.zenesis.com
   *
   *    License:
   *      MIT: https://opensource.org/licenses/MIT
   *
   *      This software is provided under the same licensing terms as Qooxdoo,
   *      please see the LICENSE file in the Qooxdoo project's top-level directory
   *      for details.
   *
   *    Authors:
   *      * John Spackman (john.spackman@zenesis.com, @johnspackman)
   *
   * *********************************************************************** */
  var imageSize = qx.tool.utils.Promisify.promisify(require("image-size"));
  var log = qx.tool.utils.LogManager.createLog("resource-manager");
  qx.Class.define("qx.tool.compiler.resources.ImageLoader", {
    extend: qx.tool.compiler.resources.ResourceLoader,
    construct: function () {
      qx.tool.compiler.resources.ResourceLoader.constructor.call(this, [".png", ".gif", ".jpg", ".jpeg", ".svg"]);
    },
    members: {
      needsLoad(filename, fileInfo, stat) {
        if (!fileInfo || fileInfo.width === undefined || fileInfo.height === undefined) {
          return true;
        }

        return qx.tool.compiler.resources.ImageLoader.prototype.needsLoad.base.call(this, filename, fileInfo, stat);
      },

      async load(asset) {
        let filename = asset.getSourceFilename();
        let fileInfo = asset.getFileInfo();
        log.trace("Getting size of " + filename);

        try {
          let dimensions = await imageSize(filename);
          fileInfo.width = dimensions.width;
          fileInfo.height = dimensions.height;
        } catch (ex) {
          log.warn("Cannot get image size of " + filename + ": " + ex);
          delete fileInfo.width;
          delete fileInfo.height;
        }
      }

    }
  });
  qx.tool.compiler.resources.ImageLoader.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.tool.compiler.resources.ResourceLoader": {
        "construct": true,
        "require": true
      },
      "qx.tool.utils.Json": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
   *
   *    qooxdoo-compiler - node.js based replacement for the Qooxdoo python
   *    toolchain
   *
   *    https://github.com/qooxdoo/qooxdoo-compiler
   *
   *    Copyright:
   *      2011-2017 Zenesis Limited, http://www.zenesis.com
   *
   *    License:
   *      MIT: https://opensource.org/licenses/MIT
   *
   *      This software is provided under the same licensing terms as Qooxdoo,
   *      please see the LICENSE file in the Qooxdoo project's top-level directory
   *      for details.
   *
   *    Authors:
   *      * John Spackman (john.spackman@zenesis.com, @johnspackman)
   *
   * *********************************************************************** */
  qx.Class.define("qx.tool.compiler.resources.MetaLoader", {
    extend: qx.tool.compiler.resources.ResourceLoader,
    construct: function () {
      qx.tool.compiler.resources.ResourceLoader.constructor.call(this, ".meta");
    },
    members: {
      async load(asset) {
        asset.getFileInfo().meta = await qx.tool.utils.Json.loadJsonAsync(asset.getSourceFilename());
      }

    }
  });
  qx.tool.compiler.resources.MetaLoader.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.tool.utils.Promisify": {
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.tool.compiler.resources.ResourceConverter": {
        "require": true
      },
      "qx.tool.compiler.resources.ScssConverter": {},
      "qx.tool.utils.files.Utils": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
   *
   *    qooxdoo-compiler - node.js based replacement for the Qooxdoo python
   *    toolchain
   *
   *    https://github.com/qooxdoo/qooxdoo-compiler
   *
   *    Copyright:
   *      2011-2017 Zenesis Limited, http://www.zenesis.com
   *
   *    License:
   *      MIT: https://opensource.org/licenses/MIT
   *
   *      This software is provided under the same licensing terms as Qooxdoo,
   *      please see the LICENSE file in the Qooxdoo project's top-level directory
   *      for details.
   *
   *    Authors:
   *      * Henner Kollmann (henner.kollmann@gmx.de)
   *
   * *********************************************************************** */
  var path = require("upath");

  var sass = require("node-sass");

  const fs = qx.tool.utils.Promisify.fs;
  qx.Class.define("qx.tool.compiler.resources.ScssIncludeConverter", {
    extend: qx.tool.compiler.resources.ResourceConverter,
    members: {
      matches(filename) {
        filename = path.basename(filename);
        return filename[0] == '_' && filename.endsWith(".scss");
      },

      isDoNotCopy(filename) {
        if (qx.tool.compiler.resources.ScssConverter.COPY_ORIGINAL_FILES) return false;
        return true;
      },

      async convert(target, asset, srcFilename, destFilename, isThemeFile) {
        await qx.tool.utils.files.Utils.copyFile(srcFilename, destFilename);
      }

    }
  });
  qx.tool.compiler.resources.ScssIncludeConverter.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.lang.Array": {},
      "qx.tool.utils.Promisify": {},
      "qx.tool.utils.files.Utils": {},
      "qx.tool.utils.Utils": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
   *
   *    qooxdoo-compiler - node.js based replacement for the Qooxdoo python
   *    toolchain
   *
   *    https://github.com/qooxdoo/qooxdoo-compiler
   *
   *    Copyright:
   *      2011-2019 Zenesis Limited, http://www.zenesis.com
   *
   *    License:
   *      MIT: https://opensource.org/licenses/MIT
   *
   *      This software is provided under the same licensing terms as Qooxdoo,
   *      please see the LICENSE file in the Qooxdoo project's top-level directory
   *      for details.
   *
   *    Authors:
   *      * John Spackman (john.spackman@zenesis.com, @johnspackman)
   *
   * *********************************************************************** */
  const path = require("upath");

  qx.Class.define("qx.tool.compiler.resources.Asset", {
    extend: qx.core.Object,
    construct: function (library, filename, fileInfo) {
      qx.core.Object.constructor.call(this);
      this.__P_34_0 = library;
      this.__filename = filename;
      this.__P_34_1 = fileInfo;
    },
    members: {
      /** {Library} that this asset belongs to */
      __P_34_0: null,

      /** {String} path within the library resources */
      __filename: null,

      /** {Object} the data in the database */
      __P_34_1: null,

      /** {ResourceLoader[]?} array of loaders */
      __P_34_2: null,

      /** {ResourceConverter[]?} array of converters */
      __P_34_3: null,

      /** {Asset[]?} list of assets which refer to this asset (eg for image combining) */
      __P_34_4: null,

      /** {Asset[]?} list of assets which the meta in this asset refers to (eg for image combining) */
      __P_34_5: null,

      /** {Asset[]?} list of assets which this asset depends on */
      __P_34_6: null,

      /** {Asset[]?} list of assets which depend on this asset */
      __P_34_7: null,

      getLibrary() {
        return this.__P_34_0;
      },

      getFilename() {
        return this.__filename;
      },

      getFileInfo() {
        return this.__P_34_1;
      },

      isThemeFile() {
        return this.__P_34_1.resourcePath == "themePath";
      },

      getSourceFilename() {
        return path.relative(process.cwd(), this.isThemeFile() ? this.__P_34_0.getThemeFilename(this.__filename) : this.__P_34_0.getResourceFilename(this.__filename));
      },

      getDestFilename(target) {
        let filename = null;

        if (this.__P_34_3) {
          filename = this.__P_34_3[this.__P_34_3.length - 1].getDestFilename(target, this);
        }

        return filename ? filename : path.relative(process.cwd(), path.join(target.getOutputDir(), "resource", this.__filename));
      },

      setLoaders(loaders) {
        this.__P_34_2 = loaders.length ? loaders : null;
      },

      setConverters(converters) {
        this.__P_34_3 = converters.length ? converters : null;
      },

      addMetaReferee(asset) {
        if (!this.__P_34_4) {
          this.__P_34_4 = [];
        }

        if (!qx.lang.Array.contains(this.__P_34_4, asset)) {
          this.__P_34_4.push(asset);
        }
      },

      getMetaReferees() {
        return this.__P_34_4;
      },

      addMetaReferTo(asset) {
        if (!this.__P_34_5) {
          this.__P_34_5 = [];
        }

        if (!qx.lang.Array.contains(this.__P_34_5, asset)) {
          this.__P_34_5.push(asset);
        }
      },

      getMetaReferTo() {
        return this.__P_34_5;
      },

      setDependsOn(assets) {
        if (this.__P_34_6) {
          this.__P_34_6.forEach(thatAsset => delete thatAsset.__P_34_7[this.getFilename]);
        }

        if (assets && assets.length) {
          this.__P_34_6 = assets;
          this.__P_34_1.dependsOn = assets.map(asset => asset.toUri());
          assets.forEach(thatAsset => {
            if (!thatAsset.__P_34_7) {
              thatAsset.__P_34_7 = {};
            }

            thatAsset.__P_34_7[this.getFilename()] = this;
          });
        } else {
          this.__P_34_6 = null;
          delete this.__P_34_1.dependsOn;
        }
      },

      getDependsOn() {
        return this.__P_34_6;
      },

      getDependsOnThisAsset() {
        return this.__P_34_7 ? Object.values(this.__P_34_7) : null;
      },

      async load() {
        if (this.__P_34_2) {
          this.__P_34_2.forEach(loader => loader.load(this));
        }
      },

      async sync(target) {
        let destFilename = this.getDestFilename(target);
        let srcFilename = this.getSourceFilename();

        if (this.__P_34_3) {
          let doNotCopy = await qx.tool.utils.Promisify.some(this.__P_34_3, converter => converter.isDoNotCopy(srcFilename));

          if (doNotCopy) {
            return;
          }
        }

        let destStat = await qx.tool.utils.files.Utils.safeStat(destFilename);

        if (destStat) {
          let filenames = [this.getSourceFilename()];

          if (this.__P_34_6) {
            this.__P_34_6.forEach(asset => filenames.push(asset.getSourceFilename()));
          }

          let needsIt = await qx.tool.utils.Promisify.some(filenames, async filename => {
            let srcStat = await qx.tool.utils.files.Utils.safeStat(filename);
            return srcStat && srcStat.mtime.getTime() > destStat.mtime.getTime();
          });

          if (!needsIt && this.__P_34_3) {
            needsIt = await qx.tool.utils.Promisify.some(this.__P_34_3, converter => converter.needsConvert(target, this, srcFilename, destFilename, this.isThemeFile()));
          }

          if (!needsIt) {
            return;
          }
        }

        await qx.tool.utils.Utils.makeParentDir(destFilename);

        if (this.__P_34_3) {
          let dependsOn = [];

          if (this.__P_34_3.length == 1) {
            dependsOn = (await this.__P_34_3[0].convert(target, this, srcFilename, destFilename, this.isThemeFile())) || [];
          } else {
            let lastTempFilename = null;
            qx.tool.utils.Promisify.each(this.__P_34_3, async (converter, index) => {
              let tmpSrc = lastTempFilename ? lastTempFilename : srcFilename;
              let tmpDest = index === this.__P_34_3.length - 1 ? destFilename : path.join(require("os").tmpdir(), path.basename(srcFilename) + "-pass" + (index + 1) + "-");
              let tmpDependsOn = (await converter.convert(target, this, tmpSrc, tmpDest, this.isThemeFile())) || [];
              tmpDependsOn.forEach(str => dependsOn.push(str));
              lastTempFilename = tmpDest;
            });
          }

          let rm = target.getAnalyser().getResourceManager();
          dependsOn = dependsOn.map(filename => rm.getAsset(path.resolve(filename), true)).filter(tmp => tmp !== this);
          this.setDependsOn(dependsOn);
        } else {
          await qx.tool.utils.files.Utils.copyFile(srcFilename, destFilename);
        }
      },

      toUri() {
        return this.__P_34_0.getNamespace() + ":" + this.__filename;
      },

      toString() {
        return this.toUri();
      }

    }
  });
  qx.tool.compiler.resources.Asset.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.tool.utils.Promisify": {
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.tool.cli.commands.Command": {
        "require": true
      },
      "qx.tool.compiler.Console": {},
      "qx.tool.config.Manifest": {},
      "qx.tool.cli.ConfigDb": {},
      "qx.tool.utils.Utils": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2018 Zenesis Ltd
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * John Spackman (john.spackman@zenesis.com, @johnspackman)
  
  ************************************************************************ */
  const process = require("process");

  const path = require("path");

  const columnify = require("columnify");

  const fs = qx.tool.utils.Promisify.fs;
  /**
   * Handles persistent configuration
   */

  qx.Class.define("qx.tool.cli.commands.Config", {
    extend: qx.tool.cli.commands.Command,
    statics: {
      getYargsCommand: function () {
        function run(argv, name) {
          var cmd = new qx.tool.cli.commands.Config(argv);
          return cmd[name](argv).catch(e => {
            qx.tool.compiler.Console.log(e.stack || e.message);
            process.exit(1);
          });
        }

        return {
          command: "config <key> [value]",
          describe: "gets/sets persistent configuration",
          builder: function (yargs) {
            yargs.option("quiet", {
              alias: "q",
              describe: "Suppresses warnings (eg about unknown configuration keys)",
              type: "boolean"
            }).command("set <key> <value>", "Sets a configuration value", () => {}, argv => run(argv, "cmdSet")).command("get <key> [options]", "Gets a configuration value", {
              "bare": {
                type: "boolean",
                describe: "Restricts output to just the value"
              }
            }, argv => run(argv, "cmdGet")).command("delete <key>", "Deletes a configuration value", () => {}, argv => run(argv, "cmdDelete")).command("list", "Lists all known configuration values", {
              "all": {
                type: "boolean",
                describe: "Shows all keys, including unset"
              }
            }, argv => run(argv, "cmdList"));
          },
          handler: function (argv) {// Nothing
          }
        };
      },
      KNOWN_VALUES: {
        "github.token": {
          desc: "The API token used to connect to GitHub"
        },
        "qx.library": {
          desc: "The directory where qooxdoo library is installed",
          set: async function (value) {
            if (!value) {
              return undefined;
            }

            if (!(await fs.existsAsync(path.join(value, qx.tool.config.Manifest.config.fileName)))) {
              if (await fs.existsAsync(path.join(value, "framework/Manifest.json"))) {
                value = path.join(value, "framework");
              } else {
                qx.tool.compiler.Console.error(`Cannot set qx.library to ${value} because there is no Manifest.json`);
                return undefined;
              }
            }

            return path.resolve(value);
          }
        },
        "qx.translation.strictPoCompatibility": {
          desc: "Whether to write PO files with strict compatibility, i.e. include line numbers in output",
          set: async function (value) {
            return value === "true" ? true : value === "false" ? false : Boolean(value);
          }
        },
        "qx.default.color": {
          desc: "The default color for console output (eg \"white bgRed bold\")"
        },
        "qx.default.feedback": {
          desc: "Default value for compiler feedback (override with --[no-]feedback)",
          set: async function (value) {
            return value === "true" ? true : value === "false" ? false : undefined;
          }
        }
      }
    },
    members: {
      __P_10_0: function (key) {
        var data = qx.tool.cli.commands.Config.KNOWN_VALUES[key];
        return data && data.desc;
      },
      __P_10_1: function (argv) {
        if (!argv.quiet) {
          let desc = this.__P_10_0(argv.key);

          if (!desc) {
            qx.tool.compiler.Console.warn("Warning: Unrecognised configuration key " + argv.key);
          }
        }
      },
      __P_10_2: function (key) {
        let pos = key.lastIndexOf(".");
        let parentKey = pos > -1 ? key.substring(0, pos) : "";
        let childKey = key.substring(pos + 1);
        return {
          key: key,
          parentKey: parentKey,
          childKey: childKey
        };
      },
      cmdSet: async function (argv) {
        this.__P_10_1(argv);

        let cfg = await qx.tool.cli.ConfigDb.getInstance();
        let setting = qx.tool.cli.commands.Config.KNOWN_VALUES[argv.key];
        let value = argv.value;

        if (setting && typeof setting.set == "function") {
          value = await setting.set(value);
        }

        let keyInfo = this.__P_10_2(argv.key);

        let parent = cfg.db(keyInfo.parentKey, {});

        if (value === undefined) {
          delete parent[keyInfo.childKey];
        } else {
          parent[keyInfo.childKey] = value;
        }

        await cfg.save();
      },
      cmdDelete: async function (argv) {
        this.__P_10_1(argv);

        let cfg = await qx.tool.cli.ConfigDb.getInstance();

        let keyInfo = this.__P_10_2(argv.key);

        let parent = cfg.db(keyInfo.parentKey);

        if (parent) {
          delete parent[keyInfo.childKey];
        }

        await cfg.save();
      },
      cmdGet: async function (argv) {
        this.__P_10_1(argv);

        let cfg = await qx.tool.cli.ConfigDb.getInstance();
        let value = cfg.db(argv.key);

        if (argv.bare) {
          qx.tool.compiler.Console.log(value || "");
        } else if (value !== undefined) {
          qx.tool.compiler.Console.log(argv.key + "=" + value);
        } else {
          qx.tool.compiler.Console.log(argv.key + " is not set");
        }
      },
      cmdList: async function (argv) {
        let cfg = await qx.tool.cli.ConfigDb.getInstance();
        let keys = {};

        function scan(obj, parentKey) {
          for (let key in obj) {
            let value = obj[key];
            let fullKey = parentKey + (parentKey.length ? "." : "") + key;

            if (qx.tool.utils.Utils.isPlainObject(value)) {
              scan(value, fullKey);
              continue;
            }

            keys[fullKey] = true;
          }
        }

        if (argv.all) {
          for (let key in qx.tool.cli.commands.Config.KNOWN_VALUES) {
            keys[key] = true;
          }
        } // Recursively get a list of all known keys


        scan(cfg.db(), "");
        keys = Object.keys(keys);
        keys.sort();
        keys = keys.map(key => ({
          key: key,
          value: cfg.db(key),
          description: this.__P_10_0(key) || "Unrecognised key"
        })); // Display each value

        qx.tool.compiler.Console.log(columnify(keys));
      }
    }
  });
  qx.tool.cli.commands.Config.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.tool.cli.commands.Command": {
        "require": true
      },
      "qx.tool.compiler.Console": {},
      "qx.tool.utils.Utils": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2017 Christian Boulanger and others
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Boulanger (info@bibliograph.org, @cboulanger)
       * Henner Kollmann (hkollmann)
  
  ************************************************************************ */
  const fs = require("fs");

  const path = require("upath");

  const inquirer = require("inquirer");
  /**
   * Create a new qooxdoo project. This will assemble the information needed to create the
   * new project by the following ways, in order of precedence:
   * 1. use parameters passed to the CLI command via the options
   * 2. if available, retrieve the info from the given environment
   * 3. ask the user the missing values interactively, offering default values where available
   * The variables needed are stored in the templates/template_vars.js file, together
   * with some metadata.
   *
   * Issues: automatic determination of qooxdoo path doesn't work yet.
   */


  qx.Class.define("qx.tool.cli.commands.Create", {
    extend: qx.tool.cli.commands.Command,
    statics: {
      getYargsCommand: function () {
        return {
          command: "create <application namespace> [options]",
          describe: "creates a new qooxdoo project.",
          builder: {
            "type": {
              alias: "t",
              describe: "Type of the application to create. Must be one of " + this.getSkeletonNames().join(", "),
              nargs: 1,
              requiresArg: true,
              type: "string"
            },
            "out": {
              alias: "o",
              describe: "Output directory for the application content."
            },
            "namespace": {
              alias: "s",
              describe: "Top-level namespace."
            },
            "name": {
              alias: "n",
              describe: "Name of application/library (defaults to namespace)."
            },
            "theme": {
              describe: "The name of the theme to be used.",
              default: "indigo"
            },
            "icontheme": {
              describe: "The name of the icon theme to be used.",
              default: "Tango"
            },
            "noninteractive": {
              alias: "I",
              describe: "Do not prompt for missing values"
            },
            "verbose": {
              alias: "v",
              describe: "Verbose logging"
            }
          }
        };
      },

      /**
       * Returns the names of the skeleton directories in the template folder
       * @returns {string[]}
       */
      getSkeletonNames: function () {
        // need access to an non static method...
        let dir = path.join(this.prototype.getTemplateDir(), "skeleton");
        let res = fs.readdirSync(dir).filter(entry => {
          try {
            return fs.existsSync(`${dir}/${entry}/Manifest.tmpl.json`);
          } catch (e) {
            return false;
          }
        });
        return res;
      }
    },
    members: {
      /**
       * Creates a new qooxdoo application
       */
      process: async function () {
        // init
        let argv = this.argv;
        let data = {};
        let questions = [];
        let values = {}; // qooxdoo path

        data.qooxdoo_path = await this.getUserQxPath(); // use CLI options, if available
        // qooxdoo version

        try {
          data.qooxdoo_version = await this.getLibraryVersion(data.qooxdoo_path);
        } catch (e) {
          qx.tool.compiler.Console.error(e.message);
          throw new qx.tool.utils.Utils.UserError("Cannot find qooxdoo framework folder.");
        } // get map of metdata on variables that need to be inserted in the templates


        data.template_dir = this.getTemplateDir();
        data.getLibraryVersion = this.getLibraryVersion.bind(this);
        let template_vars;
        const template_vars_path = path.join(this.getTemplateDir(), "template_vars");
        template_vars = require(template_vars_path)(argv, data); // prepare inquirer question data

        for (let var_name of Object.getOwnPropertyNames(template_vars)) {
          let v = template_vars[var_name];
          let deflt = typeof v.default === "function" ? v.default() : v.default; // we have a final value that doesn't need to be asked for / confirmed.

          if (v.value !== undefined) {
            values[var_name] = typeof v.value === "function" ? v.value.call(values) : v.value;
            continue;
          } // do not ask for optional values in non-interactive mode


          if (argv.noninteractive) {
            if (v.optional || deflt) {
              values[var_name] = deflt;
              continue;
            }

            throw new qx.tool.utils.Utils.UserError(`Cannot skip required value for '${var_name}'.`);
          } // ask user


          let message = `Please enter ${v.description} ${v.optional ? "(optional)" : ""}:`;
          questions.push({
            type: v.type || "input",
            choices: v.choices,
            name: var_name,
            message,
            default: v.default,
            validate: v.validate || function (answer, hash) {
              return true;
            }
          });
        } // ask user for missing values


        let answers;

        try {
          answers = await inquirer.prompt(questions);
        } catch (e) {
          throw new qx.tool.utils.Utils.UserError(e.message);
        } // finalize values


        for (let var_name of Object.getOwnPropertyNames(template_vars)) {
          let value = values[var_name]; // combine preset and inquirer data

          if (answers[var_name] !== undefined) {
            value = answers[var_name];
          } // handle special cases


          switch (var_name) {
            case "namespace":
              // match valid javascript object accessor TODO: allow unicode characters
              if (!value.match(/^([a-zA-Z_$][0-9a-zA-Z_$]*\.?)+$/)) {
                throw new qx.tool.utils.Utils.UserError(`Illegal characters in namespace "${value}."`);
              }

              break;

            case "locales":
              value = JSON.stringify(value.split(/,/).map(locale => locale.trim()));
              break;
            // this sets 'authors' and 'authors_map'

            case "authors":
              {
                if (value === undefined) {
                  values.author_map = "[]";
                  break;
                }

                let authors = value.split(/,/).map(a => a.trim());
                values.author_map = JSON.stringify(authors.map(author => {
                  let parts = author.split(/ /);
                  let email = parts.pop();
                  return {
                    name: parts.join(" "),
                    email
                  };
                }), null, 2);
                value = authors.join("\n" + " ".repeat(12));
                break;
              }
          } // update value


          values[var_name] = value;
        } // create application folder if it doesn't exist


        let appdir = path.normalize(values.out);

        if (!fs.existsSync(appdir)) {
          let parentDir = path.dirname(appdir);

          if (!fs.existsSync(parentDir)) {
            throw new qx.tool.utils.Utils.UserError(`Invalid directory ${appdir}`);
          }

          try {
            fs.accessSync(parentDir, fs.constants.W_OK);
          } catch (e) {
            throw new qx.tool.utils.Utils.UserError(`Directory ${parentDir} is not writable.`);
          }

          fs.mkdirSync(appdir);
        } // skeleton dir might come from options or was input interactively


        let app_type = argv.type || values.type;
        let skeleton_dir = path.join(data.template_dir, "skeleton", app_type);

        if (argv.type && !fs.existsSync(skeleton_dir)) {
          throw new qx.tool.utils.Utils.UserError(`Application type '${argv.type}' does not exist or has not been implemented yet.`);
        } // copy template, replacing template vars


        function traverseFileSystem(sourceDir, targetDir) {
          let files = fs.readdirSync(sourceDir);

          for (let part of files) {
            let sourceFile = path.join(sourceDir, part);
            let stats = fs.statSync(sourceFile);

            if (stats.isFile()) {
              let targetFile = path.join(targetDir, part.replace(/\.tmpl/, ""));

              if (sourceFile.includes(".tmpl")) {
                // template file
                let template = fs.readFileSync(sourceFile, "utf-8");

                for (let var_name in values) {
                  template = template.replace(new RegExp(`\\$\{${var_name}\}`, "g"), values[var_name]);
                }

                if (argv.verbose) {
                  qx.tool.compiler.Console.info(`>>> Creating ${targetFile} from template ${sourceFile}...`);
                } // qx.tool.compiler.Console.log(template);


                if (fs.existsSync(targetFile)) {
                  throw new qx.tool.utils.Utils.UserError(`${targetFile} already exists.`);
                }

                fs.writeFileSync(targetFile, template, "utf-8");
              } else {
                // normal file
                if (argv.verbose) {
                  qx.tool.compiler.Console.info(`>>> Copying ${sourceFile} to ${targetFile}...`);
                }

                fs.copyFileSync(sourceFile, targetFile);
              }
            } else if (stats.isDirectory()) {
              let newTargetDir = targetDir; // replace "custon" with namespace, creating namespaced folders in the "class" dir, but not anywhere else

              let parts = part === "custom" ? values.namespace.split(/\./) : [part];

              for (let part of parts) {
                newTargetDir = path.join(newTargetDir, part);
                fs.mkdirSync(newTargetDir);
              }

              traverseFileSystem(sourceFile, newTargetDir);
            }
          }
        } // go


        traverseFileSystem.bind(this)(skeleton_dir, appdir);
      }
    }
  });
  qx.tool.cli.commands.Create.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.tool.cli.commands.Compile": {
        "require": true
      },
      "qx.tool.compiler.Console": {
        "defer": "runtime"
      },
      "qx.lang.Object": {},
      "qx.tool.utils.Promisify": {},
      "qx.tool.utils.files.Utils": {},
      "qx.tool.utils.Utils": {},
      "qx.Promise": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2020 Zenesis Ltd https://www.zenesis.com
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * John Spackman (john.spackman@zenesis.com, @johnspackman)
       * Henner Kollmann (Henner.Kollmann@gmx.de, @hkollmann)
  
  ************************************************************************ */
  const fs = require("fs");

  const path = require("upath");
  /**
   * Build and deploy a project.
   *
   * To add your own deployment actions, use the `compile.js` file by
   *
   * - adding a listener for the "afterDeploy" event fired on the command
   * instance  in the `load()` method of the class extending {@link
   * qx.tool.cli.api.LibraryApi} or {@link qx.tool.cli.api.CompilerApi}.
   *
   * - or by implementing a `afterDeploy()` method in the class
   * extending {@link qx.tool.cli.api.CompilerApi}
   *
   * The event and/or method is called with a {@link qx.event.type.Data}
   * containing an object with the properties described below.
   *
   */


  qx.Class.define("qx.tool.cli.commands.Deploy", {
    extend: qx.tool.cli.commands.Compile,
    statics: {
      YARGS_BUILDER: {
        "out": {
          describe: "Output directory for the deployment",
          alias: "o"
        },
        "app-name": {
          describe: "The name of the application to deploy (default is all apps), can be comma separated list",
          nargs: 1,
          type: "string"
        },
        "source-maps": {
          describe: "Enable source maps",
          type: "boolean",
          default: false,
          alias: "m"
        }
      },
      getYargsCommand: function () {
        return {
          command: "deploy [options]",
          describe: "deploys qooxdoo application(s)",
          builder: (() => {
            let res = Object.assign({}, qx.tool.cli.commands.Compile.YARGS_BUILDER, qx.tool.cli.commands.Deploy.YARGS_BUILDER);
            delete res.watch;
            delete res["write-library-info"];
            delete res.download;
            delete res["update-po-files"];
            delete res["save-unminified"];
            delete res.bundling;
            delete res.minify;
            return res;
          })()
        };
      }
    },
    events: {
      /***
       * fired after deploying. With this event
       * application can do aditional copying.
       *
       * The event data is an object with the following properties:
       *
       * targetDir  : {String}  The target dir of the build
       * deployDir  : {String}  The output dir for the deployment
       * argv       : {Object}  Arguments
       * application: {Object}  application to build
       */
      "afterDeploy": "qx.event.type.Data"
    },
    members: {
      /*
       * @Override
       */
      processArgs: function (argv) {
        qx.tool.cli.commands.Deploy.prototype.processArgs.base.call(this, argv);

        if (!argv.clean) {
          qx.tool.compiler.Console.print("qx.tool.cli.deploy.notClean");
        }

        let compileArgv = {
          writeLibraryInfo: false,
          download: false,
          updatePoFiles: false,
          saveUnminified: false,
          bundling: true,
          minify: "mangle",
          target: "build",
          deploying: true
        };
        qx.lang.Object.mergeWith(argv, compileArgv);
      },

      /*
       * @Override
       */
      process: async function () {
        await qx.tool.cli.commands.Deploy.prototype.process.base.call(this);
        let argv = this.argv;
        let appNames = null;

        if (argv.appName) {
          appNames = {};
          argv.appName.split(",").forEach(appName => appNames[appName] = true);
        }

        if (argv.clean) {
          await qx.tool.utils.Promisify.eachOfSeries(this.getMakers(), async maker => {
            let target = maker.getTarget();
            await qx.tool.utils.Promisify.eachOfSeries(maker.getApplications(), async app => {
              if (appNames && !appNames[app.getName()]) {
                return;
              }

              if (app.getDeploy() === false) {
                return;
              }

              let deployDir = argv.out || typeof target.getDeployDir == "function" && target.getDeployDir();

              if (deployDir) {
                await qx.tool.utils.files.Utils.deleteRecursive(deployDir);
              }
            });
          });
        }

        await qx.tool.utils.Promisify.eachOfSeries(this.getMakers(), async (maker, makerIndex) => {
          let target = maker.getTarget();
          await qx.tool.utils.Promisify.eachOfSeries(maker.getApplications(), async app => {
            if (appNames && !appNames[app.getName()]) {
              return;
            }

            if (app.getDeploy() === false) {
              return;
            }

            let deployDir = argv.out || typeof target.getDeployDir == "function" && target.getDeployDir();

            if (!deployDir) {
              qx.tool.compiler.Console.print("qx.tool.cli.deploy.deployDirNotSpecified", target.getType());
              return;
            }

            let sourceMaps = argv.sourceMaps || typeof target.getDeployMap == "function" && target.getDeployMap() || typeof target.getSaveSourceInMap == "function" && target.getSaveSourceInMap();
            let appRoot = target.getApplicationRoot(app);
            let destRoot = path.join(deployDir, app.getName());
            await this.__P_11_0(appRoot, destRoot, sourceMaps);
            {
              let from = path.join(target.getOutputDir(), "resource");

              if (fs.existsSync(from)) {
                let to = path.join(deployDir, "resource");

                if (makerIndex == 0 && argv.clean) {
                  await qx.tool.utils.files.Utils.deleteRecursive(to);
                }

                await qx.tool.utils.files.Utils.sync(from, to);
              }
            }
            {
              let from = path.join(target.getOutputDir(), "index.html");
              let to = path.join(deployDir, "index.html");

              if (fs.existsSync(from)) {
                fs.copyFileSync(from, to);
              }
            }
            let data = {
              targetDir: target.getOutputDir(),
              deployDir: deployDir,
              argv: argv,
              application: app
            };
            await this.fireDataEventAsync("afterDeploy", data);

            if (this.getCompilerApi() && typeof this.getCompilerApi().afterDeploy == "function") {
              await this.getCompilerApi().afterDeploy(data);
            }
          });
        });
      },
      __P_11_0: async function (srcDir, destDir, sourceMaps) {
        await qx.tool.utils.Utils.makeDirs(destDir);
        let files = await fs.readdirAsync(srcDir);
        await qx.tool.utils.Promisify.eachOf(files, async file => {
          let from = path.join(srcDir, file);
          let to = path.join(destDir, file);
          let stat = await fs.statAsync(from);

          if (!stat.isFile()) {
            await this.__P_11_0(from, to, sourceMaps);
            return;
          }

          let ext = path.extname(file);

          if (ext == ".map" && !sourceMaps) {
            return;
          }

          if (ext == ".js" && !sourceMaps) {
            await qx.tool.utils.Utils.makeParentDir(to);
            let rs = fs.createReadStream(from, {
              encoding: "utf8",
              emitClose: true
            });
            let ws = fs.createWriteStream(to, {
              encoding: "utf8",
              emitClose: true
            });
            let ss = new qx.tool.utils.Utils.StripSourceMapTransform();
            await new qx.Promise((resolve, reject) => {
              rs.on("error", reject);
              ws.on("error", reject);
              ws.on("finish", resolve);
              rs.pipe(ss);
              ss.pipe(ws);
            });
          } else {
            await qx.tool.utils.files.Utils.copyFile(from, to);
          }
        });
      }
    },
    defer: function (statics) {
      qx.tool.compiler.Console.addMessageIds({
        "qx.tool.cli.deploy.deployDirNotSpecified": "No deploy dir for target <%1> configured! Use --out parameter or deployPath target property in compile.json."
      }, "error");
      qx.tool.compiler.Console.addMessageIds({
        "qx.tool.cli.deploy.notClean": "Incremental build compilation - this is faster but may preserve old artifacts, it is recommended to use --clean command line option"
      }, "warning");
    }
  });
  qx.tool.cli.commands.Deploy.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.tool.utils.Promisify": {
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.tool.cli.commands.Command": {
        "require": true
      },
      "qx.tool.cli.Cli": {},
      "qx.tool.compiler.Console": {},
      "qx.tool.utils.Utils": {},
      "qx.Promise": {},
      "qx.tool.compiler.app.Library": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2017 Christian Boulanger and others
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project"s top-level directory for details.
  
     Authors:
       * Henner Kollmann (hkollmann)
  
  ************************************************************************ */
  const CLIEngine = require("eslint").CLIEngine;

  const fs = qx.tool.utils.Promisify.fs;
  qx.Class.define("qx.tool.cli.commands.Lint", {
    extend: qx.tool.cli.commands.Command,
    statics: {
      getYargsCommand: function () {
        return {
          "command": "lint [files...]",
          "describe": "runs eslint on the current application or as set of single files.",
          "builder": {
            "fix": {
              describe: "runs eslint with --fix"
            },
            "fix-jsdoc-params": {
              describe: "changes the order or @param name and {Type} to make it compatible for the generator ('name-first') or with JSDoc linting ('type-first').",
              choices: ["off", "name-first", "type-first"],
              default: "off"
            },
            "use-eslintrc": {
              describe: "Use the .eslintrc file for configuration, if it exists",
              default: true
            },
            "cache": {
              describe: "operate only on changed files",
              default: false
            },
            "warnAsError": {
              alias: "w",
              describe: "handle warnings as error"
            },
            "print-config": {
              alias: "p",
              describe: "print the eslint configuration"
            },
            "format": {
              alias: "f",
              describe: "use a specific output format",
              default: "codeframe"
            },
            "outputFile": {
              alias: "o",
              describe: "specify file to which the report will be written",
              nargs: 1,
              requiresArg: true,
              type: "string"
            },
            "verbose": {
              alias: "v",
              describe: "enables additional progress output to console",
              type: "boolean"
            },
            "quiet": {
              alias: "q",
              describe: "No output"
            }
          }
        };
      }
    },
    members: {
      process: async function () {
        await this.__P_12_0();
        let config;
        config = await qx.tool.cli.Cli.getInstance().getParsedArgs();
        let lintOptions = config.eslintConfig || {};
        lintOptions.extends = lintOptions.extends || ["@qooxdoo/qx/browser"];
        lintOptions.globals = Object.assign(lintOptions.globals || {}, await this.__P_12_1(config));
        let linter = new CLIEngine({
          cache: this.argv.cache || false,
          baseConfig: lintOptions,
          useEslintrc: this.argv.useEslintrc,
          fix: this.argv.fix
        });
        let files = this.argv.files || [];

        if (files.length === 0) {
          files.push("source/class/");
        }

        if (this.argv.config) {
          const fileConfig = linter.getConfigForFile(files[0]);
          qx.tool.compiler.Console.info(JSON.stringify(fileConfig, null, "  "));
        } else {
          let report = linter.executeOnFiles(files);

          if (this.argv.fix) {
            CLIEngine.outputFixes(report);
          }

          if (report.errorCount > 0 || report.warningCount > 0) {
            let outputFormat = this.argv.format || "codeframe";
            const formatter = linter.getFormatter(outputFormat);
            const s = formatter(report.results);

            if (this.argv.outputFile) {
              if (this.argv.verbose) {
                qx.tool.compiler.Console.info(`Report to be written to ${this.argv.outputFile}`);
              }

              await fs.writeFileAsync(this.argv.outputFile, s, "UTF-8").then(() => {
                if (this.argv.verbose) {
                  qx.tool.compiler.Console.info(`Report written to ${this.argv.outputFile}`);
                }
              }).catch(e => qx.tool.compiler.Console.error(`Error writing report to ${this.argv.outputFile}:` + e.message));
            } else if (report.errorCount > 0 || this.argv.warnAsError) {
              throw new qx.tool.utils.Utils.UserError(s);
            } else {
              qx.tool.compiler.Console.info(s);
            }
          } else {
            qx.tool.compiler.Console.info("No errors found!");
          }
        }
      },

      /**
       * Scan all libraries and add the namespace to globals
       * @param {Object} data
       * @return {Promise<void>}
       */
      async __P_12_1(data) {
        let result = {};

        if (data.libraries) {
          await qx.Promise.all(data.libraries.map(async dir => {
            let lib = await qx.tool.compiler.app.Library.createLibrary(dir);
            let s = lib.getNamespace();
            let libs = s.split(".");
            result[libs[0]] = false;
          }));
        }

        return result;
      },

      /**
       * Apply fixes before linting code
       * @return {Promise<void>}
       * @private
       */
      async __P_12_0() {
        let replaceInFiles = [];
        const fixParams = this.argv.fixJsdocParams;

        if (fixParams && fixParams !== "off") {
          const regex = fixParams === "type-first" ? /@param\s+([\w$]+)\s+({[\w|[\]{}<>?. ]+})/g : /@param\s+({[\w|[\]{}<>?. ]+})\s+([\w$]+)/g;
          replaceInFiles.push({
            files: "source/class/**/*.js",
            from: regex,
            to: "@param $2 $1"
          });
        }

        await this.migrate(null, replaceInFiles);
      }

    }
  });
  qx.tool.cli.commands.Lint.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.tool.cli.commands.Package": {
        "require": true
      },
      "qx.tool.cli.Cli": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2017 Christian Boulanger
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Boulanger (info@bibliograph.org, @cboulanger)
  
  ************************************************************************ */

  /**
   * "qx pkg" is an alias for "qx package"
   */
  qx.Class.define("qx.tool.cli.commands.Pkg", {
    extend: qx.tool.cli.commands.Package,
    statics: {
      /**
       * The yargs command data
       * @return {{}}
       */
      getYargsCommand: function () {
        return {
          command: "pkg <command> [options]",
          desc: "alias for 'qx package'.",
          builder: function (yargs) {
            qx.tool.cli.Cli.addYargsCommands(yargs, ["Install", "List", "Publish", "Remove", "Update", "Upgrade", "Migrate"], "qx.tool.cli.commands.package");
            return yargs.demandCommand().showHelpOnFail().help();
          },
          handler: function (argv) {// Nothing
          }
        };
      }
    }
  });
  qx.tool.cli.commands.Pkg.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.tool.cli.commands.Compile": {
        "require": true
      },
      "qx.tool.compiler.Console": {
        "defer": "runtime"
      },
      "qx.Promise": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2019 Zenesis Ltd
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * John Spackman (john.spackman@zenesis.com, @johnspackman)
  
  ************************************************************************ */
  const path = require("upath");

  const process = require("process");

  const psTree = require("ps-tree");
  /**
   * Runs a server application
   */


  qx.Class.define("qx.tool.cli.commands.Run", {
    extend: qx.tool.cli.commands.Compile,
    statics: {
      YARGS_BUILDER: {
        "inspect": {
          describe: "Whether to start node for debugging (ie with the --inspect argument)",
          type: "boolean",
          default: false
        },
        "inspect-brk": {
          describe: "Whether to start node for debugging and break immediately (ie with the --inspect-brk argument)",
          type: "boolean",
          default: false
        }
      },
      getYargsCommand: function () {
        return {
          command: "run [configFile]",
          describe: "runs a server application (written in node) with continuous compilation, using compile.json",
          builder: Object.assign({}, qx.tool.cli.commands.Compile.YARGS_BUILDER, qx.tool.cli.commands.Run.YARGS_BUILDER)
        };
      }
    },
    members: {
      /*
       * @Override
       */
      process: async function () {
        this.argv.watch = true;
        this.argv["machine-readable"] = false;
        this.argv["feedback"] = false;
        await qx.tool.cli.commands.Run.prototype.process.base.call(this);

        let config = this._getConfig();

        if (!config.run) {
          qx.tool.compiler.Console.print("qx.tool.cli.run.noRunConfig");
          process.exit(-1);
        }

        if (!config.run.application) {
          qx.tool.compiler.Console.print("qx.tool.cli.run.noAppName");
          process.exit(-1);
        }

        let maker = null;
        let app = null;
        this.getMakers().forEach(tmp => {
          let apps = tmp.getApplications().filter(app => app.getName() == config.run.application);

          if (apps.length) {
            if (maker) {
              qx.tool.compiler.Console.print("qx.tool.cli.run.tooManyMakers");
              process.exit(-1);
            }

            if (apps.length != 1) {
              qx.tool.compiler.Console.print("qx.tool.cli.run.tooManyApplications");
              process.exit(-1);
            }

            maker = tmp;
            app = apps[0];
          }
        });

        if (!app) {
          qx.tool.compiler.Console.print("qx.tool.cli.run.noAppName");
          process.exit(-1);
        }

        if (app.getType() != "node") {
          qx.tool.compiler.Console.print("qx.tool.cli.run.mustBeNode");
          process.exit(-1);
        }

        let target = maker.getTarget();

        function kill(parentId) {
          return new qx.Promise((resolve, reject) => {
            psTree(parentId, function (err, children) {
              if (err) {
                reject(err);
                return;
              }

              children.forEach(item => {
                try {
                  process.kill(item.PID);
                } catch (ex) {// Nothing
                }
              });

              try {
                process.kill(parentId);
              } catch (ex) {// Nothing
              }

              resolve();
            });
          });
        }

        let scriptname = path.join(target.getApplicationRoot(app), "index.js");
        let args = config.run.arguments || "";
        let debug = "";

        if (this.argv["inspect-brk"]) {
          debug = " --inspect-brk";
        } else if (this.argv["inspect"]) {
          debug = " --inspect";
        }

        let cmd = `node${debug} ${scriptname} ${args}`;
        let restartNeeded = true;
        this.addListener("making", evt => {
          restartNeeded = false;
        });
        this.addListener("writtenApplication", evt => {
          if (app === evt.getData()) {
            restartNeeded = true;
          }
        });
        /* eslint-disable @qooxdoo/qx/no-illegal-private-usage */

        this.addListener("made", async e => {
          if (this.__P_14_0) {
            if (!restartNeeded) {
              return;
            }

            try {
              await kill(this.__P_14_0.pid);
            } catch (ex) {//Nothing
            }

            this.__P_14_0 = null;
          }

          console.log("Starting application: " + cmd);

          let child = this.__P_14_0 = require("child_process").exec(cmd);

          child.stdout.setEncoding("utf8");
          child.stdout.on("data", function (data) {
            console.log(data);
          });
          child.stderr.setEncoding("utf8");
          child.stderr.on("data", function (data) {
            console.error(data);
          });
          child.on("close", function (code) {
            console.log("Application has terminated");
            this.__P_14_0 = null;
          });
          child.on("error", function (err) {
            console.error("Application has failed: " + err);
          });
        });
      }
    },
    defer: function (statics) {
      qx.tool.compiler.Console.addMessageIds({
        "qx.tool.cli.run.noRunConfig": "Cannot run anything because the config.json does not have a `run` configuration",
        "qx.tool.cli.run.noAppName": "Cannot run anything because the config.json does not specify a unique application name",
        "qx.tool.cli.run.mustBeNode": "The application %1 is not a node application (only node applications are supported)",
        "qx.tool.cli.run.tooManyMakers": "Cannot run anything because multiple targets are detected",
        "qx.tool.cli.run.tooManyApplications": "Cannot run anything because multiple applications are detected"
      }, "error");
    }
  });
  qx.tool.cli.commands.Run.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.tool.utils.Promisify": {
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.tool.cli.commands.Compile": {
        "require": true
      },
      "qx.tool.utils.Website": {},
      "qx.tool.compiler.Console": {
        "defer": "runtime"
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2017 Zenesis Ltd
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * John Spackman (john.spackman@zenesis.com, @johnspackman)
  
  ************************************************************************ */
  const path = require("upath");

  const process = require("process");

  const express = require("express");

  const http = require("http");

  const fs = qx.tool.utils.Promisify.fs;

  require("app-module-path").addPath(process.cwd() + "/node_modules");
  /**
   * Compiles the project and serves it up as a web page
   */


  qx.Class.define("qx.tool.cli.commands.Serve", {
    extend: qx.tool.cli.commands.Compile,
    statics: {
      YARGS_BUILDER: {
        "listen-port": {
          alias: "p",
          describe: "The port for the web browser to listen on",
          type: "number",
          default: 8080
        },
        "show-startpage": {
          alias: "S",
          describe: "Show the startpage with the list of applications and additional information",
          type: "boolean",
          default: null
        },
        "rebuild-startpage": {
          alias: "R",
          describe: "Rebuild the startpage with the list of applications and additional information",
          type: "boolean",
          default: false
        }
      },
      getYargsCommand: function () {
        return {
          command: "serve",
          describe: "runs a webserver to run the current application with continuous compilation, using compile.json",
          builder: (() => {
            let res = Object.assign({}, qx.tool.cli.commands.Compile.YARGS_BUILDER, qx.tool.cli.commands.Serve.YARGS_BUILDER);
            delete res.watch;
            return res;
          })()
        };
      }
    },
    events: {
      /**
       * Fired before server start
       *
       * The event data is an object with the following properties: 
       *   server: the http server
       *   application: the used express server instance
       */
      "beforeStart": "qx.event.type.Data",

      /**
       * Fired when server is started
      */
      "afterStart": "qx.event.type.Event"
    },
    members: {
      /** @type {qx.tool.utils.Website} the Website instance */
      _website: null,

      /*
       * @Override
       */
      process: async function () {
        this.argv.watch = true;
        this.argv["machine-readable"] = false;
        this.argv["feedback"] = false;
        await qx.tool.cli.commands.Serve.prototype.process.base.call(this); // build website if it hasn't been built yet.

        const website = this._website = new qx.tool.utils.Website();

        if (!(await fs.existsAsync(website.getTargetDir()))) {
          qx.tool.compiler.Console.info(">>> Building startpage...");
          await this._website.rebuildAll();
        } else if (this.argv.rebuildStartpage) {
          this._website.startWatcher();
        }

        await this.runWebServer();
      },

      /**
       *
       * returns the showStartpage flag
       *
       */
      showStartpage: function () {
        return this.__P_15_0;
      },

      /**
       * Runs the web server
       */
      runWebServer: async function () {
        let makers = this.getMakers().filter(maker => maker.getApplications().some(app => app.getStandalone()));
        let apps = [];
        let defaultMaker = null;
        let firstMaker = null;
        makers.forEach(maker => {
          maker.getApplications().forEach(app => {
            if (app.isBrowserApp() && app.getStandalone()) {
              apps.push(app);

              if (firstMaker === null) {
                firstMaker = maker;
              }

              if (defaultMaker === null && app.getWriteIndexHtmlToRoot()) {
                defaultMaker = maker;
              }
            }
          });
        });

        if (!defaultMaker && apps.length === 1) {
          defaultMaker = firstMaker;
        }

        this.__P_15_0 = this.argv.showStartpage;

        if (this.__P_15_0 === null) {
          this.__P_15_0 = defaultMaker === null;
        }

        var config = this._getConfig();

        const app = express();
        const website = new qx.tool.utils.Website();

        if (!this.__P_15_0) {
          app.use("/", express.static(defaultMaker.getTarget().getOutputDir()));
        } else {
          let s = await this.getAppQxPath();

          if (!(await fs.existsAsync(path.join(s, "docs")))) {
            s = path.dirname(s);
          }

          app.use("/docs", express.static(path.join(s, "docs")));
          app.use("/apps", express.static(path.join(s, "apps")));
          app.use("/", express.static(website.getTargetDir()));
          var appsData = [];
          makers.forEach(maker => {
            let target = maker.getTarget();
            let out = path.normalize("/" + target.getOutputDir());
            app.use(out, express.static(target.getOutputDir()));
            appsData.push({
              target: {
                type: target.getType(),
                outputDir: out
              },
              apps: maker.getApplications().filter(app => app.getStandalone()).map(app => ({
                isBrowser: app.isBrowserApp(),
                name: app.getName(),
                type: app.getType(),
                title: app.getTitle() || app.getName(),
                appClass: app.getClassName(),
                description: app.getDescription(),
                outputPath: target.getProjectDir(app) // no trailing slash or link will break

              }))
            });
          });
          app.get("/serve.api/apps.json", (req, res) => {
            res.set("Content-Type", "application/json");
            res.send(JSON.stringify(appsData, null, 2));
          });
        }

        this.addListenerOnce("made", e => {
          let server = http.createServer(app);
          this.fireDataEvent("beforeStart", {
            server: server,
            application: app
          });
          server.on("error", e => {
            if (e.code === "EADDRINUSE") {
              qx.tool.compiler.Console.print("qx.tool.cli.serve.webAddrInUse", config.serve.listenPort);
              process.exit(-1);
            } else {
              qx.tool.compiler.Console.log("Error when starting web server: " + e);
            }
          });
          server.listen(config.serve.listenPort, () => {
            qx.tool.compiler.Console.print("qx.tool.cli.serve.webStarted", "http://localhost:" + config.serve.listenPort);
            this.fireEvent("afterStart");
          });
        });
      },
      __P_15_0: null
    },
    defer: function (statics) {
      qx.tool.compiler.Console.addMessageIds({
        "qx.tool.cli.serve.webStarted": "Web server started, please browse to %1",
        "qx.tool.cli.serve.webAddrInUse": "Web server cannot start because port %1 is already in use"
      });
    }
  });
  qx.tool.cli.commands.Serve.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.tool.utils.Promisify": {
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.util.ResourceManager": {
        "construct": true
      },
      "qx.tool.utils.files.Utils": {},
      "qx.tool.compiler.Console": {},
      "qx.tool.cli.commands.Create": {},
      "qx.tool.cli.commands.package.Install": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2011-2019 The authors
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * John Spackman (john.spackman@zenesis.com, @johnspackman)
       * Christian Boulanger (info@bibliograph.org, @cboulanger)
  
  ************************************************************************ */
  const fs = qx.tool.utils.Promisify.fs;

  const process = require("process");

  const path = require("upath");

  const rimraf = require("rimraf");

  const dot = require("dot");

  require("jstransformer-dot");

  const metalsmith = require("metalsmith");

  const layouts = require("metalsmith-layouts");

  const markdown = require("metalsmith-markdown"); //const filenames = require("metalsmith-filenames");
  //var permalinks = require("metalsmith-permalinks");


  const sass = require("node-sass");

  const chokidar = require("chokidar"); // config


  dot.templateSettings.strip = false;
  qx.Class.define("qx.tool.utils.Website", {
    extend: qx.core.Object,
    statics: {
      APP_NAMESPACE: "apps"
    },
    construct: function (options = {}) {
      qx.core.Object.apply(this, arguments);
      const self = qx.tool.utils.Website;
      let p = qx.util.ResourceManager.getInstance().toUri("qx/tool/website/.gitignore");
      p = path.dirname(p);
      this.initSourceDir(p);
      this.initTargetDir(path.join(p, "build"));
      this.initAppsNamespace(self.APP_NAMESPACE);

      for (let key of Object.getOwnPropertyNames(options)) {
        this.set(key, options[key]);
      }
    },
    properties: {
      appsNamespace: {
        check: "String",
        deferredInit: true
      },
      sourceDir: {
        check: "String",
        deferredInit: true
      },
      targetDir: {
        check: "String",
        deferredInit: true
      }
    },
    members: {
      /** @type {chokidar} watcher */
      __P_51_0: null,

      /** @type {Boolean} whether the watcher is ready yet */
      __P_51_1: false,

      /** @type {Integer} setTimeout timer ID for debouncing builds */
      __P_51_2: null,

      /** @type {Boolean} Whether the build is currently taking place */
      __P_51_3: false,

      /** @type {Boolean} Whether a rebuild is needed ASAP */
      __P_51_4: false,

      /**
       * Starts the watcher for files in the source directory and compiles as needed
       */
      async startWatcher() {
        await this.stopWatcher();
        let sourceDir = await qx.tool.utils.files.Utils.correctCase(this.getSourceDir());
        this._watcher = chokidar.watch([sourceDir], {});

        this._watcher.on("change", filename => this.__P_51_5("change", filename));

        this._watcher.on("add", filename => this.__P_51_5("add", filename));

        this._watcher.on("unlink", filename => this.__P_51_5("unlink", filename));

        this._watcher.on("ready", async () => {
          await this.triggerRebuild(true);
          this.__P_51_1 = true;
        });

        this._watcher.on("error", err => {
          qx.tool.compiler.Console.print(err.code == "ENOSPC" ? "qx.tool.cli.watch.enospcError" : "qx.tool.cli.watch.watchError", err);
        });
      },

      /**
       * Stops the watcher, if its running
       */
      async stopWatcher() {
        if (this._watcher) {
          await this._watcher.stop();
          this._watcher = null;
          this.__P_51_1 = false;
        }
      },

      /**
       * Whether the watcher is running
       * 
       * @return {Boolean} true if its running
       */
      isWatching() {
        return Boolean(this._watcher);
      },

      /**
       * Waits for the rebuild process to complete, if it is running
       */
      async waitForRebuildComplete() {
        if (this.__P_51_6) {
          await this.__P_51_6;
        }
      },

      /**
       * Rebuilds everything needed for the website
       */
      async rebuildAll() {
        await this.generateSite();
        await this.compileScss();
      },

      /**
       * Event handler for changes to the source files
       * 
       * @param type {String} type of change, one of "change", "add", "unlink"
       * @param filename {String} the file that changed
       */
      __P_51_5(type, filename) {
        if (this.__P_51_1) {
          if (!filename.toLowerCase().startsWith(this.getTargetDir().toLowerCase())) {
            this.triggerRebuild(false);
          }
        }
      },

      /**
       * Triggers a rebuild of the website, asynchronously.  Unless immediate is true,
       * the rebuild will only happen after a short delay; but each time this is called,
       * the delay is restarted.  This is to allow multiple files to be changed without
       * swamping the processor with compilations.
       * 
       * @param immediate {Boolean?} if true, rebuild starts ASAP
       */
      triggerRebuild(immediate) {
        if (this.__P_51_3) {
          this.__P_51_4 = true;
          return;
        }

        let rebuilderImpl = async () => {
          await this.rebuildAll();

          if (this.__P_51_4) {
            this.__P_51_4 = false;
            await rebuilderImpl();
          }
        };

        let rebuilder = async () => {
          this.__P_51_3 = true;

          try {
            this.__P_51_6 = rebuilderImpl();
            await this.__P_51_6;
            this.__P_51_6 = null;
          } finally {
            this.__P_51_3 = false;
          }
        };

        if (this.__P_51_2) {
          clearTimeout(this.__P_51_2);
          this.__P_51_2 = null;
        }

        this.__P_51_2 = setTimeout(rebuilder, immediate ? 1 : 250);
      },

      /**
       * Metalsmith Plugin that collates a list of pages that are to be included in the site navigation
       * into the metadata, along with their URLs.
       *
       * If the metadata has a `sites.pages`, then it is expected to be an array of URLs which indicates
       * the ordering to be applied; `sites.pages` is replaced with an array of objects, one per page,
       * that contains `url` and `title` properties.
       *
       */
      async getPages(files, metalsmith) {
        var metadata = metalsmith.metadata();
        var pages = [];
        var order = {};

        if (metadata.site.pages) {
          metadata.site.pages.forEach((url, index) => typeof url == "string" ? order[url] = index : null);
        }

        var unorderedPages = [];

        function addPage(url, title) {
          var page = {
            url: url,
            title: title
          };
          var index = order[url];

          if (index !== undefined) {
            pages[index] = page;
          } else {
            unorderedPages.push(page);
          }
        }

        for (let filename of Object.getOwnPropertyNames(files)) {
          let file = files[filename];

          if (filename === "index.html") {
            addPage("/", file.title || "Home Page");
          } else if (file.permalink || file.navigation) {
            addPage(file.permalink || filename, file.title || "Home Page");
          }
        }

        unorderedPages.forEach(page => pages.push(page));
        metadata.site.pages = pages;
      },

      /**
       * Metalsmith plugin that loads partials and adding them to the metadata.partials map.  Each file
       * is added with its filename, and if it is a .html filename is also added without the .html
       * extension.
       *
       */
      async loadPartials(files, metalsmith) {
        const metadata = metalsmith.metadata();
        const partialsDir = path.join(this.getSourceDir(), "partials");
        files = await fs.readdirAsync(partialsDir, "utf8");

        for (let filename of files) {
          let m = filename.match(/^(.+)\.([^.]+)$/);

          if (!m) {
            continue;
          }

          let [unused, name, ext] = m;

          if (unused) {// this is simply to avoid linting errors until https://github.com/qooxdoo/qooxdoo-compiler/issues/461 is fixed
          }

          let data = await fs.readFileAsync(path.join(partialsDir, filename), "utf8");
          let fn;

          try {
            fn = dot.template(data);
          } catch (err) {
            qx.tool.compiler.Console.log("Failed to load partial " + filename + ": " + err);
            continue;
          }

          fn.name = filename;
          metadata.partials[filename] = fn;

          if (ext === "html") {
            metadata.partials[name] = fn;
          }
        }
      },

      /**
       * Generates the site with Metalsmith
       * @returns {Promise}
       */
      async generateSite() {
        await new Promise((resolve, reject) => {
          metalsmith(this.getSourceDir()).metadata({
            site: {
              title: "Qooxdoo Application Server",
              description: "Mini website used by \"qx serve\"",
              email: "info@qooxdoo.org",
              twitter_username: "qooxdoo",
              github_username: "qooxdoo",
              pages: ["/", "/about/"]
            },
            baseurl: "",
            url: "",
            lang: "en",
            partials: {}
          }).source(path.join(this.getSourceDir(), "src")).destination(this.getTargetDir()).clean(true).use(this.loadPartials.bind(this)).use(markdown()).use(this.getPages.bind(this)).use(layouts({
            engine: "dot"
          })).build(function (err) {
            if (err) {
              reject(err);
            } else {
              resolve();
            }
          });
        });
      },

      /**
       * Compiles SCSS into CSS
       *
       * @returns {Promise}
       */
      async compileScss() {
        let result = await new Promise((resolve, reject) => {
          sass.render({
            file: path.join(this.getSourceDir(), "sass", "qooxdoo.scss"),
            outFile: path.join(this.getTargetDir(), "qooxdoo.css")
          }, function (err, result) {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          });
        });
        await fs.writeFileAsync(path.join(this.getTargetDir(), "qooxdoo.css"), result.css, "utf8");
      },

      /**
       * Build the development tool apps (APIViewer, Playground, Widgetbrowser, Demobrowser)
       * @return {Promise<void>}
       */
      async buildDevtools() {
        const namespace = this.getAppsNamespace();
        process.chdir(this.getTargetDir());
        let apps_path = path.join(this.getTargetDir(), namespace);

        if (await fs.existsAsync(apps_path)) {
          rimraf.sync(apps_path);
        }

        const opts = {
          noninteractive: true,
          namespace,
          theme: "indigo",
          icontheme: "Tango"
        };
        await new qx.tool.cli.commands.Create(opts).process();
        process.chdir(apps_path);

        for (let name of ["apiviewer", "widgetbrowser", "playground", "demobrowser"]) {
          await new qx.tool.cli.commands.package.Install({}).install("qooxdoo/qxl." + name);
        }
      }

    }
  });
  qx.tool.utils.Website.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.tool.cli.commands.Serve": {
        "construct": true,
        "require": true
      },
      "qx.tool.cli.commands.Compile": {},
      "qx.core.Assert": {},
      "qx.tool.cli.api.Test": {},
      "qx.tool.compiler.Console": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2020 Henner Kollmann
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project"s top-level directory for details.
  
  
  ************************************************************************ */
  const fs = require("fs");

  const path = require("path");

  const process = require("process");
  /**
   * Compiles the project, serves it up as a web page (default, can be turned off),
   * and dispatches the "runTests" event.
   *
   * All tests that should be run need to register themselves by the
   * test command. This is usually done in a `compile.js` file by either
   *
   * - adding a listener for the "runTests" event fired on the command
   * instance  in the `load()` method of the class extending {@link
   * qx.tool.cli.api.CompilerApi} or {@link qx.tool.cli.api.CompilerApi}.
   *
   * - or by implementing a `beforeTests()` method in the class
   * extending {@link qx.tool.cli.api.CompilerApi}
   *
   * The event and/or method is called with a {@link qx.event.type.Data}
   * containing the command instance.
   *
   */


  qx.Class.define("qx.tool.cli.commands.Test", {
    extend: qx.tool.cli.commands.Serve,
    statics: {
      /**
       * The name of the file containing the compile config for the testrunner
       * defaults to "compile-test.json"
       */
      CONFIG_FILENAME: "compile-test.json",
      YARGS_BUILDER: {
        "fail-fast": {
          describe: "Exit on first failing test",
          default: true,
          type: "boolean"
        },
        "disable-webserver": {
          describe: "Disables the start of the webserver",
          default: false,
          type: "boolean"
        }
      },
      getYargsCommand: function () {
        return {
          command: "test",
          describe: "run test for current project",
          builder: (() => {
            let res = Object.assign({}, qx.tool.cli.commands.Compile.YARGS_BUILDER, qx.tool.cli.commands.Serve.YARGS_BUILDER, qx.tool.cli.commands.Test.YARGS_BUILDER);
            delete res.watch;
            delete res["machine-readable"];
            delete res["feedback"];
            delete res["show-startpage"];
            delete res["rebuild-startpage"];
            return res;
          })()
        };
      }
    },
    events: {
      /**
       * Fired to start tests.
       *
       * The event data is the command instance:
       *  cmd: {qx.tool.cli.commands.Test}
       */
      "runTests": "qx.event.type.Data"
    },

    construct(argv) {
      qx.tool.cli.commands.Serve.constructor.call(this, argv);
      this.__P_16_0 = [];
      this.addListener("changeExitCode", evt => {
        let exitCode = evt.getData(); // overwrite error code only in case of errors

        if (exitCode && argv.failFast) {
          process.exit(exitCode);
        }
      });
    },

    properties: {
      /**
       * The exit code of all tests.
       *
       */
      exitCode: {
        check: "Number",
        event: "changeExitCode",
        nullable: true,
        init: null
      },

      /**
       * Is the webserver instance needed for the test?
       */
      needsServer: {
        check: "Boolean",
        nullable: false,
        init: false
      }
    },
    members: {
      /**
       * @var {Array}
       */
      __P_16_0: null,

      /**
       * add a test object and listens for the change of exitCode property
       * @param {qx.tool.cli.api.Test} test
       */
      addTest: function (test) {
        qx.core.Assert.assertInstance(test, qx.tool.cli.api.Test);
        test.addListenerOnce("changeExitCode", evt => {
          let exitCode = evt.getData(); // handle result and inform user

          if (exitCode === 0) {
            if (test.getName() && !this.argv.quiet) {
              qx.tool.compiler.Console.info(`Test '${test.getName()}' passed.`);
            }
          } else if (test.getName()) {
            qx.tool.compiler.Console.error(`Test '${test.getName()}' failed with exit code ${exitCode}.`);
          } // overwrite error code only in case of errors


          if (exitCode) {
            this.setExitCode(exitCode);
          }
        });

        this.__P_16_0.push(test);

        return test;
      },

      /**
       * @Override
       */
      process: async function () {
        this.argv.watch = false;
        this.argv["machine-readable"] = false;
        this.argv["feedback"] = false;
        this.argv["show-startpage"] = false; // check for special test compiler config

        if (!this.argv.configFile && fs.existsSync(path.join(process.cwd(), qx.tool.cli.commands.Test.CONFIG_FILENAME))) {
          this.argv.configFile = qx.tool.cli.commands.Test.CONFIG_FILENAME;
        }

        this.addListener("making", () => {
          if (!this.hasListener("runTests") && this.__P_16_0.length === 0 && (!this.getCompilerApi() || typeof this.getCompilerApi().beforeTests != "function")) {
            qx.tool.compiler.Console.error(`No tests are registered! You need to either register tests, or install a testrunner.
             See documentation at https://qooxdoo.org/docs/#/development/testing/`);
            process.exit(-1);
          }
        });
        this.addListener("afterStart", async () => {
          qx.tool.compiler.Console.info(`Running unit tests`);
          await this.fireDataEventAsync("runTests", this);

          if (this.getCompilerApi() && typeof this.getCompilerApi().beforeTests == "function") {
            await this.getCompilerApi().beforeTests(this);
          }

          for (let test of this.__P_16_0) {
            qx.tool.compiler.Console.info(`Running ${test.getName()}`);
            await test.execute();
          }

          process.exit(this.getExitCode());
        });

        if (this.__P_16_1()) {
          // start server
          await qx.tool.cli.commands.Test.prototype.process.base.call(this);
        } else {
          // compile only
          await qx.tool.cli.commands.Compile.prototype.process.call(this); // since the server is not started, manually fire the event necessary for firing the "runTests" event

          this.fireEvent("afterStart");
        }
      },
      __P_16_1: function () {
        return !this.argv.disableWebserver && (this.getNeedsServer() || this.__P_16_0.some(test => test.getNeedsServer()));
      }
    }
  });
  qx.tool.cli.commands.Test.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.tool.cli.commands.Command": {
        "require": true
      },
      "qx.tool.config.Manifest": {},
      "qx.tool.utils.Utils": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2017 Christian Boulanger and others
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Boulanger (info@bibliograph.org, @cboulanger)
  
  ************************************************************************ */
  const fs = require("fs");

  const process = require("process");

  const path = require("upath");
  /**
   * Add a new class file to the current project, based on a template.
   *
   * Syntax: `qx add class <classname> [--type=template_name] [--extend=extended_class] [--import] [--from-pkg=package_name]`
   * If omitted, `--type` defaults to "default". The path to the template file will be calculated as follows:
   * 1. transform template_name to ${template_name}.tmpl.js
   * 2. check if this file exists in the "templates/class" folder
   *    a. of a package, if the --from-pkg paramater wass passed (not implemented)
   *    b. otherwise, of the current project
   *    c. finally, of the CLI library
   *
   * If the --import flag is set, copy the template to the templates/class folder of the current project,
   * so it can be customized and used instead of the one shipped with the CLI.
   *
   * If you place a file named `header.js` in the root of your project, this header will be used verbatim
   * as the ${header} template variable instead of the generic header template, which is populated with
   * information from Manifest.json
   *
   * (Package support is not yet implemented)
   *
   */


  qx.Class.define("qx.tool.cli.commands.add.Class", {
    extend: qx.tool.cli.commands.Command,
    statics: {
      getYargsCommand: function () {
        return {
          command: "class <classname> [options]",
          describe: "adds a new class file to the current project, based on a template.",
          builder: {
            "type": {
              alias: "t",
              describe: "the type of the class (optional).",
              default: "default"
            },
            "extend": {
              alias: "e",
              describe: "the base class of the new class"
            },
            "import": {
              describe: "import the template to the `templates/class` folder of the current project, where it can be customized"
            },
            "force": {
              alias: "f",
              describe: "overwrite an existing file"
            }
          }
        };
      }
    },
    members: {
      process: async function () {
        let argv = this.argv; // read Manifest.json

        let manifestConfig = await qx.tool.config.Manifest.getInstance().load();
        let manifestData = manifestConfig.getData(); // prepare template vars

        let values = Object.assign({}, manifestData.info, manifestData.provides); // @todo Add support for authors, ask interactively if author info should be taken
        // from Manifest or entered manually, then create string representation to insert.

        values.authors = "";
        values.classname = argv.classname;
        values.extend = argv.extend ? argv.extend : "qx.core.Object"; // @todo ask interactively for copyright holder, create a setting in Manifest.json

        values.copyright = new Date().getFullYear(); // check top-level namespace

        let class_namespaces = argv.classname.split(/\./);
        let manifest_namepaces = values.namespace.split(/\./);

        if (class_namespaces[0] !== manifest_namepaces[0]) {
          throw new qx.tool.utils.Utils.UserError(`Invalid top namespace '${class_namespaces[0]}'. Must be '${manifest_namepaces[0]}'.`);
        } // get path to the template file


        let template_name = argv.type;
        let template_path;
        let potential_dirs = [// 1. in the templates/class dir of the current project
        path.join(process.cwd(), "templates"), // 2. in the templates/class dir of cli
        this.getTemplateDir() // 3. @todo: in a package's templates dir
        ];
        let found = false;

        for (let dir of potential_dirs) {
          template_path = path.join(dir, "class", template_name + ".tmpl.js");

          if (await fs.existsAsync(template_path)) {
            found = true;
            break;
          }
        }

        if (!found) {
          throw new qx.tool.utils.Utils.UserError(`Template ${template_name} does not exist.`);
        }

        let template = await fs.readFileAsync(template_path, "utf-8"); // handle header macro in the project root

        let header_template;
        let header_template_path = path.join(process.cwd(), "header.js");

        try {
          header_template = fs.readFileSync(header_template_path, "utf-8");
        } catch (e) {
          // if none exists, use header template in the same folder as the template itself
          header_template_path = path.join(path.dirname(template_path), "header.tmpl.js");

          try {
            header_template = fs.readFileSync(header_template_path, "utf-8");
          } catch (e) {}
        }

        if (header_template) {
          // replace template vars in header
          if (header_template_path.includes(".tmpl.js")) {
            for (let var_name in values) {
              header_template = header_template.replace(new RegExp(`\\$\{${var_name}\}`, "g"), values[var_name]);
            }
          }

          values.header = header_template;
        } // replace template vars


        let final_content = template;

        for (let var_name in values) {
          final_content = final_content.replace(new RegExp(`\\$\{${var_name}\}`, "g"), values[var_name]);
        } // check if file already exists


        let relative_path = path.join("source", "class", ...class_namespaces) + ".js";
        let absolute_path = path.join(process.cwd(), relative_path);
        let file_exists = false;

        try {
          fs.accessSync(absolute_path);
          file_exists = true;
        } catch (e) {}

        if (file_exists && !argv.force) {
          throw new qx.tool.utils.Utils.UserError(`Class file ${relative_path} already exists. Use --force to overwrite it`);
        } // write out new class file


        try {
          require("mkdirp").sync(path.dirname(absolute_path), 0o755);

          await fs.writeFileAsync(absolute_path, final_content, "utf-8");
        } catch (e) {
          throw new qx.tool.utils.Utils.UserError(`Cannot write to ${absolute_path}: ${e.message}`);
        } // import


        if (argv.import) {
          let local_templates_path = path.join(process.cwd(), "templates", "class");
          let local_copy_path = path.join(local_templates_path, path.basename(template_path));

          try {
            require("mkdirp").sync(local_templates_path, 0o755);

            await fs.writeFileAsync(local_copy_path, template, "utf-8");
          } catch (e) {
            throw new qx.tool.utils.Utils.UserError(`Cannot copy template to ${local_templates_path}: ${e.message}`);
          }
        }
      }
    }
  });
  qx.tool.cli.commands.add.Class.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.tool.cli.commands.Command": {
        "require": true
      },
      "qx.tool.config.Manifest": {},
      "qx.tool.utils.Utils": {},
      "qx.tool.compiler.Console": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2017 Christian Boulanger and others
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Boulanger (info@bibliograph.org, @cboulanger)
  
  ************************************************************************ */
  const fs = require("fs");

  const process = require("process");

  const path = require("upath");

  const inquirer = require("inquirer");
  /**
   * Add a new script file to the current project, to be loaded by the qooxdoo boot loader
   *
   * Syntax: `qx add script path/to/script.js`
   *
   */


  qx.Class.define("qx.tool.cli.commands.add.Script", {
    extend: qx.tool.cli.commands.Command,
    statics: {
      getYargsCommand: function () {
        return {
          command: "script <scriptpath> [options]",
          describe: "adds a new script file to the current project, to be loaded before application startup.",
          builder: {
            "resourcedir": {
              describe: "The subdirectory of the resource folder in which to place the file",
              alias: "d",
              default: "js"
            },
            "rename": {
              describe: "Rename the file to the given name",
              alias: "r"
            },
            "undo": {
              describe: "Removes the file that would normally be added with the given arguments",
              alias: "z"
            },
            "noninteractive": {
              alias: "I",
              describe: "Do not prompt user"
            }
          }
        };
      }
    },
    members: {
      process: async function () {
        let manifestModel = await qx.tool.config.Manifest.getInstance().load();
        let namespace = manifestModel.getValue("provides.namespace");
        let script_path = this.argv.scriptpath;
        let script_name = path.basename(script_path);
        let resource_dir_path = path.join(process.cwd(), "source", "resource", namespace, this.argv.resourcedir);
        let resource_file_path = path.join(resource_dir_path, this.argv.rename || script_name);
        let external_res_path = path.join(namespace, this.argv.resourcedir, this.argv.rename || script_name); // validate file paths

        if (!script_path.endsWith(".js")) {
          throw new qx.tool.utils.Utils.UserError("File doesn't seem to be a javascript file.");
        }

        if (!(await fs.existsAsync(script_path)) && !this.argv.undo) {
          throw new qx.tool.utils.Utils.UserError(`File does not exist: ${script_path}`);
        }

        if ((await fs.existsAsync(resource_file_path)) && !this.argv.undo) {
          if (!this.argv.noninteractive) {
            let question = {
              type: "confirm",
              name: "doOverwrite",
              message: `Script already exists and will be overwritten. Do you want to proceed?`,
              default: "y"
            };
            let answer = await inquirer.prompt(question);

            if (!answer.doOverwrite) {
              process.exit(0);
            }
          }
        } // check manifest structure


        let script_list = manifestModel.getValue("externalResources.script") || [];

        if (this.argv.undo) {
          // undo, i.e. remove file from resource folder and Manifest
          if (script_list.includes(external_res_path)) {
            script_list = script_list.filter(elem => elem !== external_res_path);
          }

          if (await fs.existsAsync(resource_file_path)) {
            await fs.unlinkAsync(resource_file_path);
          }
        } else {
          // copy script to app resources and add to manifest
          if (!(await fs.existsAsync(resource_dir_path))) {
            require("mkdirp").sync(resource_dir_path, 0o755);
          }

          await fs.copyFileAsync(script_path, resource_file_path);

          if (!script_list.includes(external_res_path)) {
            script_list.push(external_res_path);
          }
        } // save


        qx.tool.compiler.Console.debug(script_list);
        manifestModel.setValue("externalResources.script", script_list).save();
      }
    }
  });
  qx.tool.cli.commands.add.Script.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.tool.cli.commands.Package": {
        "require": true
      },
      "qx.tool.compiler.Console": {},
      "qx.tool.utils.Utils": {},
      "qx.tool.cli.ConfigDb": {},
      "qx.tool.config.Registry": {},
      "qx.tool.config.Abstract": {},
      "qx.tool.config.Manifest": {},
      "qx.tool.utils.Json": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2017 Christian Boulanger
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Boulanger (info@bibliograph.org, @cboulanger)
  
  ************************************************************************ */
  const fs = require("fs");

  const path = require("upath");

  const process = require("process");

  const {
    Octokit
  } = require("@octokit/rest");

  const semver = require("semver");

  const inquirer = require("inquirer");

  const glob = require("glob");
  /**
   * Publishes a release on GitHub
   */


  qx.Class.define("qx.tool.cli.commands.package.Publish", {
    extend: qx.tool.cli.commands.Package,
    statics: {
      getYargsCommand: function () {
        return {
          command: "publish",
          describe: "publishes a new release of the package on GitHub. Requires a GitHub access token. By default, makes a patch release.",
          builder: {
            "type": {
              alias: "t",
              describe: "Set the release type",
              nargs: 1,
              requiresArg: true,
              choices: "major,premajor,minor,preminor,patch,prepatch,prerelease".split(/,/),
              type: "string",
              default: "patch"
            },
            "noninteractive": {
              alias: "I",
              describe: "Do not prompt user"
            },
            "use-version": {
              alias: "V",
              describe: "Use given version number"
            },
            "prerelease": {
              alias: "p",
              describe: "Publish as a prerelease (as opposed to a stable release)"
            },
            "quiet": {
              alias: "q",
              describe: "No output"
            },
            "message": {
              alias: "m",
              describe: "Set commit/release message"
            },
            "dryrun": {
              alias: "d",
              describe: "Show result only, do not publish to GitHub"
            },
            "verbose": {
              alias: "v",
              describe: "Verbose logging"
            },
            "force": {
              alias: "f",
              describe: "Ignore warnings (such as demo check)"
            },
            "create-index": {
              alias: "i",
              describe: "Create an index file (qooxdoo.json) with paths to Manifest.json files"
            }
          }
        };
      }
    },
    members: {
      /**
       * Publishes a new release of the package on GitHub, by executing the following steps:
       *
       * 1. In Manifest.json, update the qooxdoo-range value to include the version of the qooxdoo
       *    framework (As per package.json).
       * 2. In Manifest.json, based the given options, increment the version number (patch,
       *    feature, breaking).
       * 3. Create a release with the tag vX.Y.Z according to the current version.
       * 4. Add "qooxdoo-package" to the list of GitHub topics.
       *
       */
      process: async function () {
        await qx.tool.cli.commands.package.Publish.prototype.process.base.call(this); // init

        const argv = this.argv; // qooxdoo version

        let qooxdoo_version = await this.getUserQxVersion();

        if (argv.verbose) {
          qx.tool.compiler.Console.log(`>>> qooxdoo version:  ${qooxdoo_version}`);
        } // check git status


        let status = await this.exec("git status --porcelain");

        if (status.trim() !== "") {
          throw new qx.tool.utils.Utils.UserError("Please commit or stash all remaining changes first.");
        }

        status = await this.exec("git status --porcelain --branch");

        if (status.includes("ahead")) {
          throw new qx.tool.utils.Utils.UserError("Please push all local commits to GitHub first.");
        } // token


        let cfg = await qx.tool.cli.ConfigDb.getInstance();
        let github = cfg.db("github", {});

        if (!github.token) {
          let response = await inquirer.prompt([{
            type: "input",
            name: "token",
            message: "Publishing to GitHub requires an API token - visit https://github.com/settings/tokens to obtain one (you must assign permission to publish);\nWhat is your GitHub API Token ? "
          }]);

          if (!response.token) {
            qx.tool.compiler.Console.error("You have not provided a GitHub token.");
            return;
          }

          github.token = response.token;
          cfg.save();
        }

        let token = github.token;

        if (!token) {
          throw new qx.tool.utils.Utils.UserError(`GitHub access token required.`);
        }

        const octokit = new Octokit({
          auth: token
        }); // create index file first?

        if (argv.i) {
          await this.__P_19_0(argv);
        }

        let libraries;
        let version;
        let manifestModels = [];
        let mainManifestModel;
        const cwd = process.cwd();
        const registryModel = qx.tool.config.Registry.getInstance();

        if (await registryModel.exists()) {
          // we have a qooxdoo.json index file containing the paths of libraries in the repository
          await registryModel.load();
          libraries = registryModel.getValue("libraries");

          for (let library of libraries) {
            let manifestModel = await new qx.tool.config.Abstract(qx.tool.config.Manifest.config).set({
              baseDir: path.join(cwd, library.path)
            }).load();
            manifestModels.push(manifestModel); // use the first manifest or the one with a truthy property "main" as reference

            if (!version || library.main) {
              version = manifestModel.getValue("info.version");
              mainManifestModel = manifestModel;
            }
          }
        } else {
          // read Manifest.json
          mainManifestModel = await qx.tool.config.Manifest.getInstance().load();
          manifestModels.push(mainManifestModel); // prevent accidental publication of demo manifest.

          if (!argv.force && mainManifestModel.getValue("provides.namespace").includes(".demo")) {
            throw new qx.tool.utils.Utils.UserError("This seems to be the library demo. Please go into the library root directory to publish the library.");
          }

          libraries = [{
            path: "."
          }];
        } // version


        let new_version;

        if (argv.useVersion) {
          // use user-supplied value
          new_version = semver.coerce(argv.useVersion);

          if (!new_version) {
            throw new qx.tool.utils.Utils.UserError(`${argv.useVersion} is not a valid version number.`);
          }

          new_version = new_version.toString();
        } else {
          // use version number from manifest and increment it
          let old_version = mainManifestModel.getValue("info.version");

          if (!semver.valid(old_version)) {
            throw new qx.tool.utils.Utils.UserError("Invalid version number in Manifest. Must be a valid semver version (x.y.z).");
          }

          new_version = semver.inc(old_version, argv.type);
        } // tag and repo name


        let tag = `v${new_version}`;
        let url;

        try {
          url = (await this.exec("git config --get remote.origin.url")).trim();
        } catch (e) {
          throw new qx.tool.utils.Utils.UserError("Cannot determine remote repository.");
        }

        let repo_name = url.replace(/(https:\/\/github.com\/|git@github.com:)/, "").replace(/\.git/, "");
        let [owner, repo] = repo_name.split(/\//);

        if (argv.verbose) {
          qx.tool.compiler.Console.log(`>>> Repository:  ${repo_name}`);
        }

        let repoExists = false;

        try {
          await octokit.repos.getReleaseByTag({
            owner,
            repo,
            tag
          });
          repoExists = true;
        } catch (e) {}

        if (repoExists) {
          throw new qx.tool.utils.Utils.UserError(`A release with tag '${tag} already exists.'`);
        } // get topics, this will also check credentials


        let result;
        let topics;

        try {
          result = await octokit.repos.getAllTopics({
            owner,
            repo
          });
          topics = result.data.names;
        } catch (e) {
          if (e.message.includes("Bad credentials")) {
            throw new qx.tool.utils.Utils.UserError(`Your token is invalid.`);
          }

          throw e;
        } // prompt user to confirm


        let doRelease = true;

        if (!argv.noninteractive) {
          let question = {
            type: "confirm",
            name: "doRelease",
            message: `This will ${argv.version ? "set" : "increment"} the version to ${new_version} and create a release of the current master on GitHub. Do you want to proceed?`,
            default: "y"
          };
          let answer = await inquirer.prompt(question);
          doRelease = answer.doRelease;
        }

        if (!doRelease) {
          process.exit(0);
        } // framework dependency


        let semver_range = mainManifestModel.getValue("requires.@qooxdoo/framework");

        if (!semver.satisfies(qooxdoo_version, semver_range, {
          loose: true
        })) {
          semver_range += "^" + qooxdoo_version;
        } // update Manifest(s)


        for (let manifestModel of manifestModels) {
          manifestModel.setValue("requires.@qooxdoo/framework", semver_range).setValue("info.version", new_version);

          if (argv.dryrun) {
            if (!argv.quiet) {
              qx.tool.compiler.Console.info(`Dry run: Not committing ${manifestModel.getRelativeDataPath()} with the following content:`);
              qx.tool.compiler.Console.info(manifestModel.getData());
            }
          } else {
            manifestModel.save();
          }
        } // package.json, only supported in the root


        const package_json_path = path.join(process.cwd(), "package.json");

        if (await fs.existsAsync(package_json_path)) {
          let data = await qx.tool.utils.Json.loadJsonAsync(package_json_path);
          data.version = new_version;

          if (this.argv.dryrun) {
            qx.tool.compiler.Console.info("Dry run: Not changing package.json version...");
          } else {
            await qx.tool.utils.Json.saveJsonAsync(package_json_path, data);

            if (!this.argv.quiet) {
              qx.tool.compiler.Console.info(`Updated version in package.json.`);
            }
          }
        }

        if (argv.dryrun) {
          qx.tool.compiler.Console.info(`Dry run: not creating tag and release '${tag}' of ${repo_name}...`);
          process.exit(0);
        } // commit message


        let message;

        if (argv.message) {
          message = argv.message.replace(/"/g, "\\\"");
        } else if (!argv.noninteractive) {
          let question = {
            type: "input",
            name: "message",
            message: `Please enter a commit message:`
          };
          let answer = await inquirer.prompt([question]);
          message = answer.message;
        }

        if (!message) {
          message = `Release v${new_version}`;
        }

        if (!argv.quiet) {
          qx.tool.compiler.Console.info(`Creating tag and release '${tag}' of ${repo_name}...`);
        } // commit and push


        try {
          await this.run("git", ["add", "--all"]);
          await this.run("git", ["commit", `-m "${message}"`, "--allow-empty"]);
          await this.run("git", ["push"]);
          let release_data = {
            owner,
            repo,
            tag_name: tag,
            target_commitish: "master",
            name: tag,
            body: message,
            draft: false,
            prerelease: Boolean(argv.prerelease)
          };
          await octokit.repos.createRelease(release_data);

          if (!argv.quiet) {
            qx.tool.compiler.Console.info(`Published new version '${tag}'.`);
          }
        } catch (e) {
          throw new qx.tool.utils.Utils.UserError(e.message);
        } // add GitHub topic


        const topic = "qooxdoo-package";

        if (!topics.includes(topic)) {
          topics.push(topic);
          await octokit.repos.replaceAllTopics({
            owner,
            repo,
            names: topics
          });

          if (!argv.quiet) {
            qx.tool.compiler.Console.info(`Added GitHub topic '${topic}'.`);
          }
        }
      },

      /**
       * Creates a qooxdoo.json file with paths to Manifest.json files in this repository
       * @private
       */
      __P_19_0: async argv => new Promise((resolve, reject) => {
        if (argv.verbose && !argv.quiet) {
          qx.tool.compiler.Console.info("Creating index file...");
        }

        glob(qx.tool.config.Manifest.config.fileName, {
          matchBase: true
        }, async (err, files) => {
          if (err) {
            reject(err);
          }

          if (!files || !files.length) {
            reject(new qx.tool.utils.Utils.UserError("No Manifest.json files could be found"));
          }

          let mainpath;

          if (files.length > 1) {
            let choices = files.map(p => {
              let m = qx.tool.utils.Json.parseJson(fs.readFileSync(path.join(process.cwd(), p), "utf-8"));
              return {
                name: m.info.name + (m.info.summary ? ": " + m.info.summary : ""),
                value: p
              };
            });
            let answer = await inquirer.prompt({
              name: "mainpath",
              message: "Please choose the main library",
              type: "list",
              choices
            });
            mainpath = answer.mainpath;
          }

          let data = {
            libraries: files.map(p => files.length > 1 && p === mainpath ? {
              path: path.dirname(p),
              main: true
            } : {
              path: path.dirname(p)
            })
          }; // write index file

          const registryModel = qx.tool.config.Registry.getInstance();

          if (argv.dryrun) {
            qx.tool.compiler.Console.info(`Dry run: not creating index file ${registryModel.getRelativeDataPath()} with the following content:`);
            qx.tool.compiler.Console.info(data);
          } else {
            await registryModel.load(data);
            await registryModel.save();

            if (!argv.quiet) {
              qx.tool.compiler.Console.info(`Created index file ${registryModel.getRelativeDataPath()}'.`);
            }
          }

          resolve();
        });
      })
    }
  });
  qx.tool.cli.commands.package.Publish.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.tool.cli.commands.Package": {
        "require": true
      },
      "qx.tool.utils.Utils": {},
      "qx.tool.compiler.Console": {},
      "qx.tool.utils.Json": {},
      "qx.tool.config.Manifest": {},
      "qx.tool.config.Compile": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2017 Christian Boulanger
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Christian Boulanger (info@bibliograph.org, @cboulanger)
  
  ************************************************************************ */
  const fs = require("fs");

  const path = require("upath");

  const rimraf = require("rimraf");
  /**
   * Installs a package
   */


  qx.Class.define("qx.tool.cli.commands.package.Remove", {
    extend: qx.tool.cli.commands.Package,
    statics: {
      getYargsCommand: function () {
        return {
          command: "remove [uri]",
          describe: "removes a package from the configuration.",
          builder: {
            "verbose": {
              alias: "v",
              describe: "Verbose logging"
            },
            "quiet": {
              alias: "q",
              describe: "No output"
            }
          }
        };
      }
    },
    members: {
      /**
       * Removes packages
       */
      process: async function () {
        await qx.tool.cli.commands.package.Remove.prototype.process.base.call(this);

        if (!this.argv.uri) {
          throw new qx.tool.utils.Utils.UserError("No repository name given.");
        } // read libraries array from the lockfile


        let data = await this.getLockfileData(); // currently, the uri is github_username/repo_name[/path/to/repo].

        let parts = this.argv.uri.split(/\//);
        let tag = parts.length > 2 ? "uri" : "repo_name";
        let found = [];
        let libraries = [];

        for (const elem of data.libraries) {
          if (elem[tag] === this.argv.uri) {
            await this.__P_20_0(elem.uri);
            await this.__P_20_1(elem.uri);
            let c = elem.path.split(/\//).length;
            let p = elem.path;

            if (c > parts.length) {
              p = path.dirname(p);
            }

            if (!found.includes(p)) {
              found.push(p);
            }
          } else {
            libraries.push(elem);
          }
        }

        if (found.length) {
          for (const p of found) {
            rimraf.sync(p);
          }

          if (!this.argv.quiet) {
            qx.tool.compiler.Console.info(`Deleted ${found.length} entries for ${this.argv.uri}`);
          }
        } else if (this.argv.verbose) {
          qx.tool.compiler.Console.warn(`No entry for ${this.argv.uri}`);
        }

        data.libraries = libraries;
        fs.writeFileSync(this.getLockfilePath(), JSON.stringify(data, null, 2), "utf-8");

        if (this.argv.verbose) {
          qx.tool.compiler.Console.info(">>> Done.");
        }
      },
      __P_20_1: async function (uri) {
        let manifest = await qx.tool.utils.Json.loadJsonAsync(qx.tool.config.Manifest.config.fileName);

        if (manifest.requires && manifest.requires[uri]) {
          delete manifest.requires[uri];
          await qx.tool.utils.Json.saveJsonAsync(qx.tool.config.Manifest.config.fileName, manifest);
        }
      },

      /**
       * Removes installed applications
       * @param uri
       * @return {Promise<void>}
       * @private
       */
      __P_20_0: async function (uri) {
        let pkgData = await this.getLockfileData();
        let libraryData = pkgData.libraries.find(data => data.uri === uri);

        if (!libraryData) {
          throw new Error("Repo for " + uri + " is not an installed package");
        }

        let manifest = await qx.tool.utils.Json.loadJsonAsync(path.join(libraryData.path, qx.tool.config.Manifest.config.fileName));

        if (!manifest || !manifest.provides || !manifest.provides.application) {
          if (this.argv.verbose) {
            qx.tool.compiler.Console.info(">>> No application to remove.");
          }

          return;
        }

        let compileData = await qx.tool.utils.Json.loadJsonAsync(qx.tool.config.Compile.config.fileName);
        let manifestApp = manifest.provides.application;
        let app = compileData.applications.find(app => {
          if (manifestApp.name && app.name) {
            return manifestApp.name === app.name;
          }

          return manifestApp["class"] === app["class"];
        });

        if (app) {
          let idx = compileData.applications.indexOf(app);
          compileData.applications.splice(idx, 1);

          if (this.argv.verbose) {
            qx.tool.compiler.Console.info(">>> Removed application " + (app.name || app["class"]));
          }

          await qx.tool.utils.Json.saveJsonAsync(qx.tool.config.Compile.config.fileName, compileData);
        }
      }
    }
  });
  qx.tool.cli.commands.package.Remove.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
   *
   *    qooxdoo-compiler - node.js based replacement for the Qooxdoo python
   *    toolchain
   *
   *    https://github.com/qooxdoo/qooxdoo-compiler
   *
   *    Copyright:
   *      2011-2017 Zenesis Limited, http://www.zenesis.com
   *
   *    License:
   *      MIT: https://opensource.org/licenses/MIT
   *
   *      This software is provided under the same licensing terms as Qooxdoo,
   *      please see the LICENSE file in the Qooxdoo project's top-level directory
   *      for details.
   *
   *    Authors:
   *      * John Spackman (john.spackman@zenesis.com, @johnspackman)
   *
   * *********************************************************************** */
  var fs = require("fs");

  qx.Class.define("qx.tool.compiler.Preprocess", {
    extend: qx.core.Object,
    construct: function (path) {
      qx.core.Object.constructor.call(this);
      this.__P_24_0 = path;
    },
    members: {
      __P_24_0: null,
      run: function (outputTo, cb) {
        var t = this;
        fs.readFile(this.__P_24_0, {
          encoding: "utf8"
        }, function (err, data) {
          if (err) {
            cb(err);
          } else {
            t._process(data, function (data) {
              if (typeof outputTo == "string") {
                fs.writeFile(outputTo, data, {
                  encoding: "utf8"
                }, cb);
              } else if (typeof outputTo == "function") {
                outputTo(data, cb);
              } else {
                cb(null, data);
              }
            });
          }
        });
      },
      _process: function (data, cb) {
        data = data.replace(/(''|"")?\/\*#([^\n]+)([\s\S]*)\*\//gm, function (match, quotes, cmd, body) {
          var quote = quotes[0];

          if (quote == "'") {
            body = body.replace(/'/gm, "\\'");
          } else {
            body = body.replace(/"/gm, "\\\"");
          }

          var result = "";
          body.split("\n").forEach(function (line, index) {
            if (index == 0) {
              return;
            }

            if (index > 1) {
              result += " + \n";
            }

            result += quote + line + "\\n" + quote;
          });
          return result;
        });
        cb(data);
      }
    }
  });
  qx.tool.compiler.Preprocess.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.tool.utils.Promisify": {
        "require": true
      },
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      },
      "qx.tool.utils.files.Utils": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
   *
   *    qooxdoo-compiler - node.js based replacement for the Qooxdoo python
   *    toolchain
   *
   *    https://github.com/qooxdoo/qooxdoo-compiler
   *
   *    Copyright:
   *      2011-2019 Zenesis Limited, http://www.zenesis.com
   *
   *    License:
   *      MIT: https://opensource.org/licenses/MIT
   *
   *      This software is provided under the same licensing terms as Qooxdoo,
   *      please see the LICENSE file in the Qooxdoo project's top-level directory
   *      for details.
   *
   *    Authors:
   *      * John Spackman (john.spackman@zenesis.com, @johnspackman)
   *
   * ************************************************************************/
  const fs = qx.tool.utils.Promisify.fs;

  const path = require("upath");

  const crypto = require("crypto");

  const sourceMap = require("source-map");
  /**
   * Copies multiple javascript source files into a single destination, preserving (merging)
   * source maps as it goes.
   *
   * This will not rewrite the output files if the file content will not change.
   */


  qx.Class.define("qx.tool.compiler.targets.SourceCodeCopier", {
    extend: qx.core.Object,

    /**
     * Constructor
     * @param outputFilename {String} the destination file for combined output
     */
    construct: function (outputFilename) {
      qx.core.Object.constructor.call(this);
      let pos = outputFilename.lastIndexOf(".");
      let basename = outputFilename.substring(0, pos);
      this.__P_37_0 = basename + "-tmp.js";
      this.__P_37_1 = basename + ".js";
      this.__P_37_2 = basename + ".js.map";
      this.__P_37_3 = fs.createWriteStream(this.__P_37_0);
      this.__P_37_4 = crypto.createHash("sha256");

      this.__P_37_4.setEncoding("hex");

      this.__P_37_5 = new sourceMap.SourceMapGenerator({
        file: this.__P_37_2
      });
      this.__P_37_6 = 0;
    },
    members: {
      /** {String} Output filename for combined javascript */
      __P_37_1: null,

      /** {String} output filename for temporary code */
      __P_37_0: null,

      /** {String} output filename for the combined sourcemap */
      __P_37_2: null,

      /** {String} write stream for javascript */
      __P_37_3: null,

      /** {crypto.createHash} hash accumulator for combined javascript */
      __P_37_4: null,

      /** {String} hash value for existing combined javascript */
      __P_37_7: null,
      __P_37_5: null,
      __P_37_6: null,

      /**
       * Returns the file the code is copied to
       */
      getOutputFilename() {
        return this.__P_37_1;
      },

      /**
       * Opens the output
       */
      async open() {
        let stat = await qx.tool.utils.files.Utils.safeStat(this.__P_37_1);

        if (stat) {
          let hash = crypto.createHash("sha256");
          hash.setEncoding("hex");
          let data = await fs.readFileAsync(this.__P_37_1, "utf8");
          hash.write(data);
          this.__P_37_7 = this.__P_37_4.read();
        }
      },

      /**
       * Helper method to write output
       * @param str {String} data to write
       */
      __P_37_8(str) {
        this.__P_37_4.write(str);

        this.__P_37_3.write(str);
      },

      /**
       * Adds a source file to the output
       *
       * @param jsFilename {String} filename to add
       * @param jsUri {String} uri of the file being added, relative to the output directory
       */
      async addSourceFile(jsFilename, jsUri) {
        let jsMapFilename = jsFilename + ".map";
        let numLines = 0;
        let data = await fs.readFileAsync(jsFilename, "utf8");
        data = data.replace(/\/\/[@#]\ssourceMappingURL[^\r\n]*/g, "//");
        data += "\n";

        this.__P_37_8(data);

        for (var i = 0; i < data.length; i++) {
          if (data[i] === "\n") {
            numLines++;
          }
        }

        let stat = await qx.tool.utils.files.Utils.safeStat(jsMapFilename);

        if (stat) {
          let source = jsUri || jsFilename;
          data = await fs.readFileAsync(jsMapFilename, "utf8");
          var map = new sourceMap.SourceMapConsumer(data);
          map.eachMapping(mapping => {
            mapping = {
              generated: {
                line: mapping.generatedLine + this.__P_37_6,
                column: mapping.generatedColumn
              },
              original: {
                line: mapping.originalLine || 1,
                column: mapping.originalColumn || 1
              },
              source: source
            };

            this.__P_37_5.addMapping(mapping);
          });
          map.sources.forEach(origSource => this.__P_37_5.setSourceContent(source, map.sourceContentFor(origSource)));
        }

        this.__P_37_6 += numLines;
      },

      /**
       * Closes the output
       */
      async close() {
        this.__P_37_8("\n//# sourceMappingURL=" + path.basename(this.__P_37_2) + "\n");

        this.__P_37_3.end();

        this.__P_37_4.end();

        var hashValue = this.__P_37_4.read();

        if (!this.__P_37_7 || hashValue !== this.__P_37_7) {
          await fs.renameAsync(this.__P_37_0, this.__P_37_1);
          await fs.writeFileAsync(this.__P_37_2, JSON.stringify(JSON.parse(this.__P_37_5.toString()), null, 2), "utf8");
          return true;
        }

        await fs.unlinkAsync(this.__P_37_0);
        return false;
      }

    }
  });
  qx.tool.compiler.targets.SourceCodeCopier.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "construct": true,
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
   *
   *    qooxdoo-compiler - node.js based replacement for the Qooxdoo python
   *    toolchain
   *
   *    https://github.com/qooxdoo/qooxdoo-compiler
   *
   *    Copyright:
   *      2011-2017 Zenesis Limited, http://www.zenesis.com
   *
   *    License:
   *      MIT: https://opensource.org/licenses/MIT
   *
   *      This software is provided under the same licensing terms as Qooxdoo,
   *      please see the LICENSE file in the Qooxdoo project's top-level directory
   *      for details.
   *
   *    Authors:
   *      * John Spackman (john.spackman@zenesis.com, @johnspackman)
   *
   * *********************************************************************** */
  var fs = require("fs");

  var async = require("async");

  qx.Class.define("qx.tool.utils.files.FindFiles", {
    extend: qx.core.Object,
    construct: function (root) {
      qx.core.Object.constructor.call(this);
      this.__P_52_0 = root;
    },
    properties: {
      matchFiles: {
        init: null,
        nullable: true,
        check: "RegEx"
      }
    },
    members: {
      __P_52_0: null,
      scan: function (notify, cb) {
        cb = cb || function () {};

        var t = this;

        function scanImpl(path, cb) {
          async.waterfall([function (cb) {
            fs.readdir(path, cb);
          }, function (files, cb) {
            async.forEach(files, function (file, cb) {
              fs.stat(path + "/" + file, function (err, stat) {
                if (err) {
                  cb(err);
                  return;
                }

                if (stat.isDirectory()) {
                  scanImpl(path + "/" + file, cb);
                  return;
                }

                if (stat.isFile()) {
                  t._onFindFile(path + "/" + file, notify, cb);

                  return;
                }

                cb();
              });
            }, cb);
          }], cb);
        }

        scanImpl(this.__P_52_0, cb);
      },
      _onFindFile: function (file, notify, cb) {
        var re = this.getMatchFiles();

        if (re && !re.test(file)) {
          return;
        }

        notify(file, cb);
      }
    }
  });
  qx.tool.utils.files.FindFiles.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
  
  ************************************************************************ */

  /**
   * Theme classes contain styling information for certain aspects of the
   * graphical user interface.
   *
   * Supported themes are: colors, decorations, fonts, icons, appearances.
   * The additional meta theme allows for grouping of the individual
   * themes.
   *
   * For more details, take a look at the
   * <a href='http://qooxdoo.org/docs/#desktop/gui/theming.md' target='_blank'>
   * documentation of the theme system in the qooxdoo manual.</a>
   */
  qx.Bootstrap.define("qx.Theme", {
    statics: {
      /*
      ---------------------------------------------------------------------------
         PUBLIC API
      ---------------------------------------------------------------------------
      */

      /**
       * Theme config
       *
       * Example:
       * <pre class='javascript'>
       * qx.Theme.define("name",
       * {
       *   aliases : {
       *     "aliasKey" : "resourceFolderOrUri"
       *   },
       *   extend : otherTheme,
       *   include : [MMixinTheme],
       *   patch : [MMixinTheme],
       *   colors : {},
       *   decorations : {},
       *   fonts : {},
       *   widgets : {},
       *   appearances : {},
       *   meta : {},
       *   boot : function(){}
       * });
       * </pre>
       *
       * For more details, take a look at the
       * <a href='http://qooxdoo.org/docs/#desktop/gui/theming.md' target='_blank'>
       * documentation of the theme system in the qooxdoo manual.</a>
       *
       * @param name {String} name of the mixin
       * @param config {Map} config structure
       */
      define: function (name, config) {
        if (!config) {
          var config = {};
        }

        config.include = this.__P_68_0(config.include);
        config.patch = this.__P_68_0(config.patch); // Validate incoming data

        // Create alias
        var theme = {
          $$type: "Theme",
          name: name,
          title: config.title,
          // Attach toString
          toString: this.genericToString
        }; // Remember extend

        if (config.extend) {
          theme.supertheme = config.extend;
        } // Assign to namespace


        theme.basename = qx.Bootstrap.createNamespace(name, theme); // Convert theme entry from Object to Function (for prototype inheritance)

        this.__P_68_1(theme, config);

        this.__P_68_2(theme, config); // Store class reference in global class registry


        this.$$registry[name] = theme; // Include mixin themes

        for (var i = 0, a = config.include, l = a.length; i < l; i++) {
          this.include(theme, a[i]);
        }

        for (var i = 0, a = config.patch, l = a.length; i < l; i++) {
          this.patch(theme, a[i]);
        } // Run boot code


        if (config.boot) {
          config.boot();
        }
      },

      /**
       * Normalize an object to an array
       *
       * @param objectOrArray {Object|Array} Either an object that is to be
       *   normalized to an array, or an array, which is just passed through
       *
       * @return {Array} Either an array that has the original object as its
       *   single item, or the original array itself
       */
      __P_68_0: function (objectOrArray) {
        if (!objectOrArray) {
          return [];
        }

        if (qx.Bootstrap.isArray(objectOrArray)) {
          return objectOrArray;
        } else {
          return [objectOrArray];
        }
      },

      /**
       * Initialize alias inheritance
       *
       * @param theme {Map} The theme
       * @param config {Map} config structure
       */
      __P_68_2: function (theme, config) {
        var aliases = config.aliases || {};

        if (config.extend && config.extend.aliases) {
          qx.Bootstrap.objectMergeWith(aliases, config.extend.aliases, false);
        }

        theme.aliases = aliases;
      },

      /**
       * Return a map of all known themes
       *
       * @return {Map} known themes
       */
      getAll: function () {
        return this.$$registry;
      },

      /**
       * Returns a theme by name
       *
       * @param name {String} theme name to check
       * @return {Object ? void} theme object
       */
      getByName: function (name) {
        return this.$$registry[name];
      },

      /**
       * Determine if theme exists
       *
       * @param name {String} theme name to check
       * @return {Boolean} true if theme exists
       */
      isDefined: function (name) {
        return this.getByName(name) !== undefined;
      },

      /**
       * Determine the number of themes which are defined
       *
       * @return {Number} the number of classes
       */
      getTotalNumber: function () {
        return qx.Bootstrap.objectGetLength(this.$$registry);
      },

      /*
      ---------------------------------------------------------------------------
         PRIVATE/INTERNAL API
      ---------------------------------------------------------------------------
      */

      /**
       * This method will be attached to all themes to return
       * a nice identifier for them.
       *
       * @internal
       * @return {String} The interface identifier
       */
      genericToString: function () {
        return "[Theme " + this.name + "]";
      },

      /**
       * Extract the inheritable key (could be only one)
       *
       * @param config {Map} The map from where to extract the key
       * @return {String} the key which was found
       */
      __P_68_3: function (config) {
        for (var i = 0, keys = this.__P_68_4, l = keys.length; i < l; i++) {
          if (config[keys[i]]) {
            return keys[i];
          }
        }
      },

      /**
       * Convert existing entry to a prototype based inheritance function
       *
       * @param theme {Theme} newly created theme object
       * @param config {Map} incoming theme configuration
       */
      __P_68_1: function (theme, config) {
        var type = this.__P_68_3(config); // Use theme key from extended theme if own one is not available


        if (config.extend && !type) {
          type = config.extend.type;
        } // Save theme type


        theme.type = type || "other"; // Create pseudo class

        var clazz = function () {}; // Process extend config


        if (config.extend) {
          clazz.prototype = new config.extend.$$clazz();
        }

        var target = clazz.prototype;
        var source = config[type]; // Copy entries to prototype

        for (var id in source) {
          target[id] = source[id]; // Appearance themes only:
          // Convert base flag to class reference (needed for mixin support)

          if (target[id].base) {
            target[id].base = config.extend;
          }
        } // store pseudo class


        theme.$$clazz = clazz; // and create instance under the old key

        theme[type] = new clazz();
      },

      /** @type {Map} Internal theme registry */
      $$registry: {},

      /** @type {Array} Keys which support inheritance */
      __P_68_4: ["colors", "borders", "decorations", "fonts", "icons", "widgets", "appearances", "meta"],

      /** @type {Map} allowed keys in theme definition */
      __P_68_5: null,

      /** @type {Map} allowed keys inside a meta theme block */
      __P_68_6: null,

      /**
       * Validates incoming configuration and checks keys and values
       *
       * @signature function(name, config)
       * @param name {String} The name of the class
       * @param config {Map} Configuration map
       * @throws {Error} if the given config is not valid (e.g. wrong key or wrong key value)
       */
      __P_68_7: function () {},

      /**
       * Include all keys of the given mixin theme into the theme. The mixin may
       * include keys which are already defined in the target theme. Existing
       * features of equal name will be overwritten.
       *
       * @param theme {Theme} An existing theme which should be modified by including the mixin theme.
       * @param mixinTheme {Theme} The theme to be included.
       */
      patch: function (theme, mixinTheme) {
        this.__P_68_8(mixinTheme);

        var type = this.__P_68_3(mixinTheme);

        if (type !== this.__P_68_3(theme)) {
          throw new Error("The mixins '" + theme.name + "' are not compatible '" + mixinTheme.name + "'!");
        }

        var source = mixinTheme[type];
        var target = theme.$$clazz.prototype;

        for (var key in source) {
          target[key] = source[key];
        }
      },

      /**
       * Include all keys of the given mixin theme into the theme. If the
       * mixin includes any keys that are already available in the
       * class, they will be silently ignored. Use the {@link #patch} method
       * if you need to overwrite keys in the current class.
       *
       * @param theme {Theme} An existing theme which should be modified by including the mixin theme.
       * @param mixinTheme {Theme} The theme to be included.
       */
      include: function (theme, mixinTheme) {
        this.__P_68_8(mixinTheme);

        var type = mixinTheme.type;

        if (type !== theme.type) {
          throw new Error("The mixins '" + theme.name + "' are not compatible '" + mixinTheme.name + "'!");
        }

        var source = mixinTheme[type];
        var target = theme.$$clazz.prototype;

        for (var key in source) {
          //Skip keys already present
          if (target[key] !== undefined) {
            continue;
          }

          target[key] = source[key];
        }
      },

      /**
       * Helper method to check for an invalid theme
       *
       * @param mixinTheme {qx.Theme?null} theme to check
       * @throws {Error} if the theme is not valid
       */
      __P_68_8: function (mixinTheme) {
        if (typeof mixinTheme === "undefined" || mixinTheme == null) {
          var errorObj = new Error("Mixin theme is not a valid theme!");
          throw errorObj;
        }
      }
    }
  });
  qx.Theme.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.bom.Style": {
        "require": true,
        "defer": "runtime"
      },
      "qx.core.Environment": {
        "defer": "load",
        "require": true
      },
      "qx.Bootstrap": {
        "usage": "dynamic",
        "require": true
      },
      "qx.bom.client.Engine": {
        "require": true
      },
      "qx.bom.client.Browser": {}
    },
    "environment": {
      "provided": ["css.textoverflow", "css.placeholder", "css.borderradius", "css.boxshadow", "css.gradient.linear", "css.gradient.radial", "css.gradient.legacywebkit", "css.boxmodel", "css.rgba", "css.borderimage", "css.borderimage.standardsyntax", "css.usermodify", "css.userselect", "css.userselect.none", "css.appearance", "css.float", "css.boxsizing", "css.inlineblock", "css.opacity", "css.textShadow", "css.alphaimageloaderneeded", "css.pointerevents", "css.flexboxSyntax"],
      "required": {
        "engine.name": {
          "className": "qx.bom.client.Engine"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * The purpose of this class is to contain all checks about css.
   *
   * This class is used by {@link qx.core.Environment} and should not be used
   * directly. Please check its class comment for details how to use it.
   *
   * @internal
   * @ignore(WebKitCSSMatrix)
   * @require(qx.bom.Style)
   */
  qx.Bootstrap.define("qx.bom.client.Css", {
    statics: {
      __P_85_0: null,

      /**
       * Checks what box model is used in the current environment.
       * @return {String} It either returns "content" or "border".
       * @internal
       */
      getBoxModel: function () {
        var content = qx.bom.client.Engine.getName() !== "mshtml" || !qx.bom.client.Browser.getQuirksMode();
        return content ? "content" : "border";
      },

      /**
       * Returns the (possibly vendor-prefixed) name the browser uses for the
       * <code>textOverflow</code> style property.
       *
       * @return {String|null} textOverflow property name or <code>null</code> if
       * textOverflow is not supported.
       * @internal
       */
      getTextOverflow: function () {
        return qx.bom.Style.getPropertyName("textOverflow");
      },

      /**
       * Checks if a placeholder could be used.
       * @return {Boolean} <code>true</code>, if it could be used.
       * @internal
       */
      getPlaceholder: function () {
        if (qx.core.Environment.get("engine.name") === "mshtml") {
          return false;
        }

        var i = document.createElement("input");
        return "placeholder" in i;
      },

      /**
       * Returns the (possibly vendor-prefixed) name the browser uses for the
       * <code>appearance</code> style property.
       *
       * @return {String|null} appearance property name or <code>null</code> if
       * appearance is not supported.
       * @internal
       */
      getAppearance: function () {
        return qx.bom.Style.getPropertyName("appearance");
      },

      /**
       * Returns the (possibly vendor-prefixed) name the browser uses for the
       * <code>borderRadius</code> style property.
       *
       * @return {String|null} borderRadius property name or <code>null</code> if
       * borderRadius is not supported.
       * @internal
       */
      getBorderRadius: function () {
        return qx.bom.Style.getPropertyName("borderRadius");
      },

      /**
       * Returns the (possibly vendor-prefixed) name the browser uses for the
       * <code>boxShadow</code> style property.
       *
       * @return {String|null} boxShadow property name or <code>null</code> if
       * boxShadow is not supported.
       * @internal
       */
      getBoxShadow: function () {
        return qx.bom.Style.getPropertyName("boxShadow");
      },

      /**
       * Returns the (possibly vendor-prefixed) name the browser uses for the
       * <code>borderImage</code> style property.
       *
       * @return {String|null} borderImage property name or <code>null</code> if
       * borderImage is not supported.
       * @internal
       */
      getBorderImage: function () {
        return qx.bom.Style.getPropertyName("borderImage");
      },

      /**
       * Returns the type of syntax this client supports for its CSS border-image
       * implementation. Some browsers do not support the "fill" keyword defined
       * in the W3C draft (http://www.w3.org/TR/css3-background/) and will not
       * show the border image if it's set. Others follow the standard closely and
       * will omit the center image if "fill" is not set.
       *
       * @return {Boolean|null} <code>true</code> if the standard syntax is supported.
       * <code>null</code> if the supported syntax could not be detected.
       * @internal
       */
      getBorderImageSyntax: function () {
        var styleName = qx.bom.client.Css.getBorderImage();

        if (!styleName) {
          return null;
        }

        var el = document.createElement("div");

        if (styleName === "borderImage") {
          // unprefixed implementation: check individual properties
          el.style[styleName] = 'url("foo.png") 4 4 4 4 fill stretch';

          if (el.style.borderImageSource.indexOf("foo.png") >= 0 && el.style.borderImageSlice.indexOf("4 fill") >= 0 && el.style.borderImageRepeat.indexOf("stretch") >= 0) {
            return true;
          }
        } else {
          // prefixed implementation, assume no support for "fill"
          el.style[styleName] = 'url("foo.png") 4 4 4 4 stretch'; // serialized value is unreliable, so just a simple check

          if (el.style[styleName].indexOf("foo.png") >= 0) {
            return false;
          }
        } // unable to determine syntax


        return null;
      },

      /**
       * Returns the (possibly vendor-prefixed) name the browser uses for the
       * <code>userSelect</code> style property.
       *
       * @return {String|null} userSelect property name or <code>null</code> if
       * userSelect is not supported.
       * @internal
       */
      getUserSelect: function () {
        return qx.bom.Style.getPropertyName("userSelect");
      },

      /**
       * Returns the (possibly vendor-prefixed) value for the
       * <code>userSelect</code> style property that disables selection. For Gecko,
       * "-moz-none" is returned since "none" only makes the target element appear
       * as if its text could not be selected
       *
       * @internal
       * @return {String|null} the userSelect property value that disables
       * selection or <code>null</code> if userSelect is not supported
       */
      getUserSelectNone: function () {
        var styleProperty = qx.bom.client.Css.getUserSelect();

        if (styleProperty) {
          var el = document.createElement("span");
          el.style[styleProperty] = "-moz-none";
          return el.style[styleProperty] === "-moz-none" ? "-moz-none" : "none";
        }

        return null;
      },

      /**
       * Returns the (possibly vendor-prefixed) name the browser uses for the
       * <code>userModify</code> style property.
       *
       * @return {String|null} userModify property name or <code>null</code> if
       * userModify is not supported.
       * @internal
       */
      getUserModify: function () {
        return qx.bom.Style.getPropertyName("userModify");
      },

      /**
       * Returns the vendor-specific name of the <code>float</code> style property
       *
       * @return {String|null} <code>cssFloat</code> for standards-compliant
       * browsers, <code>styleFloat</code> for legacy IEs, <code>null</code> if
       * the client supports neither property.
       * @internal
       */
      getFloat: function () {
        var style = document.documentElement.style;
        return style.cssFloat !== undefined ? "cssFloat" : style.styleFloat !== undefined ? "styleFloat" : null;
      },

      /**
       * Returns the (possibly vendor-prefixed) name this client uses for
       * <code>linear-gradient</code>.
       * http://dev.w3.org/csswg/css3-images/#linear-gradients
       *
       * @return {String|null} Prefixed linear-gradient name or <code>null</code>
       * if linear gradients are not supported
       * @internal
       */
      getLinearGradient: function () {
        qx.bom.client.Css.__P_85_0 = false;
        var value = "linear-gradient(0deg, #fff, #000)";
        var el = document.createElement("div");
        var style = qx.bom.Style.getAppliedStyle(el, "backgroundImage", value);

        if (!style) {
          //try old WebKit syntax (versions 528 - 534.16)
          value = "-webkit-gradient(linear,0% 0%,100% 100%,from(white), to(red))";
          var style = qx.bom.Style.getAppliedStyle(el, "backgroundImage", value, false);

          if (style) {
            qx.bom.client.Css.__P_85_0 = true;
          }
        } // not supported


        if (!style) {
          return null;
        }

        var match = /(.*?)\(/.exec(style);
        return match ? match[1] : null;
      },

      /**
       * Returns the (possibly vendor-prefixed) name this client uses for
       * <code>radial-gradient</code>.
       *
       * @return {String|null} Prefixed radial-gradient name or <code>null</code>
       * if radial gradients are not supported
       * @internal
       */
      getRadialGradient: function () {
        var value = "radial-gradient(0px 0px, cover, red 50%, blue 100%)";
        var el = document.createElement("div");
        var style = qx.bom.Style.getAppliedStyle(el, "backgroundImage", value);

        if (!style) {
          return null;
        }

        var match = /(.*?)\(/.exec(style);
        return match ? match[1] : null;
      },

      /**
       * Checks if **only** the old WebKit (version < 534.16) syntax for
       * linear gradients is supported, e.g.
       * <code>linear-gradient(0deg, #fff, #000)</code>
       *
       * @return {Boolean} <code>true</code> if the legacy syntax must be used
       * @internal
       */
      getLegacyWebkitGradient: function () {
        if (qx.bom.client.Css.__P_85_0 === null) {
          qx.bom.client.Css.getLinearGradient();
        }

        return qx.bom.client.Css.__P_85_0;
      },

      /**
       * Checks if rgba colors can be used:
       * http://www.w3.org/TR/2010/PR-css3-color-20101028/#rgba-color
       *
       * @return {Boolean} <code>true</code>, if rgba colors are supported.
       * @internal
       */
      getRgba: function () {
        var el;

        try {
          el = document.createElement("div");
        } catch (ex) {
          el = document.createElement();
        } // try catch for IE


        try {
          el.style["color"] = "rgba(1, 2, 3, 0.5)";

          if (el.style["color"].indexOf("rgba") != -1) {
            return true;
          }
        } catch (ex) {}

        return false;
      },

      /**
       * Returns the (possibly vendor-prefixed) name the browser uses for the
       * <code>boxSizing</code> style property.
       *
       * @return {String|null} boxSizing property name or <code>null</code> if
       * boxSizing is not supported.
       * @internal
       */
      getBoxSizing: function () {
        return qx.bom.Style.getPropertyName("boxSizing");
      },

      /**
       * Returns the browser-specific name used for the <code>display</code> style
       * property's <code>inline-block</code> value.
       *
       * @internal
       * @return {String|null}
       */
      getInlineBlock: function () {
        var el = document.createElement("span");
        el.style.display = "inline-block";

        if (el.style.display == "inline-block") {
          return "inline-block";
        }

        el.style.display = "-moz-inline-box";

        if (el.style.display !== "-moz-inline-box") {
          return "-moz-inline-box";
        }

        return null;
      },

      /**
       * Checks if CSS opacity is supported
       *
       * @internal
       * @return {Boolean} <code>true</code> if opacity is supported
       */
      getOpacity: function () {
        return typeof document.documentElement.style.opacity == "string";
      },

      /**
       * Checks if CSS texShadow is supported
       *
       * @internal
       * @return {Boolean} <code>true</code> if textShadow is supported
       */
      getTextShadow: function () {
        return !!qx.bom.Style.getPropertyName("textShadow");
      },

      /**
       * Checks if the Alpha Image Loader must be used to display transparent PNGs.
       *
       * @return {Boolean} <code>true</code> if the Alpha Image Loader is required
       */
      getAlphaImageLoaderNeeded: function () {
        return qx.bom.client.Engine.getName() == "mshtml" && qx.bom.client.Browser.getDocumentMode() < 9;
      },

      /**
       * Checks if pointer events are available.
       *
       * @internal
       * @return {Boolean} <code>true</code> if pointer events are supported.
       */
      getPointerEvents: function () {
        var el = document.documentElement; // Check if browser reports that pointerEvents is a known style property

        if ("pointerEvents" in el.style) {
          // The property is defined in Opera and IE9 but setting it has no effect
          var initial = el.style.pointerEvents;
          el.style.pointerEvents = "auto"; // don't assume support if a nonsensical value isn't ignored

          el.style.pointerEvents = "foo";
          var supported = el.style.pointerEvents == "auto";
          el.style.pointerEvents = initial;
          return supported;
        }

        return false;
      },

      /**
       * Returns which Flexbox syntax is supported by the browser.
       * <code>display: box;</code> old 2009 version of Flexbox.
       * <code>display: flexbox;</code> tweener phase in 2011.
       * <code>display: flex;</code> current specification.
       * @internal
       * @return {String} <code>flex</code>,<code>flexbox</code>,<code>box</code> or <code>null</code>
       */
      getFlexboxSyntax: function () {
        var detectedSyntax = null;
        var detector = document.createElement("detect");
        var flexSyntax = [{
          value: "flex",
          syntax: "flex"
        }, {
          value: "-ms-flexbox",
          syntax: "flexbox"
        }, {
          value: "-webkit-flex",
          syntax: "flex"
        }];

        for (var i = 0; i < flexSyntax.length; i++) {
          // old IEs will throw an "Invalid argument" exception here
          try {
            detector.style.display = flexSyntax[i].value;
          } catch (ex) {
            return null;
          }

          if (detector.style.display === flexSyntax[i].value) {
            detectedSyntax = flexSyntax[i].syntax;
            break;
          }
        }

        detector = null;
        return detectedSyntax;
      }
    },
    defer: function (statics) {
      qx.core.Environment.add("css.textoverflow", statics.getTextOverflow);
      qx.core.Environment.add("css.placeholder", statics.getPlaceholder);
      qx.core.Environment.add("css.borderradius", statics.getBorderRadius);
      qx.core.Environment.add("css.boxshadow", statics.getBoxShadow);
      qx.core.Environment.add("css.gradient.linear", statics.getLinearGradient);
      qx.core.Environment.add("css.gradient.radial", statics.getRadialGradient);
      qx.core.Environment.add("css.gradient.legacywebkit", statics.getLegacyWebkitGradient);
      qx.core.Environment.add("css.boxmodel", statics.getBoxModel);
      qx.core.Environment.add("css.rgba", statics.getRgba);
      qx.core.Environment.add("css.borderimage", statics.getBorderImage);
      qx.core.Environment.add("css.borderimage.standardsyntax", statics.getBorderImageSyntax);
      qx.core.Environment.add("css.usermodify", statics.getUserModify);
      qx.core.Environment.add("css.userselect", statics.getUserSelect);
      qx.core.Environment.add("css.userselect.none", statics.getUserSelectNone);
      qx.core.Environment.add("css.appearance", statics.getAppearance);
      qx.core.Environment.add("css.float", statics.getFloat);
      qx.core.Environment.add("css.boxsizing", statics.getBoxSizing);
      qx.core.Environment.add("css.inlineblock", statics.getInlineBlock);
      qx.core.Environment.add("css.opacity", statics.getOpacity);
      qx.core.Environment.add("css.textShadow", statics.getTextShadow);
      qx.core.Environment.add("css.alphaimageloaderneeded", statics.getAlphaImageLoaderNeeded);
      qx.core.Environment.add("css.pointerevents", statics.getPointerEvents);
      qx.core.Environment.add("css.flexboxSyntax", statics.getFlexboxSyntax);
    }
  });
  qx.bom.client.Css.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.core.Environment": {
        "defer": "load",
        "usage": "dynamic",
        "require": true
      },
      "qx.Theme": {
        "usage": "dynamic",
        "require": true
      },
      "qx.bom.client.Css": {
        "require": true
      }
    },
    "environment": {
      "provided": [],
      "required": {
        "css.rgba": {
          "load": true,
          "className": "qx.bom.client.Css"
        }
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * Simple color theme
   */
  qx.Theme.define("qx.theme.simple.Color", {
    colors: {
      // main
      "background": "white",
      "dark-blue": "#5685D6",
      "light-background": "#E0ECFF",
      // backgrounds
      "background-selected": "#6694E3",
      "background-selected-disabled": "#CDCDCD",
      "background-selected-dark": "#5685D6",
      "background-disabled": "#F7F7F7",
      "background-disabled-checked": "#BBBBBB",
      "background-pane": "#FAFBFE",
      // tabview
      "tabview-unselected": "#1866B5",
      "tabview-button-border": "#134983",
      "tabview-label-active-disabled": "#D9D9D9",
      // text colors
      "link": "#24B",
      // scrollbar
      "scrollbar-bright": "#F1F1F1",
      "scrollbar-dark": "#EBEBEB",
      // form
      "button": "#E8F0E3",
      "button-border": "#BBB",
      "button-border-hovered": "#939393",
      "invalid": "#FF0000",
      "button-box-bright": "#F9F9F9",
      "button-box-dark": "#E3E3E3",
      "button-box-bright-pressed": "#DDDDDD",
      "button-box-dark-pressed": "#F5F5F5",
      "border-lead": "#888888",
      // window
      "window-border": "#2E3A46",
      "window-border-inner": "#9DCBFE",
      // group box
      "white-box-border": "#BCBCBC",
      // shadows
      "shadow": qx.core.Environment.get("css.rgba") ? "rgba(0, 0, 0, 0.4)" : "#666666",
      // borders
      // 'border-main' is an alias of 'background-selected' (compatibility reasons)
      "border-main": "#6694E3",
      "border-light": "#B7B7B7",
      "border-light-shadow": "#686868",
      // separator
      "border-separator": "#808080",
      // text
      "text": "black",
      "text-disabled": "#A7A6AA",
      "text-selected": "white",
      "text-placeholder": "#CBC8CD",
      // tooltip
      "tooltip": "#FFFFE1",
      "tooltip-text": "black",
      // table
      "table-header": [242, 242, 242],
      "table-focus-indicator": [179, 217, 255],
      // used in table code
      "table-header-cell": [235, 234, 219],
      "table-row-background-focused-selected": [90, 138, 211],
      "table-row-background-focused": [221, 238, 255],
      "table-row-background-selected": [51, 94, 168],
      "table-row-background-even": "white",
      "table-row-background-odd": "white",
      "table-row-selected": [255, 255, 255],
      "table-row": [0, 0, 0],
      "table-row-line": "#EEE",
      "table-column-line": "#EEE",
      // used in progressive code
      "progressive-table-header": "#AAAAAA",
      "progressive-table-row-background-even": [250, 248, 243],
      "progressive-table-row-background-odd": [255, 255, 255],
      "progressive-progressbar-background": "gray",
      "progressive-progressbar-indicator-done": "#CCCCCC",
      "progressive-progressbar-indicator-undone": "white",
      "progressive-progressbar-percent-background": "gray",
      "progressive-progressbar-percent-text": "white"
    }
  });
  qx.theme.simple.Color.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Theme": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
     * Martin Wittemann (martinwittemann)
  
  ************************************************************************* */

  /**
   * The simple qooxdoo decoration theme.
   */
  qx.Theme.define("qx.theme.simple.Decoration", {
    aliases: {
      decoration: "qx/decoration/Simple"
    },
    decorations: {
      /*
      ---------------------------------------------------------------------------
        CORE
      ---------------------------------------------------------------------------
      */
      "border-blue": {
        style: {
          width: 4,
          color: "background-selected"
        }
      },
      "main": {
        style: {
          width: 1,
          color: "border-main"
        }
      },
      "main-dark": {
        style: {
          width: 1,
          color: "button-border"
        }
      },
      "popup": {
        style: {
          width: 1,
          color: "window-border",
          shadowLength: 2,
          shadowBlurRadius: 5,
          shadowColor: "shadow"
        }
      },
      "dragover": {
        style: {
          bottom: [2, "solid", "dark-blue"]
        }
      },

      /*
      ---------------------------------------------------------------------------
        BUTTON
      ---------------------------------------------------------------------------
      */
      "button-box": {
        style: {
          radius: 3,
          width: 1,
          color: "button-border",
          gradientStart: ["button-box-bright", 40],
          gradientEnd: ["button-box-dark", 70],
          backgroundColor: "button-box-bright"
        }
      },
      "button-box-pressed": {
        include: "button-box",
        style: {
          gradientStart: ["button-box-bright-pressed", 40],
          gradientEnd: ["button-box-dark-pressed", 70],
          backgroundColor: "button-box-bright-pressed"
        }
      },
      "button-box-pressed-hovered": {
        include: "button-box-pressed",
        style: {
          color: "button-border-hovered"
        }
      },
      "button-box-hovered": {
        include: "button-box",
        style: {
          color: "button-border-hovered"
        }
      },

      /*
      ---------------------------------------------------------------------------
        BUTTON INVALID
      ---------------------------------------------------------------------------
      */
      "button-box-invalid": {
        include: "button-box",
        style: {
          color: "invalid"
        }
      },
      "button-box-pressed-invalid": {
        include: "button-box-pressed",
        style: {
          color: "invalid"
        }
      },
      "button-box-hovered-invalid": {
        include: "button-box-invalid"
      },
      "button-box-pressed-hovered-invalid": {
        include: "button-box-pressed-invalid"
      },

      /*
      ---------------------------------------------------------------------------
        BUTTON FOCUSED
      ---------------------------------------------------------------------------
      */
      "button-box-focused": {
        include: "button-box",
        style: {
          color: "background-selected"
        }
      },
      "button-box-pressed-focused": {
        include: "button-box-pressed",
        style: {
          color: "background-selected"
        }
      },
      "button-box-hovered-focused": {
        include: "button-box-focused"
      },
      "button-box-pressed-hovered-focused": {
        include: "button-box-pressed-focused"
      },

      /*
      ---------------------------------------------------------------------------
        BUTTON RIGHT
      ---------------------------------------------------------------------------
      */
      "button-box-right": {
        include: "button-box",
        style: {
          radius: [0, 3, 3, 0]
        }
      },
      "button-box-pressed-right": {
        include: "button-box-pressed",
        style: {
          radius: [0, 3, 3, 0]
        }
      },
      "button-box-pressed-hovered-right": {
        include: "button-box-pressed-hovered",
        style: {
          radius: [0, 3, 3, 0]
        }
      },
      "button-box-hovered-right": {
        include: "button-box-hovered",
        style: {
          radius: [0, 3, 3, 0]
        }
      },
      "button-box-focused-right": {
        include: "button-box-focused",
        style: {
          radius: [0, 3, 3, 0]
        }
      },
      "button-box-hovered-focused-right": {
        include: "button-box-hovered-focused",
        style: {
          radius: [0, 3, 3, 0]
        }
      },
      "button-box-pressed-focused-right": {
        include: "button-box-pressed-focused",
        style: {
          radius: [0, 3, 3, 0]
        }
      },
      "button-box-pressed-hovered-focused-right": {
        include: "button-box-pressed-hovered-focused",
        style: {
          radius: [0, 3, 3, 0]
        }
      },

      /*
      ---------------------------------------------------------------------------
        BUTTON BORDERLESS RIGHT
      ---------------------------------------------------------------------------
      */
      "button-box-right-borderless": {
        include: "button-box",
        style: {
          radius: [0, 3, 3, 0],
          width: [1, 1, 1, 0]
        }
      },
      "button-box-pressed-right-borderless": {
        include: "button-box-pressed",
        style: {
          radius: [0, 3, 3, 0],
          width: [1, 1, 1, 0]
        }
      },
      "button-box-pressed-hovered-right-borderless": {
        include: "button-box-pressed-hovered",
        style: {
          radius: [0, 3, 3, 0],
          width: [1, 1, 1, 0]
        }
      },
      "button-box-hovered-right-borderless": {
        include: "button-box-hovered",
        style: {
          radius: [0, 3, 3, 0],
          width: [1, 1, 1, 0]
        }
      },

      /*
      ---------------------------------------------------------------------------
        BUTTON TOP RIGHT
      ---------------------------------------------------------------------------
      */
      "button-box-top-right": {
        include: "button-box",
        style: {
          radius: [0, 3, 0, 0],
          width: [1, 1, 1, 0]
        }
      },
      "button-box-pressed-top-right": {
        include: "button-box-pressed",
        style: {
          radius: [0, 3, 0, 0],
          width: [1, 1, 1, 0]
        }
      },
      "button-box-pressed-hovered-top-right": {
        include: "button-box-pressed-hovered",
        style: {
          radius: [0, 3, 0, 0],
          width: [1, 1, 1, 0]
        }
      },
      "button-box-hovered-top-right": {
        include: "button-box-hovered",
        style: {
          radius: [0, 3, 0, 0],
          width: [1, 1, 1, 0]
        }
      },

      /*
      ---------------------------------------------------------------------------
        BUTTON BOTOM RIGHT
      ---------------------------------------------------------------------------
      */
      "button-box-bottom-right": {
        include: "button-box",
        style: {
          radius: [0, 0, 3, 0],
          width: [0, 1, 1, 0]
        }
      },
      "button-box-pressed-bottom-right": {
        include: "button-box-pressed",
        style: {
          radius: [0, 0, 3, 0],
          width: [0, 1, 1, 0]
        }
      },
      "button-box-pressed-hovered-bottom-right": {
        include: "button-box-pressed-hovered",
        style: {
          radius: [0, 0, 3, 0],
          width: [0, 1, 1, 0]
        }
      },
      "button-box-hovered-bottom-right": {
        include: "button-box-hovered",
        style: {
          radius: [0, 0, 3, 0],
          width: [0, 1, 1, 0]
        }
      },

      /*
      ---------------------------------------------------------------------------
        BUTTON BOTOM LEFT
      ---------------------------------------------------------------------------
      */
      "button-box-bottom-left": {
        include: "button-box",
        style: {
          radius: [0, 0, 0, 3],
          width: [0, 0, 1, 1]
        }
      },
      "button-box-pressed-bottom-left": {
        include: "button-box-pressed",
        style: {
          radius: [0, 0, 0, 3],
          width: [0, 0, 1, 1]
        }
      },
      "button-box-pressed-hovered-bottom-left": {
        include: "button-box-pressed-hovered",
        style: {
          radius: [0, 0, 0, 3],
          width: [0, 0, 1, 1]
        }
      },
      "button-box-hovered-bottom-left": {
        include: "button-box-hovered",
        style: {
          radius: [0, 0, 0, 3],
          width: [0, 0, 1, 1]
        }
      },

      /*
      ---------------------------------------------------------------------------
        BUTTON TOP LEFT
      ---------------------------------------------------------------------------
      */
      "button-box-top-left": {
        include: "button-box",
        style: {
          radius: [3, 0, 0, 0],
          width: [1, 0, 0, 1]
        }
      },
      "button-box-pressed-top-left": {
        include: "button-box-pressed",
        style: {
          radius: [3, 0, 0, 0],
          width: [1, 0, 0, 1]
        }
      },
      "button-box-pressed-hovered-top-left": {
        include: "button-box-pressed-hovered",
        style: {
          radius: [3, 0, 0, 0],
          width: [1, 0, 0, 1]
        }
      },
      "button-box-hovered-top-left": {
        include: "button-box-hovered",
        style: {
          radius: [3, 0, 0, 0],
          width: [1, 0, 0, 1]
        }
      },

      /*
      ---------------------------------------------------------------------------
        BUTTON MIDDLE
      ---------------------------------------------------------------------------
      */
      "button-box-middle": {
        include: "button-box",
        style: {
          radius: 0,
          width: [1, 0, 1, 1]
        }
      },
      "button-box-pressed-middle": {
        include: "button-box-pressed",
        style: {
          radius: 0,
          width: [1, 0, 1, 1]
        }
      },
      "button-box-pressed-hovered-middle": {
        include: "button-box-pressed-hovered",
        style: {
          radius: 0,
          width: [1, 0, 1, 1]
        }
      },
      "button-box-hovered-middle": {
        include: "button-box-hovered",
        style: {
          radius: 0,
          width: [1, 0, 1, 1]
        }
      },

      /*
      ---------------------------------------------------------------------------
        BUTTON LEFT
      ---------------------------------------------------------------------------
      */
      "button-box-left": {
        include: "button-box",
        style: {
          radius: [3, 0, 0, 3],
          width: [1, 0, 1, 1]
        }
      },
      "button-box-pressed-left": {
        include: "button-box-pressed",
        style: {
          radius: [3, 0, 0, 3],
          width: [1, 0, 1, 1]
        }
      },
      "button-box-pressed-hovered-left": {
        include: "button-box-pressed-hovered",
        style: {
          radius: [3, 0, 0, 3],
          width: [1, 0, 1, 1]
        }
      },
      "button-box-hovered-left": {
        include: "button-box-hovered",
        style: {
          radius: [3, 0, 0, 3],
          width: [1, 0, 1, 1]
        }
      },
      "button-box-focused-left": {
        include: "button-box-focused",
        style: {
          radius: [3, 0, 0, 3],
          width: [1, 0, 1, 1]
        }
      },
      "button-box-hovered-focused-left": {
        include: "button-box-hovered-focused",
        style: {
          radius: [3, 0, 0, 3],
          width: [1, 0, 1, 1]
        }
      },
      "button-box-pressed-hovered-focused-left": {
        include: "button-box-pressed-hovered-focused",
        style: {
          radius: [3, 0, 0, 3],
          width: [1, 0, 1, 1]
        }
      },
      "button-box-pressed-focused-left": {
        include: "button-box-pressed-focused",
        style: {
          radius: [3, 0, 0, 3],
          width: [1, 0, 1, 1]
        }
      },

      /*
      ---------------------------------------------------------------------------
        SEPARATOR
      ---------------------------------------------------------------------------
      */
      "separator-horizontal": {
        style: {
          widthLeft: 1,
          colorLeft: "border-separator"
        }
      },
      "separator-vertical": {
        style: {
          widthTop: 1,
          colorTop: "border-separator"
        }
      },

      /*
      ---------------------------------------------------------------------------
        SCROLL KNOB
      ---------------------------------------------------------------------------
      */
      "scroll-knob": {
        style: {
          radius: 3,
          width: 1,
          color: "button-border",
          backgroundColor: "scrollbar-bright"
        }
      },
      "scroll-knob-pressed": {
        include: "scroll-knob",
        style: {
          backgroundColor: "scrollbar-dark"
        }
      },
      "scroll-knob-hovered": {
        include: "scroll-knob",
        style: {
          color: "button-border-hovered"
        }
      },
      "scroll-knob-pressed-hovered": {
        include: "scroll-knob-pressed",
        style: {
          color: "button-border-hovered"
        }
      },

      /*
      ---------------------------------------------------------------------------
        HOVER BUTTON
      ---------------------------------------------------------------------------
      */
      "button-hover": {
        style: {
          backgroundColor: "button",
          radius: 3
        }
      },

      /*
      ---------------------------------------------------------------------------
        WINDOW
      ---------------------------------------------------------------------------
      */
      "window": {
        style: {
          width: 1,
          color: "window-border",
          innerWidth: 4,
          innerColor: "window-border-inner",
          shadowLength: 1,
          shadowBlurRadius: 3,
          shadowColor: "shadow",
          backgroundColor: "background"
        }
      },
      "window-active": {
        include: "window",
        style: {
          shadowLength: 2,
          shadowBlurRadius: 5
        }
      },
      "window-caption": {
        style: {
          width: [0, 0, 2, 0],
          color: "window-border-inner"
        }
      },

      /*
      ---------------------------------------------------------------------------
        GROUP BOX
      ---------------------------------------------------------------------------
      */
      "white-box": {
        style: {
          width: 1,
          color: "white-box-border",
          shadowBlurRadius: 2,
          shadowColor: "#999999",
          radius: 7,
          backgroundColor: "white",
          shadowLength: 0
        }
      },

      /*
      ---------------------------------------------------------------------------
        TEXT FIELD
      ---------------------------------------------------------------------------
      */
      "inset": {
        style: {
          width: 1,
          color: ["border-light-shadow", "border-light", "border-light", "border-light"]
        }
      },
      "focused-inset": {
        style: {
          width: 2,
          color: "background-selected"
        }
      },
      "border-invalid": {
        style: {
          width: 2,
          color: "invalid"
        }
      },

      /*
      ---------------------------------------------------------------------------
        LIST ITEM
      ---------------------------------------------------------------------------
      */
      "lead-item": {
        style: {
          width: 1,
          style: "dotted",
          color: "border-lead"
        }
      },

      /*
      ---------------------------------------------------------------------------
        TOOL TIP
      ---------------------------------------------------------------------------
      */
      "tooltip": {
        style: {
          width: 1,
          color: "tooltip-text",
          shadowLength: 1,
          shadowBlurRadius: 2,
          shadowColor: "shadow"
        }
      },
      "tooltip-error": {
        style: {
          radius: 5,
          backgroundColor: "invalid"
        }
      },

      /*
      ---------------------------------------------------------------------------
        TOOLBAR
      ---------------------------------------------------------------------------
      */
      "toolbar-separator": {
        style: {
          widthLeft: 1,
          colorLeft: "button-border"
        }
      },

      /*
      ---------------------------------------------------------------------------
        MENU
      ---------------------------------------------------------------------------
      */
      "menu-separator": {
        style: {
          widthTop: 1,
          colorTop: "background-selected"
        }
      },

      /*
      ---------------------------------------------------------------------------
        MENU BAR
      ---------------------------------------------------------------------------
      */
      "menubar-button-hovered": {
        style: {
          width: 1,
          color: "border-main",
          radius: 3,
          backgroundColor: "white"
        }
      },
      "menubar-button-pressed": {
        include: "menubar-button-hovered",
        style: {
          radius: [3, 3, 0, 0],
          width: [1, 1, 0, 1]
        }
      },

      /*
      ---------------------------------------------------------------------------
        DATE CHOOSER
      ---------------------------------------------------------------------------
      */
      "datechooser-date-pane": {
        style: {
          widthTop: 1,
          colorTop: "gray",
          style: "solid"
        }
      },
      "datechooser-weekday": {
        style: {
          widthBottom: 1,
          colorBottom: "gray",
          style: "solid"
        }
      },
      "datechooser-week": {
        style: {
          widthRight: 1,
          colorRight: "gray",
          style: "solid"
        }
      },
      "datechooser-week-header": {
        style: {
          widthBottom: 1,
          colorBottom: "gray",
          widthRight: 1,
          colorRight: "gray",
          style: "solid"
        }
      },

      /*
      ---------------------------------------------------------------------------
        TAB VIEW
      ---------------------------------------------------------------------------
      */
      "tabview-page-button-top": {
        style: {
          width: [1, 1, 0, 1],
          backgroundColor: "background",
          color: "border-main",
          radius: [3, 3, 0, 0]
        }
      },
      "tabview-page-button-bottom": {
        include: "tabview-page-button-top",
        style: {
          radius: [0, 0, 3, 3],
          width: [0, 1, 1, 1]
        }
      },
      "tabview-page-button-left": {
        include: "tabview-page-button-top",
        style: {
          radius: [3, 0, 0, 3],
          width: [1, 0, 1, 1]
        }
      },
      "tabview-page-button-right": {
        include: "tabview-page-button-top",
        style: {
          radius: [0, 3, 3, 0],
          width: [1, 1, 1, 0]
        }
      },

      /*
      ---------------------------------------------------------------------------
        TABLE
      ---------------------------------------------------------------------------
      */
      "statusbar": {
        style: {
          widthTop: 1,
          colorTop: "background-selected",
          styleTop: "solid"
        }
      },
      "table-scroller-focus-indicator": {
        style: {
          width: 2,
          color: "table-focus-indicator",
          style: "solid"
        }
      },
      "table-header": {
        include: "button-box",
        style: {
          radius: 0,
          width: [1, 0, 1, 0]
        }
      },
      "table-header-column-button": {
        include: "table-header",
        style: {
          width: 1,
          color: "button-border"
        }
      },
      "table-header-cell": {
        style: {
          widthRight: 1,
          color: "button-border"
        }
      },
      "table-header-cell-first": {
        include: "table-header-cell",
        style: {
          widthLeft: 1
        }
      },
      "progressive-table-header": {
        include: "button-box",
        style: {
          radius: 0,
          width: [1, 0, 1, 1]
        }
      },
      "progressive-table-header-cell": {
        style: {
          widthRight: 1,
          color: "button-border"
        }
      },

      /*
      ---------------------------------------------------------------------------
        PROGRESSBAR
      ---------------------------------------------------------------------------
      */
      "progressbar": {
        style: {
          backgroundColor: "#FFF",
          width: 1,
          color: "border-separator"
        }
      },

      /*
      ---------------------------------------------------------------------------
        RADIO BUTTON
      ---------------------------------------------------------------------------
      */
      "radiobutton": {
        style: {
          radius: 10,
          width: 1,
          color: "button-border",
          innerColor: "background",
          innerWidth: 2
        }
      },
      "radiobutton-focused": {
        include: "radiobutton",
        style: {
          color: "background-selected"
        }
      },
      "radiobutton-invalid": {
        include: "radiobutton",
        style: {
          color: "invalid"
        }
      },

      /*
      ---------------------------------------------------------------------------
        CHECK BOX
      ---------------------------------------------------------------------------
      */
      "checkbox": {
        style: {
          width: 1,
          color: "button-border"
        }
      },
      "checkbox-focused": {
        include: "checkbox",
        style: {
          color: "background-selected"
        }
      },
      "checkbox-invalid": {
        include: "checkbox",
        style: {
          color: "invalid"
        }
      }
    }
  });
  qx.theme.simple.Decoration.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Theme": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
     * Martin Wittemann (martinwittemann)
  
  ************************************************************************* */

  /**
   * The simple qooxdoo font theme.
   */
  qx.Theme.define("qx.theme.simple.Font", {
    fonts: {
      "default": {
        size: 13,
        family: ["arial", "sans-serif"]
      },
      "bold": {
        size: 13,
        family: ["arial", "sans-serif"],
        bold: true
      },
      "headline": {
        size: 24,
        family: ["sans-serif", "arial"]
      },
      "small": {
        size: 11,
        family: ["arial", "sans-serif"]
      },
      "monospace": {
        size: 11,
        family: ["DejaVu Sans Mono", "Courier New", "monospace"]
      }
    }
  });
  qx.theme.simple.Font.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Theme": {
        "usage": "dynamic",
        "require": true
      },
      "qx.theme.simple.Image": {}
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
     * Martin Wittemann (martinwittemann)
  
  ************************************************************************* */

  /* ************************************************************************
  
  
  ************************************************************************* */

  /**
   * The simple qooxdoo appearance theme.
   *
   * @asset(qx/icon/${qx.icontheme}/16/apps/office-calendar.png)
   * @asset(qx/icon/${qx.icontheme}/16/places/folder-open.png)
   * @asset(qx/icon/${qx.icontheme}/16/places/folder.png)
   * @asset(qx/icon/${qx.icontheme}/16/mimetypes/text-plain.png)
   * @asset(qx/icon/${qx.icontheme}/16/actions/view-refresh.png)
   * @asset(qx/icon/${qx.icontheme}/16/actions/window-close.png)
   * @asset(qx/icon/${qx.icontheme}/16/actions/dialog-cancel.png)
   * @asset(qx/icon/${qx.icontheme}/16/actions/dialog-ok.png)
   */
  qx.Theme.define("qx.theme.simple.Appearance", {
    appearances: {
      /*
      ---------------------------------------------------------------------------
        CORE
      ---------------------------------------------------------------------------
      */
      "widget": {},
      "label": {
        style: function (states) {
          return {
            textColor: states.disabled ? "text-disabled" : undefined
          };
        }
      },
      "image": {
        style: function (states) {
          return {
            opacity: !states.replacement && states.disabled ? 0.3 : undefined
          };
        }
      },
      "atom": {},
      "atom/label": "label",
      "atom/icon": "image",
      "root": {
        style: function (states) {
          return {
            backgroundColor: "background",
            textColor: "text",
            font: "default"
          };
        }
      },
      "popup": {
        style: function (states) {
          return {
            decorator: "popup",
            backgroundColor: "background-pane"
          };
        }
      },
      "tooltip": {
        include: "popup",
        style: function (states) {
          return {
            backgroundColor: "tooltip",
            textColor: "tooltip-text",
            decorator: "tooltip",
            padding: [1, 3, 2, 3],
            offset: [10, 5, 5, 5]
          };
        }
      },
      "tooltip/atom": "atom",
      "tooltip-error": {
        include: "tooltip",
        style: function (states) {
          return {
            textColor: "text-selected",
            showTimeout: 100,
            hideTimeout: 10000,
            decorator: "tooltip-error",
            font: "bold",
            backgroundColor: undefined
          };
        }
      },
      "tooltip-error/atom": "atom",
      "iframe": {
        style: function (states) {
          return {
            backgroundColor: "white",
            decorator: "main-dark"
          };
        }
      },
      "move-frame": {
        style: function (states) {
          return {
            decorator: "main-dark"
          };
        }
      },
      "resize-frame": "move-frame",
      "dragdrop-cursor": {
        style: function (states) {
          var icon = "nodrop";

          if (states.copy) {
            icon = "copy";
          } else if (states.move) {
            icon = "move";
          } else if (states.alias) {
            icon = "alias";
          }

          return {
            source: qx.theme.simple.Image.URLS["cursor-" + icon],
            position: "right-top",
            offset: [2, 16, 2, 6]
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        SLIDEBAR
      ---------------------------------------------------------------------------
      */
      "slidebar": {},
      "slidebar/scrollpane": {},
      "slidebar/content": {},
      "slidebar/button-forward": {
        alias: "button",
        include: "button",
        style: function (states) {
          return {
            icon: qx.theme.simple.Image.URLS["arrow-" + (states.vertical ? "down" : "right")]
          };
        }
      },
      "slidebar/button-backward": {
        alias: "button",
        include: "button",
        style: function (states) {
          return {
            icon: qx.theme.simple.Image.URLS["arrow-" + (states.vertical ? "up" : "left")]
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        TABLE
      ---------------------------------------------------------------------------
      */
      "table": "widget",
      "table/statusbar": {
        style: function (states) {
          return {
            decorator: "statusbar",
            padding: [2, 5]
          };
        }
      },
      "table/column-button": {
        alias: "button",
        style: function (states) {
          return {
            decorator: "table-header-column-button",
            padding: 3,
            icon: qx.theme.simple.Image.URLS["select-column-order"]
          };
        }
      },
      "table-column-reset-button": {
        include: "menu-button",
        alias: "menu-button",
        style: function () {
          return {
            icon: "icon/16/actions/view-refresh.png"
          };
        }
      },
      "table-scroller/scrollbar-x": "scrollbar",
      "table-scroller/scrollbar-y": "scrollbar",
      "table-scroller": "widget",
      "table-scroller/header": {
        style: function () {
          return {
            decorator: "table-header"
          };
        }
      },
      "table-scroller/pane": {},
      "table-scroller/focus-indicator": {
        style: function (states) {
          return {
            decorator: "main"
          };
        }
      },
      "table-scroller/resize-line": {
        style: function (states) {
          return {
            backgroundColor: "button-border",
            width: 3
          };
        }
      },
      "table-header-cell": {
        alias: "atom",
        style: function (states) {
          return {
            decorator: states.first ? "table-header-cell-first" : "table-header-cell",
            minWidth: 13,
            font: "bold",
            paddingTop: 3,
            paddingLeft: 5,
            cursor: states.disabled ? undefined : "pointer",
            sortIcon: states.sorted ? qx.theme.simple.Image.URLS["table-" + (states.sortedAscending ? "ascending" : "descending")] : undefined
          };
        }
      },
      "table-header-cell/icon": {
        include: "atom/icon",
        style: function (states) {
          return {
            paddingRight: 5
          };
        }
      },
      "table-header-cell/sort-icon": {
        style: function (states) {
          return {
            alignY: "middle",
            alignX: "right",
            paddingRight: 5
          };
        }
      },
      "table-editor-textfield": {
        include: "textfield",
        style: function (states) {
          return {
            decorator: undefined,
            padding: [2, 2]
          };
        }
      },
      "table-editor-selectbox": {
        include: "selectbox",
        alias: "selectbox",
        style: function (states) {
          return {
            padding: [0, 2]
          };
        }
      },
      "table-editor-combobox": {
        include: "combobox",
        alias: "combobox",
        style: function (states) {
          return {
            decorator: undefined
          };
        }
      },
      "progressive-table-header": {
        style: function (states) {
          return {
            decorator: "progressive-table-header"
          };
        }
      },
      "progressive-table-header-cell": {
        style: function (states) {
          return {
            decorator: "progressive-table-header-cell",
            padding: [5, 6, 5, 6]
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        TREEVIRTUAL
      ---------------------------------------------------------------------------
      */
      "treevirtual": {
        include: "textfield",
        alias: "table",
        style: function (states, superStyles) {
          return {
            padding: [superStyles.padding[0] + 2, superStyles.padding[1] + 1]
          };
        }
      },
      "treevirtual-folder": {
        style: function (states) {
          return {
            icon: states.opened ? "icon/16/places/folder-open.png" : "icon/16/places/folder.png",
            opacity: states.drag ? 0.5 : undefined
          };
        }
      },
      "treevirtual-file": {
        include: "treevirtual-folder",
        alias: "treevirtual-folder",
        style: function (states) {
          return {
            icon: "icon/16/mimetypes/text-plain.png",
            opacity: states.drag ? 0.5 : undefined
          };
        }
      },
      "treevirtual-line": {
        style: function (states) {
          return {
            icon: qx.theme.simple.Image.URLS["treevirtual-line"]
          };
        }
      },
      "treevirtual-contract": {
        style: function (states) {
          return {
            icon: qx.theme.simple.Image.URLS["tree-minus"]
          };
        }
      },
      "treevirtual-expand": {
        style: function (states) {
          return {
            icon: qx.theme.simple.Image.URLS["tree-plus"]
          };
        }
      },
      "treevirtual-only-contract": {
        style: function (states) {
          return {
            icon: qx.theme.simple.Image.URLS["treevirtual-minus-only"]
          };
        }
      },
      "treevirtual-only-expand": {
        style: function (states) {
          return {
            icon: qx.theme.simple.Image.URLS["treevirtual-plus-only"]
          };
        }
      },
      "treevirtual-start-contract": {
        style: function (states) {
          return {
            icon: qx.theme.simple.Image.URLS["treevirtual-minus-start"]
          };
        }
      },
      "treevirtual-start-expand": {
        style: function (states) {
          return {
            icon: qx.theme.simple.Image.URLS["treevirtual-plus-start"]
          };
        }
      },
      "treevirtual-end-contract": {
        style: function (states) {
          return {
            icon: qx.theme.simple.Image.URLS["treevirtual-minus-end"]
          };
        }
      },
      "treevirtual-end-expand": {
        style: function (states) {
          return {
            icon: qx.theme.simple.Image.URLS["treevirtual-plus-end"]
          };
        }
      },
      "treevirtual-cross-contract": {
        style: function (states) {
          return {
            icon: qx.theme.simple.Image.URLS["treevirtual-minus-cross"]
          };
        }
      },
      "treevirtual-cross-expand": {
        style: function (states) {
          return {
            icon: qx.theme.simple.Image.URLS["treevirtual-plus-cross"]
          };
        }
      },
      "treevirtual-end": {
        style: function (states) {
          return {
            icon: qx.theme.simple.Image.URLS["treevirtual-end"]
          };
        }
      },
      "treevirtual-cross": {
        style: function (states) {
          return {
            icon: qx.theme.simple.Image.URLS["treevirtual-cross"]
          };
        }
      },
      "treevirtual-node-editor-textfield": {
        include: "textfield",
        style: function (states) {
          return {
            decorator: undefined,
            padding: [2, 2]
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        RESIZER
      ---------------------------------------------------------------------------
      */
      "resizer": {
        style: function (states) {
          return {
            decorator: "main-dark"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        SPLITPANE
      ---------------------------------------------------------------------------
      */
      "splitpane": {},
      "splitpane/splitter": {
        style: function (states) {
          return {
            backgroundColor: "light-background"
          };
        }
      },
      "splitpane/splitter/knob": {
        style: function (states) {
          return {
            source: qx.theme.simple.Image.URLS["knob-" + (states.horizontal ? "horizontal" : "vertical")],
            padding: 2
          };
        }
      },
      "splitpane/slider": {
        style: function (states) {
          return {
            backgroundColor: "border-light-shadow",
            opacity: 0.3
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        MENU
      ---------------------------------------------------------------------------
      */
      "menu": {
        style: function (states) {
          var result = {
            backgroundColor: "background",
            decorator: "main",
            spacingX: 6,
            spacingY: 1,
            iconColumnWidth: 16,
            arrowColumnWidth: 4,
            padding: 1,
            placementModeY: states.submenu || states.contextmenu ? "best-fit" : "keep-align"
          };

          if (states.submenu) {
            result.position = "right-top";
            result.offset = [-2, -3];
          }

          if (states.contextmenu) {
            result.offset = 4;
          }

          return result;
        }
      },
      "menu/slidebar": "menu-slidebar",
      "menu-slidebar": "widget",
      "menu-slidebar-button": {
        style: function (states) {
          return {
            backgroundColor: states.hovered ? "background-selected" : undefined,
            padding: 6,
            center: true
          };
        }
      },
      "menu-slidebar/button-backward": {
        include: "menu-slidebar-button",
        style: function (states) {
          return {
            icon: qx.theme.simple.Image.URLS["arrow-up" + (states.hovered ? "-invert" : "")]
          };
        }
      },
      "menu-slidebar/button-forward": {
        include: "menu-slidebar-button",
        style: function (states) {
          return {
            icon: qx.theme.simple.Image.URLS["arrow-down" + (states.hovered ? "-invert" : "")]
          };
        }
      },
      "menu-separator": {
        style: function (states) {
          return {
            height: 0,
            decorator: "menu-separator",
            marginTop: 4,
            marginBottom: 4,
            marginLeft: 2,
            marginRight: 2
          };
        }
      },
      "menu-button": {
        alias: "atom",
        style: function (states) {
          return {
            backgroundColor: states.selected ? "background-selected" : undefined,
            textColor: states.selected ? "text-selected" : undefined,
            padding: [2, 6]
          };
        }
      },
      "menu-button/icon": {
        include: "image",
        style: function (states) {
          return {
            alignY: "middle"
          };
        }
      },
      "menu-button/label": {
        include: "label",
        style: function (states) {
          return {
            alignY: "middle",
            padding: 1
          };
        }
      },
      "menu-button/shortcut": {
        include: "label",
        style: function (states) {
          return {
            alignY: "middle",
            marginLeft: 14,
            padding: 1
          };
        }
      },
      "menu-button/arrow": {
        include: "image",
        style: function (states) {
          return {
            source: qx.theme.simple.Image.URLS["arrow-right" + (states.selected ? "-invert" : "")],
            alignY: "middle"
          };
        }
      },
      "menu-checkbox": {
        alias: "menu-button",
        include: "menu-button",
        style: function (states) {
          return {
            icon: !states.checked ? undefined : qx.theme.simple.Image.URLS["menu-checkbox" + (states.selected ? "-invert" : "")]
          };
        }
      },
      "menu-radiobutton": {
        alias: "menu-button",
        include: "menu-button",
        style: function (states) {
          return {
            icon: !states.checked ? undefined : qx.theme.simple.Image.URLS["menu-radiobutton" + (states.selected ? "-invert" : "")]
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        MENU BAR
      ---------------------------------------------------------------------------
      */
      "menubar": {
        style: function (states) {
          return {
            backgroundColor: "light-background",
            padding: [4, 2]
          };
        }
      },
      "menubar-button": {
        style: function (states) {
          var decorator;
          var padding = [2, 6];

          if (!states.disabled) {
            if (states.pressed) {
              decorator = "menubar-button-pressed";
              padding = [1, 5, 2, 5];
            } else if (states.hovered) {
              decorator = "menubar-button-hovered";
              padding = [1, 5];
            }
          }

          return {
            padding: padding,
            cursor: states.disabled ? undefined : "pointer",
            textColor: "link",
            decorator: decorator
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        VIRTUAL WIDGETS
      ---------------------------------------------------------------------------
      */
      "virtual-list": "list",
      "virtual-list/row-layer": "row-layer",
      "row-layer": "widget",
      "column-layer": "widget",
      "group-item": {
        include: "label",
        alias: "label",
        style: function (states) {
          return {
            padding: 4,
            backgroundColor: "#BABABA",
            textColor: "white",
            font: "bold"
          };
        }
      },
      "virtual-selectbox": "selectbox",
      "virtual-selectbox/dropdown": "popup",
      "virtual-selectbox/dropdown/list": {
        alias: "virtual-list"
      },
      "virtual-combobox": "combobox",
      "virtual-combobox/dropdown": "popup",
      "virtual-combobox/dropdown/list": {
        alias: "virtual-list"
      },
      "virtual-tree": {
        include: "tree",
        alias: "tree",
        style: function (states) {
          return {
            itemHeight: 21
          };
        }
      },
      "virtual-tree-folder": "tree-folder",
      "virtual-tree-file": "tree-file",
      "cell": {
        style: function (states) {
          return {
            backgroundColor: states.selected ? "table-row-background-selected" : "table-row-background-even",
            textColor: states.selected ? "text-selected" : "text",
            padding: [3, 6]
          };
        }
      },
      "cell-string": "cell",
      "cell-number": {
        include: "cell",
        style: function (states) {
          return {
            textAlign: "right"
          };
        }
      },
      "cell-image": "cell",
      "cell-boolean": "cell",
      "cell-atom": "cell",
      "cell-date": "cell",
      "cell-html": "cell",

      /*
      ---------------------------------------------------------------------------
        SCROLLBAR
      ---------------------------------------------------------------------------
      */
      "scrollbar": {},
      "scrollbar/slider": {},
      "scrollbar/slider/knob": {
        style: function (states) {
          var decorator = "scroll-knob";

          if (!states.disabled) {
            if (states.hovered && !states.pressed && !states.checked) {
              decorator = "scroll-knob-hovered";
            } else if (states.hovered && (states.pressed || states.checked)) {
              decorator = "scroll-knob-pressed-hovered";
            } else if (states.pressed || states.checked) {
              decorator = "scroll-knob-pressed";
            }
          }

          return {
            height: 14,
            width: 14,
            cursor: states.disabled ? undefined : "pointer",
            decorator: decorator,
            minHeight: states.horizontal ? undefined : 20,
            minWidth: states.horizontal ? 20 : undefined
          };
        }
      },
      "scrollbar/button": {
        style: function (states) {
          var styles = {};
          styles.padding = 4;
          var icon = "";

          if (states.left) {
            icon = "left";
            styles.marginRight = 2;
          } else if (states.right) {
            icon += "right";
            styles.marginLeft = 2;
          } else if (states.up) {
            icon += "up";
            styles.marginBottom = 2;
          } else {
            icon += "down";
            styles.marginTop = 2;
          }

          styles.icon = qx.theme.simple.Image.URLS["arrow-" + icon];
          styles.cursor = "pointer";
          styles.decorator = "button-box";
          return styles;
        }
      },
      "scrollbar/button-begin": "scrollbar/button",
      "scrollbar/button-end": "scrollbar/button",

      /*
      ---------------------------------------------------------------------------
        SCROLLAREA
      ---------------------------------------------------------------------------
      */
      "scrollarea/corner": {
        style: function (states) {
          return {
            backgroundColor: "background"
          };
        }
      },
      "scrollarea": "widget",
      "scrollarea/pane": "widget",
      "scrollarea/scrollbar-x": "scrollbar",
      "scrollarea/scrollbar-y": "scrollbar",

      /*
      ---------------------------------------------------------------------------
        TEXT FIELD
      ---------------------------------------------------------------------------
      */
      "textfield": {
        style: function (states) {
          var textColor;

          if (states.disabled) {
            textColor = "text-disabled";
          } else if (states.showingPlaceholder) {
            textColor = "text-placeholder";
          } else {
            textColor = undefined;
          }

          var decorator;
          var padding;

          if (states.disabled) {
            decorator = "inset";
            padding = [2, 3];
          } else if (states.invalid) {
            decorator = "border-invalid";
            padding = [1, 2];
          } else if (states.focused) {
            decorator = "focused-inset";
            padding = [1, 2];
          } else {
            padding = [2, 3];
            decorator = "inset";
          }

          return {
            decorator: decorator,
            padding: padding,
            textColor: textColor,
            backgroundColor: states.disabled ? "background-disabled" : "white"
          };
        }
      },
      "textarea": "textfield",

      /*
      ---------------------------------------------------------------------------
        RADIO BUTTON
      ---------------------------------------------------------------------------
      */
      "radiobutton/icon": {
        style: function (states) {
          var decorator = "radiobutton";

          if (states.focused && !states.invalid) {
            decorator = "radiobutton-focused";
          }

          decorator += states.invalid && !states.disabled ? "-invalid" : "";
          var backgroundColor;

          if (states.disabled && states.checked) {
            backgroundColor = "background-disabled-checked";
          } else if (states.disabled) {
            backgroundColor = "background-disabled";
          } else if (states.checked) {
            backgroundColor = "background-selected";
          }

          return {
            decorator: decorator,
            width: 12,
            height: 12,
            backgroundColor: backgroundColor
          };
        }
      },
      "radiobutton": {
        style: function (states) {
          // set an empty icon to be sure that the icon image is rendered
          return {
            icon: qx.theme.simple.Image.URLS["blank"]
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        FORM
      ---------------------------------------------------------------------------
      */
      "form-renderer-label": {
        include: "label",
        style: function () {
          return {
            paddingTop: 3
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        CHECK BOX
      ---------------------------------------------------------------------------
      */
      "checkbox": {
        alias: "atom",
        style: function (states) {
          // The "disabled" icon is set to an icon **without** the -disabled
          // suffix on purpose. This is because the Image widget handles this
          // already by replacing the current image with a disabled version
          // (if available). If no disabled image is found, the opacity style
          // is used.
          var icon; // Checked

          if (states.checked) {
            icon = qx.theme.simple.Image.URLS["checkbox-checked"]; // Undetermined
          } else if (states.undetermined) {
            icon = qx.theme.simple.Image.URLS["checkbox-undetermined"]; // Unchecked
          } else {
            // empty icon
            icon = qx.theme.simple.Image.URLS["blank"];
          }

          return {
            icon: icon,
            gap: 6
          };
        }
      },
      "checkbox/icon": {
        style: function (states) {
          var decorator = "checkbox";

          if (states.focused && !states.invalid) {
            decorator = "checkbox-focused";
          }

          decorator += states.invalid && !states.disabled ? "-invalid" : "";
          var padding; // Checked

          if (states.checked) {
            padding = 2; // Undetermined
          } else if (states.undetermined) {
            padding = [4, 2];
          }

          return {
            decorator: decorator,
            width: 12,
            height: 12,
            padding: padding,
            backgroundColor: "white"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        SPINNER
      ---------------------------------------------------------------------------
      */
      "spinner": {
        style: function (states) {
          return {
            textColor: states.disabled ? "text-disabled" : undefined
          };
        }
      },
      "spinner/textfield": "textfield",
      "spinner/upbutton": {
        alias: "combobox/button",
        include: "combobox/button",
        style: function (states) {
          var decorator = "button-box-top-right";

          if (states.hovered && !states.pressed && !states.checked) {
            decorator = "button-box-hovered-top-right";
          } else if (states.hovered && (states.pressed || states.checked)) {
            decorator = "button-box-pressed-hovered-top-right";
          } else if (states.pressed || states.checked) {
            decorator = "button-box-pressed-top-right";
          }

          return {
            icon: qx.theme.simple.Image.URLS["arrow-up-small"],
            decorator: decorator,
            width: 17
          };
        }
      },
      "spinner/downbutton": {
        alias: "combobox/button",
        include: "combobox/button",
        style: function (states) {
          var decorator = "button-box-bottom-right";

          if (states.hovered && !states.pressed && !states.checked) {
            decorator = "button-box-hovered-bottom-right";
          } else if (states.hovered && (states.pressed || states.checked)) {
            decorator = "button-box-pressed-hovered-bottom-right";
          } else if (states.pressed || states.checked) {
            decorator = "button-box-pressed-bottom-right";
          }

          return {
            icon: qx.theme.simple.Image.URLS["arrow-down-small"],
            decorator: decorator,
            width: 17
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        SELECTBOX
      ---------------------------------------------------------------------------
      */
      "selectbox": "button-frame",
      "selectbox/atom": "atom",
      "selectbox/popup": "popup",
      "selectbox/list": {
        alias: "list",
        include: "list",
        style: function () {
          return {
            decorator: undefined
          };
        }
      },
      "selectbox/arrow": {
        include: "image",
        style: function (states) {
          return {
            source: qx.theme.simple.Image.URLS["arrow-down"],
            paddingRight: 4,
            paddingLeft: 5
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        COMBO BOX
      ---------------------------------------------------------------------------
      */
      "combobox": {},
      "combobox/button": {
        alias: "button-frame",
        include: "button-frame",
        style: function (states) {
          var decorator = "button-box-right-borderless";

          if (states.hovered && !states.pressed && !states.checked) {
            decorator = "button-box-hovered-right-borderless";
          } else if (states.hovered && (states.pressed || states.checked)) {
            decorator = "button-box-pressed-hovered-right-borderless";
          } else if (states.pressed || states.checked) {
            decorator = "button-box-pressed-right-borderless";
          }

          return {
            icon: qx.theme.simple.Image.URLS["arrow-down"],
            decorator: decorator,
            padding: [0, 5],
            width: 19
          };
        }
      },
      "combobox/popup": "popup",
      "combobox/list": {
        alias: "list"
      },
      "combobox/textfield": "textfield",

      /*
      ---------------------------------------------------------------------------
        DATEFIELD
      ---------------------------------------------------------------------------
      */
      "datefield": "textfield",
      "datefield/button": {
        alias: "combobox/button",
        include: "combobox/button",
        style: function (states) {
          return {
            icon: "icon/16/apps/office-calendar.png",
            padding: [0, 0, 0, 3],
            backgroundColor: undefined,
            decorator: undefined,
            width: 19
          };
        }
      },
      "datefield/textfield": {
        alias: "textfield",
        include: "textfield",
        style: function (states) {
          return {
            decorator: undefined,
            padding: 0
          };
        }
      },
      "datefield/list": {
        alias: "datechooser",
        include: "datechooser",
        style: function (states) {
          return {
            decorator: undefined
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        LIST
      ---------------------------------------------------------------------------
      */
      "list": {
        alias: "scrollarea",
        include: "textfield"
      },
      "listitem": {
        alias: "atom",
        style: function (states) {
          var padding = [3, 5, 3, 5];

          if (states.lead) {
            padding = [2, 4, 2, 4];
          }

          if (states.dragover) {
            padding[2] -= 2;
          }

          var backgroundColor;

          if (states.selected) {
            backgroundColor = "background-selected";

            if (states.disabled) {
              backgroundColor += "-disabled";
            }
          }

          return {
            gap: 4,
            padding: padding,
            backgroundColor: backgroundColor,
            textColor: states.selected ? "text-selected" : undefined,
            decorator: states.lead ? "lead-item" : states.dragover ? "dragover" : undefined,
            opacity: states.drag ? 0.5 : undefined
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        SLIDER
      ---------------------------------------------------------------------------
      */
      "slider": {
        style: function (states) {
          var decorator;
          var padding;

          if (states.disabled) {
            decorator = "inset";
            padding = [2, 3];
          } else if (states.invalid) {
            decorator = "border-invalid";
            padding = [1, 2];
          } else if (states.focused) {
            decorator = "focused-inset";
            padding = [1, 2];
          } else {
            padding = [2, 3];
            decorator = "inset";
          }

          return {
            decorator: decorator,
            padding: padding
          };
        }
      },
      "slider/knob": "scrollbar/slider/knob",

      /*
      ---------------------------------------------------------------------------
        BUTTON
      ---------------------------------------------------------------------------
      */
      "button-frame": {
        alias: "atom",
        style: function (states) {
          var decorator = "button-box";

          if (!states.disabled) {
            if (states.hovered && !states.pressed && !states.checked) {
              decorator = "button-box-hovered";
            } else if (states.hovered && (states.pressed || states.checked)) {
              decorator = "button-box-pressed-hovered";
            } else if (states.pressed || states.checked) {
              decorator = "button-box-pressed";
            }
          }

          if (states.invalid && !states.disabled) {
            decorator += "-invalid";
          } else if (states.focused) {
            decorator += "-focused";
          }

          return {
            decorator: decorator,
            padding: [3, 8],
            cursor: states.disabled ? undefined : "pointer",
            minWidth: 5,
            minHeight: 5
          };
        }
      },
      "button-frame/label": {
        alias: "atom/label",
        style: function (states) {
          return {
            textColor: states.disabled ? "text-disabled" : undefined
          };
        }
      },
      "button": {
        alias: "button-frame",
        include: "button-frame",
        style: function (states) {
          return {
            center: true
          };
        }
      },
      "toggle-button": "button",
      "hover-button": {
        alias: "button",
        include: "button",
        style: function (states) {
          return {
            decorator: states.hovered ? "button-hover" : undefined
          };
        }
      },
      "menubutton": {
        include: "button",
        alias: "button",
        style: function (states) {
          return {
            icon: qx.theme.simple.Image.URLS["arrow-down"],
            iconPosition: "right"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        SPLIT BUTTON
      ---------------------------------------------------------------------------
      */
      "splitbutton": {},
      "splitbutton/button": {
        alias: "atom",
        style: function (states) {
          var decorator = "button-box";

          if (!states.disabled) {
            if (states.pressed || states.checked) {
              decorator += "-pressed";
            }

            if (states.hovered) {
              decorator += "-hovered";
            }
          }

          if (states.focused) {
            decorator += "-focused";
          }

          decorator += "-left";
          return {
            decorator: decorator,
            padding: [3, 8],
            cursor: states.disabled ? undefined : "pointer"
          };
        }
      },
      "splitbutton/arrow": {
        style: function (states) {
          var decorator = "button-box";

          if (!states.disabled) {
            if (states.pressed || states.checked) {
              decorator += "-pressed";
            }

            if (states.hovered) {
              decorator += "-hovered";
            }
          }

          if (states.focused) {
            decorator += "-focused";
          }

          decorator += "-right";
          return {
            icon: qx.theme.simple.Image.URLS["arrow-down"],
            decorator: decorator,
            cursor: states.disabled ? undefined : "pointer",
            padding: [3, 4]
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        GROUP BOX
      ---------------------------------------------------------------------------
      */
      "groupbox": {},
      "groupbox/legend": {
        alias: "atom",
        style: function (states) {
          return {
            textColor: states.invalid ? "invalid" : undefined,
            padding: 5,
            margin: 4,
            font: "bold"
          };
        }
      },
      "groupbox/frame": {
        style: function (states) {
          return {
            backgroundColor: "background",
            padding: [6, 9],
            margin: [18, 2, 2, 2],
            decorator: "white-box"
          };
        }
      },
      "check-groupbox": "groupbox",
      "check-groupbox/legend": {
        alias: "checkbox",
        include: "checkbox",
        style: function (states) {
          return {
            textColor: states.invalid ? "invalid" : undefined,
            padding: 5,
            margin: 4,
            font: "bold"
          };
        }
      },
      "radio-groupbox": "groupbox",
      "radio-groupbox/legend": {
        alias: "radiobutton",
        include: "radiobutton",
        style: function (states) {
          return {
            textColor: states.invalid ? "invalid" : undefined,
            padding: 5,
            margin: 4,
            font: "bold"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        TREE
      ---------------------------------------------------------------------------
      */
      "tree-folder/open": {
        include: "image",
        style: function (states) {
          return {
            source: states.opened ? qx.theme.simple.Image.URLS["tree-minus"] : qx.theme.simple.Image.URLS["tree-plus"]
          };
        }
      },
      "tree-folder": {
        style: function (states) {
          var backgroundColor;

          if (states.selected) {
            backgroundColor = "background-selected";

            if (states.disabled) {
              backgroundColor += "-disabled";
            }
          }

          return {
            padding: [2, 8, 2, 5],
            icon: states.opened ? "icon/16/places/folder-open.png" : "icon/16/places/folder.png",
            backgroundColor: backgroundColor,
            iconOpened: "icon/16/places/folder-open.png",
            opacity: states.drag ? 0.5 : undefined
          };
        }
      },
      "tree-folder/icon": {
        include: "image",
        style: function (states) {
          return {
            padding: [0, 4, 0, 0]
          };
        }
      },
      "tree-folder/label": {
        style: function (states) {
          return {
            padding: [1, 2],
            textColor: states.selected && !states.disabled ? "text-selected" : undefined
          };
        }
      },
      "tree-file": {
        include: "tree-folder",
        alias: "tree-folder",
        style: function (states) {
          return {
            icon: "icon/16/mimetypes/text-plain.png",
            opacity: states.drag ? 0.5 : undefined
          };
        }
      },
      "tree": {
        include: "list",
        alias: "list",
        style: function (states) {
          return {
            contentPadding: states.invalid && !states.disabled ? [3, 0] : [4, 1],
            padding: states.focused ? 0 : 1
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        WINDOW
      ---------------------------------------------------------------------------
      */
      "window": {
        style: function (states) {
          return {
            contentPadding: [10, 10, 10, 10],
            backgroundColor: "background",
            decorator: states.maximized ? undefined : states.active ? "window-active" : "window"
          };
        }
      },
      "window-resize-frame": "resize-frame",
      "window/pane": {},
      "window/captionbar": {
        style: function (states) {
          return {
            backgroundColor: states.active ? "light-background" : "background-disabled",
            padding: 8,
            font: "bold",
            decorator: "window-caption"
          };
        }
      },
      "window/icon": {
        style: function (states) {
          return {
            marginRight: 4
          };
        }
      },
      "window/title": {
        style: function (states) {
          return {
            cursor: "default",
            font: "bold",
            marginRight: 20,
            alignY: "middle"
          };
        }
      },
      "window/minimize-button": {
        alias: "button",
        style: function (states) {
          return {
            icon: qx.theme.simple.Image.URLS["window-minimize"],
            padding: [1, 2],
            cursor: states.disabled ? undefined : "pointer"
          };
        }
      },
      "window/restore-button": {
        alias: "button",
        style: function (states) {
          return {
            icon: qx.theme.simple.Image.URLS["window-restore"],
            padding: [1, 2],
            cursor: states.disabled ? undefined : "pointer"
          };
        }
      },
      "window/maximize-button": {
        alias: "button",
        style: function (states) {
          return {
            icon: qx.theme.simple.Image.URLS["window-maximize"],
            padding: [1, 2],
            cursor: states.disabled ? undefined : "pointer"
          };
        }
      },
      "window/close-button": {
        alias: "button",
        style: function (states) {
          return {
            marginLeft: 2,
            icon: qx.theme.simple.Image.URLS["window-close"],
            padding: [1, 2],
            cursor: states.disabled ? undefined : "pointer"
          };
        }
      },
      "window/statusbar": {
        style: function (states) {
          return {
            decorator: "statusbar",
            padding: [2, 6]
          };
        }
      },
      "window/statusbar-text": "label",

      /*
      ---------------------------------------------------------------------------
        DATE CHOOSER
      ---------------------------------------------------------------------------
      */
      "datechooser": {
        style: function (states) {
          return {
            decorator: "main",
            minWidth: 220
          };
        }
      },
      "datechooser/navigation-bar": {
        style: function (states) {
          return {
            backgroundColor: "background",
            textColor: states.disabled ? "text-disabled" : states.invalid ? "invalid" : undefined,
            padding: [2, 10]
          };
        }
      },
      "datechooser/last-year-button-tooltip": "tooltip",
      "datechooser/last-month-button-tooltip": "tooltip",
      "datechooser/next-year-button-tooltip": "tooltip",
      "datechooser/next-month-button-tooltip": "tooltip",
      "datechooser/last-year-button": "datechooser/button",
      "datechooser/last-month-button": "datechooser/button",
      "datechooser/next-year-button": "datechooser/button",
      "datechooser/next-month-button": "datechooser/button",
      "datechooser/button/icon": {},
      "datechooser/button": {
        style: function (states) {
          var result = {
            width: 17,
            show: "icon",
            cursor: states.disabled ? undefined : "pointer"
          };

          if (states.lastYear) {
            result.icon = qx.theme.simple.Image.URLS["arrow-rewind"];
          } else if (states.lastMonth) {
            result.icon = qx.theme.simple.Image.URLS["arrow-left"];
          } else if (states.nextYear) {
            result.icon = qx.theme.simple.Image.URLS["arrow-forward"];
          } else if (states.nextMonth) {
            result.icon = qx.theme.simple.Image.URLS["arrow-right"];
          }

          return result;
        }
      },
      "datechooser/month-year-label": {
        style: function (states) {
          return {
            font: "bold",
            textAlign: "center"
          };
        }
      },
      "datechooser/date-pane": {
        style: function (states) {
          return {
            decorator: "datechooser-date-pane",
            backgroundColor: "background"
          };
        }
      },
      "datechooser/weekday": {
        style: function (states) {
          return {
            decorator: "datechooser-weekday",
            font: "bold",
            textAlign: "center",
            textColor: states.disabled ? "text-disabled" : states.weekend ? "background-selected-dark" : "background",
            backgroundColor: states.weekend ? "background" : "background-selected-dark",
            paddingTop: 2
          };
        }
      },
      "datechooser/day": {
        style: function (states) {
          return {
            textAlign: "center",
            decorator: states.today ? "main" : undefined,
            textColor: states.disabled ? "text-disabled" : states.selected ? "text-selected" : states.otherMonth ? "text-disabled" : undefined,
            backgroundColor: states.disabled ? undefined : states.selected ? "background-selected" : undefined,
            padding: states.today ? [1, 3] : [2, 4]
          };
        }
      },
      "datechooser/week": {
        style: function (states) {
          return {
            textAlign: "center",
            textColor: "background-selected-dark",
            padding: [2, 4],
            decorator: states.header ? "datechooser-week-header" : "datechooser-week"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        PROGRESSBAR
      ---------------------------------------------------------------------------
      */
      "progressbar": {
        style: function (states) {
          return {
            decorator: "progressbar",
            padding: 1,
            backgroundColor: "white",
            width: 200,
            height: 20
          };
        }
      },
      "progressbar/progress": {
        style: function (states) {
          return {
            backgroundColor: states.disabled ? "background-disabled-checked" : "background-selected"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        TOOLBAR
      ---------------------------------------------------------------------------
      */
      "toolbar": {
        style: function (states) {
          return {
            backgroundColor: "light-background",
            padding: 0
          };
        }
      },
      "toolbar/part": {
        style: function (states) {
          return {
            margin: [0, 15]
          };
        }
      },
      "toolbar/part/container": {},
      "toolbar/part/handle": {},
      "toolbar-separator": {
        style: function (states) {
          return {
            decorator: "toolbar-separator",
            margin: [7, 0],
            width: 4
          };
        }
      },
      "toolbar-button": {
        alias: "atom",
        style: function (states) {
          var decorator = "button-box";

          if (states.disabled) {
            decorator = "button-box";
          } else if (states.hovered && !states.pressed && !states.checked) {
            decorator = "button-box-hovered";
          } else if (states.hovered && (states.pressed || states.checked)) {
            decorator = "button-box-pressed-hovered";
          } else if (states.pressed || states.checked) {
            decorator = "button-box-pressed";
          } // set the right left and right decorator


          if (states.left) {
            decorator += "-left";
          } else if (states.right) {
            decorator += "-right";
          } else if (states.middle) {
            decorator += "-middle";
          } // set the margin


          var margin = [7, 10];

          if (states.left || states.middle || states.right) {
            margin = [7, 0];
          }

          return {
            cursor: states.disabled ? undefined : "pointer",
            decorator: decorator,
            margin: margin,
            padding: [3, 5]
          };
        }
      },
      "toolbar-menubutton": {
        alias: "toolbar-button",
        include: "toolbar-button",
        style: function (states) {
          return {
            showArrow: true
          };
        }
      },
      "toolbar-menubutton/arrow": {
        alias: "image",
        include: "image",
        style: function (states) {
          return {
            source: qx.theme.simple.Image.URLS["arrow-down"],
            cursor: states.disabled ? undefined : "pointer",
            padding: [0, 5],
            marginLeft: 2
          };
        }
      },
      "toolbar-splitbutton": {},
      "toolbar-splitbutton/button": {
        alias: "toolbar-button",
        include: "toolbar-button",
        style: function (states) {
          var decorator = "button-box";

          if (states.disabled) {
            decorator = "button-box";
          } else if (states.hovered && !states.pressed && !states.checked) {
            decorator = "button-box-hovered";
          } else if (states.hovered && (states.pressed || states.checked)) {
            decorator = "button-box-pressed-hovered";
          } else if (states.pressed || states.checked) {
            decorator = "button-box-pressed";
          } // default margin, when the button is alone


          var margin = [7, 0, 7, 10];

          if (states.left || states.middle || states.right) {
            margin = [7, 0, 7, 0];
          } // set the right left and right decorator


          if (states.left) {
            decorator += "-left";
          } else if (states.right) {
            decorator += "-middle";
          } else if (states.middle) {
            decorator += "-middle";
          } else {
            decorator += "-left";
          }

          return {
            icon: qx.theme.simple.Image.URLS["arrow-down"],
            decorator: decorator,
            margin: margin
          };
        }
      },
      "toolbar-splitbutton/arrow": {
        alias: "toolbar-button",
        include: "toolbar-button",
        style: function (states) {
          var decorator = "button-box";

          if (states.disabled) {
            decorator = "button-box";
          } else if (states.hovered && !states.pressed && !states.checked) {
            decorator = "button-box-hovered";
          } else if (states.hovered && (states.pressed || states.checked)) {
            decorator = "button-box-pressed-hovered";
          } else if (states.pressed || states.checked) {
            decorator = "button-box-pressed";
          } // default margin, when the button is alone


          var margin = [7, 10, 7, 0];

          if (states.left || states.middle || states.right) {
            margin = [7, 0, 7, 0];
          } // set the right left and right decorator


          if (states.left) {
            decorator += "-middle";
          } else if (states.right) {
            decorator += "-right";
          } else if (states.middle) {
            decorator += "-middle";
          } else {
            decorator += "-right";
          }

          return {
            icon: qx.theme.simple.Image.URLS["arrow-down"],
            decorator: decorator,
            margin: margin
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        TABVIEW
      ---------------------------------------------------------------------------
      */
      "tabview": {},
      "tabview/bar": {
        alias: "slidebar",
        style: function (states) {
          var marginTop = 0,
              marginRight = 0,
              marginBottom = 0,
              marginLeft = 0;

          if (states.barTop) {
            marginBottom -= 1;
          } else if (states.barBottom) {
            marginTop -= 1;
          } else if (states.barRight) {
            marginLeft -= 1;
          } else {
            marginRight -= 1;
          }

          return {
            marginBottom: marginBottom,
            marginTop: marginTop,
            marginLeft: marginLeft,
            marginRight: marginRight
          };
        }
      },
      "tabview/bar/button-forward": {
        include: "slidebar/button-forward",
        alias: "slidebar/button-forward",
        style: function (states) {
          if (states.barTop) {
            return {
              marginTop: 4,
              marginBottom: 2,
              decorator: null
            };
          } else if (states.barBottom) {
            return {
              marginTop: 2,
              marginBottom: 4,
              decorator: null
            };
          } else if (states.barLeft) {
            return {
              marginLeft: 4,
              marginRight: 2,
              decorator: null
            };
          } else {
            return {
              marginLeft: 2,
              marginRight: 4,
              decorator: null
            };
          }
        }
      },
      "tabview/bar/button-backward": {
        include: "slidebar/button-backward",
        alias: "slidebar/button-backward",
        style: function (states) {
          if (states.barTop) {
            return {
              marginTop: 4,
              marginBottom: 2,
              decorator: null
            };
          } else if (states.barBottom) {
            return {
              marginTop: 2,
              marginBottom: 4,
              decorator: null
            };
          } else if (states.barLeft) {
            return {
              marginLeft: 4,
              marginRight: 2,
              decorator: null
            };
          } else {
            return {
              marginLeft: 2,
              marginRight: 4,
              decorator: null
            };
          }
        }
      },
      "tabview/pane": {
        style: function (states) {
          return {
            backgroundColor: "background",
            decorator: "main",
            padding: 10
          };
        }
      },
      "tabview-page": "widget",
      "tabview-page/button": {
        style: function (states) {
          var decorator; // default padding

          if (states.barTop || states.barBottom) {
            var padding = [8, 16, 8, 13];
          } else {
            var padding = [8, 4, 8, 4];
          } // decorator


          if (states.checked) {
            if (states.barTop) {
              decorator = "tabview-page-button-top";
            } else if (states.barBottom) {
              decorator = "tabview-page-button-bottom";
            } else if (states.barRight) {
              decorator = "tabview-page-button-right";
            } else if (states.barLeft) {
              decorator = "tabview-page-button-left";
            }
          } else {
            for (var i = 0; i < padding.length; i++) {
              padding[i] += 1;
            } // reduce the size by 1 because we have different decorator border width


            if (states.barTop) {
              padding[2] -= 1;
            } else if (states.barBottom) {
              padding[0] -= 1;
            } else if (states.barRight) {
              padding[3] -= 1;
            } else if (states.barLeft) {
              padding[1] -= 1;
            }
          }

          return {
            zIndex: states.checked ? 10 : 5,
            decorator: decorator,
            textColor: states.disabled ? "text-disabled" : states.checked ? null : "link",
            padding: padding,
            cursor: "pointer"
          };
        }
      },
      "tabview-page/button/label": {
        alias: "label",
        style: function (states) {
          return {
            padding: [0, 1, 0, 1]
          };
        }
      },
      "tabview-page/button/icon": "image",
      "tabview-page/button/close-button": {
        alias: "atom",
        style: function (states) {
          return {
            cursor: states.disabled ? undefined : "pointer",
            icon: qx.theme.simple.Image.URLS["tabview-close"]
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        COLOR POPUP
      ---------------------------------------------------------------------------
      */
      "colorpopup": {
        alias: "popup",
        include: "popup",
        style: function (states) {
          return {
            padding: 5
          };
        }
      },
      "colorpopup/field": {
        style: function (states) {
          return {
            margin: 2,
            width: 14,
            height: 14,
            backgroundColor: "background",
            decorator: "main-dark"
          };
        }
      },
      "colorpopup/selector-button": "button",
      "colorpopup/auto-button": "button",
      "colorpopup/preview-pane": "groupbox",
      "colorpopup/current-preview": {
        style: function (state) {
          return {
            height: 20,
            padding: 4,
            marginLeft: 4,
            decorator: "main-dark",
            allowGrowX: true
          };
        }
      },
      "colorpopup/selected-preview": {
        style: function (state) {
          return {
            height: 20,
            padding: 4,
            marginRight: 4,
            decorator: "main-dark",
            allowGrowX: true
          };
        }
      },
      "colorpopup/colorselector-okbutton": {
        alias: "button",
        include: "button",
        style: function (states) {
          return {
            icon: "icon/16/actions/dialog-ok.png"
          };
        }
      },
      "colorpopup/colorselector-cancelbutton": {
        alias: "button",
        include: "button",
        style: function (states) {
          return {
            icon: "icon/16/actions/dialog-cancel.png"
          };
        }
      },

      /*
      ---------------------------------------------------------------------------
        COLOR SELECTOR
      ---------------------------------------------------------------------------
      */
      "colorselector": "widget",
      "colorselector/control-bar": "widget",
      "colorselector/visual-pane": "groupbox",
      "colorselector/control-pane": "widget",
      "colorselector/preset-grid": "widget",
      "colorselector/colorbucket": {
        style: function (states) {
          return {
            decorator: "main-dark",
            width: 16,
            height: 16
          };
        }
      },
      "colorselector/preset-field-set": "groupbox",
      "colorselector/input-field-set": {
        include: "groupbox",
        alias: "groupbox",
        style: function () {
          return {
            paddingTop: 12
          };
        }
      },
      "colorselector/preview-field-set": {
        include: "groupbox",
        alias: "groupbox",
        style: function () {
          return {
            paddingTop: 12
          };
        }
      },
      "colorselector/hex-field-composite": "widget",
      "colorselector/hex-field": "textfield",
      "colorselector/rgb-spinner-composite": "widget",
      "colorselector/rgb-spinner-red": "spinner",
      "colorselector/rgb-spinner-green": "spinner",
      "colorselector/rgb-spinner-blue": "spinner",
      "colorselector/hsb-spinner-composite": "widget",
      "colorselector/hsb-spinner-hue": "spinner",
      "colorselector/hsb-spinner-saturation": "spinner",
      "colorselector/hsb-spinner-brightness": "spinner",
      "colorselector/preview-content-old": {
        style: function (states) {
          return {
            decorator: "main-dark",
            width: 50,
            height: 25
          };
        }
      },
      "colorselector/preview-content-new": {
        style: function (states) {
          return {
            decorator: "main-dark",
            backgroundColor: "white",
            width: 50,
            height: 25
          };
        }
      },
      "colorselector/hue-saturation-field": {
        style: function (states) {
          return {
            decorator: "main-dark",
            margin: 5
          };
        }
      },
      "colorselector/brightness-field": {
        style: function (states) {
          return {
            decorator: "main-dark",
            margin: [5, 7]
          };
        }
      },
      "colorselector/hue-saturation-pane": "widget",
      "colorselector/hue-saturation-handle": "widget",
      "colorselector/brightness-pane": "widget",
      "colorselector/brightness-handle": "widget",

      /*
      ---------------------------------------------------------------------------
        APPLICATION
      ---------------------------------------------------------------------------
      */
      "app-header": {
        style: function (states) {
          return {
            font: "headline",
            textColor: "text-selected",
            backgroundColor: "background-selected-dark",
            padding: [8, 12]
          };
        }
      },
      "app-header-label": {
        style: function (states) {
          return {
            paddingTop: 5
          };
        }
      },
      "app-splitpane": {
        alias: "splitpane",
        style: function (states) {
          return {
            padding: [0, 10, 10, 10],
            backgroundColor: "light-background"
          };
        }
      },

      /*
        --------------------
        VIRTUAL SELECTBOX 
        --------------------
      */
      "list-search-highlight": {
        style: function (states) {
          return {
            color: '#FF0000',
            fontWeight: 'bold'
          };
        }
      }
    }
  });
  qx.theme.simple.Appearance.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Theme": {
        "usage": "dynamic",
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2008 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Sebastian Werner (wpbasti)
       * Andreas Ecker (ecker)
  
  ************************************************************************ */

  /**
   * Tango icons
   */
  qx.Theme.define("qx.theme.icon.Tango", {
    title: "Tango",
    aliases: {
      "icon": "qx/icon/Tango"
    }
  });
  qx.theme.icon.Tango.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Theme": {
        "usage": "dynamic",
        "require": true
      },
      "qx.theme.simple.Color": {
        "require": true
      },
      "qx.theme.simple.Decoration": {
        "require": true
      },
      "qx.theme.simple.Font": {
        "require": true
      },
      "qx.theme.simple.Appearance": {
        "require": true
      },
      "qx.theme.icon.Tango": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2011 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /**
   * Simple Theme
   */
  qx.Theme.define("qx.theme.Simple", {
    title: "Simple",
    meta: {
      color: qx.theme.simple.Color,
      decoration: qx.theme.simple.Decoration,
      font: qx.theme.simple.Font,
      appearance: qx.theme.simple.Appearance,
      icon: qx.theme.icon.Tango
    }
  });
  qx.theme.Simple.$$dbClassInfo = $$dbClassInfo;
})();

(function () {
  var $$dbClassInfo = {
    "dependsOn": {
      "qx.Class": {
        "usage": "dynamic",
        "require": true
      },
      "qx.core.Object": {
        "require": true
      }
    }
  };
  qx.Bootstrap.executePendingDefers($$dbClassInfo);

  /* ************************************************************************
  
     qooxdoo - the new era of web development
  
     http://qooxdoo.org
  
     Copyright:
       2004-2010 1&1 Internet AG, Germany, http://www.1und1.de
  
     License:
       MIT: https://opensource.org/licenses/MIT
       See the LICENSE file in the project's top-level directory for details.
  
     Authors:
       * Martin Wittemann (martinwittemann)
  
  ************************************************************************ */

  /* ************************************************************************
  
  
  ************************************************************************* */

  /**
   * Mapping class for all images used in the simple theme.
   *
   * @asset(qx/decoration/Simple/*)
   * @asset(qx/static/blank.png)
   */
  qx.Class.define("qx.theme.simple.Image", {
    extend: qx.core.Object,
    statics: {
      /**
       * Holds a map containing all the URL to the images.
       * @internal
       */
      URLS: {
        "blank": "qx/static/blank.png",
        // checkbox
        "checkbox-checked": "decoration/checkbox/checked.png",
        "checkbox-undetermined": "decoration/checkbox/undetermined.png",
        // window
        "window-minimize": "decoration/window/minimize.gif",
        "window-maximize": "decoration/window/maximize.gif",
        "window-restore": "decoration/window/restore.gif",
        "window-close": "decoration/window/close.gif",
        // cursor
        "cursor-copy": "decoration/cursors/copy.gif",
        "cursor-move": "decoration/cursors/move.gif",
        "cursor-alias": "decoration/cursors/alias.gif",
        "cursor-nodrop": "decoration/cursors/nodrop.gif",
        // arrows
        "arrow-right": "decoration/arrows/right.gif",
        "arrow-left": "decoration/arrows/left.gif",
        "arrow-up": "decoration/arrows/up.gif",
        "arrow-down": "decoration/arrows/down.gif",
        "arrow-forward": "decoration/arrows/forward.gif",
        "arrow-rewind": "decoration/arrows/rewind.gif",
        "arrow-down-small": "decoration/arrows/down-small.gif",
        "arrow-up-small": "decoration/arrows/up-small.gif",
        "arrow-up-invert": "decoration/arrows/up-invert.gif",
        "arrow-down-invert": "decoration/arrows/down-invert.gif",
        "arrow-right-invert": "decoration/arrows/right-invert.gif",
        // split pane
        "knob-horizontal": "decoration/splitpane/knob-horizontal.png",
        "knob-vertical": "decoration/splitpane/knob-vertical.png",
        // tree
        "tree-minus": "decoration/tree/minus.gif",
        "tree-plus": "decoration/tree/plus.gif",
        // table
        "select-column-order": "decoration/table/select-column-order.png",
        "table-ascending": "decoration/table/ascending.png",
        "table-descending": "decoration/table/descending.png",
        // tree virtual
        "treevirtual-line": "decoration/treevirtual/line.gif",
        "treevirtual-minus-only": "decoration/treevirtual/only_minus.gif",
        "treevirtual-plus-only": "decoration/treevirtual/only_plus.gif",
        "treevirtual-minus-start": "decoration/treevirtual/start_minus.gif",
        "treevirtual-plus-start": "decoration/treevirtual/start_plus.gif",
        "treevirtual-minus-end": "decoration/treevirtual/end_minus.gif",
        "treevirtual-plus-end": "decoration/treevirtual/end_plus.gif",
        "treevirtual-minus-cross": "decoration/treevirtual/cross_minus.gif",
        "treevirtual-plus-cross": "decoration/treevirtual/cross_plus.gif",
        "treevirtual-end": "decoration/treevirtual/end.gif",
        "treevirtual-cross": "decoration/treevirtual/cross.gif",
        // menu
        "menu-checkbox": "decoration/menu/checkbox.gif",
        "menu-checkbox-invert": "decoration/menu/checkbox-invert.gif",
        "menu-radiobutton-invert": "decoration/menu/radiobutton-invert.gif",
        "menu-radiobutton": "decoration/menu/radiobutton.gif",
        // tabview
        "tabview-close": "decoration/tabview/close.gif"
      }
    }
  });
  qx.theme.simple.Image.$$dbClassInfo = $$dbClassInfo;
})();
qx.$$packageData['0'] = {
  "locales": {
    "C": {
      "alternateQuotationEnd": "’",
      "alternateQuotationStart": "‘",
      "quotationEnd": "”",
      "quotationStart": "“",
      "cldr_am": "AM",
      "cldr_pm": "PM",
      "cldr_date_format_full": "EEEE, MMMM d, y",
      "cldr_date_format_long": "MMMM d, y",
      "cldr_date_format_medium": "MMM d, y",
      "cldr_date_format_short": "M/d/yy",
      "cldr_date_time_format_Ed": "d E",
      "cldr_date_time_format_Hm": "HH:mm",
      "cldr_date_time_format_Hms": "HH:mm:ss",
      "cldr_date_time_format_M": "L",
      "cldr_date_time_format_MEd": "E, M/d",
      "cldr_date_time_format_MMM": "LLL",
      "cldr_date_time_format_MMMEd": "E, MMM d",
      "cldr_date_time_format_MMMd": "MMM d",
      "cldr_date_time_format_Md": "M/d",
      "cldr_date_time_format_d": "d",
      "cldr_date_time_format_hm": "h:mm a",
      "cldr_date_time_format_hms": "h:mm:ss a",
      "cldr_date_time_format_ms": "mm:ss",
      "cldr_date_time_format_y": "y",
      "cldr_date_time_format_yM": "M/y",
      "cldr_date_time_format_yMEd": "E, M/d/y",
      "cldr_date_time_format_yMMM": "MMM y",
      "cldr_date_time_format_yMMMEd": "E, MMM d, y",
      "cldr_date_time_format_yMMMd": "MMM d, y",
      "cldr_date_time_format_yMd": "M/d/y",
      "cldr_date_time_format_yQ": null,
      "cldr_date_time_format_yQQQ": "QQQ y",
      "cldr_day_format_abbreviated_fri": "Fri",
      "cldr_day_format_abbreviated_mon": "Mon",
      "cldr_day_format_abbreviated_sat": "Sat",
      "cldr_day_format_abbreviated_sun": "Sun",
      "cldr_day_format_abbreviated_thu": "Thu",
      "cldr_day_format_abbreviated_tue": "Tue",
      "cldr_day_format_abbreviated_wed": "Wed",
      "cldr_day_format_wide_fri": "Friday",
      "cldr_day_format_wide_mon": "Monday",
      "cldr_day_format_wide_sat": "Saturday",
      "cldr_day_format_wide_sun": "Sunday",
      "cldr_day_format_wide_thu": "Thursday",
      "cldr_day_format_wide_tue": "Tuesday",
      "cldr_day_format_wide_wed": "Wednesday",
      "cldr_day_stand-alone_narrow_fri": "F",
      "cldr_day_stand-alone_narrow_mon": "M",
      "cldr_day_stand-alone_narrow_sat": "S",
      "cldr_day_stand-alone_narrow_sun": "S",
      "cldr_day_stand-alone_narrow_thu": "T",
      "cldr_day_stand-alone_narrow_tue": "T",
      "cldr_day_stand-alone_narrow_wed": "W",
      "cldr_month_format_abbreviated_1": "Jan",
      "cldr_month_format_abbreviated_2": "Feb",
      "cldr_month_format_abbreviated_3": "Mar",
      "cldr_month_format_abbreviated_4": "Apr",
      "cldr_month_format_abbreviated_5": "May",
      "cldr_month_format_abbreviated_6": "Jun",
      "cldr_month_format_abbreviated_7": "Jul",
      "cldr_month_format_abbreviated_8": "Aug",
      "cldr_month_format_abbreviated_9": "Sep",
      "cldr_month_format_abbreviated_10": "Oct",
      "cldr_month_format_abbreviated_11": "Nov",
      "cldr_month_format_abbreviated_12": "Dec",
      "cldr_month_format_wide_1": "January",
      "cldr_month_format_wide_2": "February",
      "cldr_month_format_wide_3": "March",
      "cldr_month_format_wide_4": "April",
      "cldr_month_format_wide_5": "May",
      "cldr_month_format_wide_6": "June",
      "cldr_month_format_wide_7": "July",
      "cldr_month_format_wide_8": "August",
      "cldr_month_format_wide_9": "September",
      "cldr_month_format_wide_10": "October",
      "cldr_month_format_wide_11": "November",
      "cldr_month_format_wide_12": "December",
      "cldr_month_stand-alone_narrow_1": "J",
      "cldr_month_stand-alone_narrow_2": "F",
      "cldr_month_stand-alone_narrow_3": "M",
      "cldr_month_stand-alone_narrow_4": "A",
      "cldr_month_stand-alone_narrow_5": "M",
      "cldr_month_stand-alone_narrow_6": "J",
      "cldr_month_stand-alone_narrow_7": "J",
      "cldr_month_stand-alone_narrow_8": "A",
      "cldr_month_stand-alone_narrow_9": "S",
      "cldr_month_stand-alone_narrow_10": "O",
      "cldr_month_stand-alone_narrow_11": "N",
      "cldr_month_stand-alone_narrow_12": "D",
      "cldr_number_decimal_separator": ".",
      "cldr_number_group_separator": ",",
      "cldr_number_percent_format": "#,##0%",
      "day": [
        "day"
      ],
      "dayperiod": [
        "AM/PM",
        "am/pm"
      ],
      "era": [
        "era"
      ],
      "hour": [
        "hour"
      ],
      "minute": [
        "minute"
      ],
      "month": [
        "month"
      ],
      "second": [
        "second"
      ],
      "week": [
        "week"
      ],
      "weekday": [
        "day of the week"
      ],
      "year": [
        "year"
      ],
      "zone": [
        "time zone"
      ]
    },
    "en": {
      "alternateQuotationEnd": "’",
      "alternateQuotationStart": "‘",
      "quotationEnd": "”",
      "quotationStart": "“",
      "cldr_am": "AM",
      "cldr_pm": "PM",
      "cldr_date_format_full": "EEEE, MMMM d, y",
      "cldr_date_format_long": "MMMM d, y",
      "cldr_date_format_medium": "MMM d, y",
      "cldr_date_format_short": "M/d/yy",
      "cldr_date_time_format_Ed": "d E",
      "cldr_date_time_format_Hm": "HH:mm",
      "cldr_date_time_format_Hms": "HH:mm:ss",
      "cldr_date_time_format_M": "L",
      "cldr_date_time_format_MEd": "E, M/d",
      "cldr_date_time_format_MMM": "LLL",
      "cldr_date_time_format_MMMEd": "E, MMM d",
      "cldr_date_time_format_MMMd": "MMM d",
      "cldr_date_time_format_Md": "M/d",
      "cldr_date_time_format_d": "d",
      "cldr_date_time_format_hm": "h:mm a",
      "cldr_date_time_format_hms": "h:mm:ss a",
      "cldr_date_time_format_ms": "mm:ss",
      "cldr_date_time_format_y": "y",
      "cldr_date_time_format_yM": "M/y",
      "cldr_date_time_format_yMEd": "E, M/d/y",
      "cldr_date_time_format_yMMM": "MMM y",
      "cldr_date_time_format_yMMMEd": "E, MMM d, y",
      "cldr_date_time_format_yMMMd": "MMM d, y",
      "cldr_date_time_format_yMd": "M/d/y",
      "cldr_date_time_format_yQ": null,
      "cldr_date_time_format_yQQQ": "QQQ y",
      "cldr_day_format_abbreviated_fri": "Fri",
      "cldr_day_format_abbreviated_mon": "Mon",
      "cldr_day_format_abbreviated_sat": "Sat",
      "cldr_day_format_abbreviated_sun": "Sun",
      "cldr_day_format_abbreviated_thu": "Thu",
      "cldr_day_format_abbreviated_tue": "Tue",
      "cldr_day_format_abbreviated_wed": "Wed",
      "cldr_day_format_wide_fri": "Friday",
      "cldr_day_format_wide_mon": "Monday",
      "cldr_day_format_wide_sat": "Saturday",
      "cldr_day_format_wide_sun": "Sunday",
      "cldr_day_format_wide_thu": "Thursday",
      "cldr_day_format_wide_tue": "Tuesday",
      "cldr_day_format_wide_wed": "Wednesday",
      "cldr_day_stand-alone_narrow_fri": "F",
      "cldr_day_stand-alone_narrow_mon": "M",
      "cldr_day_stand-alone_narrow_sat": "S",
      "cldr_day_stand-alone_narrow_sun": "S",
      "cldr_day_stand-alone_narrow_thu": "T",
      "cldr_day_stand-alone_narrow_tue": "T",
      "cldr_day_stand-alone_narrow_wed": "W",
      "cldr_month_format_abbreviated_1": "Jan",
      "cldr_month_format_abbreviated_2": "Feb",
      "cldr_month_format_abbreviated_3": "Mar",
      "cldr_month_format_abbreviated_4": "Apr",
      "cldr_month_format_abbreviated_5": "May",
      "cldr_month_format_abbreviated_6": "Jun",
      "cldr_month_format_abbreviated_7": "Jul",
      "cldr_month_format_abbreviated_8": "Aug",
      "cldr_month_format_abbreviated_9": "Sep",
      "cldr_month_format_abbreviated_10": "Oct",
      "cldr_month_format_abbreviated_11": "Nov",
      "cldr_month_format_abbreviated_12": "Dec",
      "cldr_month_format_wide_1": "January",
      "cldr_month_format_wide_2": "February",
      "cldr_month_format_wide_3": "March",
      "cldr_month_format_wide_4": "April",
      "cldr_month_format_wide_5": "May",
      "cldr_month_format_wide_6": "June",
      "cldr_month_format_wide_7": "July",
      "cldr_month_format_wide_8": "August",
      "cldr_month_format_wide_9": "September",
      "cldr_month_format_wide_10": "October",
      "cldr_month_format_wide_11": "November",
      "cldr_month_format_wide_12": "December",
      "cldr_month_stand-alone_narrow_1": "J",
      "cldr_month_stand-alone_narrow_2": "F",
      "cldr_month_stand-alone_narrow_3": "M",
      "cldr_month_stand-alone_narrow_4": "A",
      "cldr_month_stand-alone_narrow_5": "M",
      "cldr_month_stand-alone_narrow_6": "J",
      "cldr_month_stand-alone_narrow_7": "J",
      "cldr_month_stand-alone_narrow_8": "A",
      "cldr_month_stand-alone_narrow_9": "S",
      "cldr_month_stand-alone_narrow_10": "O",
      "cldr_month_stand-alone_narrow_11": "N",
      "cldr_month_stand-alone_narrow_12": "D",
      "cldr_number_decimal_separator": ".",
      "cldr_number_group_separator": ",",
      "cldr_number_percent_format": "#,##0%",
      "day": [
        "day"
      ],
      "dayperiod": [
        "AM/PM",
        "am/pm"
      ],
      "era": [
        "era"
      ],
      "hour": [
        "hour"
      ],
      "minute": [
        "minute"
      ],
      "month": [
        "month"
      ],
      "second": [
        "second"
      ],
      "week": [
        "week"
      ],
      "weekday": [
        "day of the week"
      ],
      "year": [
        "year"
      ],
      "zone": [
        "time zone"
      ]
    }
  },
  "resources": {
    "qx/decoration/Simple/arrows/down-invert.gif": [
      7,
      4,
      "gif",
      "qx"
    ],
    "qx/decoration/Simple/arrows/down-small.gif": [
      5,
      3,
      "gif",
      "qx"
    ],
    "qx/decoration/Simple/arrows/down.gif": [
      7,
      4,
      "gif",
      "qx"
    ],
    "qx/decoration/Simple/arrows/forward.gif": [
      8,
      7,
      "gif",
      "qx"
    ],
    "qx/decoration/Simple/arrows/left-invert.gif": [
      4,
      7,
      "gif",
      "qx"
    ],
    "qx/decoration/Simple/arrows/left.gif": [
      4,
      7,
      "gif",
      "qx"
    ],
    "qx/decoration/Simple/arrows/rewind.gif": [
      8,
      7,
      "gif",
      "qx"
    ],
    "qx/decoration/Simple/arrows/right-invert.gif": [
      4,
      7,
      "gif",
      "qx"
    ],
    "qx/decoration/Simple/arrows/right.gif": [
      4,
      7,
      "gif",
      "qx"
    ],
    "qx/decoration/Simple/arrows/up-invert.gif": [
      7,
      4,
      "gif",
      "qx"
    ],
    "qx/decoration/Simple/arrows/up-small.gif": [
      5,
      3,
      "gif",
      "qx"
    ],
    "qx/decoration/Simple/arrows/up.gif": [
      7,
      4,
      "gif",
      "qx"
    ],
    "qx/decoration/Simple/checkbox/checked-disabled.png": [
      6,
      6,
      "png",
      "qx"
    ],
    "qx/decoration/Simple/checkbox/checked.png": [
      6,
      6,
      "png",
      "qx"
    ],
    "qx/decoration/Simple/checkbox/undetermined-disabled.png": [
      6,
      2,
      "png",
      "qx"
    ],
    "qx/decoration/Simple/checkbox/undetermined.png": [
      6,
      2,
      "png",
      "qx"
    ],
    "qx/decoration/Simple/colorselector/brightness-field.png": [
      19,
      256,
      "png",
      "qx"
    ],
    "qx/decoration/Simple/colorselector/brightness-handle.gif": [
      35,
      11,
      "gif",
      "qx"
    ],
    "qx/decoration/Simple/colorselector/huesaturation-field.jpg": [
      256,
      256,
      "jpg",
      "qx"
    ],
    "qx/decoration/Simple/colorselector/huesaturation-handle.gif": [
      11,
      11,
      "gif",
      "qx"
    ],
    "qx/decoration/Simple/cursors/alias.gif": [
      19,
      15,
      "gif",
      "qx"
    ],
    "qx/decoration/Simple/cursors/copy.gif": [
      19,
      15,
      "gif",
      "qx"
    ],
    "qx/decoration/Simple/cursors/move.gif": [
      13,
      9,
      "gif",
      "qx"
    ],
    "qx/decoration/Simple/cursors/nodrop.gif": [
      20,
      20,
      "gif",
      "qx"
    ],
    "qx/decoration/Simple/menu/checkbox-invert.gif": [
      16,
      7,
      "gif",
      "qx"
    ],
    "qx/decoration/Simple/menu/checkbox.gif": [
      16,
      7,
      "gif",
      "qx"
    ],
    "qx/decoration/Simple/menu/radiobutton-invert.gif": [
      16,
      5,
      "gif",
      "qx"
    ],
    "qx/decoration/Simple/menu/radiobutton.gif": [
      16,
      5,
      "gif",
      "qx"
    ],
    "qx/decoration/Simple/splitpane/knob-horizontal.png": [
      1,
      8,
      "png",
      "qx"
    ],
    "qx/decoration/Simple/splitpane/knob-vertical.png": [
      8,
      1,
      "png",
      "qx"
    ],
    "qx/decoration/Simple/table/ascending-invert.png": [
      10,
      10,
      "png",
      "qx"
    ],
    "qx/decoration/Simple/table/ascending.png": [
      10,
      10,
      "png",
      "qx"
    ],
    "qx/decoration/Simple/table/boolean-false.png": [
      11,
      11,
      "png",
      "qx"
    ],
    "qx/decoration/Simple/table/boolean-true.png": [
      11,
      11,
      "png",
      "qx"
    ],
    "qx/decoration/Simple/table/descending-invert.png": [
      10,
      10,
      "png",
      "qx"
    ],
    "qx/decoration/Simple/table/descending.png": [
      10,
      10,
      "png",
      "qx"
    ],
    "qx/decoration/Simple/table/select-column-order.png": [
      10,
      9,
      "png",
      "qx"
    ],
    "qx/decoration/Simple/tabview/close.gif": [
      10,
      9,
      "gif",
      "qx"
    ],
    "qx/decoration/Simple/tree/minus.gif": [
      19,
      16,
      "gif",
      "qx"
    ],
    "qx/decoration/Simple/tree/plus.gif": [
      19,
      16,
      "gif",
      "qx"
    ],
    "qx/decoration/Simple/treevirtual/cross.gif": [
      19,
      16,
      "gif",
      "qx"
    ],
    "qx/decoration/Simple/treevirtual/cross_minus.gif": [
      19,
      16,
      "gif",
      "qx"
    ],
    "qx/decoration/Simple/treevirtual/cross_plus.gif": [
      19,
      16,
      "gif",
      "qx"
    ],
    "qx/decoration/Simple/treevirtual/end.gif": [
      19,
      16,
      "gif",
      "qx"
    ],
    "qx/decoration/Simple/treevirtual/end_minus.gif": [
      19,
      16,
      "gif",
      "qx"
    ],
    "qx/decoration/Simple/treevirtual/end_plus.gif": [
      19,
      16,
      "gif",
      "qx"
    ],
    "qx/decoration/Simple/treevirtual/line.gif": [
      19,
      16,
      "gif",
      "qx"
    ],
    "qx/decoration/Simple/treevirtual/only_minus.gif": [
      19,
      16,
      "gif",
      "qx"
    ],
    "qx/decoration/Simple/treevirtual/only_plus.gif": [
      19,
      16,
      "gif",
      "qx"
    ],
    "qx/decoration/Simple/treevirtual/start.gif": [
      19,
      16,
      "gif",
      "qx"
    ],
    "qx/decoration/Simple/treevirtual/start_minus.gif": [
      19,
      16,
      "gif",
      "qx"
    ],
    "qx/decoration/Simple/treevirtual/start_plus.gif": [
      19,
      16,
      "gif",
      "qx"
    ],
    "qx/decoration/Simple/window/close-white.gif": [
      10,
      9,
      "gif",
      "qx"
    ],
    "qx/decoration/Simple/window/close.gif": [
      10,
      9,
      "gif",
      "qx"
    ],
    "qx/decoration/Simple/window/maximize-white.gif": [
      9,
      9,
      "gif",
      "qx"
    ],
    "qx/decoration/Simple/window/maximize.gif": [
      9,
      9,
      "gif",
      "qx"
    ],
    "qx/decoration/Simple/window/minimize-white.gif": [
      9,
      9,
      "gif",
      "qx"
    ],
    "qx/decoration/Simple/window/minimize.gif": [
      9,
      9,
      "gif",
      "qx"
    ],
    "qx/decoration/Simple/window/restore-white.gif": [
      8,
      9,
      "gif",
      "qx"
    ],
    "qx/decoration/Simple/window/restore.gif": [
      8,
      9,
      "gif",
      "qx"
    ],
    "qx/static/blank.png": [
      1,
      1,
      "png",
      "qx"
    ],
    "qx/tool/bin/build-devtools": [
      null,
      null,
      "",
      "qxcompiler"
    ],
    "qx/tool/bin/build-website": [
      null,
      null,
      "",
      "qxcompiler"
    ],
    "qx/tool/bin/download-assets": [
      null,
      null,
      "",
      "qxcompiler"
    ],
    "qx/tool/schema/Manifest-1-0-0.json": [
      null,
      null,
      "json",
      "qxcompiler"
    ],
    "qx/tool/schema/compile-1-0-0.json": [
      null,
      null,
      "json",
      "qxcompiler"
    ],
    "qx/tool/schema/qooxdoo-1-0-0.json": [
      null,
      null,
      "json",
      "qxcompiler"
    ],
    "qx/tool/website/.gitignore": [
      null,
      null,
      "",
      "qxcompiler"
    ],
    "qx/tool/cli/templates/template_vars.js": [
      null,
      null,
      "js",
      "qxcompiler"
    ],
    "qx/tool/website/build/404.html": [
      null,
      null,
      "html",
      "qxcompiler"
    ],
    "qx/tool/website/build/about.html": [
      null,
      null,
      "html",
      "qxcompiler"
    ],
    "qx/tool/website/build/index.html": [
      null,
      null,
      "html",
      "qxcompiler"
    ],
    "qx/tool/website/build/qooxdoo.css": [
      null,
      null,
      "css",
      "qxcompiler"
    ],
    "qx/tool/website/layouts/default.dot": [
      null,
      null,
      "dot",
      "qxcompiler"
    ],
    "qx/tool/website/partials/footer.html": [
      null,
      null,
      "html",
      "qxcompiler"
    ],
    "qx/tool/website/partials/head.html": [
      null,
      null,
      "html",
      "qxcompiler"
    ],
    "qx/tool/website/partials/header.html": [
      null,
      null,
      "html",
      "qxcompiler"
    ],
    "qx/tool/website/partials/icon-github.html": [
      null,
      null,
      "html",
      "qxcompiler"
    ],
    "qx/tool/website/partials/icon-github.svg": [
      16,
      16,
      "svg",
      "qxcompiler"
    ],
    "qx/tool/website/partials/icon-twitter.html": [
      null,
      null,
      "html",
      "qxcompiler"
    ],
    "qx/tool/website/partials/icon-twitter.svg": [
      16,
      16,
      "svg",
      "qxcompiler"
    ],
    "qx/tool/website/sass/qooxdoo.scss": [
      null,
      null,
      "scss",
      "qxcompiler"
    ],
    "qx/tool/website/src/404.html": [
      null,
      null,
      "html",
      "qxcompiler"
    ],
    "qx/tool/website/src/about.md": [
      null,
      null,
      "md",
      "qxcompiler"
    ],
    "qx/tool/website/src/index.html": [
      null,
      null,
      "html",
      "qxcompiler"
    ],
    "qx/tool/cli/templates/class/header.tmpl.js": [
      null,
      null,
      "js",
      "qxcompiler"
    ],
    "qx/tool/cli/templates/class/interface.tmpl.js": [
      null,
      null,
      "js",
      "qxcompiler"
    ],
    "qx/tool/cli/templates/class/default.tmpl.js": [
      null,
      null,
      "js",
      "qxcompiler"
    ],
    "qx/tool/cli/templates/class/mixin.tmpl.js": [
      null,
      null,
      "js",
      "qxcompiler"
    ],
    "qx/tool/cli/templates/class/singleton.tmpl.js": [
      null,
      null,
      "js",
      "qxcompiler"
    ],
    "qx/tool/cli/templates/loader/loader-browser.tmpl.js": [
      null,
      null,
      "js",
      "qxcompiler"
    ],
    "qx/tool/cli/templates/loader/loader-node.tmpl.js": [
      null,
      null,
      "js",
      "qxcompiler"
    ],
    "qx/tool/cli/templates/loader/loader-rhino.tmpl.js": [
      null,
      null,
      "js",
      "qxcompiler"
    ],
    "qx/tool/website/build/assets/abel.css": [
      null,
      null,
      "css",
      "qxcompiler"
    ],
    "qx/tool/website/build/assets/bluebird.min.js": [
      null,
      null,
      "js",
      "qxcompiler"
    ],
    "qx/tool/website/build/assets/bootstrap.css": [
      null,
      null,
      "css",
      "qxcompiler"
    ],
    "qx/tool/website/build/assets/bootstrap.min.css": [
      null,
      null,
      "css",
      "qxcompiler"
    ],
    "qx/tool/website/build/assets/bootstrap.min.css.map": [
      null,
      null,
      "map",
      "qxcompiler"
    ],
    "qx/tool/website/build/assets/buttons.js": [
      null,
      null,
      "js",
      "qxcompiler"
    ],
    "qx/tool/website/build/assets/favicon.png": [
      32,
      32,
      "png",
      "qxcompiler"
    ],
    "qx/tool/website/build/assets/fontawesome-all.js": [
      null,
      null,
      "js",
      "qxcompiler"
    ],
    "qx/tool/website/build/assets/jquery.js": [
      null,
      null,
      "js",
      "qxcompiler"
    ],
    "qx/tool/website/build/assets/logo.svg": [
      512,
      145,
      "svg",
      "qxcompiler"
    ],
    "qx/tool/website/build/assets/qx-api.png": [
      1144,
      640,
      "png",
      "qxcompiler"
    ],
    "qx/tool/website/build/assets/qx-ide.png": [
      3183,
      1752,
      "png",
      "qxcompiler"
    ],
    "qx/tool/website/build/assets/qx-oo.png": [
      870,
      502,
      "png",
      "qxcompiler"
    ],
    "qx/tool/website/build/assets/qx-white.svg": [
      64,
      65,
      "svg",
      "qxcompiler"
    ],
    "qx/tool/website/build/diagnostics/dependson.html": [
      null,
      null,
      "html",
      "qxcompiler"
    ],
    "qx/tool/website/build/diagnostics/dependson.js": [
      null,
      null,
      "js",
      "qxcompiler"
    ],
    "qx/tool/website/build/diagnostics/requiredby.html": [
      null,
      null,
      "html",
      "qxcompiler"
    ],
    "qx/tool/website/build/diagnostics/requiredby.js": [
      null,
      null,
      "js",
      "qxcompiler"
    ],
    "qx/tool/website/build/scripts/serve.js": [
      null,
      null,
      "js",
      "qxcompiler"
    ],
    "qx/tool/website/src/assets/abel.css": [
      null,
      null,
      "css",
      "qxcompiler"
    ],
    "qx/tool/website/src/assets/bluebird.min.js": [
      null,
      null,
      "js",
      "qxcompiler"
    ],
    "qx/tool/website/src/assets/bootstrap.min.css": [
      null,
      null,
      "css",
      "qxcompiler"
    ],
    "qx/tool/website/src/assets/bootstrap.min.css.map": [
      null,
      null,
      "map",
      "qxcompiler"
    ],
    "qx/tool/website/src/assets/bootstrap.css": [
      null,
      null,
      "css",
      "qxcompiler"
    ],
    "qx/tool/website/src/assets/buttons.js": [
      null,
      null,
      "js",
      "qxcompiler"
    ],
    "qx/tool/website/src/assets/favicon.png": [
      32,
      32,
      "png",
      "qxcompiler"
    ],
    "qx/tool/website/src/assets/fontawesome-all.js": [
      null,
      null,
      "js",
      "qxcompiler"
    ],
    "qx/tool/website/src/assets/jquery.js": [
      null,
      null,
      "js",
      "qxcompiler"
    ],
    "qx/tool/website/src/assets/logo.svg": [
      512,
      145,
      "svg",
      "qxcompiler"
    ],
    "qx/tool/website/src/assets/qx-api.png": [
      1144,
      640,
      "png",
      "qxcompiler"
    ],
    "qx/tool/website/src/assets/qx-ide.png": [
      3183,
      1752,
      "png",
      "qxcompiler"
    ],
    "qx/tool/website/src/assets/qx-oo.png": [
      870,
      502,
      "png",
      "qxcompiler"
    ],
    "qx/tool/website/src/assets/qx-white.svg": [
      64,
      65,
      "svg",
      "qxcompiler"
    ],
    "qx/tool/website/src/diagnostics/dependson.html": [
      null,
      null,
      "html",
      "qxcompiler"
    ],
    "qx/tool/website/src/diagnostics/requiredby.html": [
      null,
      null,
      "html",
      "qxcompiler"
    ],
    "qx/tool/website/src/diagnostics/dependson.js": [
      null,
      null,
      "js",
      "qxcompiler"
    ],
    "qx/tool/website/src/diagnostics/requiredby.js": [
      null,
      null,
      "js",
      "qxcompiler"
    ],
    "qx/tool/website/src/scripts/serve.js": [
      null,
      null,
      "js",
      "qxcompiler"
    ],
    "qx/tool/cli/templates/skeleton/desktop/.gitignore.tmpl": [
      null,
      null,
      "tmpl",
      "qxcompiler"
    ],
    "qx/tool/cli/templates/skeleton/desktop/Manifest.tmpl.json": [
      null,
      null,
      "json",
      "qxcompiler"
    ],
    "qx/tool/cli/templates/skeleton/desktop/compile.tmpl.json": [
      null,
      null,
      "json",
      "qxcompiler"
    ],
    "qx/tool/cli/templates/skeleton/desktop/readme.tmpl.md": [
      null,
      null,
      "md",
      "qxcompiler"
    ],
    "qx/tool/cli/templates/skeleton/mobile/.gitignore.tmpl": [
      null,
      null,
      "tmpl",
      "qxcompiler"
    ],
    "qx/tool/cli/templates/skeleton/mobile/Manifest.tmpl.json": [
      null,
      null,
      "json",
      "qxcompiler"
    ],
    "qx/tool/cli/templates/skeleton/mobile/compile.tmpl.json": [
      null,
      null,
      "json",
      "qxcompiler"
    ],
    "qx/tool/cli/templates/skeleton/mobile/readme.tmpl.md": [
      null,
      null,
      "md",
      "qxcompiler"
    ],
    "qx/tool/cli/templates/skeleton/package/.gitignore.tmpl": [
      null,
      null,
      "tmpl",
      "qxcompiler"
    ],
    "qx/tool/cli/templates/skeleton/package/Manifest.tmpl.json": [
      null,
      null,
      "json",
      "qxcompiler"
    ],
    "qx/tool/cli/templates/skeleton/package/compile.tmpl.json": [
      null,
      null,
      "json",
      "qxcompiler"
    ],
    "qx/tool/cli/templates/skeleton/package/readme.tmpl.md": [
      null,
      null,
      "md",
      "qxcompiler"
    ],
    "qx/tool/cli/templates/skeleton/server/.gitignore.tmpl": [
      null,
      null,
      "tmpl",
      "qxcompiler"
    ],
    "qx/tool/cli/templates/skeleton/server/Manifest.tmpl.json": [
      null,
      null,
      "json",
      "qxcompiler"
    ],
    "qx/tool/cli/templates/skeleton/server/compile.tmpl.json": [
      null,
      null,
      "json",
      "qxcompiler"
    ],
    "qx/tool/cli/templates/skeleton/server/readme.tmpl.txt": [
      null,
      null,
      "txt",
      "qxcompiler"
    ],
    "qx/tool/cli/templates/skeleton/desktop/source/boot/index.tmpl.html": [
      null,
      null,
      "html",
      "qxcompiler"
    ],
    "qx/tool/cli/templates/skeleton/desktop/source/boot/nojs.tmpl.html": [
      null,
      null,
      "html",
      "qxcompiler"
    ],
    "qx/tool/cli/templates/skeleton/desktop/source/translation/readme.txt": [
      null,
      null,
      "txt",
      "qxcompiler"
    ],
    "qx/tool/cli/templates/skeleton/mobile/source/boot/index.tmpl.html": [
      null,
      null,
      "html",
      "qxcompiler"
    ],
    "qx/tool/cli/templates/skeleton/mobile/source/boot/nojs.tmpl.html": [
      null,
      null,
      "html",
      "qxcompiler"
    ],
    "qx/tool/cli/templates/skeleton/mobile/source/translation/readme.txt": [
      null,
      null,
      "txt",
      "qxcompiler"
    ],
    "qx/tool/cli/templates/skeleton/package/source/translation/readme.txt": [
      null,
      null,
      "txt",
      "qxcompiler"
    ],
    "qx/tool/cli/templates/skeleton/server/source/translation/readme.txt": [
      null,
      null,
      "txt",
      "qxcompiler"
    ],
    "qx/tool/cli/templates/skeleton/desktop/source/class/custom/Application.tmpl.js": [
      null,
      null,
      "js",
      "qxcompiler"
    ],
    "qx/tool/cli/templates/skeleton/desktop/source/class/custom/__init__.tmpl.js": [
      null,
      null,
      "js",
      "qxcompiler"
    ],
    "qx/tool/cli/templates/skeleton/desktop/source/resource/custom/app.png": [
      180,
      180,
      "png",
      "qxcompiler"
    ],
    "qx/tool/cli/templates/skeleton/desktop/source/resource/custom/favicon.png": [
      32,
      32,
      "png",
      "qxcompiler"
    ],
    "qx/tool/cli/templates/skeleton/desktop/source/resource/custom/js_256x256.png": [
      256,
      256,
      "png",
      "qxcompiler"
    ],
    "qx/tool/cli/templates/skeleton/desktop/source/resource/custom/test.png": [
      32,
      32,
      "png",
      "qxcompiler"
    ],
    "qx/tool/cli/templates/skeleton/mobile/source/class/custom/Application.tmpl.js": [
      null,
      null,
      "js",
      "qxcompiler"
    ],
    "qx/tool/cli/templates/skeleton/mobile/source/class/custom/__init__.tmpl.js": [
      null,
      null,
      "js",
      "qxcompiler"
    ],
    "qx/tool/cli/templates/skeleton/mobile/source/resource/custom/app.png": [
      180,
      180,
      "png",
      "qxcompiler"
    ],
    "qx/tool/cli/templates/skeleton/mobile/source/resource/custom/favicon.png": [
      32,
      32,
      "png",
      "qxcompiler"
    ],
    "qx/tool/cli/templates/skeleton/mobile/source/resource/custom/js_256x256.png": [
      256,
      256,
      "png",
      "qxcompiler"
    ],
    "qx/tool/cli/templates/skeleton/package/source/class/custom/Button.tmpl.js": [
      null,
      null,
      "js",
      "qxcompiler"
    ],
    "qx/tool/cli/templates/skeleton/package/source/class/custom/__init__.tmpl.js": [
      null,
      null,
      "js",
      "qxcompiler"
    ],
    "qx/tool/cli/templates/skeleton/package/source/resource/custom/test.png": [
      32,
      32,
      "png",
      "qxcompiler"
    ],
    "qx/tool/cli/templates/skeleton/server/source/class/custom/Application.tmpl.js": [
      null,
      null,
      "js",
      "qxcompiler"
    ],
    "qx/tool/cli/templates/skeleton/server/source/class/custom/__init__.tmpl.js": [
      null,
      null,
      "js",
      "qxcompiler"
    ],
    "qx/tool/cli/templates/skeleton/server/source/resource/custom/.gitignore.tmpl": [
      null,
      null,
      "tmpl",
      "qxcompiler"
    ],
    "qx/tool/cli/templates/skeleton/desktop/source/class/custom/test/DemoTest.tmpl.js": [
      null,
      null,
      "js",
      "qxcompiler"
    ],
    "qx/tool/cli/templates/skeleton/desktop/source/class/custom/theme/Appearance.tmpl.js": [
      null,
      null,
      "js",
      "qxcompiler"
    ],
    "qx/tool/cli/templates/skeleton/desktop/source/class/custom/theme/Color.tmpl.js": [
      null,
      null,
      "js",
      "qxcompiler"
    ],
    "qx/tool/cli/templates/skeleton/desktop/source/class/custom/theme/Decoration.tmpl.js": [
      null,
      null,
      "js",
      "qxcompiler"
    ],
    "qx/tool/cli/templates/skeleton/desktop/source/class/custom/theme/Font.tmpl.js": [
      null,
      null,
      "js",
      "qxcompiler"
    ],
    "qx/tool/cli/templates/skeleton/desktop/source/class/custom/theme/Theme.tmpl.js": [
      null,
      null,
      "js",
      "qxcompiler"
    ],
    "qx/tool/cli/templates/skeleton/mobile/source/class/custom/page/Login.tmpl.js": [
      null,
      null,
      "js",
      "qxcompiler"
    ],
    "qx/tool/cli/templates/skeleton/mobile/source/class/custom/page/Overview.tmpl.js": [
      null,
      null,
      "js",
      "qxcompiler"
    ],
    "qx/tool/cli/templates/skeleton/mobile/source/class/custom/page/__init__.tmpl.js": [
      null,
      null,
      "js",
      "qxcompiler"
    ],
    "qx/tool/cli/templates/skeleton/mobile/source/resource/custom/css/.gitignore.tmpl": [
      null,
      null,
      "tmpl",
      "qxcompiler"
    ],
    "qx/tool/cli/templates/skeleton/mobile/source/theme/custom/scss/_styles.scss": [
      null,
      null,
      "scss",
      "qxcompiler"
    ],
    "qx/tool/cli/templates/skeleton/mobile/source/theme/custom/scss/custom.scss": [
      null,
      null,
      "scss",
      "qxcompiler"
    ],
    "qx/tool/cli/templates/skeleton/package/source/class/custom/demo/Application.tmpl.js": [
      null,
      null,
      "js",
      "qxcompiler"
    ],
    "qx/tool/cli/templates/skeleton/package/source/class/custom/test/DemoTest.tmpl.js": [
      null,
      null,
      "js",
      "qxcompiler"
    ],
    "qx/tool/cli/templates/skeleton/package/source/class/custom/theme/Appearance.tmpl.js": [
      null,
      null,
      "js",
      "qxcompiler"
    ],
    "qx/tool/cli/templates/skeleton/package/source/class/custom/theme/Color.tmpl.js": [
      null,
      null,
      "js",
      "qxcompiler"
    ],
    "qx/tool/cli/templates/skeleton/package/source/class/custom/theme/Decoration.tmpl.js": [
      null,
      null,
      "js",
      "qxcompiler"
    ],
    "qx/tool/cli/templates/skeleton/package/source/class/custom/theme/Font.tmpl.js": [
      null,
      null,
      "js",
      "qxcompiler"
    ],
    "qx/tool/cli/templates/skeleton/package/source/class/custom/theme/Theme.tmpl.js": [
      null,
      null,
      "js",
      "qxcompiler"
    ],
    "qx/tool/cli/templates/skeleton/server/source/class/custom/test/DemoTest.tmpl.js": [
      null,
      null,
      "js",
      "qxcompiler"
    ],
    "qx/tool/cli/templates/skeleton/package/source/class/custom/resource/custom/test.png": [
      32,
      32,
      "png",
      "qxcompiler"
    ]
  },
  "translations": {
    "en": {
      "": "Project-Id-Version: qooxdoo framework\nReport-Msgid-Bugs-To: \nPOT-Creation-Date: 2008-05-19 10:11+0200\nPO-Revision-Date: 2007-01-23 17:53+0100\nLast-Translator: Automatically generated\nLanguage-Team: none\nMIME-Version: 1.0\nContent-Type: text/plain; charset=ASCII\nContent-Transfer-Encoding: 8bit\nPlural-Forms: nplurals=2; plural=(n != 1);\n"
    }
  }
};



qx.$$loader.init();
if (typeof exports != "undefined") {
  for (var key in qx) {
    exports[key] = qx[key];
  }
}



